<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ata › libata-core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>libata-core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  libata-core.c - helper library for ATA</span>
<span class="cm"> *</span>
<span class="cm"> *  Maintained by:  Jeff Garzik &lt;jgarzik@pobox.com&gt;</span>
<span class="cm"> *    		    Please ALWAYS copy linux-ide@vger.kernel.org</span>
<span class="cm"> *		    on emails.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright 2003-2004 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> *  Copyright 2003-2004 Jeff Garzik</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *  any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; see the file COPYING.  If not, write to</span>
<span class="cm"> *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  libata documentation is available via &#39;make {ps|pdf}docs&#39;,</span>
<span class="cm"> *  as Documentation/DocBook/libata.*</span>
<span class="cm"> *</span>
<span class="cm"> *  Hardware documentation available from http://www.t13.org/ and</span>
<span class="cm"> *  http://www.sata-io.org/</span>
<span class="cm"> *</span>
<span class="cm"> *  Standards documents from:</span>
<span class="cm"> *	http://www.t13.org (ATA standards, PCI DMA IDE spec)</span>
<span class="cm"> *	http://www.t10.org (SCSI MMC - for ATAPI MMC)</span>
<span class="cm"> *	http://www.sata-io.org (SATA)</span>
<span class="cm"> *	http://www.compactflash.org (CF)</span>
<span class="cm"> *	http://www.qic.org (QIC157 - Tape and DSC)</span>
<span class="cm"> *	http://www.ce-ata.org (CE-ATA: not supported)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/async.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>

<span class="cp">#include &quot;libata.h&quot;</span>
<span class="cp">#include &quot;libata-transport.h&quot;</span>

<span class="cm">/* debounce timing parameters in msecs { interval, duration, timeout } */</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sata_deb_timing_normal</span><span class="p">[]</span>		<span class="o">=</span> <span class="p">{</span>   <span class="mi">5</span><span class="p">,</span>  <span class="mi">100</span><span class="p">,</span> <span class="mi">2000</span> <span class="p">};</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sata_deb_timing_hotplug</span><span class="p">[]</span>		<span class="o">=</span> <span class="p">{</span>  <span class="mi">25</span><span class="p">,</span>  <span class="mi">500</span><span class="p">,</span> <span class="mi">2000</span> <span class="p">};</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sata_deb_timing_long</span><span class="p">[]</span>		<span class="o">=</span> <span class="p">{</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">5000</span> <span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_base_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">prereset</span>		<span class="o">=</span> <span class="n">ata_std_prereset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">postreset</span>		<span class="o">=</span> <span class="n">ata_std_postreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_handler</span>		<span class="o">=</span> <span class="n">ata_std_error_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">sata_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_base_port_ops</span><span class="p">,</span>

	<span class="p">.</span><span class="n">qc_defer</span>		<span class="o">=</span> <span class="n">ata_std_qc_defer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hardreset</span>		<span class="o">=</span> <span class="n">sata_std_hardreset</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_dev_init_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">heads</span><span class="p">,</span> <span class="n">u16</span> <span class="n">sectors</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ata_dev_set_xfermode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ata_dev_xfermask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ata_dev_blacklisted</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="n">atomic_t</span> <span class="n">ata_print_id</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ata_force_param</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cbl</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">spd_limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">xfer_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">horkage_on</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">horkage_off</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">lflags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ata_force_ent</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_force_param</span>	<span class="n">param</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_force_ent</span> <span class="o">*</span><span class="n">ata_force_tbl</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ata_force_tbl_size</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">ata_force_param_buf</span><span class="p">[</span><span class="n">PAGE_SIZE</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
<span class="cm">/* param_buf is thrown away after initialization, disallow read */</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="n">ata_force_param_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ata_force_param_buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="s">&quot;Force ATA configurations including cable type, link speed and transfer mode (see Documentation/kernel-parameters.txt for details)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">atapi_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">atapi_enabled</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">atapi_enabled</span><span class="p">,</span> <span class="s">&quot;Enable discovery of ATAPI devices (0=off, 1=on [default])&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">atapi_dmadir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">atapi_dmadir</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">atapi_dmadir</span><span class="p">,</span> <span class="s">&quot;Enable ATAPI DMADIR bridge support (0=off [default], 1=on)&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">atapi_passthru16</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">atapi_passthru16</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">atapi_passthru16</span><span class="p">,</span> <span class="s">&quot;Enable ATA_16 passthru for ATAPI devices (0=off, 1=on [default])&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">libata_fua</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">fua</span><span class="p">,</span> <span class="n">libata_fua</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fua</span><span class="p">,</span> <span class="s">&quot;FUA support (0=off [default], 1=on)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ata_ignore_hpa</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">ignore_hpa</span><span class="p">,</span> <span class="n">ata_ignore_hpa</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ignore_hpa</span><span class="p">,</span> <span class="s">&quot;Ignore HPA limit (0=keep BIOS limits, 1=ignore limits, using full disk)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">libata_dma_mask</span> <span class="o">=</span> <span class="n">ATA_DMA_MASK_ATA</span><span class="o">|</span><span class="n">ATA_DMA_MASK_ATAPI</span><span class="o">|</span><span class="n">ATA_DMA_MASK_CFA</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">libata_dma_mask</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="s">&quot;DMA enable/disable (0x1==ATA, 0x2==ATAPI, 0x4==CF)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ata_probe_timeout</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ata_probe_timeout</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ata_probe_timeout</span><span class="p">,</span> <span class="s">&quot;Set ATA probing timeout (seconds)&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">libata_noacpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">noacpi</span><span class="p">,</span> <span class="n">libata_noacpi</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">noacpi</span><span class="p">,</span> <span class="s">&quot;Disable the use of ACPI in probe/suspend/resume (0=off [default], 1=on)&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">libata_allow_tpm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">allow_tpm</span><span class="p">,</span> <span class="n">libata_allow_tpm</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">allow_tpm</span><span class="p">,</span> <span class="s">&quot;Permit the use of TPM commands (0=off [default], 1=on)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">atapi_an</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">atapi_an</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">atapi_an</span><span class="p">,</span> <span class="s">&quot;Enable ATAPI AN media presence notification (0=0ff [default], 1=on)&quot;</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jeff Garzik&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Library module for ATA devices&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>


<span class="k">static</span> <span class="n">bool</span> <span class="nf">ata_sstatus_online</span><span class="p">(</span><span class="n">u32</span> <span class="n">sstatus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sstatus</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_link_next - link iteration helper</span>
<span class="cm"> *	@link: the previous link, NULL to start</span>
<span class="cm"> *	@ap: ATA port containing links to iterate</span>
<span class="cm"> *	@mode: iteration mode, one of ATA_LITER_*</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Host lock or EH context.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Pointer to the next link.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="nf">ata_link_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
			       <span class="k">enum</span> <span class="n">ata_link_iter_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">ATA_LITER_EDGE</span> <span class="o">&amp;&amp;</span>
	       <span class="n">mode</span> <span class="o">!=</span> <span class="n">ATA_LITER_PMP_FIRST</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">ATA_LITER_HOST_FIRST</span><span class="p">);</span>

	<span class="cm">/* NULL link indicates start of iteration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ATA_LITER_EDGE</span>:
		<span class="k">case</span> <span class="n">ATA_LITER_PMP_FIRST</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">ATA_LITER_HOST_FIRST</span>:
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* we just iterated over the host link, what&#39;s next? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ATA_LITER_HOST_FIRST</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">ATA_LITER_PMP_FIRST</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">ATA_LITER_EDGE</span>:
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* slave_link excludes PMP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* we were over a PMP link */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">link</span> <span class="o">&lt;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span> <span class="o">+</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_pmp_links</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">link</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">ATA_LITER_PMP_FIRST</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_next - device iteration helper</span>
<span class="cm"> *	@dev: the previous device, NULL to start</span>
<span class="cm"> *	@link: ATA link containing devices to iterate</span>
<span class="cm"> *	@mode: iteration mode, one of ATA_DITER_*</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Host lock or EH context.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Pointer to the next device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="nf">ata_dev_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">ata_dev_iter_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">ATA_DITER_ENABLED</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">ATA_DITER_ENABLED_REVERSE</span> <span class="o">&amp;&amp;</span>
	       <span class="n">mode</span> <span class="o">!=</span> <span class="n">ATA_DITER_ALL</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">ATA_DITER_ALL_REVERSE</span><span class="p">);</span>

	<span class="cm">/* NULL dev indicates start of iteration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ATA_DITER_ENABLED</span>:
		<span class="k">case</span> <span class="n">ATA_DITER_ALL</span>:
			<span class="n">dev</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">check</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ATA_DITER_ENABLED_REVERSE</span>:
		<span class="k">case</span> <span class="n">ATA_DITER_ALL_REVERSE</span>:
			<span class="n">dev</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">+</span> <span class="n">ata_link_max_devices</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">check</span><span class="p">;</span>
		<span class="p">}</span>

 <span class="nl">next:</span>
	<span class="cm">/* move to the next one */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_DITER_ENABLED</span>:
	<span class="k">case</span> <span class="n">ATA_DITER_ALL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dev</span> <span class="o">&lt;</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">+</span> <span class="n">ata_link_max_devices</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">check</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_DITER_ENABLED_REVERSE</span>:
	<span class="k">case</span> <span class="n">ATA_DITER_ALL_REVERSE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">dev</span> <span class="o">&gt;=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">check</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">check:</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="n">ATA_DITER_ENABLED</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">ATA_DITER_ENABLED_REVERSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ata_dev_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_phys_link - find physical link for a device</span>
<span class="cm"> *	@dev: ATA device to look up physical link for</span>
<span class="cm"> *</span>
<span class="cm"> *	Look up physical link which @dev is attached to.  Note that</span>
<span class="cm"> *	this is different from @dev-&gt;link only when @dev is on slave</span>
<span class="cm"> *	link.  For all other cases, it&#39;s the same as @dev-&gt;link.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Don&#39;t care.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Pointer to the found physical link.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="nf">ata_dev_phys_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_force_cbl - force cable type according to libata.force</span>
<span class="cm"> *	@ap: ATA port of interest</span>
<span class="cm"> *</span>
<span class="cm"> *	Force cable type according to libata.force and whine about it.</span>
<span class="cm"> *	The last entry which has matching port number is used, so it</span>
<span class="cm"> *	can be specified as part of device force parameters.  For</span>
<span class="cm"> *	example, both &quot;a:40c,1.00:udma4&quot; and &quot;1.00:40c,udma4&quot; have the</span>
<span class="cm"> *	same effect.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	EH context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_force_cbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ata_force_tbl_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_force_ent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_force_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">cbl</span> <span class="o">==</span> <span class="n">ATA_CBL_NONE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">cbl</span><span class="p">;</span>
		<span class="n">ata_port_notice</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;FORCE: cable set to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_force_link_limits - force link limits according to libata.force</span>
<span class="cm"> *	@link: ATA link of interest</span>
<span class="cm"> *</span>
<span class="cm"> *	Force link flags and SATA spd limit according to libata.force</span>
<span class="cm"> *	and whine about it.  When only the port part is specified</span>
<span class="cm"> *	(e.g. 1:), the limit applies to all links connected to both</span>
<span class="cm"> *	the host link and all fan-out ports connected via PMP.  If the</span>
<span class="cm"> *	device part is specified as 0 (e.g. 1.00:), it specifies the</span>
<span class="cm"> *	first fan-out link not the host link.  Device number 15 always</span>
<span class="cm"> *	points to the host link whether PMP is attached or not.  If the</span>
<span class="cm"> *	controller has slave link, device number 16 points to it.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	EH context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_force_link_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">did_spd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">linkno</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
		<span class="n">linkno</span> <span class="o">+=</span> <span class="mi">15</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ata_force_tbl_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_force_ent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_force_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">linkno</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* only honor the first spd limit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">did_spd</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">spd_limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">link</span><span class="o">-&gt;</span><span class="n">hw_sata_spd_limit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">spd_limit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ata_link_notice</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;FORCE: PHY spd limit set to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
			<span class="n">did_spd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* let lflags stack */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">lflags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">link</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">lflags</span><span class="p">;</span>
			<span class="n">ata_link_notice</span><span class="p">(</span><span class="n">link</span><span class="p">,</span>
					<span class="s">&quot;FORCE: link flag 0x%x forced -&gt; 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">lflags</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_force_xfermask - force xfermask according to libata.force</span>
<span class="cm"> *	@dev: ATA device of interest</span>
<span class="cm"> *</span>
<span class="cm"> *	Force xfer_mask according to libata.force and whine about it.</span>
<span class="cm"> *	For consistency with link selection, device number 15 selects</span>
<span class="cm"> *	the first device connected to the host link.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	EH context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_force_xfermask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">devno</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alt_devno</span> <span class="o">=</span> <span class="n">devno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* allow n.15/16 for devices attached to host port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">))</span>
		<span class="n">alt_devno</span> <span class="o">+=</span> <span class="mi">15</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ata_force_tbl_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_force_ent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_force_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pio_mask</span><span class="p">,</span> <span class="n">mwdma_mask</span><span class="p">,</span> <span class="n">udma_mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">devno</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">alt_devno</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">xfer_mask</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ata_unpack_xfermask</span><span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">xfer_mask</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">pio_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mwdma_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udma_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udma_mask</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="n">udma_mask</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mwdma_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="n">mwdma_mask</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mask</span> <span class="o">=</span> <span class="n">pio_mask</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ata_dev_notice</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;FORCE: xfer_mask set to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_force_horkage - force horkage according to libata.force</span>
<span class="cm"> *	@dev: ATA device of interest</span>
<span class="cm"> *</span>
<span class="cm"> *	Force horkage according to libata.force and whine about it.</span>
<span class="cm"> *	For consistency with link selection, device number 15 selects</span>
<span class="cm"> *	the first device connected to the host link.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	EH context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_force_horkage</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">devno</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alt_devno</span> <span class="o">=</span> <span class="n">devno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* allow n.15/16 for devices attached to host port */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">))</span>
		<span class="n">alt_devno</span> <span class="o">+=</span> <span class="mi">15</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ata_force_tbl_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_force_ent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_force_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">devno</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="n">alt_devno</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">~</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">horkage_on</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">horkage_off</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">|=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">horkage_on</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">horkage_off</span><span class="p">;</span>

		<span class="n">ata_dev_notice</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;FORCE: horkage modified (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">fe</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	atapi_cmd_type - Determine ATAPI command type from SCSI opcode</span>
<span class="cm"> *	@opcode: SCSI opcode</span>
<span class="cm"> *</span>
<span class="cm"> *	Determine ATAPI command type from @opcode.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	ATAPI_{READ|WRITE|READ_CD|PASS_THRU|MISC}</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atapi_cmd_type</span><span class="p">(</span><span class="n">u8</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GPCMD_READ_10</span>:
	<span class="k">case</span> <span class="n">GPCMD_READ_12</span>:
		<span class="k">return</span> <span class="n">ATAPI_READ</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GPCMD_WRITE_10</span>:
	<span class="k">case</span> <span class="n">GPCMD_WRITE_12</span>:
	<span class="k">case</span> <span class="n">GPCMD_WRITE_AND_VERIFY_10</span>:
		<span class="k">return</span> <span class="n">ATAPI_WRITE</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GPCMD_READ_CD</span>:
	<span class="k">case</span> <span class="n">GPCMD_READ_CD_MSF</span>:
		<span class="k">return</span> <span class="n">ATAPI_READ_CD</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATA_16</span>:
	<span class="k">case</span> <span class="n">ATA_12</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">atapi_passthru16</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ATAPI_PASS_THRU</span><span class="p">;</span>
		<span class="cm">/* fall thru */</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">ATAPI_MISC</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_tf_to_fis - Convert ATA taskfile to SATA FIS structure</span>
<span class="cm"> *	@tf: Taskfile to convert</span>
<span class="cm"> *	@pmp: Port multiplier port</span>
<span class="cm"> *	@is_cmd: This FIS is for command</span>
<span class="cm"> *	@fis: Buffer into which data will output</span>
<span class="cm"> *</span>
<span class="cm"> *	Converts a standard ATA taskfile to a Serial ATA</span>
<span class="cm"> *	FIS structure (Register - Host to Device).</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_tf_to_fis</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pmp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">fis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x27</span><span class="p">;</span>			<span class="cm">/* Register - Host to Device FIS */</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pmp</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>		<span class="cm">/* Port multiplier number*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_cmd</span><span class="p">)</span>
		<span class="n">fis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>	<span class="cm">/* bit 7 indicates Command FIS */</span>

	<span class="n">fis</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">;</span>

	<span class="n">fis</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

	<span class="n">fis</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span><span class="p">;</span>

	<span class="n">fis</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>

	<span class="n">fis</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fis</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_tf_from_fis - Convert SATA FIS to ATA taskfile</span>
<span class="cm"> *	@fis: Buffer from which data will be input</span>
<span class="cm"> *	@tf: Taskfile to output</span>
<span class="cm"> *</span>
<span class="cm"> *	Converts a serial ATA FIS structure to a standard ATA taskfile.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_tf_from_fis</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">fis</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* status */</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* error */</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span>	<span class="o">=</span> <span class="n">fis</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">ata_rw_cmds</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* pio multi */</span>
	<span class="n">ATA_CMD_READ_MULTI</span><span class="p">,</span>
	<span class="n">ATA_CMD_WRITE_MULTI</span><span class="p">,</span>
	<span class="n">ATA_CMD_READ_MULTI_EXT</span><span class="p">,</span>
	<span class="n">ATA_CMD_WRITE_MULTI_EXT</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="n">ATA_CMD_WRITE_MULTI_FUA_EXT</span><span class="p">,</span>
	<span class="cm">/* pio */</span>
	<span class="n">ATA_CMD_PIO_READ</span><span class="p">,</span>
	<span class="n">ATA_CMD_PIO_WRITE</span><span class="p">,</span>
	<span class="n">ATA_CMD_PIO_READ_EXT</span><span class="p">,</span>
	<span class="n">ATA_CMD_PIO_WRITE_EXT</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* dma */</span>
	<span class="n">ATA_CMD_READ</span><span class="p">,</span>
	<span class="n">ATA_CMD_WRITE</span><span class="p">,</span>
	<span class="n">ATA_CMD_READ_EXT</span><span class="p">,</span>
	<span class="n">ATA_CMD_WRITE_EXT</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="n">ATA_CMD_WRITE_FUA_EXT</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_rwcmd_protocol - set taskfile r/w commands and protocol</span>
<span class="cm"> *	@tf: command to examine and configure</span>
<span class="cm"> *	@dev: device tf belongs to</span>
<span class="cm"> *</span>
<span class="cm"> *	Examine the device configuration and tf-&gt;flags to calculate</span>
<span class="cm"> *	the proper read/write commands and protocol to use.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_rwcmd_protocol</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">fua</span><span class="p">,</span> <span class="n">lba48</span><span class="p">,</span> <span class="n">write</span><span class="p">;</span>

	<span class="n">fua</span> <span class="o">=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_FUA</span><span class="p">)</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lba48</span> <span class="o">=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">write</span> <span class="o">=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_PIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_PIO</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lba48</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PIO_LBA48</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Unable to use DMA due to host limitation */</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_PIO</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_DMA</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">ata_rw_cmds</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">fua</span> <span class="o">+</span> <span class="n">lba48</span> <span class="o">+</span> <span class="n">write</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_tf_read_block - Read block address from ATA taskfile</span>
<span class="cm"> *	@tf: ATA taskfile of interest</span>
<span class="cm"> *	@dev: ATA device @tf belongs to</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	Read block address from @tf.  This function can handle all</span>
<span class="cm"> *	three address formats - LBA, LBA48 and CHS.  tf-&gt;protocol and</span>
<span class="cm"> *	flags select the address format to use.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Block address read from @tf.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">ata_tf_read_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_LBA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">block</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span><span class="p">;</span>
			<span class="n">block</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
			<span class="n">block</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">block</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>

		<span class="n">block</span> <span class="o">|=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">block</span> <span class="o">|=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">block</span> <span class="o">|=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">cyl</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">sect</span><span class="p">;</span>

		<span class="n">cyl</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">|</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">sect</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sect</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;device reported invalid CHS sector 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* oh well */</span>
		<span class="p">}</span>

		<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">cyl</span> <span class="o">*</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">+</span> <span class="n">head</span><span class="p">)</span> <span class="o">*</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">+</span> <span class="n">sect</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_build_rw_tf - Build ATA taskfile for given read/write request</span>
<span class="cm"> *	@tf: Target ATA taskfile</span>
<span class="cm"> *	@dev: ATA device @tf belongs to</span>
<span class="cm"> *	@block: Block address</span>
<span class="cm"> *	@n_block: Number of blocks</span>
<span class="cm"> *	@tf_flags: RW/FUA etc...</span>
<span class="cm"> *	@tag: tag</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	Build ATA taskfile @tf for read/write request described by</span>
<span class="cm"> *	@block, @n_block, @tf_flags and @tag on @dev.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *</span>
<span class="cm"> *	0 on success, -ERANGE if the request is too large for @dev,</span>
<span class="cm"> *	-EINVAL if the request is invalid.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_build_rw_tf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		    <span class="n">u64</span> <span class="n">block</span><span class="p">,</span> <span class="n">u32</span> <span class="n">n_block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tf_flags</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">tf_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_ncq_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">ATA_TAG_INTERNAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* yay, NCQ */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lba_48_ok</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NCQ</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA</span> <span class="o">|</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_FPDMA_WRITE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_FPDMA_READ</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">=</span> <span class="n">n_block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_FUA</span><span class="p">)</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_LBA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lba_28_ok</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* use LBA28 */</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lba_48_ok</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_LBA48</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

			<span class="cm">/* use LBA48 */</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">;</span>

			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* request too large even for LBA48 */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ata_rwcmd_protocol</span><span class="p">(</span><span class="n">tf</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">n_block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|=</span> <span class="n">ATA_LBA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* CHS */</span>
		<span class="n">u32</span> <span class="n">sect</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">cyl</span><span class="p">,</span> <span class="n">track</span><span class="p">;</span>

		<span class="cm">/* The request -may- be too large for CHS addressing. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lba_28_ok</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ata_rwcmd_protocol</span><span class="p">(</span><span class="n">tf</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* Convert LBA to CHS */</span>
		<span class="n">track</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">block</span> <span class="o">/</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">;</span>
		<span class="n">cyl</span>   <span class="o">=</span> <span class="n">track</span> <span class="o">/</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">;</span>
		<span class="n">head</span>  <span class="o">=</span> <span class="n">track</span> <span class="o">%</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">;</span>
		<span class="n">sect</span>  <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">block</span> <span class="o">%</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;block %u track %u cyl %u head %u sect %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">block</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">cyl</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">sect</span><span class="p">);</span>

		<span class="cm">/* Check whether the converted CHS can fit.</span>
<span class="cm">		   Cylinder: 0-65535</span>
<span class="cm">		   Head: 0-15</span>
<span class="cm">		   Sector: 1-255*/</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cyl</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">head</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sect</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">sect</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">n_block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span> <span class="cm">/* Sector count 0 means 256 sectors */</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">sect</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="n">cyl</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="n">cyl</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|=</span> <span class="n">head</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pack_xfermask - Pack pio, mwdma and udma masks into xfer_mask</span>
<span class="cm"> *	@pio_mask: pio_mask</span>
<span class="cm"> *	@mwdma_mask: mwdma_mask</span>
<span class="cm"> *	@udma_mask: udma_mask</span>
<span class="cm"> *</span>
<span class="cm"> *	Pack @pio_mask, @mwdma_mask and @udma_mask into a single</span>
<span class="cm"> *	unsigned int xfer_mask.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Packed xfer_mask.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ata_pack_xfermask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pio_mask</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mwdma_mask</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">udma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">pio_mask</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATA_MASK_PIO</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">mwdma_mask</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_MWDMA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATA_MASK_MWDMA</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">udma_mask</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_UDMA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATA_MASK_UDMA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_unpack_xfermask - Unpack xfer_mask into pio, mwdma and udma masks</span>
<span class="cm"> *	@xfer_mask: xfer_mask to unpack</span>
<span class="cm"> *	@pio_mask: resulting pio_mask</span>
<span class="cm"> *	@mwdma_mask: resulting mwdma_mask</span>
<span class="cm"> *	@udma_mask: resulting udma_mask</span>
<span class="cm"> *</span>
<span class="cm"> *	Unpack @xfer_mask into @pio_mask, @mwdma_mask and @udma_mask.</span>
<span class="cm"> *	Any NULL distination masks will be ignored.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_unpack_xfermask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pio_mask</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mwdma_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">udma_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pio_mask</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pio_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfer_mask</span> <span class="o">&amp;</span> <span class="n">ATA_MASK_PIO</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mwdma_mask</span><span class="p">)</span>
		<span class="o">*</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfer_mask</span> <span class="o">&amp;</span> <span class="n">ATA_MASK_MWDMA</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">ATA_SHIFT_MWDMA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udma_mask</span><span class="p">)</span>
		<span class="o">*</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfer_mask</span> <span class="o">&amp;</span> <span class="n">ATA_MASK_UDMA</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">ATA_SHIFT_UDMA</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_xfer_ent</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">base</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ata_xfer_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">,</span> <span class="n">ATA_NR_PIO_MODES</span><span class="p">,</span> <span class="n">XFER_PIO_0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">ATA_SHIFT_MWDMA</span><span class="p">,</span> <span class="n">ATA_NR_MWDMA_MODES</span><span class="p">,</span> <span class="n">XFER_MW_DMA_0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">ATA_SHIFT_UDMA</span><span class="p">,</span> <span class="n">ATA_NR_UDMA_MODES</span><span class="p">,</span> <span class="n">XFER_UDMA_0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_xfer_mask2mode - Find matching XFER_* for the given xfer_mask</span>
<span class="cm"> *	@xfer_mask: xfer_mask of interest</span>
<span class="cm"> *</span>
<span class="cm"> *	Return matching XFER_* value for @xfer_mask.  Only the highest</span>
<span class="cm"> *	bit of @xfer_mask is considered.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Matching XFER_* value, 0xff if no match found.</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="nf">ata_xfer_mask2mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">highbit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_xfer_ent</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ent</span> <span class="o">=</span> <span class="n">ata_xfer_tbl</span><span class="p">;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ent</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">highbit</span> <span class="o">&gt;=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">&amp;&amp;</span> <span class="n">highbit</span> <span class="o">&lt;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">+</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">highbit</span> <span class="o">-</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="k">return</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_xfer_mode2mask - Find matching xfer_mask for XFER_*</span>
<span class="cm"> *	@xfer_mode: XFER_* of interest</span>
<span class="cm"> *</span>
<span class="cm"> *	Return matching xfer_mask for @xfer_mode.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Matching xfer_mask, 0 if no match found.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ata_xfer_mode2mask</span><span class="p">(</span><span class="n">u8</span> <span class="n">xfer_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_xfer_ent</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ent</span> <span class="o">=</span> <span class="n">ata_xfer_tbl</span><span class="p">;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ent</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer_mode</span> <span class="o">&gt;=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;&amp;</span> <span class="n">xfer_mode</span> <span class="o">&lt;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">((</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">+</span> <span class="n">xfer_mode</span> <span class="o">-</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_xfer_mode2shift - Find matching xfer_shift for XFER_*</span>
<span class="cm"> *	@xfer_mode: XFER_* of interest</span>
<span class="cm"> *</span>
<span class="cm"> *	Return matching xfer_shift for @xfer_mode.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Matching xfer_shift, -1 if no match found.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_xfer_mode2shift</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_xfer_ent</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ent</span> <span class="o">=</span> <span class="n">ata_xfer_tbl</span><span class="p">;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ent</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer_mode</span> <span class="o">&gt;=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;&amp;</span> <span class="n">xfer_mode</span> <span class="o">&lt;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_mode_string - convert xfer_mask to string</span>
<span class="cm"> *	@xfer_mask: mask of bits supported; only highest bit counts.</span>
<span class="cm"> *</span>
<span class="cm"> *	Determine string which represents the highest speed</span>
<span class="cm"> *	(highest bit in @modemask).</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Constant C string representing highest speed listed in</span>
<span class="cm"> *	@mode_mask, or the constant C string &quot;&lt;n/a&gt;&quot;.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ata_mode_string</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">xfer_mode_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;PIO0&quot;</span><span class="p">,</span>
		<span class="s">&quot;PIO1&quot;</span><span class="p">,</span>
		<span class="s">&quot;PIO2&quot;</span><span class="p">,</span>
		<span class="s">&quot;PIO3&quot;</span><span class="p">,</span>
		<span class="s">&quot;PIO4&quot;</span><span class="p">,</span>
		<span class="s">&quot;PIO5&quot;</span><span class="p">,</span>
		<span class="s">&quot;PIO6&quot;</span><span class="p">,</span>
		<span class="s">&quot;MWDMA0&quot;</span><span class="p">,</span>
		<span class="s">&quot;MWDMA1&quot;</span><span class="p">,</span>
		<span class="s">&quot;MWDMA2&quot;</span><span class="p">,</span>
		<span class="s">&quot;MWDMA3&quot;</span><span class="p">,</span>
		<span class="s">&quot;MWDMA4&quot;</span><span class="p">,</span>
		<span class="s">&quot;UDMA/16&quot;</span><span class="p">,</span>
		<span class="s">&quot;UDMA/25&quot;</span><span class="p">,</span>
		<span class="s">&quot;UDMA/33&quot;</span><span class="p">,</span>
		<span class="s">&quot;UDMA/44&quot;</span><span class="p">,</span>
		<span class="s">&quot;UDMA/66&quot;</span><span class="p">,</span>
		<span class="s">&quot;UDMA/100&quot;</span><span class="p">,</span>
		<span class="s">&quot;UDMA/133&quot;</span><span class="p">,</span>
		<span class="s">&quot;UDMA7&quot;</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">highbit</span><span class="p">;</span>

	<span class="n">highbit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">highbit</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">highbit</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">xfer_mode_str</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">xfer_mode_str</span><span class="p">[</span><span class="n">highbit</span><span class="p">];</span>
	<span class="k">return</span> <span class="s">&quot;&lt;n/a&gt;&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sata_spd_string</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">spd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">spd_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;1.5 Gbps&quot;</span><span class="p">,</span>
		<span class="s">&quot;3.0 Gbps&quot;</span><span class="p">,</span>
		<span class="s">&quot;6.0 Gbps&quot;</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spd</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">spd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">spd_str</span><span class="p">))</span>
		<span class="k">return</span> <span class="s">&quot;&lt;unknown&gt;&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">spd_str</span><span class="p">[</span><span class="n">spd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_classify - determine device type based on ATA-spec signature</span>
<span class="cm"> *	@tf: ATA taskfile register set for device to be identified</span>
<span class="cm"> *</span>
<span class="cm"> *	Determine from taskfile register contents whether a device is</span>
<span class="cm"> *	ATA or ATAPI, as per &quot;Signature and persistence&quot; section</span>
<span class="cm"> *	of ATA/PI spec (volume 1, sect 5.14).</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Device type, %ATA_DEV_ATA, %ATA_DEV_ATAPI, %ATA_DEV_PMP or</span>
<span class="cm"> *	%ATA_DEV_UNKNOWN the event of failure.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_dev_classify</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Apple&#39;s open source Darwin code hints that some devices only</span>
<span class="cm">	 * put a proper signature into the LBA mid/high registers,</span>
<span class="cm">	 * So, we only check those.  It&#39;s sufficient for uniqueness.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ATA/ATAPI-7 (d1532v1r1: Feb. 19, 2003) specified separate</span>
<span class="cm">	 * signatures for ATA and ATAPI devices attached on SerialATA,</span>
<span class="cm">	 * 0x3c/0xc3 and 0x69/0x96 respectively.  However, SerialATA</span>
<span class="cm">	 * spec has never mentioned about using different signatures</span>
<span class="cm">	 * for ATA/ATAPI devices.  Then, Serial ATA II: Port</span>
<span class="cm">	 * Multiplier specification began to use 0x69/0x96 to identify</span>
<span class="cm">	 * port multpliers and 0x3c/0xc3 to identify SEMB device.</span>
<span class="cm">	 * ATA/ATAPI-7 dropped descriptions about 0x3c/0xc3 and</span>
<span class="cm">	 * 0x69/0x96 shortly and described them as reserved for</span>
<span class="cm">	 * SerialATA.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We follow the current spec and consider that 0x69/0x96</span>
<span class="cm">	 * identifies a port multiplier and 0x3c/0xc3 a SEMB device.</span>
<span class="cm">	 * Unfortunately, WDC WD1600JS-62MHB5 (a hard drive) reports</span>
<span class="cm">	 * SEMB signature.  This is worked around in</span>
<span class="cm">	 * ata_dev_read_id().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;found ATA device by sig</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ATA_DEV_ATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">==</span> <span class="mh">0x14</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">==</span> <span class="mh">0xeb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;found ATAPI device by sig</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">==</span> <span class="mh">0x69</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">==</span> <span class="mh">0x96</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;found PMP device by sig</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ATA_DEV_PMP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">==</span> <span class="mh">0x3c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">==</span> <span class="mh">0xc3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;found SEMB device by sig (could be ATA device)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ATA_DEV_SEMB</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;unknown device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ATA_DEV_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_id_string - Convert IDENTIFY DEVICE page into string</span>
<span class="cm"> *	@id: IDENTIFY DEVICE results we will examine</span>
<span class="cm"> *	@s: string into which data is output</span>
<span class="cm"> *	@ofs: offset into identify device page</span>
<span class="cm"> *	@len: length of string to return. must be an even number.</span>
<span class="cm"> *</span>
<span class="cm"> *	The strings in the IDENTIFY DEVICE page are broken up into</span>
<span class="cm"> *	16-bit chunks.  Run through the string, and output each</span>
<span class="cm"> *	8-bit chunk linearly, regardless of platform.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_id_string</span><span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="n">ofs</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">s</span><span class="o">++</span><span class="p">;</span>

		<span class="n">c</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="n">ofs</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">s</span><span class="o">++</span><span class="p">;</span>

		<span class="n">ofs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_id_c_string - Convert IDENTIFY DEVICE page into C string</span>
<span class="cm"> *	@id: IDENTIFY DEVICE results we will examine</span>
<span class="cm"> *	@s: string into which data is output</span>
<span class="cm"> *	@ofs: offset into identify device page</span>
<span class="cm"> *	@len: length of string to return. must be an odd number.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is identical to ata_id_string except that it</span>
<span class="cm"> *	trims trailing spaces and terminates the resulting string with</span>
<span class="cm"> *	null.  @len must be actual maximum length (even number) + 1.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_id_c_string</span><span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
		<span class="n">p</span><span class="o">--</span><span class="p">;</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">ata_id_n_sectors</span><span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_lba</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_lba48</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ata_id_u64</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">ATA_ID_LBA_CAPACITY_2</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">ata_id_u32</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">ATA_ID_LBA_CAPACITY</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_current_chs_valid</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_CUR_CYLS</span><span class="p">]</span> <span class="o">*</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_CUR_HEADS</span><span class="p">]</span> <span class="o">*</span>
			       <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_CUR_SECTORS</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_CYLS</span><span class="p">]</span> <span class="o">*</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_HEADS</span><span class="p">]</span> <span class="o">*</span>
			       <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_SECTORS</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">ata_tf_to_lba48</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sectors</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">ata_tf_to_lba</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">sectors</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sectors</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_read_native_max_address - Read native max address</span>
<span class="cm"> *	@dev: target device</span>
<span class="cm"> *	@max_sectors: out parameter for the result native max address</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform an LBA48 or LBA28 native size query upon the device in</span>
<span class="cm"> *	question.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -EACCES if command is aborted by the drive.</span>
<span class="cm"> *	-EIO on other errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_read_native_max_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">max_sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lba48</span> <span class="o">=</span> <span class="n">ata_id_has_lba48</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="n">ata_tf_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>

	<span class="cm">/* always clear all address registers */</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_DEVICE</span> <span class="o">|</span> <span class="n">ATA_TFLAG_ISADDR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lba48</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_READ_NATIVE_MAX_EXT</span><span class="p">;</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_READ_NATIVE_MAX</span><span class="p">;</span>

	<span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">|=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">device</span> <span class="o">|=</span> <span class="n">ATA_LBA</span><span class="p">;</span>

	<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_exec_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;failed to read native max address (err_mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">err_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">==</span> <span class="n">AC_ERR_DEV</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">ATA_ABORTED</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lba48</span><span class="p">)</span>
		<span class="o">*</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">ata_tf_to_lba48</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">ata_tf_to_lba</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_HPA_SIZE</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">max_sectors</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_set_max_sectors - Set max sectors</span>
<span class="cm"> *	@dev: target device</span>
<span class="cm"> *	@new_sectors: new max sectors value to set for the device</span>
<span class="cm"> *</span>
<span class="cm"> *	Set max sectors of @dev to @new_sectors.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -EACCES if command is aborted or denied (due to</span>
<span class="cm"> *	previous non-volatile SET_MAX) by the drive.  -EIO on other</span>
<span class="cm"> *	errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_set_max_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new_sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lba48</span> <span class="o">=</span> <span class="n">ata_id_has_lba48</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="n">new_sectors</span><span class="o">--</span><span class="p">;</span>

	<span class="n">ata_tf_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>

	<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_DEVICE</span> <span class="o">|</span> <span class="n">ATA_TFLAG_ISADDR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lba48</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_SET_MAX_EXT</span><span class="p">;</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">;</span>

		<span class="n">tf</span><span class="p">.</span><span class="n">hob_lbal</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sectors</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">hob_lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sectors</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">hob_lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sectors</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_SET_MAX</span><span class="p">;</span>

		<span class="n">tf</span><span class="p">.</span><span class="n">device</span> <span class="o">|=</span> <span class="p">(</span><span class="n">new_sectors</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">|=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">device</span> <span class="o">|=</span> <span class="n">ATA_LBA</span><span class="p">;</span>

	<span class="n">tf</span><span class="p">.</span><span class="n">lbal</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sectors</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sectors</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_sectors</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_exec_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;failed to set max address (err_mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">err_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">==</span> <span class="n">AC_ERR_DEV</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_ABORTED</span> <span class="o">|</span> <span class="n">ATA_IDNF</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_hpa_resize		-	Resize a device with an HPA set</span>
<span class="cm"> *	@dev: Device to resize</span>
<span class="cm"> *</span>
<span class="cm"> *	Read the size of an LBA28 or LBA48 disk with HPA features and resize</span>
<span class="cm"> *	it if required to the full size of the media. The caller must check</span>
<span class="cm"> *	the drive has the HPA feature set enabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_hpa_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="o">*</span><span class="n">ehc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">print_info</span> <span class="o">=</span> <span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_EHI_PRINTINFO</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">unlock_hpa</span> <span class="o">=</span> <span class="n">ata_ignore_hpa</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_UNLOCK_HPA</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">sectors</span> <span class="o">=</span> <span class="n">ata_id_n_sectors</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">native_sectors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* do we need to do it? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">ATA_DEV_ATA</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">ata_id_has_lba</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">ata_id_hpa_enabled</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_BROKEN_HPA</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* read native max address */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_read_native_max_address</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">native_sectors</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If device aborted the command or HPA isn&#39;t going to</span>
<span class="cm">		 * be unlocked, skip HPA resizing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span> <span class="o">||</span> <span class="o">!</span><span class="n">unlock_hpa</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;HPA support seems broken, skipping HPA handling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">|=</span> <span class="n">ATA_HORKAGE_BROKEN_HPA</span><span class="p">;</span>

			<span class="cm">/* we can continue if device aborted the command */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_native_sectors</span> <span class="o">=</span> <span class="n">native_sectors</span><span class="p">;</span>

	<span class="cm">/* nothing to do? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">native_sectors</span> <span class="o">&lt;=</span> <span class="n">sectors</span> <span class="o">||</span> <span class="o">!</span><span class="n">unlock_hpa</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">print_info</span> <span class="o">||</span> <span class="n">native_sectors</span> <span class="o">==</span> <span class="n">sectors</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">native_sectors</span> <span class="o">&gt;</span> <span class="n">sectors</span><span class="p">)</span>
			<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;HPA detected: current %llu, native %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sectors</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">native_sectors</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">native_sectors</span> <span class="o">&lt;</span> <span class="n">sectors</span><span class="p">)</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;native sectors (%llu) is smaller than sectors (%llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">native_sectors</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sectors</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* let&#39;s unlock HPA */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_set_max_sectors</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">native_sectors</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if device aborted the command, skip HPA resizing */</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;device aborted resize (%llu -&gt; %llu), skipping HPA handling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sectors</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">native_sectors</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">|=</span> <span class="n">ATA_HORKAGE_BROKEN_HPA</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* re-read IDENTIFY data */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_reread_id</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;failed to re-read IDENTIFY data after HPA resizing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">print_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">new_sectors</span> <span class="o">=</span> <span class="n">ata_id_n_sectors</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;HPA unlocked: %llu -&gt; %llu, native %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">sectors</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_sectors</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">native_sectors</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dump_id - IDENTIFY DEVICE info debugging output</span>
<span class="cm"> *	@id: IDENTIFY DEVICE page to dump</span>
<span class="cm"> *</span>
<span class="cm"> *	Dump selected 16-bit words from the given IDENTIFY DEVICE</span>
<span class="cm"> *	page.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_dump_id</span><span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;49==0x%04x  &quot;</span>
		<span class="s">&quot;53==0x%04x  &quot;</span>
		<span class="s">&quot;63==0x%04x  &quot;</span>
		<span class="s">&quot;64==0x%04x  &quot;</span>
		<span class="s">&quot;75==0x%04x  </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">49</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">53</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">63</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">64</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">75</span><span class="p">]);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;80==0x%04x  &quot;</span>
		<span class="s">&quot;81==0x%04x  &quot;</span>
		<span class="s">&quot;82==0x%04x  &quot;</span>
		<span class="s">&quot;83==0x%04x  &quot;</span>
		<span class="s">&quot;84==0x%04x  </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">80</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">81</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">82</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">83</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">84</span><span class="p">]);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;88==0x%04x  &quot;</span>
		<span class="s">&quot;93==0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">88</span><span class="p">],</span>
		<span class="n">id</span><span class="p">[</span><span class="mi">93</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_id_xfermask - Compute xfermask from the given IDENTIFY data</span>
<span class="cm"> *	@id: IDENTIFY data to compute xfer mask from</span>
<span class="cm"> *</span>
<span class="cm"> *	Compute the xfermask for this device. This is not as trivial</span>
<span class="cm"> *	as it seems if we must consider early devices correctly.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: pre IDE drive timing (do we care ?).</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Computed xfermask</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ata_id_xfermask</span><span class="p">(</span><span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pio_mask</span><span class="p">,</span> <span class="n">mwdma_mask</span><span class="p">,</span> <span class="n">udma_mask</span><span class="p">;</span>

	<span class="cm">/* Usual case. Word 53 indicates word 64 is valid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_FIELD_VALID</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pio_mask</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_PIO_MODES</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>
		<span class="n">pio_mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">pio_mask</span> <span class="o">|=</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If word 64 isn&#39;t valid then Word 51 high byte holds</span>
<span class="cm">		 * the PIO timing number for the maximum. Turn it into</span>
<span class="cm">		 * a mask.</span>
<span class="cm">		 */</span>
		<span class="n">u8</span> <span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_OLD_PIO_MODES</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>	<span class="cm">/* Valid PIO range */</span>
			<span class="n">pio_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">mode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pio_mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* But wait.. there&#39;s more. Design your standards by</span>
<span class="cm">		 * committee and you too can get a free iordy field to</span>
<span class="cm">		 * process. However its the speeds not the modes that</span>
<span class="cm">		 * are supported... Note drivers using the timing API</span>
<span class="cm">		 * will get this right anyway</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">mwdma_mask</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_MWDMA_MODES</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_is_cfa</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Process compact flash extended modes</span>
<span class="cm">		 */</span>
		<span class="kt">int</span> <span class="n">pio</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_CFA_MODES</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">dma</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_CFA_MODES</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pio</span><span class="p">)</span>
			<span class="n">pio_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pio_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">mwdma_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">mwdma_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">udma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_FIELD_VALID</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">udma_mask</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_UDMA_MODES</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="n">pio_mask</span><span class="p">,</span> <span class="n">mwdma_mask</span><span class="p">,</span> <span class="n">udma_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_qc_complete_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">waiting</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">complete</span><span class="p">(</span><span class="n">waiting</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_exec_internal_sg - execute libata internal command</span>
<span class="cm"> *	@dev: Device to which the command is sent</span>
<span class="cm"> *	@tf: Taskfile registers for the command and the result</span>
<span class="cm"> *	@cdb: CDB for packet command</span>
<span class="cm"> *	@dma_dir: Data tranfer direction of the command</span>
<span class="cm"> *	@sgl: sg list for the data buffer of the command</span>
<span class="cm"> *	@n_elem: Number of sg entries</span>
<span class="cm"> *	@timeout: Timeout in msecs (0 for default)</span>
<span class="cm"> *</span>
<span class="cm"> *	Executes libata internal command with timeout.  @tf contains</span>
<span class="cm"> *	command on entry and result on return.  Timeout and error</span>
<span class="cm"> *	conditions are reported via return value.  No recovery action</span>
<span class="cm"> *	is taken after a command times out.  It&#39;s caller&#39;s duty to</span>
<span class="cm"> *	clean up after timeout.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.  Should be called with kernel context, might sleep.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, AC_ERR_* mask on failure</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="nf">ata_exec_internal_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">dma_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_elem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">command</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">auto_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="n">preempted_tag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">preempted_sactive</span><span class="p">,</span> <span class="n">preempted_qc_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">preempted_nr_active_links</span><span class="p">;</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* no internal command while frozen */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_FROZEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">AC_ERR_SYSTEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize internal qc */</span>

	<span class="cm">/* XXX: Tag 0 is used for drivers with legacy EH as some</span>
<span class="cm">	 * drivers choke if any other tag is given.  This breaks</span>
<span class="cm">	 * ata_tag_internal() test for those drivers.  Don&#39;t use new</span>
<span class="cm">	 * EH stuff without converting to it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">ATA_TAG_INTERNAL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_allocated</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">qc</span> <span class="o">=</span> <span class="n">__ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ata_qc_reinit</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="n">preempted_tag</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span><span class="p">;</span>
	<span class="n">preempted_sactive</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span><span class="p">;</span>
	<span class="n">preempted_qc_active</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span><span class="p">;</span>
	<span class="n">preempted_nr_active_links</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span><span class="p">;</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">ATA_TAG_POISON</span><span class="p">;</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* prepare &amp; issue qc */</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span> <span class="o">=</span> <span class="o">*</span><span class="n">tf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">ATAPI_CDB_LEN</span><span class="p">);</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_QCFLAG_RESULT_TF</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span> <span class="o">=</span> <span class="n">dma_dir</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_dir</span> <span class="o">!=</span> <span class="n">DMA_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">buflen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

		<span class="n">for_each_sg</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">n_elem</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">buflen</span> <span class="o">+=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

		<span class="n">ata_sg_init</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">n_elem</span><span class="p">);</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">complete_fn</span> <span class="o">=</span> <span class="n">ata_qc_complete_internal</span><span class="p">;</span>

	<span class="n">ata_qc_issue</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_probe_timeout</span><span class="p">)</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">ata_probe_timeout</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">ata_internal_cmd_timeout</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>
			<span class="n">auto_timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="n">ata_eh_release</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="n">ata_eh_acquire</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">ata_sff_flush_pio_task</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* We&#39;re racing with irq here.  If we lose, the</span>
<span class="cm">		 * following test prevents us from completing the qc</span>
<span class="cm">		 * twice.  If we win, the port is frozen and will be</span>
<span class="cm">		 * cleaned up by -&gt;post_internal_cmd().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_TIMEOUT</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
				<span class="n">ata_port_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
				<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;qc timeout (cmd 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">command</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* do post_internal_cmd */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">post_internal_cmd</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">post_internal_cmd</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/* perform minimal error analysis */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">.</span><span class="n">command</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DF</span><span class="p">))</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_DEV</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span><span class="p">)</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_OTHER</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AC_ERR_OTHER</span><span class="p">)</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AC_ERR_OTHER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* finish up */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">;</span>
	<span class="n">err_mask</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span><span class="p">;</span>

	<span class="n">ata_qc_free</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">preempted_tag</span><span class="p">;</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span> <span class="o">=</span> <span class="n">preempted_sactive</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span> <span class="o">=</span> <span class="n">preempted_qc_active</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span> <span class="o">=</span> <span class="n">preempted_nr_active_links</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="n">AC_ERR_TIMEOUT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">auto_timeout</span><span class="p">)</span>
		<span class="n">ata_internal_cmd_timed_out</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_exec_internal - execute libata internal command</span>
<span class="cm"> *	@dev: Device to which the command is sent</span>
<span class="cm"> *	@tf: Taskfile registers for the command and the result</span>
<span class="cm"> *	@cdb: CDB for packet command</span>
<span class="cm"> *	@dma_dir: Data tranfer direction of the command</span>
<span class="cm"> *	@buf: Data buffer of the command</span>
<span class="cm"> *	@buflen: Length of data buffer</span>
<span class="cm"> *	@timeout: Timeout in msecs (0 for default)</span>
<span class="cm"> *</span>
<span class="cm"> *	Wrapper around ata_exec_internal_sg() which takes simple</span>
<span class="cm"> *	buffer instead of sg list.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.  Should be called with kernel context, might sleep.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, AC_ERR_* mask on failure</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="nf">ata_exec_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">dma_dir</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">psg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_elem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_dir</span> <span class="o">!=</span> <span class="n">DMA_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
		<span class="n">psg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">;</span>
		<span class="n">n_elem</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ata_exec_internal_sg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">dma_dir</span><span class="p">,</span> <span class="n">psg</span><span class="p">,</span> <span class="n">n_elem</span><span class="p">,</span>
				    <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_do_simple_cmd - execute simple internal command</span>
<span class="cm"> *	@dev: Device to which the command is sent</span>
<span class="cm"> *	@cmd: Opcode to execute</span>
<span class="cm"> *</span>
<span class="cm"> *	Execute a &#39;simple&#39; command, that only consists of the opcode</span>
<span class="cm"> *	&#39;cmd&#39; itself, without filling any other registers</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, AC_ERR_* mask on failure</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_do_simple_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>

	<span class="n">ata_tf_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>

	<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ata_exec_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pio_need_iordy	-	check if iordy needed</span>
<span class="cm"> *	@adev: ATA device</span>
<span class="cm"> *</span>
<span class="cm"> *	Check if the current speed of the device requires IORDY. Used</span>
<span class="cm"> *	by various controllers for chip configuration.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_pio_need_iordy</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t set IORDY if we&#39;re preparing for reset.  IORDY may</span>
<span class="cm">	 * lead to controller lock up on certain controllers if the</span>
<span class="cm">	 * port is not occupied.  See bko#11703 for details.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_RESETTING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Controller doesn&#39;t support IORDY.  Probably a pointless</span>
<span class="cm">	 * check as the caller should know this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_NO_IORDY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* CF spec. r4.1 Table 22 says no iordy on PIO5 and PIO6.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_is_cfa</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">==</span> <span class="n">XFER_PIO_5</span> <span class="o">||</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">==</span> <span class="n">XFER_PIO_6</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* PIO3 and higher it is mandatory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">&gt;</span> <span class="n">XFER_PIO_2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* We turn it on when possible */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_iordy</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pio_mask_no_iordy	-	Return the non IORDY mask</span>
<span class="cm"> *	@adev: ATA device</span>
<span class="cm"> *</span>
<span class="cm"> *	Compute the highest mode possible if we are not using iordy. Return</span>
<span class="cm"> *	-1 if no iordy mode is available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">ata_pio_mask_no_iordy</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we have no drive specific rule, then PIO 2 is non IORDY */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_FIELD_VALID</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* EIDE */</span>
		<span class="n">u16</span> <span class="n">pio</span> <span class="o">=</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_EIDE_PIO</span><span class="p">];</span>
		<span class="cm">/* Is the speed faster than the drive allows non IORDY ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pio</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is cycle times not frequency - watch the logic! */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pio</span> <span class="o">&gt;</span> <span class="mi">240</span><span class="p">)</span>	<span class="cm">/* PIO2 is 240nS per cycle */</span>
				<span class="k">return</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">7</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_do_dev_read_id		-	default ID read method</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@tf: proposed taskfile</span>
<span class="cm"> *	@id: data buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue the identify taskfile and hand back the buffer containing</span>
<span class="cm"> *	identify data. For some RAID controllers and for pre ATA devices</span>
<span class="cm"> *	this function is wrapped or replaced by the driver</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_do_dev_read_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_exec_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">,</span>
				     <span class="n">id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">ATA_ID_WORDS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_read_id - Read ID data from the specified device</span>
<span class="cm"> *	@dev: target device</span>
<span class="cm"> *	@p_class: pointer to class of the target device (may be changed)</span>
<span class="cm"> *	@flags: ATA_READID_* flags</span>
<span class="cm"> *	@id: buffer to read IDENTIFY data into</span>
<span class="cm"> *</span>
<span class="cm"> *	Read ID data from the specified device.  ATA_CMD_ID_ATA is</span>
<span class="cm"> *	performed on ATA devices and ATA_CMD_ID_ATAPI on ATAPI</span>
<span class="cm"> *	devices.  This function also issues ATA_CMD_INIT_DEV_PARAMS</span>
<span class="cm"> *	for pre-ATA4 drives.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: ATA_CMD_ID_ATA is optional for early drives and right</span>
<span class="cm"> *	now we abort if we hit that case.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_dev_read_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p_class</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span> <span class="o">=</span> <span class="o">*</span><span class="n">p_class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_semb</span> <span class="o">=</span> <span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_SEMB</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">may_fallback</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tried_spinup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_ctl</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ata_dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">ata_tf_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_DEV_SEMB</span>:
		<span class="n">class</span> <span class="o">=</span> <span class="n">ATA_DEV_ATA</span><span class="p">;</span>	<span class="cm">/* some hard drives report SEMB sig */</span>
	<span class="k">case</span> <span class="n">ATA_DEV_ATA</span>:
		<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_ID_ATA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_DEV_ATAPI</span>:
		<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_ID_ATAPI</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;unsupported class&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_PIO</span><span class="p">;</span>

	<span class="cm">/* Some devices choke if TF registers contain garbage.  Make</span>
<span class="cm">	 * sure those are properly initialized.</span>
<span class="cm">	 */</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>

	<span class="cm">/* Device presence detection is unreliable on some</span>
<span class="cm">	 * controllers.  Always poll IDENTIFY if available.</span>
<span class="cm">	 */</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_id</span><span class="p">)</span>
		<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_id</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_do_dev_read_id</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="n">AC_ERR_NODEV_HINT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NODEV after polling detection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_semb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;IDENTIFY failed on device w/ SEMB sig, disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* SEMB is not supported yet */</span>
			<span class="o">*</span><span class="n">p_class</span> <span class="o">=</span> <span class="n">ATA_DEV_SEMB_UNSUP</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">err_mask</span> <span class="o">==</span> <span class="n">AC_ERR_DEV</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">ATA_ABORTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Device or controller might have reported</span>
<span class="cm">			 * the wrong device class.  Give a shot at the</span>
<span class="cm">			 * other IDENTIFY if the current one is</span>
<span class="cm">			 * aborted by the device.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">may_fallback</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">may_fallback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA</span><span class="p">)</span>
					<span class="n">class</span> <span class="o">=</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">class</span> <span class="o">=</span> <span class="n">ATA_DEV_ATA</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Control reaches here iff the device aborted</span>
<span class="cm">			 * both flavors of IDENTIFYs which happens</span>
<span class="cm">			 * sometimes with phantom devices.</span>
<span class="cm">			 */</span>
			<span class="n">ata_dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;both IDENTIFYs aborted, assuming NODEV</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;I/O error&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_DUMP_ID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;dumping IDENTIFY data, &quot;</span>
			    <span class="s">&quot;class=%d may_fallback=%d tried_spinup=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">class</span><span class="p">,</span> <span class="n">may_fallback</span><span class="p">,</span> <span class="n">tried_spinup</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span>
			       <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">ATA_ID_WORDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">id</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Falling back doesn&#39;t make sense if ID data was read</span>
<span class="cm">	 * successfully at least once.</span>
<span class="cm">	 */</span>
	<span class="n">may_fallback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">swap_buf_le16</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">ATA_ID_WORDS</span><span class="p">);</span>

	<span class="cm">/* sanity check */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;device reports invalid type&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_id_is_ata</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ata_id_is_cfa</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_HOST_IGNORE_ATA</span> <span class="o">&amp;&amp;</span>
							<span class="n">ata_id_is_ata</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ata_dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;host indicates ignore ATA devices, ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_is_ata</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tried_spinup</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x37c8</span> <span class="o">||</span> <span class="n">id</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x738c</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tried_spinup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drive powered-up in standby mode, and requires a specific</span>
<span class="cm">		 * SET_FEATURES spin-up subcommand before it will accept</span>
<span class="cm">		 * anything other than the original IDENTIFY command.</span>
<span class="cm">		 */</span>
		<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_dev_set_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SETFEATURES_SPINUP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">&amp;&amp;</span> <span class="n">id</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0x738c</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;SPINUP failed&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the drive initially returned incomplete IDENTIFY info,</span>
<span class="cm">		 * we now must reissue the IDENTIFY command.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x37c8</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_READID_POSTRESET</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The exact sequence expected by certain pre-ATA4 drives is:</span>
<span class="cm">		 * SRST RESET</span>
<span class="cm">		 * IDENTIFY (optional in early ATA)</span>
<span class="cm">		 * INITIALIZE DEVICE PARAMETERS (later IDE and ATA)</span>
<span class="cm">		 * anything else..</span>
<span class="cm">		 * Some drives were very specific about that exact sequence.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that ATA4 says lba is mandatory so the second check</span>
<span class="cm">		 * should never trigger.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_major_version</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">||</span> <span class="o">!</span><span class="n">ata_id_has_lba</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_dev_init_params</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">id</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;INIT_DEV_PARAMS failed&quot;</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* current CHS translation info (id[53-58]) might be</span>
<span class="cm">			 * changed. reread the identify device info.</span>
<span class="cm">			 */</span>
			<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_READID_POSTRESET</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">p_class</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to IDENTIFY (%s, err_mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">reason</span><span class="p">,</span> <span class="n">err_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_do_link_spd_horkage</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">plink</span> <span class="o">=</span> <span class="n">ata_dev_phys_link</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">target</span><span class="p">,</span> <span class="n">target_limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sata_scr_valid</span><span class="p">(</span><span class="n">plink</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_1_5_GBPS</span><span class="p">)</span>
		<span class="n">target</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">target_limit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* if already on stricter limit, no need to push further */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plink</span><span class="o">-&gt;</span><span class="n">sata_spd_limit</span> <span class="o">&lt;=</span> <span class="n">target_limit</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">plink</span><span class="o">-&gt;</span><span class="n">sata_spd_limit</span> <span class="o">=</span> <span class="n">target_limit</span><span class="p">;</span>

	<span class="cm">/* Request another EH round by returning -EAGAIN if link is</span>
<span class="cm">	 * going faster than the target speed.  Forward progress is</span>
<span class="cm">	 * guaranteed by setting sata_spd_limit to target_limit above.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">plink</span><span class="o">-&gt;</span><span class="n">sata_spd</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;applying link speed limit horkage to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">sata_spd_string</span><span class="p">(</span><span class="n">target</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">ata_dev_knobble</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_dev_blacklisted</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_BRIDGE_OK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">==</span> <span class="n">ATA_CBL_SATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_id_is_sata</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_dev_config_ncq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">desc_sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hdepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ddepth</span> <span class="o">=</span> <span class="n">ata_id_queue_depth</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">aa_desc</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_id_has_ncq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_NONCQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">desc_sz</span><span class="p">,</span> <span class="s">&quot;NCQ (not used)&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_NCQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hdepth</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">,</span> <span class="n">ATA_MAX_QUEUE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_NCQ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_BROKEN_FPDMA_AA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_FPDMA_AA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">ata_id_has_fpdma_aa</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_dev_set_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SETFEATURES_SATA_ENABLE</span><span class="p">,</span>
			<span class="n">SATA_FPDMA_AA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				    <span class="s">&quot;failed to enable AA (error_mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">err_mask</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">!=</span> <span class="n">AC_ERR_DEV</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">|=</span> <span class="n">ATA_HORKAGE_BROKEN_FPDMA_AA</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">aa_desc</span> <span class="o">=</span> <span class="s">&quot;, AA&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdepth</span> <span class="o">&gt;=</span> <span class="n">ddepth</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">desc_sz</span><span class="p">,</span> <span class="s">&quot;NCQ (depth %d)%s&quot;</span><span class="p">,</span> <span class="n">ddepth</span><span class="p">,</span> <span class="n">aa_desc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">desc_sz</span><span class="p">,</span> <span class="s">&quot;NCQ (depth %d/%d)%s&quot;</span><span class="p">,</span> <span class="n">hdepth</span><span class="p">,</span>
			<span class="n">ddepth</span><span class="p">,</span> <span class="n">aa_desc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_configure - Configure the specified ATA/ATAPI device</span>
<span class="cm"> *	@dev: Target device to configure</span>
<span class="cm"> *</span>
<span class="cm"> *	Configure @dev according to @dev-&gt;id.  Generic and low-level</span>
<span class="cm"> *	driver specific fixups are also applied.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_dev_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="o">*</span><span class="n">ehc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">print_info</span> <span class="o">=</span> <span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_EHI_PRINTINFO</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">revbuf</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>		<span class="cm">/* XYZ-99\0 */</span>
	<span class="kt">char</span> <span class="n">fwrevbuf</span><span class="p">[</span><span class="n">ATA_ID_FW_REV_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">modelbuf</span><span class="p">[</span><span class="n">ATA_ID_PROD_LEN</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_dev_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ata_msg_info</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: ENTER/EXIT -- nodev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ata_dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* set horkage */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">|=</span> <span class="n">ata_dev_blacklisted</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ata_force_horkage</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported device, disabling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ata_dev_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">atapi_enabled</span> <span class="o">||</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_NO_ATAPI</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WARNING: ATAPI is %s, device ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">atapi_enabled</span> <span class="o">?</span> <span class="s">&quot;not supported with this driver&quot;</span>
			     <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>
		<span class="n">ata_dev_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_do_link_spd_horkage</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* let ACPI work its magic */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_acpi_on_devcfg</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* massage HPA, do it early as it might change IDENTIFY data */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_hpa_resize</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* print device capabilities */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ata_dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			    <span class="s">&quot;%s: cfg 49:%04x 82:%04x 83:%04x 84:%04x &quot;</span>
			    <span class="s">&quot;85:%04x 86:%04x 87:%04x 88:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">__func__</span><span class="p">,</span>
			    <span class="n">id</span><span class="p">[</span><span class="mi">49</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="mi">82</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="mi">83</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="mi">84</span><span class="p">],</span>
			    <span class="n">id</span><span class="p">[</span><span class="mi">85</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="mi">86</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="mi">87</span><span class="p">],</span> <span class="n">id</span><span class="p">[</span><span class="mi">88</span><span class="p">]);</span>

	<span class="cm">/* initialize to-be-configured parameters */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DFLAG_CFG_MASK</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * common ATA, ATAPI feature tests</span>
<span class="cm">	 */</span>

	<span class="cm">/* find max transfer mode; for printk only */</span>
	<span class="n">xfer_mask</span> <span class="o">=</span> <span class="n">ata_id_xfermask</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ata_dump_id</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

	<span class="cm">/* SCSI only uses 4-char revisions, dump full 8 chars from ATA */</span>
	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">fwrevbuf</span><span class="p">,</span> <span class="n">ATA_ID_FW_REV</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">fwrevbuf</span><span class="p">));</span>

	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">modelbuf</span><span class="p">,</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">modelbuf</span><span class="p">));</span>

	<span class="cm">/* ATA-specific feature tests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_is_cfa</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* CPRM may make this media unusable */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_CFA_KEY_MGMT</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
	<span class="s">&quot;supports DRM functions and may not be fully accessible</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">revbuf</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s">&quot;CFA&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">revbuf</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s">&quot;ATA-%d&quot;</span><span class="p">,</span> <span class="n">ata_id_major_version</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
			<span class="cm">/* Warn the user if the device has TPM extensions */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_tpm</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
				<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
	<span class="s">&quot;supports DRM functions and may not be fully accessible</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">=</span> <span class="n">ata_id_n_sectors</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

		<span class="cm">/* get current R/W Multiple count setting */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">[</span><span class="mi">47</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">[</span><span class="mi">59</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x100</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">[</span><span class="mi">47</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">[</span><span class="mi">59</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="cm">/* only recognize/allow powers of two here */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">max</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_power_of_2</span><span class="p">(</span><span class="n">cnt</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">)</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_lba</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lba_desc</span><span class="p">;</span>
			<span class="kt">char</span> <span class="n">ncq_desc</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>

			<span class="n">lba_desc</span> <span class="o">=</span> <span class="s">&quot;LBA&quot;</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_LBA</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_lba48</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_LBA48</span><span class="p">;</span>
				<span class="n">lba_desc</span> <span class="o">=</span> <span class="s">&quot;LBA48&quot;</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">ata_id_has_flush_ext</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_FLUSH_EXT</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* config NCQ */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_config_ncq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ncq_desc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ncq_desc</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

			<span class="cm">/* print device info to dmesg */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_drv</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">print_info</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %s, %s, max %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">revbuf</span><span class="p">,</span> <span class="n">modelbuf</span><span class="p">,</span> <span class="n">fwrevbuf</span><span class="p">,</span>
					     <span class="n">ata_mode_string</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">));</span>
				<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					     <span class="s">&quot;%llu sectors, multi %u: %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span><span class="p">,</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span><span class="p">,</span> <span class="n">lba_desc</span><span class="p">,</span> <span class="n">ncq_desc</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* CHS */</span>

			<span class="cm">/* Default translation */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cylinders</span>	<span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span>	<span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span>	<span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_current_chs_valid</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Current CHS translation is valid. */</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="mi">54</span><span class="p">];</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span>     <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="mi">55</span><span class="p">];</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span>   <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="mi">56</span><span class="p">];</span>
			<span class="p">}</span>

			<span class="cm">/* print device info to dmesg */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_drv</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">print_info</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: %s, %s, max %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">revbuf</span><span class="p">,</span>	<span class="n">modelbuf</span><span class="p">,</span> <span class="n">fwrevbuf</span><span class="p">,</span>
					     <span class="n">ata_mode_string</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">));</span>
				<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					     <span class="s">&quot;%llu sectors, multi %u, CHS %u/%u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span><span class="p">,</span>
					     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cylinders</span><span class="p">,</span>
					     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ATAPI-specific feature tests */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cdb_intr_string</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">atapi_an_string</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dma_dir_string</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sntf</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">atapi_cdb_len</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="n">ATAPI_CDB_LEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
				<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsupported CDB len</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out_nosup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/* Enable ATAPI AN if both the host and device have</span>
<span class="cm">		 * the support.  If PMP is attached, SNTF is required</span>
<span class="cm">		 * to enable ATAPI AN to discern between PHY status</span>
<span class="cm">		 * changed notifications and ATAPI ANs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atapi_an</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_AN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ata_id_has_atapi_AN</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">sata_scr_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_NOTIFICATION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sntf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span><span class="p">;</span>

			<span class="cm">/* issue SET feature command to turn this on */</span>
			<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_dev_set_feature</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">SETFEATURES_SATA_ENABLE</span><span class="p">,</span> <span class="n">SATA_AN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span><span class="p">)</span>
				<span class="n">ata_dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
					    <span class="s">&quot;failed to enable ATAPI AN (err_mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">err_mask</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_AN</span><span class="p">;</span>
				<span class="n">atapi_an_string</span> <span class="o">=</span> <span class="s">&quot;, ATAPI AN&quot;</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_cdb_intr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_CDB_INTR</span><span class="p">;</span>
			<span class="n">cdb_intr_string</span> <span class="o">=</span> <span class="s">&quot;, CDB intr&quot;</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atapi_dmadir</span> <span class="o">||</span> <span class="n">atapi_id_dmadir</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_DMADIR</span><span class="p">;</span>
			<span class="n">dma_dir_string</span> <span class="o">=</span> <span class="s">&quot;, DMADIR&quot;</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* print device info to dmesg */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_drv</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">print_info</span><span class="p">)</span>
			<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;ATAPI: %s, %s, max %s%s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">modelbuf</span><span class="p">,</span> <span class="n">fwrevbuf</span><span class="p">,</span>
				     <span class="n">ata_mode_string</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">),</span>
				     <span class="n">cdb_intr_string</span><span class="p">,</span> <span class="n">atapi_an_string</span><span class="p">,</span>
				     <span class="n">dma_dir_string</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* determine max_sectors */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">ATA_MAX_SECTORS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_LBA48</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">ATA_MAX_SECTORS_LBA48</span><span class="p">;</span>

	<span class="cm">/* Limit PATA drive on SATA cable bridge transfers to udma5,</span>
<span class="cm">	   200 sectors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_dev_knobble</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_drv</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">print_info</span><span class="p">)</span>
			<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;applying bridge limits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">&amp;=</span> <span class="n">ATA_UDMA5</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">ATA_MAX_SECTORS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">atapi_command_packet_set</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_TAPE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">ATA_MAX_SECTORS_TAPE</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">|=</span> <span class="n">ATA_HORKAGE_STUCK_ERR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_MAX_SEC_128</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ATA_MAX_SECTORS_128</span><span class="p">,</span>
					 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_sectors</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dev_config</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dev_config</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_DIAGNOSTIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Let the user know. We don&#39;t want to disallow opens for</span>
<span class="cm">		   rescue purposes, or in case the vendor is just a blithering</span>
<span class="cm">		   idiot. Do this after the dev_config call as some controllers</span>
<span class="cm">		   with buggy firmware may want to avoid reporting false device</span>
<span class="cm">		   bugs */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">print_info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
<span class="s">&quot;Drive reports diagnostics failure. This may indicate a drive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
<span class="s">&quot;fault or invalid emulation. Contact drive vendor for information.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_FIRMWARE_WARN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">print_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WARNING: device requires firmware update to be fully functional</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;         contact the vendor or visit http://ata.wiki.kernel.org</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_nosup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ata_dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: EXIT, err</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_cable_40wire	-	return 40 wire cable type</span>
<span class="cm"> *	@ap: port</span>
<span class="cm"> *</span>
<span class="cm"> *	Helper method for drivers which want to hardwire 40 wire cable</span>
<span class="cm"> *	detection.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_cable_40wire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ATA_CBL_PATA40</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_cable_80wire	-	return 80 wire cable type</span>
<span class="cm"> *	@ap: port</span>
<span class="cm"> *</span>
<span class="cm"> *	Helper method for drivers which want to hardwire 80 wire cable</span>
<span class="cm"> *	detection.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_cable_80wire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ATA_CBL_PATA80</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_cable_unknown	-	return unknown PATA cable.</span>
<span class="cm"> *	@ap: port</span>
<span class="cm"> *</span>
<span class="cm"> *	Helper method for drivers which have no PATA cable detection.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_cable_unknown</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ATA_CBL_PATA_UNK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_cable_ignore	-	return ignored PATA cable.</span>
<span class="cm"> *	@ap: port</span>
<span class="cm"> *</span>
<span class="cm"> *	Helper method for drivers which don&#39;t use cable type to limit</span>
<span class="cm"> *	transfer mode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_cable_ignore</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ATA_CBL_PATA_IGN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_cable_sata	-	return SATA cable type</span>
<span class="cm"> *	@ap: port</span>
<span class="cm"> *</span>
<span class="cm"> *	Helper method for drivers which have SATA cables</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_cable_sata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ATA_CBL_SATA</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bus_probe - Reset and probe ATA bus</span>
<span class="cm"> *	@ap: Bus to probe</span>
<span class="cm"> *</span>
<span class="cm"> *	Master ATA bus probing function.  Initiates a hardware-dependent</span>
<span class="cm"> *	bus reset, then attempts to identify any devices found on</span>
<span class="cm"> *	the bus.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	PCI/etc. bus probe sem.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, negative errno otherwise.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_bus_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">classes</span><span class="p">[</span><span class="n">ATA_MAX_DEVICES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">[</span><span class="n">ATA_MAX_DEVICES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">ALL</span><span class="p">)</span>
		<span class="n">tries</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span> <span class="o">=</span> <span class="n">ATA_PROBE_MAX_TRIES</span><span class="p">;</span>

 <span class="nl">retry:</span>
	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we issue an SRST then an ATA drive (not ATAPI)</span>
<span class="cm">		 * may change configuration and be in PIO0 timing. If</span>
<span class="cm">		 * we do a hard reset (or are coming from power on)</span>
<span class="cm">		 * this is true for ATA or ATAPI. Until we&#39;ve set a</span>
<span class="cm">		 * suitable controller mode we should not touch the</span>
<span class="cm">		 * bus as we may be talking too fast.</span>
<span class="cm">		 */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">=</span> <span class="n">XFER_PIO_0</span><span class="p">;</span>

		<span class="cm">/* If the controller has a pio mode setup function</span>
<span class="cm">		 * then use it to set the chipset to rights. Don&#39;t</span>
<span class="cm">		 * touch the DMA setup as that will be dealt with when</span>
<span class="cm">		 * configuring devices.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_piomode</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_piomode</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* reset and determine device classes */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">phy_reset</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">ATA_DEV_UNKNOWN</span><span class="p">)</span>
			<span class="n">classes</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">classes</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span> <span class="o">=</span> <span class="n">ATA_DEV_NONE</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">ATA_DEV_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* read IDENTIFY page and configure devices. We have to do the identify</span>
<span class="cm">	   specific sequence bass-ackwards so that PDIAG- is released by</span>
<span class="cm">	   the slave device */</span>

	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">ALL_REVERSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tries</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">])</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">classes</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_dev_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_read_id</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span> <span class="n">ATA_READID_POSTRESET</span><span class="p">,</span>
				     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now ask for the cable type as PDIAG- should have been released */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cable_detect</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cable_detect</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="cm">/* We may have SATA bridge glue hiding here irrespective of</span>
<span class="cm">	 * the reported cable types and sensed types.  When SATA</span>
<span class="cm">	 * drives indicate we have a bridge, we don&#39;t know which end</span>
<span class="cm">	 * of the link the bridge is which is a problem.</span>
<span class="cm">	 */</span>
	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_is_sata</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">=</span> <span class="n">ATA_CBL_SATA</span><span class="p">;</span>

	<span class="cm">/* After the identify sequence we can now set up the devices. We do</span>
<span class="cm">	   this in the normal order so that the user doesn&#39;t get confused */</span>

	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_context</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_EHI_PRINTINFO</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_configure</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_context</span><span class="p">.</span><span class="n">i</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_EHI_PRINTINFO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* configure transfer mode */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_set_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">tries</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINVAL</span>:
		<span class="cm">/* eeek, something went very wrong, give up */</span>
		<span class="n">tries</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
		<span class="cm">/* give it just one more chance */</span>
		<span class="n">tries</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tries</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EIO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">tries</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is the last chance, better to slow</span>
<span class="cm">			 * down than lose it.</span>
<span class="cm">			 */</span>
			<span class="n">sata_down_spd_limit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ata_down_xfermask_limit</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ATA_DNXFER_PIO</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tries</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">])</span>
		<span class="n">ata_dev_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_print_link_status - Print SATA link status</span>
<span class="cm"> *	@link: SATA link to printk link status about</span>
<span class="cm"> *</span>
<span class="cm"> *	This function prints link speed and status of a SATA link.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_print_link_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sstatus</span><span class="p">,</span> <span class="n">scontrol</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sstatus</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_phys_link_online</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sstatus</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">ata_link_info</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;SATA link up %s (SStatus %X SControl %X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">sata_spd_string</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">sstatus</span><span class="p">,</span> <span class="n">scontrol</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ata_link_info</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;SATA link down (SStatus %X SControl %X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">sstatus</span><span class="p">,</span> <span class="n">scontrol</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_pair		-	return other device on cable</span>
<span class="cm"> *	@adev: device</span>
<span class="cm"> *</span>
<span class="cm"> *	Obtain the other device on the same cable, or if none is</span>
<span class="cm"> *	present NULL is returned</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="nf">ata_dev_pair</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">pair</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_dev_enabled</span><span class="p">(</span><span class="n">pair</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pair</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_down_spd_limit - adjust SATA spd limit downward</span>
<span class="cm"> *	@link: Link to adjust SATA spd limit for</span>
<span class="cm"> *	@spd_limit: Additional limit</span>
<span class="cm"> *</span>
<span class="cm"> *	Adjust SATA spd limit of @link downward.  Note that this</span>
<span class="cm"> *	function only adjusts the limit.  The change must be applied</span>
<span class="cm"> *	using sata_set_spd().</span>
<span class="cm"> *</span>
<span class="cm"> *	If @spd_limit is non-zero, the speed is limited to equal to or</span>
<span class="cm"> *	lower than @spd_limit if such speed is supported.  If</span>
<span class="cm"> *	@spd_limit is slower than any supported speed, only the lowest</span>
<span class="cm"> *	supported speed is allowed.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, negative errno on failure</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_down_spd_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="n">u32</span> <span class="n">spd_limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sstatus</span><span class="p">,</span> <span class="n">spd</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">bit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sata_scr_valid</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* If SCR can be read, use it to determine the current SPD.</span>
<span class="cm">	 * If not, use cached value in link-&gt;sata_spd.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sstatus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ata_sstatus_online</span><span class="p">(</span><span class="n">sstatus</span><span class="p">))</span>
		<span class="n">spd</span> <span class="o">=</span> <span class="p">(</span><span class="n">sstatus</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">spd</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">sata_spd</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">sata_spd_limit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* unconditionally mask off the highest bit */</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>

	<span class="cm">/* Mask off all speeds higher than or equal to the current</span>
<span class="cm">	 * one.  Force 1.5Gbps if current SPD is not available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spd</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">spd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* were we already at the bottom? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spd_limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">spd_limit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">spd_limit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">bit</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">link</span><span class="o">-&gt;</span><span class="n">sata_spd_limit</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">ata_link_warn</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;limiting SATA link speed to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">sata_spd_string</span><span class="p">(</span><span class="n">fls</span><span class="p">(</span><span class="n">mask</span><span class="p">)));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__sata_set_spd_needed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">scontrol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">host_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">limit</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">spd</span><span class="p">;</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">sata_spd_limit</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t configure downstream link faster than upstream link.</span>
<span class="cm">	 * It doesn&#39;t speed up anything and some PMPs choke on such</span>
<span class="cm">	 * configuration.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">host_link</span><span class="o">-&gt;</span><span class="n">sata_spd</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">host_link</span><span class="o">-&gt;</span><span class="n">sata_spd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">==</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>

	<span class="n">spd</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">scontrol</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scontrol</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">scontrol</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf0</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">target</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">spd</span> <span class="o">!=</span> <span class="n">target</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_set_spd_needed - is SATA spd configuration needed</span>
<span class="cm"> *	@link: Link in question</span>
<span class="cm"> *</span>
<span class="cm"> *	Test whether the spd limit in SControl matches</span>
<span class="cm"> *	@link-&gt;sata_spd_limit.  This function is used to determine</span>
<span class="cm"> *	whether hardreset is necessary to apply SATA spd</span>
<span class="cm"> *	configuration.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	1 if SATA spd configuration is needed, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sata_set_spd_needed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">scontrol</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__sata_set_spd_needed</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_set_spd - set SATA spd according to spd limit</span>
<span class="cm"> *	@link: Link to set SATA spd for</span>
<span class="cm"> *</span>
<span class="cm"> *	Set SATA spd of @link according to sata_spd_limit.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 if spd doesn&#39;t need to be changed, 1 if spd has been</span>
<span class="cm"> *	changed.  Negative errno if SCR registers are inaccessible.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_set_spd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">scontrol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__sata_set_spd_needed</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="n">scontrol</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This mode timing computation functionality is ported over from</span>
<span class="cm"> * drivers/ide/ide-timing.h and was originally written by Vojtech Pavlik</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * PIO 0-4, MWDMA 0-2 and UDMA 0-6 timings (in nanoseconds).</span>
<span class="cm"> * These were taken from ATA/ATAPI-6 standard, rev 0a, except</span>
<span class="cm"> * for UDMA6, which is currently supported only by Maxtor drives.</span>
<span class="cm"> *</span>
<span class="cm"> * For PIO 5/6 MWDMA 3/4 see the CFA specification 3.0.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="n">ata_timing</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*	{ XFER_PIO_SLOW, 120, 290, 240, 960, 290, 240, 0,  960,   0 }, */</span>
	<span class="p">{</span> <span class="n">XFER_PIO_0</span><span class="p">,</span>     <span class="mi">70</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">165</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">600</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_PIO_1</span><span class="p">,</span>     <span class="mi">50</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span>  <span class="mi">93</span><span class="p">,</span> <span class="mi">383</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">383</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_PIO_2</span><span class="p">,</span>     <span class="mi">30</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span>  <span class="mi">40</span><span class="p">,</span> <span class="mi">330</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span>  <span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">240</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_PIO_3</span><span class="p">,</span>     <span class="mi">30</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span>  <span class="mi">70</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span>  <span class="mi">70</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">180</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_PIO_4</span><span class="p">,</span>     <span class="mi">25</span><span class="p">,</span>  <span class="mi">70</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span>  <span class="mi">70</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">120</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_PIO_5</span><span class="p">,</span>     <span class="mi">15</span><span class="p">,</span>  <span class="mi">65</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span>  <span class="mi">65</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">100</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_PIO_6</span><span class="p">,</span>     <span class="mi">10</span><span class="p">,</span>  <span class="mi">55</span><span class="p">,</span>  <span class="mi">20</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span>  <span class="mi">55</span><span class="p">,</span>  <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">80</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">XFER_SW_DMA_0</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">960</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_SW_DMA_1</span><span class="p">,</span>  <span class="mi">90</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_SW_DMA_2</span><span class="p">,</span>  <span class="mi">60</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">XFER_MW_DMA_0</span><span class="p">,</span>  <span class="mi">60</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">215</span><span class="p">,</span> <span class="mi">215</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_MW_DMA_1</span><span class="p">,</span>  <span class="mi">45</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span>  <span class="mi">50</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">150</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_MW_DMA_2</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">70</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">120</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_MW_DMA_3</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">65</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>  <span class="mi">100</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_MW_DMA_4</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">55</span><span class="p">,</span>  <span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>   <span class="mi">80</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>

<span class="cm">/*	{ XFER_UDMA_SLOW,  0,   0,   0,   0,   0,   0, 0,    0, 150 }, */</span>
	<span class="p">{</span> <span class="n">XFER_UDMA_0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span> <span class="mi">120</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_UDMA_1</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>  <span class="mi">80</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_UDMA_2</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>  <span class="mi">60</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_UDMA_3</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>  <span class="mi">45</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_UDMA_4</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>  <span class="mi">30</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_UDMA_5</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>  <span class="mi">20</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">XFER_UDMA_6</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>  <span class="mi">15</span> <span class="p">},</span>

	<span class="p">{</span> <span class="mh">0xFF</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#define ENOUGH(v, unit)		(((v)-1)/(unit)+1)</span>
<span class="cp">#define EZ(v, unit)		((v)?ENOUGH(v, unit):0)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_timing_quantize</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">UT</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">setup</span>	<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">setup</span>      <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>  <span class="n">T</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">act8b</span>	<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">act8b</span>      <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>  <span class="n">T</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">rec8b</span>	<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">rec8b</span>      <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>  <span class="n">T</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">cyc8b</span>	<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">cyc8b</span>      <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>  <span class="n">T</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">active</span>	<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">active</span>     <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>  <span class="n">T</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">recover</span>	<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">recover</span>    <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>  <span class="n">T</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">dmack_hold</span>	<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">dmack_hold</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>  <span class="n">T</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">cycle</span>	<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">cycle</span>      <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>  <span class="n">T</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">udma</span>		<span class="o">=</span> <span class="n">EZ</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">udma</span>       <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">UT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ata_timing_merge</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">what</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_SETUP</span>  <span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">setup</span>   <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">,</span>   <span class="n">b</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_ACT8B</span>  <span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">act8b</span>   <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">act8b</span><span class="p">,</span>   <span class="n">b</span><span class="o">-&gt;</span><span class="n">act8b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_REC8B</span>  <span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">rec8b</span>   <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rec8b</span><span class="p">,</span>   <span class="n">b</span><span class="o">-&gt;</span><span class="n">rec8b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_CYC8B</span>  <span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cyc8b</span>   <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">cyc8b</span><span class="p">,</span>   <span class="n">b</span><span class="o">-&gt;</span><span class="n">cyc8b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_ACTIVE</span> <span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">active</span>  <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">,</span>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_RECOVER</span><span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">recover</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">recover</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">recover</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_DMACK_HOLD</span><span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">dmack_hold</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">dmack_hold</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">dmack_hold</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_CYCLE</span>  <span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">cycle</span>   <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">cycle</span><span class="p">,</span>   <span class="n">b</span><span class="o">-&gt;</span><span class="n">cycle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">what</span> <span class="o">&amp;</span> <span class="n">ATA_TIMING_UDMA</span>   <span class="p">)</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">udma</span>    <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">udma</span><span class="p">,</span>    <span class="n">b</span><span class="o">-&gt;</span><span class="n">udma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="nf">ata_timing_find_mode</span><span class="p">(</span><span class="n">u8</span> <span class="n">xfer_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">ata_timing</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">xfer_mode</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span>
		<span class="n">t</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_mode</span> <span class="o">==</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ata_timing_compute</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">speed</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">UT</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_timing</span> <span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the mode.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">ata_timing_find_mode</span><span class="p">(</span><span class="n">speed</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the drive is an EIDE drive, it can tell us it needs extended</span>
<span class="cm">	 * PIO/MW_DMA cycle timing.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_FIELD_VALID</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* EIDE drive */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="n">XFER_PIO_0</span> <span class="o">&amp;&amp;</span> <span class="n">speed</span> <span class="o">&lt;</span> <span class="n">XFER_SW_DMA_0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&lt;=</span> <span class="n">XFER_PIO_2</span><span class="p">)</span>
				<span class="n">p</span><span class="p">.</span><span class="n">cycle</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">cyc8b</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_EIDE_PIO</span><span class="p">];</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">speed</span> <span class="o">&lt;=</span> <span class="n">XFER_PIO_4</span><span class="p">)</span> <span class="o">||</span>
				 <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="n">XFER_PIO_5</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ata_id_is_cfa</span><span class="p">(</span><span class="n">id</span><span class="p">)))</span>
				<span class="n">p</span><span class="p">.</span><span class="n">cycle</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">cyc8b</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_EIDE_PIO_IORDY</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;=</span> <span class="n">XFER_MW_DMA_0</span> <span class="o">&amp;&amp;</span> <span class="n">speed</span> <span class="o">&lt;=</span> <span class="n">XFER_MW_DMA_2</span><span class="p">)</span>
			<span class="n">p</span><span class="p">.</span><span class="n">cycle</span> <span class="o">=</span> <span class="n">id</span><span class="p">[</span><span class="n">ATA_ID_EIDE_DMA_MIN</span><span class="p">];</span>

		<span class="n">ata_timing_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ATA_TIMING_CYCLE</span> <span class="o">|</span> <span class="n">ATA_TIMING_CYC8B</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert the timing to bus clock counts.</span>
<span class="cm">	 */</span>

	<span class="n">ata_timing_quantize</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">UT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even in DMA/UDMA modes we still use PIO access for IDENTIFY,</span>
<span class="cm">	 * S.M.A.R.T * and some other commands. We have to ensure that the</span>
<span class="cm">	 * DMA cycle timing is slower/equal than the fastest PIO timing.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="n">XFER_PIO_6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_timing_compute</span><span class="p">(</span><span class="n">adev</span><span class="p">,</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">pio_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">UT</span><span class="p">);</span>
		<span class="n">ata_timing_merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ATA_TIMING_ALL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lengthen active &amp; recovery time so that cycle time is correct.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">act8b</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rec8b</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">cyc8b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">act8b</span> <span class="o">+=</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">cyc8b</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">act8b</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rec8b</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">rec8b</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">cyc8b</span> <span class="o">-</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">act8b</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">recover</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">cycle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">+=</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">cycle</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">recover</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">recover</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">cycle</span> <span class="o">-</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* In a few cases quantisation may produce enough errors to</span>
<span class="cm">	   leave t-&gt;cycle too low for the sum of active and recovery</span>
<span class="cm">	   if so we must correct this */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">recover</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">cycle</span><span class="p">)</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">cycle</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">recover</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_timing_cycle2mode - find xfer mode for the specified cycle duration</span>
<span class="cm"> *	@xfer_shift: ATA_SHIFT_* value for transfer type to examine.</span>
<span class="cm"> *	@cycle: cycle duration in ns</span>
<span class="cm"> *</span>
<span class="cm"> *	Return matching xfer mode for @cycle.  The returned mode is of</span>
<span class="cm"> *	the transfer type specified by @xfer_shift.  If @cycle is too</span>
<span class="cm"> *	slow for @xfer_shift, 0xff is returned.  If @cycle is faster</span>
<span class="cm"> *	than the fastest known mode, the fasted mode is returned.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Matching xfer_mode, 0xff if no match found.</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="nf">ata_timing_cycle2mode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xfer_shift</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cycle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">base_mode</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">last_mode</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_xfer_ent</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_timing</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ent</span> <span class="o">=</span> <span class="n">ata_xfer_tbl</span><span class="p">;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ent</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">shift</span> <span class="o">==</span> <span class="n">xfer_shift</span><span class="p">)</span>
			<span class="n">base_mode</span> <span class="o">=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">ata_timing_find_mode</span><span class="p">(</span><span class="n">base_mode</span><span class="p">);</span>
	     <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="n">ata_xfer_mode2shift</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="o">==</span> <span class="n">xfer_shift</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">this_cycle</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">xfer_shift</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ATA_SHIFT_PIO</span>:
		<span class="k">case</span> <span class="n">ATA_SHIFT_MWDMA</span>:
			<span class="n">this_cycle</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">cycle</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ATA_SHIFT_UDMA</span>:
			<span class="n">this_cycle</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">udma</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cycle</span> <span class="o">&gt;</span> <span class="n">this_cycle</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">last_mode</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">last_mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_down_xfermask_limit - adjust dev xfer masks downward</span>
<span class="cm"> *	@dev: Device to adjust xfer masks</span>
<span class="cm"> *	@sel: ATA_DNXFER_* selector</span>
<span class="cm"> *</span>
<span class="cm"> *	Adjust xfer masks of @dev downward.  Note that this function</span>
<span class="cm"> *	does not apply the change.  Invoking ata_set_mode() afterwards</span>
<span class="cm"> *	will apply the limit.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, negative errno on failure</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_down_xfermask_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_mask</span><span class="p">,</span> <span class="n">xfer_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pio_mask</span><span class="p">,</span> <span class="n">mwdma_mask</span><span class="p">,</span> <span class="n">udma_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">quiet</span><span class="p">,</span> <span class="n">highbit</span><span class="p">;</span>

	<span class="n">quiet</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">sel</span> <span class="o">&amp;</span> <span class="n">ATA_DNXFER_QUIET</span><span class="p">);</span>
	<span class="n">sel</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DNXFER_QUIET</span><span class="p">;</span>

	<span class="n">xfer_mask</span> <span class="o">=</span> <span class="n">orig_mask</span> <span class="o">=</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">,</span>
						  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">,</span>
						  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">);</span>
	<span class="n">ata_unpack_xfermask</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pio_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mwdma_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">udma_mask</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_DNXFER_PIO</span>:
		<span class="n">highbit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">pio_mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pio_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">highbit</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATA_DNXFER_DMA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">udma_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">highbit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">udma_mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">udma_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">highbit</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udma_mask</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mwdma_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">highbit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">mwdma_mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">mwdma_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">highbit</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mwdma_mask</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATA_DNXFER_40C</span>:
		<span class="n">udma_mask</span> <span class="o">&amp;=</span> <span class="n">ATA_UDMA_MASK_40C</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATA_DNXFER_FORCE_PIO0</span>:
		<span class="n">pio_mask</span> <span class="o">&amp;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_DNXFER_FORCE_PIO</span>:
		<span class="n">mwdma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="n">pio_mask</span><span class="p">,</span> <span class="n">mwdma_mask</span><span class="p">,</span> <span class="n">udma_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xfer_mask</span> <span class="o">&amp;</span> <span class="n">ATA_MASK_PIO</span><span class="p">)</span> <span class="o">||</span> <span class="n">xfer_mask</span> <span class="o">==</span> <span class="n">orig_mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xfer_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_MASK_MWDMA</span> <span class="o">|</span> <span class="n">ATA_MASK_UDMA</span><span class="p">))</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%s:%s&quot;</span><span class="p">,</span>
				 <span class="n">ata_mode_string</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">),</span>
				 <span class="n">ata_mode_string</span><span class="p">(</span><span class="n">xfer_mask</span> <span class="o">&amp;</span> <span class="n">ATA_MASK_PIO</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				 <span class="n">ata_mode_string</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">));</span>

		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;limiting speed to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ata_unpack_xfermask</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_dev_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="o">*</span><span class="n">ehc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">bool</span> <span class="n">nosetxfer</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_NOSETXFER</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_err_whine</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ign_dev_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DFLAG_PIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_shift</span> <span class="o">==</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_PIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nosetxfer</span> <span class="o">&amp;&amp;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SATA</span> <span class="o">&amp;&amp;</span> <span class="n">ata_id_is_sata</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
		<span class="n">dev_err_whine</span> <span class="o">=</span> <span class="s">&quot; (SET_XFERMODE skipped)&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nosetxfer</span><span class="p">)</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;NOSETXFER but PATA detected - can&#39;t &quot;</span>
				     <span class="s">&quot;skip SETXFER, might malfunction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_dev_set_xfermode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AC_ERR_DEV</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* revalidate */</span>
	<span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_EHI_POST_SETMODE</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_revalidate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ATA_DEV_UNKNOWN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_EHI_POST_SETMODE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_shift</span> <span class="o">==</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Old CFA may refuse this command, which is just fine */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_is_cfa</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
			<span class="n">ign_dev_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Catch several broken garbage emulations plus some pre</span>
<span class="cm">		   ATA devices */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_major_version</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
					<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">&lt;=</span> <span class="n">XFER_PIO_2</span><span class="p">)</span>
			<span class="n">ign_dev_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Some very old devices and some bad newer ones fail</span>
<span class="cm">		   any kind of SET_XFERMODE request but support PIO0-2</span>
<span class="cm">		   timings and no IORDY */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_id_has_iordy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">&lt;=</span> <span class="n">XFER_PIO_2</span><span class="p">)</span>
			<span class="n">ign_dev_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Early MWDMA devices do DMA but don&#39;t allow DMA mode setting.</span>
<span class="cm">	   Don&#39;t fail an MWDMA0 set IFF the device indicates it is in MWDMA0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_shift</span> <span class="o">==</span> <span class="n">ATA_SHIFT_MWDMA</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">==</span> <span class="n">XFER_MW_DMA_0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">[</span><span class="mi">63</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">ign_dev_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* if the device is actually configured correctly, ignore dev err */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_mode</span> <span class="o">==</span> <span class="n">ata_xfer_mask2mode</span><span class="p">(</span><span class="n">ata_id_xfermask</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)))</span>
		<span class="n">ign_dev_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="n">AC_ERR_DEV</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ign_dev_err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dev_err_whine</span> <span class="o">=</span> <span class="s">&quot; (device error ignored)&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;xfer_shift=%u, xfer_mode=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_shift</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_mode</span><span class="p">);</span>

	<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;configured for %s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ata_mode_string</span><span class="p">(</span><span class="n">ata_xfer_mode2mask</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_mode</span><span class="p">)),</span>
		     <span class="n">dev_err_whine</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">ata_dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to set xfermode (err_mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_do_set_mode - Program timings and issue SET FEATURES - XFER</span>
<span class="cm"> *	@link: link on which timings will be programmed</span>
<span class="cm"> *	@r_failed_dev: out parameter for failed device</span>
<span class="cm"> *</span>
<span class="cm"> *	Standard implementation of the function used to tune and set</span>
<span class="cm"> *	ATA device disk transfer mode (PIO3, UDMA6, etc.).  If</span>
<span class="cm"> *	ata_dev_set_mode() fails, pointer to the failing device is</span>
<span class="cm"> *	returned in @r_failed_dev.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	PCI/etc. bus probe sem.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, negative errno otherwise</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_do_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">**</span><span class="n">r_failed_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">used_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* step 1: calculate xfer_mask */</span>
	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pio_mask</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode_mask</span><span class="p">;</span>

		<span class="n">mode_mask</span> <span class="o">=</span> <span class="n">ATA_DMA_MASK_ATA</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">)</span>
			<span class="n">mode_mask</span> <span class="o">=</span> <span class="n">ATA_DMA_MASK_ATAPI</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ata_id_is_cfa</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
			<span class="n">mode_mask</span> <span class="o">=</span> <span class="n">ATA_DMA_MASK_CFA</span><span class="p">;</span>

		<span class="n">ata_dev_xfermask</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">ata_force_xfermask</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">pio_mask</span> <span class="o">=</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">libata_dma_mask</span> <span class="o">&amp;</span> <span class="n">mode_mask</span><span class="p">)</span>
			<span class="n">dma_mask</span> <span class="o">=</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">,</span>
						     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">=</span> <span class="n">ata_xfer_mask2mode</span><span class="p">(</span><span class="n">pio_mask</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">=</span> <span class="n">ata_xfer_mask2mode</span><span class="p">(</span><span class="n">dma_mask</span><span class="p">);</span>

		<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_dma_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">used_dma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* step 2: always set host PIO timings */</span>
	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no PIO support</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_mode</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mode</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_shift</span> <span class="o">=</span> <span class="n">ATA_SHIFT_PIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_piomode</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_piomode</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* step 3: set host DMA timings */</span>
	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_dma_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_mode</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mode</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_shift</span> <span class="o">=</span> <span class="n">ata_xfer_mode2shift</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_dmamode</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_dmamode</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* step 4: update devices&#39; xfer mode */</span>
	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_set_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Record simplex status. If we selected DMA then the other</span>
<span class="cm">	 * host channels are not permitted to do so.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used_dma</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_HOST_SIMPLEX</span><span class="p">))</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">simplex_claimed</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="o">*</span><span class="n">r_failed_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_wait_ready - wait for link to become ready</span>
<span class="cm"> *	@link: link to be waited on</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *	@check_ready: callback to check link readiness</span>
<span class="cm"> *</span>
<span class="cm"> *	Wait for @link to become ready.  @check_ready should return</span>
<span class="cm"> *	positive number if @link is ready, 0 if it isn&#39;t, -ENODEV if</span>
<span class="cm"> *	link doesn&#39;t seem to be occupied, other errno for other error</span>
<span class="cm"> *	conditions.</span>
<span class="cm"> *</span>
<span class="cm"> *	Transient -ENODEV conditions are allowed for</span>
<span class="cm"> *	ATA_TMOUT_FF_WAIT.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	EH context.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 if @linke is ready before @deadline; otherwise, -errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_wait_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nodev_deadline</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">warned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* choose which 0xff timeout to use, read comment in libata.h */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_HOST_PARALLEL_SCAN</span><span class="p">)</span>
		<span class="n">nodev_deadline</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ATA_TMOUT_FF_WAIT_LONG</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">nodev_deadline</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">ATA_TMOUT_FF_WAIT</span><span class="p">);</span>

	<span class="cm">/* Slave readiness can&#39;t be tested separately from master.  On</span>
<span class="cm">	 * M/S emulation configuration, this function should be called</span>
<span class="cm">	 * only on the master and it will handle both master and slave.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">nodev_deadline</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span>
		<span class="n">nodev_deadline</span> <span class="o">=</span> <span class="n">deadline</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ready</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">ready</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">check_ready</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ready</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * -ENODEV could be transient.  Ignore -ENODEV if link</span>
<span class="cm">		 * is online.  Also, some SATA devices take a long</span>
<span class="cm">		 * time to clear 0xff after reset.  Wait for</span>
<span class="cm">		 * ATA_TMOUT_FF_WAIT[_LONG] on -ENODEV if link isn&#39;t</span>
<span class="cm">		 * offline.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that some PATA controllers (pata_ali) explode</span>
<span class="cm">		 * if status register is read more than once when</span>
<span class="cm">		 * there&#39;s no device attached.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ready</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ata_link_online</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
				<span class="n">ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="o">!</span><span class="n">ata_link_offline</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="n">time_before</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">nodev_deadline</span><span class="p">))</span>
				<span class="n">ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ready</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ready</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warned</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">deadline</span> <span class="o">-</span> <span class="n">now</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ata_link_warn</span><span class="p">(</span><span class="n">link</span><span class="p">,</span>
				<span class="s">&quot;link is slow to respond, please be patient &quot;</span>
				<span class="s">&quot;(ready=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">warned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ata_msleep</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_wait_after_reset - wait for link to become ready after reset</span>
<span class="cm"> *	@link: link to be waited on</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *	@check_ready: callback to check link readiness</span>
<span class="cm"> *</span>
<span class="cm"> *	Wait for @link to become ready after reset.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	EH context.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 if @linke is ready before @deadline; otherwise, -errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_wait_after_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">ata_msleep</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_WAIT_AFTER_RESET</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ata_wait_ready</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">deadline</span><span class="p">,</span> <span class="n">check_ready</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_link_debounce - debounce SATA phy status</span>
<span class="cm"> *	@link: ATA link to debounce SATA phy status for</span>
<span class="cm"> *	@params: timing parameters { interval, duratinon, timeout } in msec</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	Make sure SStatus of @link reaches stable state, determined by</span>
<span class="cm"> *	holding the same value where DET is not 1 for @duration polled</span>
<span class="cm"> *	every @interval, before @timeout.  Timeout constraints the</span>
<span class="cm"> *	beginning of the stable state.  Because DET gets stuck at 1 on</span>
<span class="cm"> *	some controllers after hot unplugging, this functions waits</span>
<span class="cm"> *	until timeout then returns 0 if DET is stable at 1.</span>
<span class="cm"> *</span>
<span class="cm"> *	@timeout is further limited by @deadline.  The sooner of the</span>
<span class="cm"> *	two is used.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_link_debounce</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_jiffies</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last</span><span class="p">,</span> <span class="n">cur</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span>
		<span class="n">deadline</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">cur</span> <span class="o">&amp;=</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
	<span class="n">last_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_msleep</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">cur</span> <span class="o">&amp;=</span> <span class="mh">0xf</span><span class="p">;</span>

		<span class="cm">/* DET stable? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				       <span class="n">ata_deadline</span><span class="p">(</span><span class="n">last_jiffies</span><span class="p">,</span> <span class="n">duration</span><span class="p">)))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* unstable, start over */</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
		<span class="n">last_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="cm">/* Check deadline.  If debouncing failed, return</span>
<span class="cm">		 * -EPIPE to tell upper layer to lower link speed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_link_resume - resume SATA link</span>
<span class="cm"> *	@link: ATA link to resume SATA</span>
<span class="cm"> *	@params: timing parameters { interval, duratinon, timeout } in msec</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	Resume SATA phy @link and debounce it.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_link_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="n">ATA_LINK_RESUME_TRIES</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scontrol</span><span class="p">,</span> <span class="n">serror</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Writes to SControl sometimes get ignored under certain</span>
<span class="cm">	 * controllers (ata_piix SIDPR).  Make sure DET actually is</span>
<span class="cm">	 * cleared.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">scontrol</span> <span class="o">=</span> <span class="p">(</span><span class="n">scontrol</span> <span class="o">&amp;</span> <span class="mh">0x0f0</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x300</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="n">scontrol</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some PHYs react badly if SStatus is pounded</span>
<span class="cm">		 * immediately after resuming.  Delay 200ms before</span>
<span class="cm">		 * debouncing.</span>
<span class="cm">		 */</span>
		<span class="n">ata_msleep</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>

		<span class="cm">/* is SControl restored correctly? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">scontrol</span> <span class="o">&amp;</span> <span class="mh">0xf0f</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x300</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">tries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">scontrol</span> <span class="o">&amp;</span> <span class="mh">0xf0f</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x300</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_link_warn</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;failed to resume link (SControl %X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">scontrol</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&lt;</span> <span class="n">ATA_LINK_RESUME_TRIES</span><span class="p">)</span>
		<span class="n">ata_link_warn</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;link resume succeeded after %d retries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">ATA_LINK_RESUME_TRIES</span> <span class="o">-</span> <span class="n">tries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_link_debounce</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">deadline</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* clear SError, some PHYs require this even for SRST to work */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serror</span><span class="p">)))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_ERROR</span><span class="p">,</span> <span class="n">serror</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">?</span> <span class="n">rc</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_link_scr_lpm - manipulate SControl IPM and SPM fields</span>
<span class="cm"> *	@link: ATA link to manipulate SControl for</span>
<span class="cm"> *	@policy: LPM policy to configure</span>
<span class="cm"> *	@spm_wakeup: initiate LPM transition to active state</span>
<span class="cm"> *</span>
<span class="cm"> *	Manipulate the IPM field of the SControl register of @link</span>
<span class="cm"> *	according to @policy.  If @policy is ATA_LPM_MAX_POWER and</span>
<span class="cm"> *	@spm_wakeup is %true, the SPM field is manipulated to wake up</span>
<span class="cm"> *	the link.  This function also clears PHYRDY_CHG before</span>
<span class="cm"> *	returning.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	EH context.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on succes, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_link_scr_lpm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ata_lpm_policy</span> <span class="n">policy</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="n">spm_wakeup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="o">*</span><span class="n">ehc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">woken_up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scontrol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_LPM_MAX_POWER</span>:
		<span class="cm">/* disable all LPM transitions */</span>
		<span class="n">scontrol</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="cm">/* initiate transition to active state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spm_wakeup</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scontrol</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x4</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">);</span>
			<span class="n">woken_up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_LPM_MED_POWER</span>:
		<span class="cm">/* allow LPM to PARTIAL */</span>
		<span class="n">scontrol</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">scontrol</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x2</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_LPM_MIN_POWER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_link_nr_enabled</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* no restrictions on LPM transitions */</span>
			<span class="n">scontrol</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* empty port, power off */</span>
			<span class="n">scontrol</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>
			<span class="n">scontrol</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="n">scontrol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* give the link time to transit out of LPM state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">woken_up</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="cm">/* clear PHYRDY_CHG from SError */</span>
	<span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">serror</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SERR_PHYRDY_CHG</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sata_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_ERROR</span><span class="p">,</span> <span class="n">SERR_PHYRDY_CHG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_std_prereset - prepare for reset</span>
<span class="cm"> *	@link: ATA link to be reset</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	@link is about to be reset.  Initialize it.  Failure from</span>
<span class="cm"> *	prereset makes libata abort whole reset sequence and give up</span>
<span class="cm"> *	that port, so prereset should be best-effort.  It does its</span>
<span class="cm"> *	best to prepare for reset sequence but if things go wrong, it</span>
<span class="cm"> *	should just whine, not fail.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_std_prereset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="o">*</span><span class="n">ehc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timing</span> <span class="o">=</span> <span class="n">sata_ehc_deb_timing</span><span class="p">(</span><span class="n">ehc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* if we&#39;re about to do hardreset, nothing more to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">ATA_EH_HARDRESET</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* if SATA, resume link */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_link_resume</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
		<span class="cm">/* whine about phy resume failure but proceed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
			<span class="n">ata_link_warn</span><span class="p">(</span><span class="n">link</span><span class="p">,</span>
				      <span class="s">&quot;failed to resume link for reset (errno=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* no point in trying softreset on offline link */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_phys_link_offline</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
		<span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">action</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_EH_SOFTRESET</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_link_hardreset - reset link via SATA phy reset</span>
<span class="cm"> *	@link: link to reset</span>
<span class="cm"> *	@timing: timing parameters { interval, duratinon, timeout } in msec</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *	@online: optional out parameter indicating link onlineness</span>
<span class="cm"> *	@check_ready: optional callback to check link readiness</span>
<span class="cm"> *</span>
<span class="cm"> *	SATA phy-reset @link using DET bits of SControl register.</span>
<span class="cm"> *	After hardreset, link readiness is waited upon using</span>
<span class="cm"> *	ata_wait_ready() if @check_ready is specified.  LLDs are</span>
<span class="cm"> *	allowed to not specify @check_ready and wait itself after this</span>
<span class="cm"> *	function returns.  Device classification is LLD&#39;s</span>
<span class="cm"> *	responsibility.</span>
<span class="cm"> *</span>
<span class="cm"> *	*@online is set to one iff reset succeeded and @link is online</span>
<span class="cm"> *	after reset.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_link_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timing</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">,</span>
			<span class="n">bool</span> <span class="o">*</span><span class="n">online</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">scontrol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">online</span><span class="p">)</span>
		<span class="o">*</span><span class="n">online</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sata_set_spd_needed</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* SATA spec says nothing about how to reconfigure</span>
<span class="cm">		 * spd.  To be on the safe side, turn off phy during</span>
<span class="cm">		 * reconfiguration.  This works for at least ICH7 AHCI</span>
<span class="cm">		 * and Sil3124.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">scontrol</span> <span class="o">=</span> <span class="p">(</span><span class="n">scontrol</span> <span class="o">&amp;</span> <span class="mh">0x0f0</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x304</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="n">scontrol</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">sata_set_spd</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* issue phy wake/reset */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scontrol</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">scontrol</span> <span class="o">=</span> <span class="p">(</span><span class="n">scontrol</span> <span class="o">&amp;</span> <span class="mh">0x0f0</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x301</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_write_flush</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="n">scontrol</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Couldn&#39;t find anything in SATA I/II specs, but AHCI-1.1</span>
<span class="cm">	 * 10.4.2 says at least 1 ms.</span>
<span class="cm">	 */</span>
	<span class="n">ata_msleep</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* bring link back */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_link_resume</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* if link is offline nothing more to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_phys_link_offline</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Link is online.  From this point, -ENODEV too is an error. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">online</span><span class="p">)</span>
		<span class="o">*</span><span class="n">online</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sata_pmp_supported</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If PMP is supported, we have to do follow-up SRST.</span>
<span class="cm">		 * Some PMPs don&#39;t send D2H Reg FIS after hardreset if</span>
<span class="cm">		 * the first port is empty.  Wait only for</span>
<span class="cm">		 * ATA_TMOUT_PMP_SRST_WAIT.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_ready</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pmp_deadline</span><span class="p">;</span>

			<span class="n">pmp_deadline</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
						    <span class="n">ATA_TMOUT_PMP_SRST_WAIT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">pmp_deadline</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span>
				<span class="n">pmp_deadline</span> <span class="o">=</span> <span class="n">deadline</span><span class="p">;</span>
			<span class="n">ata_wait_ready</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">pmp_deadline</span><span class="p">,</span> <span class="n">check_ready</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_ready</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_wait_ready</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">deadline</span><span class="p">,</span> <span class="n">check_ready</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* online is set iff link is online &amp;&amp; reset succeeded */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">online</span><span class="p">)</span>
			<span class="o">*</span><span class="n">online</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">ata_link_err</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;COMRESET failed (errno=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT, rc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_std_hardreset - COMRESET w/o waiting or classification</span>
<span class="cm"> *	@link: link to reset</span>
<span class="cm"> *	@class: resulting class of attached device</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	Standard SATA COMRESET w/o waiting or classification.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 if link offline, -EAGAIN if link online, -errno on errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_std_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timing</span> <span class="o">=</span> <span class="n">sata_ehc_deb_timing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">online</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* do hardreset */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_link_hardreset</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">deadline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">online</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">online</span> <span class="o">?</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">:</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_std_postreset - standard postreset callback</span>
<span class="cm"> *	@link: the target ata_link</span>
<span class="cm"> *	@classes: classes of attached devices</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is invoked after a successful reset.  Note that</span>
<span class="cm"> *	the device might have been reset more than once using</span>
<span class="cm"> *	different reset methods before postreset is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_std_postreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">serror</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* reset complete, clear SError */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serror</span><span class="p">))</span>
		<span class="n">sata_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_ERROR</span><span class="p">,</span> <span class="n">serror</span><span class="p">);</span>

	<span class="cm">/* print link status */</span>
	<span class="n">sata_print_link_status</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_same_device - Determine whether new ID matches configured device</span>
<span class="cm"> *	@dev: device to compare against</span>
<span class="cm"> *	@new_class: class of the new device</span>
<span class="cm"> *	@new_id: IDENTIFY page of the new device</span>
<span class="cm"> *</span>
<span class="cm"> *	Compare @new_class and @new_id against @dev and determine</span>
<span class="cm"> *	whether @dev is the device indicated by @new_class and</span>
<span class="cm"> *	@new_id.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	1 if @dev matches @new_class and @new_id, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_dev_same_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_class</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">new_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="o">*</span><span class="n">old_id</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">model</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">ATA_ID_PROD_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">serial</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">ATA_ID_SERNO_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">new_class</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;class mismatch %d != %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span> <span class="n">new_class</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">old_id</span><span class="p">,</span> <span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">new_id</span><span class="p">,</span> <span class="n">model</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">old_id</span><span class="p">,</span> <span class="n">serial</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ATA_ID_SERNO</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serial</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">new_id</span><span class="p">,</span> <span class="n">serial</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ATA_ID_SERNO</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serial</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">model</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;model number mismatch &#39;%s&#39; != &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">model</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">serial</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">serial</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;serial number mismatch &#39;%s&#39; != &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">serial</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">serial</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_reread_id - Re-read IDENTIFY data</span>
<span class="cm"> *	@dev: target ATA device</span>
<span class="cm"> *	@readid_flags: read ID flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Re-read IDENTIFY page and make sure @dev is still attached to</span>
<span class="cm"> *	the port.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, negative errno otherwise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_dev_reread_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">readid_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">sector_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* read ID data */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_read_id</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">class</span><span class="p">,</span> <span class="n">readid_flags</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* is the device still there? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_dev_same_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">ATA_ID_WORDS</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_revalidate - Revalidate ATA device</span>
<span class="cm"> *	@dev: device to revalidate</span>
<span class="cm"> *	@new_class: new class code</span>
<span class="cm"> *	@readid_flags: read ID flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Re-read IDENTIFY page, make sure @dev is still attached to the</span>
<span class="cm"> *	port and reconfigure it according to the new IDENTIFY page.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, negative errno otherwise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_dev_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_class</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">readid_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">n_sectors</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">n_native_sectors</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_native_sectors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_dev_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* fail early if !ATA &amp;&amp; !ATAPI to avoid issuing [P]IDENTIFY to PMP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_class_enabled</span><span class="p">(</span><span class="n">new_class</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new_class</span> <span class="o">!=</span> <span class="n">ATA_DEV_ATA</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new_class</span> <span class="o">!=</span> <span class="n">ATA_DEV_ATAPI</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new_class</span> <span class="o">!=</span> <span class="n">ATA_DEV_SEMB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;class mismatch %u != %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span> <span class="n">new_class</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* re-read ID */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_reread_id</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">readid_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* configure device according to the new ID */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_dev_configure</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* verify n_sectors hasn&#39;t changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">ATA_DEV_ATA</span> <span class="o">||</span> <span class="o">!</span><span class="n">n_sectors</span> <span class="o">||</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">==</span> <span class="n">n_sectors</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* n_sectors has changed */</span>
	<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;n_sectors mismatch %llu != %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">n_sectors</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Something could have caused HPA to be unlocked</span>
<span class="cm">	 * involuntarily.  If n_native_sectors hasn&#39;t changed and the</span>
<span class="cm">	 * new size matches it, keep the device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_native_sectors</span> <span class="o">==</span> <span class="n">n_native_sectors</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">&gt;</span> <span class="n">n_sectors</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">==</span> <span class="n">n_native_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;new n_sectors matches native, probably &quot;</span>
			     <span class="s">&quot;late HPA unlock, n_sectors updated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* use the larger n_sectors */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some BIOSes boot w/o HPA but resume w/ HPA locked.  Try</span>
<span class="cm">	 * unlocking HPA in those cases.</span>
<span class="cm">	 *</span>
<span class="cm">	 * https://bugzilla.kernel.org/show_bug.cgi?id=15396</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_native_sectors</span> <span class="o">==</span> <span class="n">n_native_sectors</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">&lt;</span> <span class="n">n_sectors</span> <span class="o">&amp;&amp;</span> <span class="n">n_sectors</span> <span class="o">==</span> <span class="n">n_native_sectors</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_BROKEN_HPA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;old n_sectors matches native, probably &quot;</span>
			     <span class="s">&quot;late HPA lock, will try to unlock HPA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* try unlocking HPA */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_UNLOCK_HPA</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* restore original n_[native_]sectors and fail */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_native_sectors</span> <span class="o">=</span> <span class="n">n_native_sectors</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">=</span> <span class="n">n_sectors</span><span class="p">;</span>
 <span class="nl">fail:</span>
	<span class="n">ata_dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;revalidation failed (errno=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ata_blacklist_entry</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model_num</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model_rev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">horkage</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_blacklist_entry</span> <span class="n">ata_device_blacklist</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Devices with DMA related problems under Linux */</span>
	<span class="p">{</span> <span class="s">&quot;WDC AC11000H&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC AC22100H&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC AC32500H&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC AC33100H&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC AC31600H&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC AC32100H&quot;</span><span class="p">,</span>	<span class="s">&quot;24.09P07&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC AC23200L&quot;</span><span class="p">,</span>	<span class="s">&quot;21.10N21&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Compaq CRD-8241B&quot;</span><span class="p">,</span> 	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;CRD-8400B&quot;</span><span class="p">,</span>		<span class="nb">NULL</span><span class="p">,</span> 		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;CRD-848[02]B&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;CRD-84&quot;</span><span class="p">,</span>		<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SanDisk SDP3B&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SanDisk SDP3B-64&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SANYO CD-ROM CRD&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;HITACHI CDR-8&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;HITACHI CDR-8[34]35&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Toshiba CD-ROM XM-6202B&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;TOSHIBA CD-ROM XM-1702BC&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;CD-532E-A&quot;</span><span class="p">,</span> 		<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;E-IDE CD-ROM CR-840&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;CD-ROM Drive/F5A&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WPI CDD-820&quot;</span><span class="p">,</span> 	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SAMSUNG CD-ROM SC-148C&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SAMSUNG CD-ROM SC&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ATAPI CD-ROM DRIVE 40X MAXIMUM&quot;</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;_NEC DV5800A&quot;</span><span class="p">,</span> 	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;SAMSUNG CD-ROM SN-124&quot;</span><span class="p">,</span> <span class="s">&quot;N001&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Seagate STT20000A&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;2GB ATA Flash Disk&quot;</span><span class="p">,</span> <span class="s">&quot;ADMA428M&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NODMA</span> <span class="p">},</span>
	<span class="cm">/* Odd clown on sil3726/4726 PMPs */</span>
	<span class="p">{</span> <span class="s">&quot;Config  Disk&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_DISABLE</span> <span class="p">},</span>

	<span class="cm">/* Weird ATAPI devices */</span>
	<span class="p">{</span> <span class="s">&quot;TORiSAN DVD-ROM DRD-N216&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_MAX_SEC_128</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;QUANTUM DAT    DAT72-000&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_ATAPI_MOD16_DMA</span> <span class="p">},</span>

	<span class="cm">/* Devices we expect to fail diagnostics */</span>

	<span class="cm">/* Devices where NCQ should be avoided */</span>
	<span class="cm">/* NCQ is slow */</span>
	<span class="p">{</span> <span class="s">&quot;WDC WD740ADFD-00&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC WD740ADFD-00NLR1&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NONCQ</span><span class="p">,</span> <span class="p">},</span>
	<span class="cm">/* http://thread.gmane.org/gmane.linux.ide/14907 */</span>
	<span class="p">{</span> <span class="s">&quot;FUJITSU MHT2060BH&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>
	<span class="cm">/* NCQ is broken */</span>
	<span class="p">{</span> <span class="s">&quot;Maxtor *&quot;</span><span class="p">,</span>		<span class="s">&quot;BANC*&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Maxtor 7V300F0&quot;</span><span class="p">,</span>	<span class="s">&quot;VA111630&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ST380817AS&quot;</span><span class="p">,</span>		<span class="s">&quot;3.42&quot;</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ST3160023AS&quot;</span><span class="p">,</span>	<span class="s">&quot;3.42&quot;</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;OCZ CORE_SSD&quot;</span><span class="p">,</span>	<span class="s">&quot;02.10104&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>

	<span class="cm">/* Seagate NCQ + FLUSH CACHE firmware bug */</span>
	<span class="p">{</span> <span class="s">&quot;ST31500341AS&quot;</span><span class="p">,</span>	<span class="s">&quot;SD1[5-9]&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NONCQ</span> <span class="o">|</span>
						<span class="n">ATA_HORKAGE_FIRMWARE_WARN</span> <span class="p">},</span>

	<span class="p">{</span> <span class="s">&quot;ST31000333AS&quot;</span><span class="p">,</span>	<span class="s">&quot;SD1[5-9]&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NONCQ</span> <span class="o">|</span>
						<span class="n">ATA_HORKAGE_FIRMWARE_WARN</span> <span class="p">},</span>

	<span class="p">{</span> <span class="s">&quot;ST3640[36]23AS&quot;</span><span class="p">,</span>	<span class="s">&quot;SD1[5-9]&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NONCQ</span> <span class="o">|</span>
						<span class="n">ATA_HORKAGE_FIRMWARE_WARN</span> <span class="p">},</span>

	<span class="p">{</span> <span class="s">&quot;ST3320[68]13AS&quot;</span><span class="p">,</span>	<span class="s">&quot;SD1[5-9]&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NONCQ</span> <span class="o">|</span>
						<span class="n">ATA_HORKAGE_FIRMWARE_WARN</span> <span class="p">},</span>

	<span class="cm">/* Blacklist entries taken from Silicon Image 3124/3132</span>
<span class="cm">	   Windows driver .inf file - also several Linux problem reports */</span>
	<span class="p">{</span> <span class="s">&quot;HTS541060G9SA00&quot;</span><span class="p">,</span>    <span class="s">&quot;MB3OC60D&quot;</span><span class="p">,</span>     <span class="n">ATA_HORKAGE_NONCQ</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;HTS541080G9SA00&quot;</span><span class="p">,</span>    <span class="s">&quot;MB4OC60D&quot;</span><span class="p">,</span>     <span class="n">ATA_HORKAGE_NONCQ</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;HTS541010G9SA00&quot;</span><span class="p">,</span>    <span class="s">&quot;MBZOC60D&quot;</span><span class="p">,</span>     <span class="n">ATA_HORKAGE_NONCQ</span><span class="p">,</span> <span class="p">},</span>

	<span class="cm">/* https://bugzilla.kernel.org/show_bug.cgi?id=15573 */</span>
	<span class="p">{</span> <span class="s">&quot;C300-CTFDDAC128MAG&quot;</span><span class="p">,</span>	<span class="s">&quot;0001&quot;</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_NONCQ</span><span class="p">,</span> <span class="p">},</span>

	<span class="cm">/* devices which puke on READ_NATIVE_MAX */</span>
	<span class="p">{</span> <span class="s">&quot;HDS724040KLSA80&quot;</span><span class="p">,</span>	<span class="s">&quot;KFAOA20N&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_BROKEN_HPA</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC WD3200JD-00KLB0&quot;</span><span class="p">,</span> <span class="s">&quot;WD-WCAMR1130137&quot;</span><span class="p">,</span> <span class="n">ATA_HORKAGE_BROKEN_HPA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;WDC WD2500JD-00HBB0&quot;</span><span class="p">,</span> <span class="s">&quot;WD-WMAL71490727&quot;</span><span class="p">,</span> <span class="n">ATA_HORKAGE_BROKEN_HPA</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;MAXTOR 6L080L4&quot;</span><span class="p">,</span>	<span class="s">&quot;A93.0500&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_BROKEN_HPA</span> <span class="p">},</span>

	<span class="cm">/* this one allows HPA unlocking but fails IOs on the area */</span>
	<span class="p">{</span> <span class="s">&quot;OCZ-VERTEX&quot;</span><span class="p">,</span>		    <span class="s">&quot;1.30&quot;</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_BROKEN_HPA</span> <span class="p">},</span>

	<span class="cm">/* Devices which report 1 sector over size HPA */</span>
	<span class="p">{</span> <span class="s">&quot;ST340823A&quot;</span><span class="p">,</span>		<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_HPA_SIZE</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ST320413A&quot;</span><span class="p">,</span>		<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_HPA_SIZE</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ST310211A&quot;</span><span class="p">,</span>		<span class="nb">NULL</span><span class="p">,</span>		<span class="n">ATA_HORKAGE_HPA_SIZE</span><span class="p">,</span> <span class="p">},</span>

	<span class="cm">/* Devices which get the IVB wrong */</span>
	<span class="p">{</span> <span class="s">&quot;QUANTUM FIREBALLlct10 05&quot;</span><span class="p">,</span> <span class="s">&quot;A03.0900&quot;</span><span class="p">,</span> <span class="n">ATA_HORKAGE_IVB</span><span class="p">,</span> <span class="p">},</span>
	<span class="cm">/* Maybe we should just blacklist TSSTcorp... */</span>
	<span class="p">{</span> <span class="s">&quot;TSSTcorp CDDVDW SH-S202[HJN]&quot;</span><span class="p">,</span> <span class="s">&quot;SB0[01]&quot;</span><span class="p">,</span>  <span class="n">ATA_HORKAGE_IVB</span><span class="p">,</span> <span class="p">},</span>

	<span class="cm">/* Devices that do not need bridging limits applied */</span>
	<span class="p">{</span> <span class="s">&quot;MTRON MSP-SATA*&quot;</span><span class="p">,</span>		<span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_BRIDGE_OK</span><span class="p">,</span> <span class="p">},</span>

	<span class="cm">/* Devices which aren&#39;t very happy with higher link speeds */</span>
	<span class="p">{</span> <span class="s">&quot;WD My Book&quot;</span><span class="p">,</span>			<span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_1_5_GBPS</span><span class="p">,</span> <span class="p">},</span>

	<span class="cm">/*</span>
<span class="cm">	 * Devices which choke on SETXFER.  Applies only if both the</span>
<span class="cm">	 * device and controller are SATA.</span>
<span class="cm">	 */</span>
	<span class="p">{</span> <span class="s">&quot;PIONEER DVD-RW  DVRTD08&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NOSETXFER</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;PIONEER DVD-RW  DVRTD08A&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NOSETXFER</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;PIONEER DVD-RW  DVR-215&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NOSETXFER</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;PIONEER DVD-RW  DVR-212D&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NOSETXFER</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;PIONEER DVD-RW  DVR-216D&quot;</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">,</span>	<span class="n">ATA_HORKAGE_NOSETXFER</span> <span class="p">},</span>

	<span class="cm">/* End Marker */</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	glob_match - match a text string against a glob-style pattern</span>
<span class="cm"> *	@text: the string to be examined</span>
<span class="cm"> *	@pattern: the glob-style pattern to be matched against</span>
<span class="cm"> *</span>
<span class="cm"> *	Either/both of text and pattern can be empty strings.</span>
<span class="cm"> *</span>
<span class="cm"> *	Match text against a glob-style pattern, with wildcards and simple sets:</span>
<span class="cm"> *</span>
<span class="cm"> *		?	matches any single character.</span>
<span class="cm"> *		*	matches any run of characters.</span>
<span class="cm"> *		[xyz]	matches a single character from the set: x, y, or z.</span>
<span class="cm"> *		[a-d]	matches a single character from the range: a, b, c, or d.</span>
<span class="cm"> *		[a-d0-9] matches a single character from either range.</span>
<span class="cm"> *</span>
<span class="cm"> *	The special characters ?, [, -, or *, can be matched using a set, eg. [*]</span>
<span class="cm"> *	Behaviour with malformed patterns is undefined, though generally reasonable.</span>
<span class="cm"> *</span>
<span class="cm"> *	Sample patterns:  &quot;SD1?&quot;,  &quot;SD1[0-5]&quot;,  &quot;*R0&quot;,  &quot;SD*1?[012]*xx&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *	This function uses one level of recursion per &#39;*&#39; in pattern.</span>
<span class="cm"> *	Since it calls _nothing_ else, and has _no_ explicit local variables,</span>
<span class="cm"> *	this will not cause stack problems for any reasonable use here.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on match, 1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">glob_match</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pattern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Match single character or a &#39;?&#39; wildcard */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">text</span> <span class="o">==</span> <span class="o">*</span><span class="n">pattern</span> <span class="o">||</span> <span class="o">*</span><span class="n">pattern</span> <span class="o">==</span> <span class="sc">&#39;?&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pattern</span><span class="o">++</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* End of both strings: match */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Match single char against a &#39;[&#39; bracketed &#39;]&#39; pattern set */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">text</span> <span class="o">||</span> <span class="o">*</span><span class="n">pattern</span> <span class="o">!=</span> <span class="sc">&#39;[&#39;</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>  <span class="cm">/* Not a pattern set */</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">*++</span><span class="n">pattern</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pattern</span> <span class="o">!=</span> <span class="sc">&#39;]&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">text</span> <span class="o">!=</span> <span class="o">*</span><span class="n">pattern</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pattern</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">pattern</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;[&#39;</span><span class="p">)</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">text</span> <span class="o">&gt;</span> <span class="o">*</span><span class="p">(</span><span class="n">pattern</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">text</span> <span class="o">&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">pattern</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
						<span class="o">++</span><span class="n">pattern</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pattern</span> <span class="o">||</span> <span class="o">*</span><span class="n">pattern</span> <span class="o">==</span> <span class="sc">&#39;]&#39;</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* No match */</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pattern</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pattern</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;]&#39;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*++</span><span class="n">text</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">pattern</span><span class="p">);</span>

	<span class="cm">/* Match any run of chars against a &#39;*&#39; wildcard */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pattern</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*++</span><span class="n">pattern</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Match: avoid recursion at end of pattern */</span>
		<span class="cm">/* Loop to handle additional pattern chars after the wildcard */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">text</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">glob_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* Remainder matched */</span>
			<span class="o">++</span><span class="n">text</span><span class="p">;</span>  <span class="cm">/* Absorb (match) this char and try again */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">text</span> <span class="o">&amp;&amp;</span> <span class="o">!*</span><span class="n">pattern</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* End of both strings: match */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* No match */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ata_dev_blacklisted</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">model_num</span><span class="p">[</span><span class="n">ATA_ID_PROD_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">model_rev</span><span class="p">[</span><span class="n">ATA_ID_FW_REV_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_blacklist_entry</span> <span class="o">*</span><span class="n">ad</span> <span class="o">=</span> <span class="n">ata_device_blacklist</span><span class="p">;</span>

	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">model_num</span><span class="p">,</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">model_num</span><span class="p">));</span>
	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">model_rev</span><span class="p">,</span> <span class="n">ATA_ID_FW_REV</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">model_rev</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">model_num</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">glob_match</span><span class="p">(</span><span class="n">model_num</span><span class="p">,</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">model_num</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ad</span><span class="o">-&gt;</span><span class="n">model_rev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">horkage</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">glob_match</span><span class="p">(</span><span class="n">model_rev</span><span class="p">,</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">model_rev</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">ad</span><span class="o">-&gt;</span><span class="n">horkage</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ad</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_dma_blacklisted</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don&#39;t support polling DMA.</span>
<span class="cm">	 * DMA blacklist those ATAPI devices with CDB-intr (and use PIO)</span>
<span class="cm">	 * if the LLDD handles only interrupts in the HSM_ST_LAST state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PIO_POLLING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_CDB_INTR</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_NODMA</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_is_40wire		-	check drive side detection</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform drive side detection decoding, allowing for device vendors</span>
<span class="cm"> *	who can&#39;t follow the documentation.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_is_40wire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_IVB</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ata_drive_40wire_relaxed</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ata_drive_40wire</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	cable_is_40wire		-	40/80/SATA decider</span>
<span class="cm"> *	@ap: port to consider</span>
<span class="cm"> *</span>
<span class="cm"> *	This function encapsulates the policy for speed management</span>
<span class="cm"> *	in one place. At the moment we don&#39;t cache the result but</span>
<span class="cm"> *	there is a good case for setting ap-&gt;cbl to the result when</span>
<span class="cm"> *	we are called with unknown cables (and figuring out if it</span>
<span class="cm"> *	impacts hotplug at all).</span>
<span class="cm"> *</span>
<span class="cm"> *	Return 1 if the cable appears to be 40 wire.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cable_is_40wire</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* If the controller thinks we are 40 wire, we are. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">==</span> <span class="n">ATA_CBL_PATA40</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* If the controller thinks we are 80 wire, we are. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">==</span> <span class="n">ATA_CBL_PATA80</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">==</span> <span class="n">ATA_CBL_SATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If the system is known to be 40 wire short cable (eg</span>
<span class="cm">	 * laptop), then we allow 80 wire modes even if the drive</span>
<span class="cm">	 * isn&#39;t sure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">==</span> <span class="n">ATA_CBL_PATA40_SHORT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If the controller doesn&#39;t know, we scan.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We look for all 40 wire detects at this point.  Any</span>
<span class="cm">	 *       80 wire detect is taken to be 80 wire cable because</span>
<span class="cm">	 * - in many setups only the one drive (slave if present) will</span>
<span class="cm">	 *   give a valid detect</span>
<span class="cm">	 * - if you have a non detect capable drive you don&#39;t want it</span>
<span class="cm">	 *   to colour the choice</span>
<span class="cm">	 */</span>
	<span class="n">ata_for_each_link</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">ap</span><span class="p">,</span> <span class="n">EDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_is_40wire</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_xfermask - Compute supported xfermask of the given device</span>
<span class="cm"> *	@dev: Device to compute xfermask for</span>
<span class="cm"> *</span>
<span class="cm"> *	Compute supported xfermask of @dev and store it in</span>
<span class="cm"> *	dev-&gt;*_mask.  This function is responsible for applying all</span>
<span class="cm"> *	known limits including host controller limits, device</span>
<span class="cm"> *	blacklist, etc...</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_dev_xfermask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">;</span>

	<span class="cm">/* controller modes available */</span>
	<span class="n">xfer_mask</span> <span class="o">=</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">,</span>
				      <span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">);</span>

	<span class="cm">/* drive modes available */</span>
	<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">,</span>
				       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">);</span>
	<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="n">ata_id_xfermask</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	CFA Advanced TrueIDE timings are not allowed on a shared</span>
<span class="cm">	 *	cable</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_dev_pair</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* No PIO5 or PIO6 */</span>
		<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="mi">5</span><span class="p">));</span>
		<span class="cm">/* No MWDMA3 or MWDMA 4 */</span>
		<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_MWDMA</span> <span class="o">+</span> <span class="mi">3</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_dma_blacklisted</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ATA_MASK_MWDMA</span> <span class="o">|</span> <span class="n">ATA_MASK_UDMA</span><span class="p">);</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;device is on DMA blacklist, disabling DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_HOST_SIMPLEX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">host</span><span class="o">-&gt;</span><span class="n">simplex_claimed</span> <span class="o">&amp;&amp;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">simplex_claimed</span> <span class="o">!=</span> <span class="n">ap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ATA_MASK_MWDMA</span> <span class="o">|</span> <span class="n">ATA_MASK_UDMA</span><span class="p">);</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;simplex DMA is claimed by other device, disabling DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_NO_IORDY</span><span class="p">)</span>
		<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="n">ata_pio_mask_no_iordy</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode_filter</span><span class="p">)</span>
		<span class="n">xfer_mask</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode_filter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">xfer_mask</span><span class="p">);</span>

	<span class="cm">/* Apply cable rule here.  Don&#39;t apply it early because when</span>
<span class="cm">	 * we handle hot plug the cable type can itself change.</span>
<span class="cm">	 * Check this last so that we know if the transfer rate was</span>
<span class="cm">	 * solely limited by the cable.</span>
<span class="cm">	 * Unknown or 80 wire cables reported host side are checked</span>
<span class="cm">	 * drive side as well. Cases where we know a 40wire cable</span>
<span class="cm">	 * is used safely for 80 are not checked here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xfer_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xF8</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_UDMA</span><span class="p">))</span>
		<span class="cm">/* UDMA/44 or higher would be available */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cable_is_40wire</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;limited to UDMA/33 due to 40-wire cable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">xfer_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xF8</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_UDMA</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">ata_unpack_xfermask</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_set_xfermode - Issue SET FEATURES - XFER MODE command</span>
<span class="cm"> *	@dev: Device to which command will be sent</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue SET FEATURES - XFER MODE command to device @dev</span>
<span class="cm"> *	on port @ap.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	PCI/etc. bus probe sem.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, AC_ERR_* mask otherwise.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_dev_set_xfermode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span><span class="p">;</span>

	<span class="cm">/* set up set-features taskfile */</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;set features - xfer mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Some controllers and ATAPI devices show flaky interrupt</span>
<span class="cm">	 * behavior after setting xfer mode.  Use polling instead.</span>
<span class="cm">	 */</span>
	<span class="n">ata_tf_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_SET_FEATURES</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">=</span> <span class="n">SETFEATURES_XFER</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span> <span class="o">|</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>
	<span class="cm">/* If we are using IORDY we must send the mode setting command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_pio_need_iordy</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_mode</span><span class="p">;</span>
	<span class="cm">/* If the device has IORDY and the controller does not - turn it off */</span>
 	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_iordy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
		<span class="n">tf</span><span class="p">.</span><span class="n">nsect</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* In the ancient relic department - skip all of this */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_exec_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT, err_mask=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_set_feature - Issue SET FEATURES - SATA FEATURES</span>
<span class="cm"> *	@dev: Device to which command will be sent</span>
<span class="cm"> *	@enable: Whether to enable or disable the feature</span>
<span class="cm"> *	@feature: The sector count represents the feature to set</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue SET FEATURES - SATA FEATURES command to device @dev</span>
<span class="cm"> *	on port @ap with sector count</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	PCI/etc. bus probe sem.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, AC_ERR_* mask otherwise.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_dev_set_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">enable</span><span class="p">,</span> <span class="n">u8</span> <span class="n">feature</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span><span class="p">;</span>

	<span class="cm">/* set up set-features taskfile */</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;set features - SATA features</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ata_tf_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_SET_FEATURES</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">=</span> <span class="n">enable</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">feature</span><span class="p">;</span>

	<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_exec_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT, err_mask=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_init_params - Issue INIT DEV PARAMS command</span>
<span class="cm"> *	@dev: Device to which command will be sent</span>
<span class="cm"> *	@heads: Number of heads (taskfile parameter)</span>
<span class="cm"> *	@sectors: Number of sectors (taskfile parameter)</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, AC_ERR_* mask otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_dev_init_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">heads</span><span class="p">,</span> <span class="n">u16</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span><span class="p">;</span>

	<span class="cm">/* Number of sectors per track 1-255. Number of heads 1-16 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sectors</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">sectors</span> <span class="o">&gt;</span> <span class="mi">255</span> <span class="o">||</span> <span class="n">heads</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">heads</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AC_ERR_INVALID</span><span class="p">;</span>

	<span class="cm">/* set up init dev params taskfile */</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;init dev params </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ata_tf_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_INIT_DEV_PARAMS</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">device</span> <span class="o">|=</span> <span class="p">(</span><span class="n">heads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span> <span class="cm">/* max head = num. of heads - 1 */</span>

	<span class="n">err_mask</span> <span class="o">=</span> <span class="n">ata_exec_internal</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* A clean abort indicates an original or just out of spec drive</span>
<span class="cm">	   and we should continue as we issue the setup based on the</span>
<span class="cm">	   drive reported working geometry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">==</span> <span class="n">AC_ERR_DEV</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">&amp;</span> <span class="n">ATA_ABORTED</span><span class="p">))</span>
		<span class="n">err_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT, err_mask=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sg_clean - Unmap DMA memory associated with command</span>
<span class="cm"> *	@qc: Command containing DMA memory to be released</span>
<span class="cm"> *</span>
<span class="cm"> *	Unmap all mapped DMA memory associated with this command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sg_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">sg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;unmapping %u sg elements</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">)</span>
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">orig_n_elem</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_QCFLAG_DMAMAP</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	atapi_check_dma - Check whether ATAPI DMA can be supported</span>
<span class="cm"> *	@qc: Metadata associated with taskfile to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Allow low-level driver to filter ATA PACKET commands, returning</span>
<span class="cm"> *	a status indicating whether or not it is OK to use DMA for the</span>
<span class="cm"> *	supplied PACKET command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS: 0 when ATAPI DMA can be used</span>
<span class="cm"> *               nonzero otherwise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">atapi_check_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allow DMA if it isn&#39;t multiple of 16 bytes.  Quite a</span>
<span class="cm">	 * few ATAPI devices choke on such DMA requests.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_ATAPI_MOD16_DMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">check_atapi_dma</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">check_atapi_dma</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_std_qc_defer - Check whether a qc needs to be deferred</span>
<span class="cm"> *	@qc: ATA command in question</span>
<span class="cm"> *</span>
<span class="cm"> *	Non-NCQ commands cannot run with any other command, NCQ or</span>
<span class="cm"> *	not.  As upper layer only knows the queue depth, we are</span>
<span class="cm"> *	responsible for maintaining exclusion.  This function checks</span>
<span class="cm"> *	whether a new command @qc can be issued.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	ATA_DEFER_* if deferring is needed, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_std_qc_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_NCQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_tag_valid</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_tag_valid</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ATA_DEFER_LINK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ata_noop_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sg_init - Associate command with scatter-gather table.</span>
<span class="cm"> *	@qc: Command to be associated</span>
<span class="cm"> *	@sg: Scatter-gather table.</span>
<span class="cm"> *	@n_elem: Number of elements in s/g table.</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize the data-related elements of queued_cmd @qc</span>
<span class="cm"> *	to point to a scatter-gather table @sg, containing @n_elem</span>
<span class="cm"> *	elements.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sg_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span> <span class="o">=</span> <span class="n">n_elem</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sg_setup - DMA-map the scatter-gather table associated with a command.</span>
<span class="cm"> *	@qc: Command with scatter-gather table to be mapped.</span>
<span class="cm"> *</span>
<span class="cm"> *	DMA-map the scatter-gather table associated with queued_cmd @qc.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, negative on error.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_sg_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_elem</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER, ata%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">);</span>

	<span class="n">n_elem</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_elem</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%d sg elements mapped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n_elem</span><span class="p">);</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">orig_n_elem</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span> <span class="o">=</span> <span class="n">n_elem</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_QCFLAG_DMAMAP</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	swap_buf_le16 - swap halves of 16-bit words in place</span>
<span class="cm"> *	@buf:  Buffer to swap</span>
<span class="cm"> *	@buf_words:  Number of 16-bit words in buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *	Swap halves of 16-bit words if needed to convert from</span>
<span class="cm"> *	little-endian byte order to native cpu byte order, or</span>
<span class="cm"> *	vice-versa.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">swap_buf_le16</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_words</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buf_words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#endif </span><span class="cm">/* __BIG_ENDIAN */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_qc_new - Request an available ATA command, for queueing</span>
<span class="cm"> *	@ap: target port</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="nf">ata_qc_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* no command while frozen */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_FROZEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* the last tag is reserved for internal command. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATA_MAX_QUEUE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_allocated</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">qc</span> <span class="o">=</span> <span class="n">__ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">qc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_qc_new_init - Request an available ATA command, and initialize it</span>
<span class="cm"> *	@dev: Device from whom we request an available command structure</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="nf">ata_qc_new_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>

	<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_new</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

		<span class="n">ata_qc_reinit</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">qc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_qc_free - free unused ata_queued_cmd</span>
<span class="cm"> *	@qc: Command to complete</span>
<span class="cm"> *</span>
<span class="cm"> *	Designed to free unused ata_queued_cmd object</span>
<span class="cm"> *	in case something prevents using it.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_qc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">qc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span> <span class="cm">/* ata_qc_from_tag _might_ return NULL */</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ata_tag_valid</span><span class="p">(</span><span class="n">tag</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">ATA_TAG_POISON</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_allocated</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__ata_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">qc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span> <span class="cm">/* ata_qc_from_tag _might_ return NULL */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_ACTIVE</span><span class="p">));</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="n">link</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_DMAMAP</span><span class="p">))</span>
		<span class="n">ata_sg_clean</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/* command should be marked inactive atomically with qc completion */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_NCQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">ATA_TAG_POISON</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear exclusive status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_CLEAR_EXCL</span> <span class="o">&amp;&amp;</span>
		     <span class="n">ap</span><span class="o">-&gt;</span><span class="n">excl_link</span> <span class="o">==</span> <span class="n">link</span><span class="p">))</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">excl_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* atapi: mark qc as inactive to prevent the interrupt handler</span>
<span class="cm">	 * from completing the command twice later, before the error handler</span>
<span class="cm">	 * is called. (when rc != 0 and atapi request sense is needed)</span>
<span class="cm">	 */</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_QCFLAG_ACTIVE</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>

	<span class="cm">/* call completion callback */</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">complete_fn</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_result_tf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">qc_fill_rtf</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_verify_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_nodata</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ata_is_pio</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DFLAG_DUBIOUS_XFER</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_qc_complete - Complete an active ATA command</span>
<span class="cm"> *	@qc: Command to complete</span>
<span class="cm"> *</span>
<span class="cm"> *	Indicate to the mid and upper layers that an ATA command has</span>
<span class="cm"> *	completed, with either an ok or not-ok status.</span>
<span class="cm"> *</span>
<span class="cm"> *	Refrain from calling this function multiple times when</span>
<span class="cm"> *	successfully completing multiple NCQ commands.</span>
<span class="cm"> *	ata_qc_complete_multiple() should be used instead, which will</span>
<span class="cm"> *	properly update IRQ expect state.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="cm">/* XXX: New EH and old EH use different mechanisms to</span>
<span class="cm">	 * synchronize EH with regular execution path.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In new EH, a failed qc is marked with ATA_QCFLAG_FAILED.</span>
<span class="cm">	 * Normal execution path is responsible for not accessing a</span>
<span class="cm">	 * failed qc.  libata core enforces the rule by returning NULL</span>
<span class="cm">	 * from ata_qc_from_tag() for failed qcs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Old EH depends on ata_qc_complete() nullifying completion</span>
<span class="cm">	 * requests if ATA_QCFLAG_EH_SCHEDULED is set.  Old EH does</span>
<span class="cm">	 * not synchronize with interrupt handler.  Only PIO task is</span>
<span class="cm">	 * taken care of.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span><span class="p">))</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_QCFLAG_FAILED</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Finish internal commands without any further processing</span>
<span class="cm">		 * and always with the result TF filled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ata_tag_internal</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">fill_result_tf</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
			<span class="n">__ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Non-internal qc has failed.  Fill the result TF and</span>
<span class="cm">		 * summon EH.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_FAILED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fill_result_tf</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
			<span class="n">ata_qc_schedule_eh</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_FROZEN</span><span class="p">);</span>

		<span class="cm">/* read result TF if requested */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_RESULT_TF</span><span class="p">)</span>
			<span class="n">fill_result_tf</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

		<span class="cm">/* Some commands need post-processing after successful</span>
<span class="cm">		 * completion.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ATA_CMD_SET_FEATURES</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">!=</span> <span class="n">SETFEATURES_WC_ON</span> <span class="o">&amp;&amp;</span>
			    <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">!=</span> <span class="n">SETFEATURES_WC_OFF</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">ATA_CMD_INIT_DEV_PARAMS</span>: <span class="cm">/* CHS translation changed */</span>
		<span class="k">case</span> <span class="n">ATA_CMD_SET_MULTI</span>: <span class="cm">/* multi_count changed */</span>
			<span class="cm">/* revalidate device */</span>
			<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">dev_action</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span> <span class="o">|=</span> <span class="n">ATA_EH_REVALIDATE</span><span class="p">;</span>
			<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ATA_CMD_SLEEP</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_SLEEPING</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_DUBIOUS_XFER</span><span class="p">))</span>
			<span class="n">ata_verify_xfer</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

		<span class="n">__ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_EH_SCHEDULED</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* read result TF if failed or requested */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">||</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_RESULT_TF</span><span class="p">)</span>
			<span class="n">fill_result_tf</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

		<span class="n">__ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_qc_complete_multiple - Complete multiple qcs successfully</span>
<span class="cm"> *	@ap: port in question</span>
<span class="cm"> *	@qc_active: new qc_active mask</span>
<span class="cm"> *</span>
<span class="cm"> *	Complete in-flight commands.  This functions is meant to be</span>
<span class="cm"> *	called from low-level driver&#39;s interrupt routine to complete</span>
<span class="cm"> *	requests normally.  ap-&gt;qc_active and @qc_active is compared</span>
<span class="cm"> *	and commands are completed accordingly.</span>
<span class="cm"> *</span>
<span class="cm"> *	Always use this function when completing multiple NCQ commands</span>
<span class="cm"> *	from IRQ handlers instead of calling ata_qc_complete()</span>
<span class="cm"> *	multiple times to keep IRQ expect status properly in sync.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Number of completed commands on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_qc_complete_multiple</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">qc_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">done_mask</span><span class="p">;</span>

	<span class="n">done_mask</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span> <span class="o">^</span> <span class="n">qc_active</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">done_mask</span> <span class="o">&amp;</span> <span class="n">qc_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_port_err</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;illegal qc_active transition (%08x-&gt;%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span><span class="p">,</span> <span class="n">qc_active</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">done_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">done_mask</span><span class="p">);</span>

		<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
			<span class="n">nr_done</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">done_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nr_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_qc_issue - issue taskfile to device</span>
<span class="cm"> *	@qc: command to issue to device</span>
<span class="cm"> *</span>
<span class="cm"> *	Prepare an ATA command to submission to device.</span>
<span class="cm"> *	This includes mapping the data into a DMA-able</span>
<span class="cm"> *	area, filling in the S/G table, and finally</span>
<span class="cm"> *	writing the taskfile to hardware, starting the command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prot</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">;</span>

	<span class="cm">/* Make sure only one non-NCQ command is outstanding.  The</span>
<span class="cm">	 * check is skipped for old EH because it reuses active qc to</span>
<span class="cm">	 * request ATAPI sense.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span> <span class="o">&amp;&amp;</span> <span class="n">ata_tag_valid</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_ncq</span><span class="p">(</span><span class="n">prot</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span><span class="o">++</span><span class="p">;</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">sactive</span><span class="p">);</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span><span class="o">++</span><span class="p">;</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_QCFLAG_ACTIVE</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We guarantee to LLDs that they will have at least one</span>
<span class="cm">	 * non-zero sg if the command is a data command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ata_is_data</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="p">(</span><span class="o">!</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">||</span> <span class="o">!</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span> <span class="o">||</span> <span class="o">!</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">sys_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_dma</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ata_is_pio</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PIO_DMA</span><span class="p">)))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_sg_setup</span><span class="p">(</span><span class="n">qc</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">sys_err</span><span class="p">;</span>

	<span class="cm">/* if device is sleeping, schedule reset and abort the link */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_SLEEPING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">.</span><span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
		<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">,</span> <span class="s">&quot;waking up from sleep&quot;</span><span class="p">);</span>
		<span class="n">ata_link_abort</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">qc_prep</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">qc_issue</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">sys_err:</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_SYSTEM</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_scr_valid - test whether SCRs are accessible</span>
<span class="cm"> *	@link: ATA link to test SCR accessibility for</span>
<span class="cm"> *</span>
<span class="cm"> *	Test whether SCRs are accessible for @link.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	1 if SCRs are accessible, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_scr_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">scr_read</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_scr_read - read SCR register of the specified port</span>
<span class="cm"> *	@link: ATA link to read SCR for</span>
<span class="cm"> *	@reg: SCR to read</span>
<span class="cm"> *	@val: Place to store read value</span>
<span class="cm"> *</span>
<span class="cm"> *	Read SCR register @reg of @link into *@val.  This function is</span>
<span class="cm"> *	guaranteed to succeed if @link is ap-&gt;link, the cable type of</span>
<span class="cm"> *	the port is SATA and the port implements -&gt;scr_read.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None if @link is ap-&gt;link.  Kernel thread context otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, negative errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_scr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sata_scr_valid</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sata_pmp_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_scr_write - write SCR register of the specified port</span>
<span class="cm"> *	@link: ATA link to write SCR for</span>
<span class="cm"> *	@reg: SCR to write</span>
<span class="cm"> *	@val: value to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Write @val to SCR register @reg of @link.  This function is</span>
<span class="cm"> *	guaranteed to succeed if @link is ap-&gt;link, the cable type of</span>
<span class="cm"> *	the port is SATA and the port implements -&gt;scr_read.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None if @link is ap-&gt;link.  Kernel thread context otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, negative errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_scr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sata_scr_valid</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sata_pmp_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_scr_write_flush - write SCR register of the specified port and flush</span>
<span class="cm"> *	@link: ATA link to write SCR for</span>
<span class="cm"> *	@reg: SCR to write</span>
<span class="cm"> *	@val: value to write</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is identical to sata_scr_write() except that this</span>
<span class="cm"> *	function performs flush after writing to the register.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None if @link is ap-&gt;link.  Kernel thread context otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, negative errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_scr_write_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sata_scr_valid</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sata_pmp_scr_write</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_phys_link_online - test whether the given link is online</span>
<span class="cm"> *	@link: ATA link to test</span>
<span class="cm"> *</span>
<span class="cm"> *	Test whether @link is online.  Note that this function returns</span>
<span class="cm"> *	0 if online status of @link cannot be obtained, so</span>
<span class="cm"> *	ata_link_online(link) != !ata_link_offline(link).</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	True if the port online status is available and online.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">ata_phys_link_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sstatus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sstatus</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ata_sstatus_online</span><span class="p">(</span><span class="n">sstatus</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_phys_link_offline - test whether the given link is offline</span>
<span class="cm"> *	@link: ATA link to test</span>
<span class="cm"> *</span>
<span class="cm"> *	Test whether @link is offline.  Note that this function</span>
<span class="cm"> *	returns 0 if offline status of @link cannot be obtained, so</span>
<span class="cm"> *	ata_link_online(link) != !ata_link_offline(link).</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	True if the port offline status is available and offline.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">ata_phys_link_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sstatus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sstatus</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ata_sstatus_online</span><span class="p">(</span><span class="n">sstatus</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_link_online - test whether the given link is online</span>
<span class="cm"> *	@link: ATA link to test</span>
<span class="cm"> *</span>
<span class="cm"> *	Test whether @link is online.  This is identical to</span>
<span class="cm"> *	ata_phys_link_online() when there&#39;s no slave link.  When</span>
<span class="cm"> *	there&#39;s a slave link, this function should only be called on</span>
<span class="cm"> *	the master link and will return true if any of M/S links is</span>
<span class="cm"> *	online.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	True if the port online status is available and online.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">ata_link_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="n">slave</span><span class="p">);</span>	<span class="cm">/* shouldn&#39;t be called on slave link */</span>

	<span class="k">return</span> <span class="n">ata_phys_link_online</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">slave</span> <span class="o">&amp;&amp;</span> <span class="n">ata_phys_link_online</span><span class="p">(</span><span class="n">slave</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_link_offline - test whether the given link is offline</span>
<span class="cm"> *	@link: ATA link to test</span>
<span class="cm"> *</span>
<span class="cm"> *	Test whether @link is offline.  This is identical to</span>
<span class="cm"> *	ata_phys_link_offline() when there&#39;s no slave link.  When</span>
<span class="cm"> *	there&#39;s a slave link, this function should only be called on</span>
<span class="cm"> *	the master link and will return true if both M/S links are</span>
<span class="cm"> *	offline.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	True if the port offline status is available and offline.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">ata_link_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="n">slave</span><span class="p">);</span>	<span class="cm">/* shouldn&#39;t be called on slave link */</span>

	<span class="k">return</span> <span class="n">ata_phys_link_offline</span><span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="o">!</span><span class="n">slave</span> <span class="o">||</span> <span class="n">ata_phys_link_offline</span><span class="p">(</span><span class="n">slave</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_port_request_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ehi_flags</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Previous resume operation might still be in</span>
<span class="cm">	 * progress.  Wait for PM_PENDING to clear.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_PM_PENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_port_wait_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_PM_PENDING</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* request PM ops to EH */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pm_mesg</span> <span class="o">=</span> <span class="n">mesg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pm_result</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">|=</span> <span class="n">ATA_PFLAG_PM_PENDING</span><span class="p">;</span>
	<span class="n">ata_for_each_link</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">ap</span><span class="p">,</span> <span class="n">HOST_FIRST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">.</span><span class="n">action</span> <span class="o">|=</span> <span class="n">action</span><span class="p">;</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ehi_flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* wait and check result */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_port_wait_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_PM_PENDING</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define to_ata_port(d) container_of(d, struct ata_port, tdev)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_port_suspend_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">to_ata_port</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ehi_flags</span> <span class="o">=</span> <span class="n">ATA_EHI_QUIET</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * On some hardware, device fails to respond after spun down</span>
<span class="cm">	 * for suspend.  As the device won&#39;t be used before being</span>
<span class="cm">	 * resumed, we don&#39;t need to touch the device.  Ask EH to skip</span>
<span class="cm">	 * the usual stuff and proceed directly to suspend.</span>
<span class="cm">	 *</span>
<span class="cm">	 * http://thread.gmane.org/gmane.linux.ide/46764</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mesg</span><span class="p">.</span><span class="n">event</span> <span class="o">==</span> <span class="n">PM_EVENT_SUSPEND</span><span class="p">)</span>
		<span class="n">ehi_flags</span> <span class="o">|=</span> <span class="n">ATA_EHI_NO_AUTOPSY</span> <span class="o">|</span> <span class="n">ATA_EHI_NO_RECOVERY</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_port_request_pm</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">mesg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ehi_flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_port_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_runtime_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ata_port_suspend_common</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_port_do_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_runtime_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">pm_runtime_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ata_port_suspend_common</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_FREEZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_port_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_runtime_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ata_port_suspend_common</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_HIBERNATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_port_resume_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">to_ata_port</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_port_request_pm</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">PMSG_ON</span><span class="p">,</span> <span class="n">ATA_EH_RESET</span><span class="p">,</span>
		<span class="n">ATA_EHI_NO_AUTOPSY</span> <span class="o">|</span> <span class="n">ATA_EHI_QUIET</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_port_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_port_resume_common</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_port_runtime_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pm_runtime_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">ata_port_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">ata_port_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">ata_port_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="n">ata_port_do_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">ata_port_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poweroff</span> <span class="o">=</span> <span class="n">ata_port_poweroff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">ata_port_resume</span><span class="p">,</span>

	<span class="p">.</span><span class="n">runtime_suspend</span> <span class="o">=</span> <span class="n">ata_port_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_resume</span> <span class="o">=</span> <span class="n">ata_port_resume_common</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_idle</span> <span class="o">=</span> <span class="n">ata_port_runtime_idle</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_host_suspend - suspend host</span>
<span class="cm"> *	@host: host to suspend</span>
<span class="cm"> *	@mesg: PM message</span>
<span class="cm"> *</span>
<span class="cm"> *	Suspend @host.  Actual operation is performed by port suspend.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_host_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">power_state</span> <span class="o">=</span> <span class="n">mesg</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_host_resume - resume host</span>
<span class="cm"> *	@host: host to resume</span>
<span class="cm"> *</span>
<span class="cm"> *	Resume @host.  Actual operation is performed by port resume.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_host_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">power_state</span> <span class="o">=</span> <span class="n">PMSG_ON</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">device_type</span> <span class="n">ata_port_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ata_port&quot;</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_port_pm_ops</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_init - Initialize an ata_device structure</span>
<span class="cm"> *	@dev: Device structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize @dev in preparation for probing.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_dev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">ata_dev_phys_link</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* SATA spd limit is bound to the attached device, reset together */</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">sata_spd_limit</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">hw_sata_spd_limit</span><span class="p">;</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">sata_spd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* High bits of dev-&gt;flags are used to record warm plug</span>
<span class="cm">	 * requests which occur asynchronously.  Synchronize using</span>
<span class="cm">	 * host lock.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DFLAG_INIT_MASK</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span> <span class="o">+</span> <span class="n">ATA_DEVICE_CLEAR_BEGIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">ATA_DEVICE_CLEAR_END</span> <span class="o">-</span> <span class="n">ATA_DEVICE_CLEAR_BEGIN</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pio_mask</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_link_init - Initialize an ata_link structure</span>
<span class="cm"> *	@ap: ATA port link is attached to</span>
<span class="cm"> *	@link: Link structure to initialize</span>
<span class="cm"> *	@pmp: Port multiplier port number</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize @link.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_link_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* clear everything except for devices */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">link</span> <span class="o">+</span> <span class="n">ATA_LINK_CLEAR_BEGIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">ATA_LINK_CLEAR_END</span> <span class="o">-</span> <span class="n">ATA_LINK_CLEAR_BEGIN</span><span class="p">);</span>

	<span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span> <span class="o">=</span> <span class="n">pmp</span><span class="p">;</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">ATA_TAG_POISON</span><span class="p">;</span>
	<span class="n">link</span><span class="o">-&gt;</span><span class="n">hw_sata_spd_limit</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>

	<span class="cm">/* can&#39;t use iterator, ap isn&#39;t initialized yet */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ATA_MAX_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">link</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span> <span class="o">=</span> <span class="n">dev</span> <span class="o">-</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ATA_ACPI</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gtf_filter</span> <span class="o">=</span> <span class="n">ata_acpi_gtf_filter</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">ata_dev_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_link_init_spd - Initialize link-&gt;sata_spd_limit</span>
<span class="cm"> *	@link: Link to configure sata_spd_limit for</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize @link-&gt;[hw_]sata_spd_limit to the currently</span>
<span class="cm"> *	configured value.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_link_init_spd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">spd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">saved_scontrol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spd</span> <span class="o">=</span> <span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">saved_scontrol</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spd</span><span class="p">)</span>
		<span class="n">link</span><span class="o">-&gt;</span><span class="n">hw_sata_spd_limit</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">spd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ata_force_link_limits</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>

	<span class="n">link</span><span class="o">-&gt;</span><span class="n">sata_spd_limit</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">hw_sata_spd_limit</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_port_alloc - allocate and initialize basic ATA port resources</span>
<span class="cm"> *	@host: ATA host this allocated port belongs to</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate and initialize basic ATA port resources.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Allocate ATA port on success, NULL on failure.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="nf">ata_port_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">|=</span> <span class="n">ATA_PFLAG_INITIALIZING</span> <span class="o">|</span> <span class="n">ATA_PFLAG_FROZEN</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

<span class="cp">#if defined(ATA_VERBOSE_DEBUG)</span>
	<span class="cm">/* turn on all debugging levels */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="mh">0x00FF</span><span class="p">;</span>
<span class="cp">#elif defined(ATA_DEBUG)</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">ATA_MSG_DRV</span> <span class="o">|</span> <span class="n">ATA_MSG_INFO</span> <span class="o">|</span> <span class="n">ATA_MSG_CTL</span> <span class="o">|</span> <span class="n">ATA_MSG_WARN</span> <span class="o">|</span> <span class="n">ATA_MSG_ERR</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">ATA_MSG_DRV</span> <span class="o">|</span> <span class="n">ATA_MSG_ERR</span> <span class="o">|</span> <span class="n">ATA_MSG_WARN</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_scan_mutex</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hotplug_task</span><span class="p">,</span> <span class="n">ata_scsi_hotplug</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_rescan_task</span><span class="p">,</span> <span class="n">ata_scsi_dev_rescan</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">eh_done_q</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">eh_wait_q</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">park_req_pending</span><span class="p">);</span>
	<span class="n">init_timer_deferrable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">fastdrain_timer</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">fastdrain_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">ata_eh_fastdrain_timerfn</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">fastdrain_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">=</span> <span class="n">ATA_CBL_NONE</span><span class="p">;</span>

	<span class="n">ata_link_init</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef ATA_IRQ_TRAP</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">unhandled_irq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">idle_irq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ata_sff_port_init</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ap</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_host_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">gendev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">gendev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">)</span>
			<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">gendev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_host_alloc - allocate and init basic ATA host resources</span>
<span class="cm"> *	@dev: generic device this host is associated with</span>
<span class="cm"> *	@max_ports: maximum number of ATA ports associated with this host</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate and initialize basic ATA host resources.  LLD calls</span>
<span class="cm"> *	this function to allocate a host, initializes it fully and</span>
<span class="cm"> *	attaches it using ata_host_register().</span>
<span class="cm"> *</span>
<span class="cm"> *	@max_ports ports are allocated and host-&gt;n_ports is</span>
<span class="cm"> *	initialized to @max_ports.  The caller is allowed to decrease</span>
<span class="cm"> *	host-&gt;n_ports before calling ata_host_register().  The unused</span>
<span class="cm"> *	ports will be automatically freed on registration.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Allocate ATA host on success, NULL on failure.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="nf">ata_host_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_ports</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devres_open_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* alloc a container for our list of ATA ports (buses) */</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_ports</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* alloc a container for our list of ATA ports (buses) */</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">devres_alloc</span><span class="p">(</span><span class="n">ata_host_release</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">devres_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span> <span class="o">=</span> <span class="n">max_ports</span><span class="p">;</span>

	<span class="cm">/* allocate ports bound to this host */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>

		<span class="n">ap</span> <span class="o">=</span> <span class="n">ata_port_alloc</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">devres_remove_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">host</span><span class="p">;</span>

 <span class="nl">err_out:</span>
	<span class="n">devres_release_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_host_alloc_pinfo - alloc host and init with port_info array</span>
<span class="cm"> *	@dev: generic device this host is associated with</span>
<span class="cm"> *	@ppi: array of ATA port_info to initialize host with</span>
<span class="cm"> *	@n_ports: number of ATA ports attached to this host</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate ATA host and initialize with info from @ppi.  If NULL</span>
<span class="cm"> *	terminated, @ppi may contain fewer entries than @n_ports.  The</span>
<span class="cm"> *	last entry will be used for the remaining ports.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Allocate ATA host on success, NULL on failure.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="nf">ata_host_alloc_pinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ppi</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">n_ports</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">ata_host_alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">n_ports</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ppi</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="n">pi</span> <span class="o">=</span> <span class="n">ppi</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pio_mask</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">link_flags</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ata_dummy_port_ops</span><span class="p">))</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">host</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_slave_link_init - initialize slave link</span>
<span class="cm"> *	@ap: port to initialize slave link for</span>
<span class="cm"> *</span>
<span class="cm"> *	Create and initialize slave link for @ap.  This enables slave</span>
<span class="cm"> *	link handling on the port.</span>
<span class="cm"> *</span>
<span class="cm"> *	In libata, a port contains links and a link contains devices.</span>
<span class="cm"> *	There is single host link but if a PMP is attached to it,</span>
<span class="cm"> *	there can be multiple fan-out links.  On SATA, there&#39;s usually</span>
<span class="cm"> *	a single device connected to a link but PATA and SATA</span>
<span class="cm"> *	controllers emulating TF based interface can have two - master</span>
<span class="cm"> *	and slave.</span>
<span class="cm"> *</span>
<span class="cm"> *	However, there are a few controllers which don&#39;t fit into this</span>
<span class="cm"> *	abstraction too well - SATA controllers which emulate TF</span>
<span class="cm"> *	interface with both master and slave devices but also have</span>
<span class="cm"> *	separate SCR register sets for each device.  These controllers</span>
<span class="cm"> *	need separate links for physical link handling</span>
<span class="cm"> *	(e.g. onlineness, link speed) but should be treated like a</span>
<span class="cm"> *	traditional M/S controller for everything else (e.g. command</span>
<span class="cm"> *	issue, softreset).</span>
<span class="cm"> *</span>
<span class="cm"> *	slave_link is libata&#39;s way of handling this class of</span>
<span class="cm"> *	controllers without impacting core layer too much.  For</span>
<span class="cm"> *	anything other than physical link handling, the default host</span>
<span class="cm"> *	link is used for both master and slave.  For physical link</span>
<span class="cm"> *	handling, separate @ap-&gt;slave_link is used.  All dirty details</span>
<span class="cm"> *	are implemented inside libata core layer.  From LLD&#39;s POV, the</span>
<span class="cm"> *	only difference is that prereset, hardreset and postreset are</span>
<span class="cm"> *	called once more for the slave link, so the reset sequence</span>
<span class="cm"> *	looks like the following.</span>
<span class="cm"> *</span>
<span class="cm"> *	prereset(M) -&gt; prereset(S) -&gt; hardreset(M) -&gt; hardreset(S) -&gt;</span>
<span class="cm"> *	softreset(M) -&gt; postreset(M) -&gt; postreset(S)</span>
<span class="cm"> *</span>
<span class="cm"> *	Note that softreset is called only for the master.  Softreset</span>
<span class="cm"> *	resets both M/S by definition, so SRST on master should handle</span>
<span class="cm"> *	both (the standard method will work just fine).</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Should be called before host is registered.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_slave_link_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PMP</span><span class="p">);</span>

	<span class="n">link</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ata_link_init</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span> <span class="o">=</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_host_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">gendev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">gendev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_HOST_STARTED</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_stop</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_stop</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">host_stop</span><span class="p">)</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">host_stop</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_finalize_port_ops - finalize ata_port_operations</span>
<span class="cm"> *	@ops: ata_port_operations to finalize</span>
<span class="cm"> *</span>
<span class="cm"> *	An ata_port_operations can inherit from another ops and that</span>
<span class="cm"> *	ops can again inherit from another.  This can go on as many</span>
<span class="cm"> *	times as necessary as long as there is no loop in the</span>
<span class="cm"> *	inheritance chain.</span>
<span class="cm"> *</span>
<span class="cm"> *	Ops tables are finalized when the host is started.  NULL or</span>
<span class="cm"> *	unspecified entries are inherited from the closet ancestor</span>
<span class="cm"> *	which has the method and the entry is populated with it.</span>
<span class="cm"> *	After finalization, the ops table directly points to all the</span>
<span class="cm"> *	methods and -&gt;inherits is no longer necessary and cleared.</span>
<span class="cm"> *</span>
<span class="cm"> *	Using ATA_OP_NULL, inheriting ops can force a method to NULL.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_finalize_port_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">begin</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">inherits</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">pp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">inherits</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">inherits</span><span class="p">;</span> <span class="n">cur</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">inherits</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">**</span><span class="n">inherit</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">cur</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pp</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">pp</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">pp</span><span class="o">++</span><span class="p">,</span> <span class="n">inherit</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pp</span><span class="p">)</span>
				<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="o">*</span><span class="n">inherit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pp</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">pp</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">pp</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">))</span>
			<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">inherits</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_host_start - start and freeze ports of an ATA host</span>
<span class="cm"> *	@host: ATA host to start ports for</span>
<span class="cm"> *</span>
<span class="cm"> *	Start and then freeze ports of @host.  Started status is</span>
<span class="cm"> *	recorded in host-&gt;flags, so this function can be called</span>
<span class="cm"> *	multiple times.  Ports are guaranteed to get started only</span>
<span class="cm"> *	once.  If host-&gt;ops isn&#39;t initialized yet, its set to the</span>
<span class="cm"> *	first non-dummy port ops.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 if all ports are started successfully, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_host_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">have_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">start_dr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_HOST_STARTED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ata_finalize_port_ops</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">ata_finalize_port_ops</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ata_port_is_dummy</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_stop</span><span class="p">)</span>
			<span class="n">have_stop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">host_stop</span><span class="p">)</span>
		<span class="n">have_stop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">have_stop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_dr</span> <span class="o">=</span> <span class="n">devres_alloc</span><span class="p">(</span><span class="n">ata_host_stop</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_dr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_start</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;failed to start port %d (errno=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ata_eh_freeze_port</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start_dr</span><span class="p">)</span>
		<span class="n">devres_add</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">start_dr</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_HOST_STARTED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_out:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_stop</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_stop</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">devres_free</span><span class="p">(</span><span class="n">start_dr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sas_host_init - Initialize a host struct</span>
<span class="cm"> *	@host:	host to initialize</span>
<span class="cm"> *	@dev:	device host is attached to</span>
<span class="cm"> *	@flags:	host flags</span>
<span class="cm"> *	@ops:	port_ops</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	PCI/etc. bus probe sem.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cm">/* KILLME - the only user left is ipr */</span>
<span class="kt">void</span> <span class="nf">ata_host_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">eh_mutex</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__ata_port_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* kick EH for boot probing */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">probe_mask</span> <span class="o">|=</span> <span class="n">ATA_ALL_DEVICES</span><span class="p">;</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_EHI_NO_AUTOPSY</span> <span class="o">|</span> <span class="n">ATA_EHI_QUIET</span><span class="p">;</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_PFLAG_INITIALIZING</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">|=</span> <span class="n">ATA_PFLAG_LOADING</span><span class="p">;</span>
	<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ata_port_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__ata_port_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">ata_port_wait_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: bus probe begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_bus_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: bus probe end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">async_port_probe</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">async_cookie_t</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re not allowed to scan this host in parallel,</span>
<span class="cm">	 * we need to wait until all previous scans have completed</span>
<span class="cm">	 * before going further.</span>
<span class="cm">	 * Jeff Garzik says this is only within a controller, so we</span>
<span class="cm">	 * don&#39;t need to wait for port 0, only for later ports.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_HOST_PARALLEL_SCAN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">async_synchronize_cookie</span><span class="p">(</span><span class="n">cookie</span><span class="p">);</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ata_port_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="cm">/* in order to keep device order, we need to synchronize at this point */</span>
	<span class="n">async_synchronize_cookie</span><span class="p">(</span><span class="n">cookie</span><span class="p">);</span>

	<span class="n">ata_scsi_scan_host</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_host_register - register initialized ATA host</span>
<span class="cm"> *	@host: ATA host to register</span>
<span class="cm"> *	@sht: template for SCSI host</span>
<span class="cm"> *</span>
<span class="cm"> *	Register initialized ATA host.  @host is allocated using</span>
<span class="cm"> *	ata_host_alloc() and fully initialized by LLD.  This function</span>
<span class="cm"> *	starts ports, registers @host with ATA and SCSI layers and</span>
<span class="cm"> *	probe registered devices.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_host_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* host must have been started */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_HOST_STARTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG: trying to register unstarted host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Blow away unused ports.  This happens when LLD can&#39;t</span>
<span class="cm">	 * determine the exact number of ports to allocate at</span>
<span class="cm">	 * allocation time.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* give ports names and add SCSI hosts */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">print_id</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ata_print_id</span><span class="p">);</span>


	<span class="cm">/* Create associated sysfs transport objects  */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_tport_add</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">err_tadd</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_scsi_add_hosts</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">sht</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_tadd</span><span class="p">;</span>

	<span class="cm">/* associate with ACPI nodes */</span>
	<span class="n">ata_acpi_associate</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/* set cable, sata_spd_limit and report */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xfer_mask</span><span class="p">;</span>

		<span class="cm">/* set SATA cable type if still unset */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">==</span> <span class="n">ATA_CBL_NONE</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SATA</span><span class="p">))</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">=</span> <span class="n">ATA_CBL_SATA</span><span class="p">;</span>

		<span class="cm">/* init sata_spd_limit to the current value */</span>
		<span class="n">sata_link_init_spd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">)</span>
			<span class="n">sata_link_init_spd</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">);</span>

		<span class="cm">/* print per-port info to dmesg */</span>
		<span class="n">xfer_mask</span> <span class="o">=</span> <span class="n">ata_pack_xfermask</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">,</span>
					      <span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_port_is_dummy</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ata_port_info</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;%cATA max %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SATA</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;S&#39;</span> <span class="o">:</span> <span class="sc">&#39;P&#39;</span><span class="p">,</span>
				      <span class="n">ata_mode_string</span><span class="p">(</span><span class="n">xfer_mask</span><span class="p">),</span>
				      <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">.</span><span class="n">desc</span><span class="p">);</span>
			<span class="n">ata_ehi_clear_desc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ata_port_info</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;DUMMY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* perform each probe asynchronously */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">async_schedule</span><span class="p">(</span><span class="n">async_port_probe</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_tadd:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_tport_delete</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_host_activate - start host, request IRQ and register it</span>
<span class="cm"> *	@host: target ATA host</span>
<span class="cm"> *	@irq: IRQ to request</span>
<span class="cm"> *	@irq_handler: irq_handler used when requesting IRQ</span>
<span class="cm"> *	@irq_flags: irq_flags used when requesting IRQ</span>
<span class="cm"> *	@sht: scsi_host_template to use when registering the host</span>
<span class="cm"> *</span>
<span class="cm"> *	After allocating an ATA host and initializing it, most libata</span>
<span class="cm"> *	LLDs perform three steps to activate the host - start host,</span>
<span class="cm"> *	request IRQ and register it.  This helper takes necessasry</span>
<span class="cm"> *	arguments and performs the three steps in one go.</span>
<span class="cm"> *</span>
<span class="cm"> *	An invalid IRQ skips the IRQ registration and expects the host to</span>
<span class="cm"> *	have set polling mode on the port. In this case, @irq_handler</span>
<span class="cm"> *	should be NULL.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_host_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
		      <span class="n">irq_handler_t</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_host_start</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Special case for polling mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">irq_handler</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ata_host_register</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">sht</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">devm_request_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">,</span>
			      <span class="n">dev_driver_string</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ata_port_desc</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;irq %d&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_host_register</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">sht</span><span class="p">);</span>
	<span class="cm">/* if failed, just free the IRQ and leave ports alone */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">devm_free_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_port_detach - Detach ATA port in prepration of device removal</span>
<span class="cm"> *	@ap: ATA port to be detached</span>
<span class="cm"> *</span>
<span class="cm"> *	Detach all ATA devices and the associated SCSI devices of @ap;</span>
<span class="cm"> *	then, remove the associated SCSI host.  @ap is guaranteed to</span>
<span class="cm"> *	be quiescent on return from this function.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_port_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">skip_eh</span><span class="p">;</span>

	<span class="cm">/* tell EH we&#39;re leaving &amp; flush EH */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">|=</span> <span class="n">ATA_PFLAG_UNLOADING</span><span class="p">;</span>
	<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* wait till EH commits suicide */</span>
	<span class="n">ata_port_wait_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="cm">/* it better be dead now */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_UNLOADED</span><span class="p">));</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hotplug_task</span><span class="p">);</span>

 <span class="nl">skip_eh:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SATA_PMP_MAX_PORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ata_tlink_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">ata_tport_delete</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="cm">/* remove the associated SCSI host */</span>
	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_host_detach - Detach all ports of an ATA host</span>
<span class="cm"> *	@host: Host to detach</span>
<span class="cm"> *</span>
<span class="cm"> *	Detach all ports of @host.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_host_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ata_port_detach</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* the host is dead now, dissociate ACPI */</span>
	<span class="n">ata_acpi_dissociate</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_remove_one - PCI layer callback for device removal</span>
<span class="cm"> *	@pdev: PCI device that was removed</span>
<span class="cm"> *</span>
<span class="cm"> *	PCI layer indicates to libata via this hook that hot-unplug or</span>
<span class="cm"> *	module unload event has occurred.  Detach all ports.  Resource</span>
<span class="cm"> *	release is handled via devres.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from PCI layer (may sleep).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_pci_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ata_host_detach</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* move to PCI subsystem */</span>
<span class="kt">int</span> <span class="nf">pci_test_config_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_bits</span> <span class="o">*</span><span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bits</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="p">{</span>
		<span class="n">u8</span> <span class="n">tmp8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bits</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp8</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tmp16</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bits</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp16</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="mi">4</span>: <span class="p">{</span>
		<span class="n">u32</span> <span class="n">tmp32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bits</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp32</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp32</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="n">bits</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">bits</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="kt">void</span> <span class="nf">ata_pci_device_do_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mesg</span><span class="p">.</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">PM_EVENT_SLEEP</span><span class="p">)</span>
		<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ata_pci_device_do_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcim_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;failed to enable device after resume (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ata_pci_device_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_host_suspend</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">mesg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ata_pci_device_do_suspend</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mesg</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ata_pci_device_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_device_do_resume</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ata_host_resume</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ata_parse_force_one</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">cur</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ata_force_ent</span> <span class="o">*</span><span class="n">force_ent</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: Currently, there&#39;s no way to tag init const data and</span>
<span class="cm">	 * using __initdata causes build failure on some versions of</span>
<span class="cm">	 * gcc.  Once __initdataconst is implemented, add const to the</span>
<span class="cm">	 * following structure.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_force_param</span> <span class="n">force_tbl</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="s">&quot;40c&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">cbl</span>		<span class="o">=</span> <span class="n">ATA_CBL_PATA40</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;80c&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">cbl</span>		<span class="o">=</span> <span class="n">ATA_CBL_PATA80</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;short40c&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">cbl</span>		<span class="o">=</span> <span class="n">ATA_CBL_PATA40_SHORT</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;unk&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">cbl</span>		<span class="o">=</span> <span class="n">ATA_CBL_PATA_UNK</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;ign&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">cbl</span>		<span class="o">=</span> <span class="n">ATA_CBL_PATA_IGN</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;sata&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">cbl</span>		<span class="o">=</span> <span class="n">ATA_CBL_SATA</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;1.5Gbps&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">spd_limit</span>	<span class="o">=</span> <span class="mi">1</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;3.0Gbps&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">spd_limit</span>	<span class="o">=</span> <span class="mi">2</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;noncq&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">horkage_on</span>	<span class="o">=</span> <span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;ncq&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">horkage_off</span>	<span class="o">=</span> <span class="n">ATA_HORKAGE_NONCQ</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;dump_id&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">horkage_on</span>	<span class="o">=</span> <span class="n">ATA_HORKAGE_DUMP_ID</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;pio0&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;pio1&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;pio2&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;pio3&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;pio4&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;pio5&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;pio6&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_PIO</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;mwdma0&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_MWDMA</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;mwdma1&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_MWDMA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;mwdma2&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_MWDMA</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;mwdma3&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_MWDMA</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;mwdma4&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_MWDMA</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma0&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma16&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma/16&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma1&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma25&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma/25&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma2&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma33&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma/33&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma3&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma44&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma/44&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma4&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma66&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma/66&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma5&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma100&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma/100&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma6&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma133&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma/133&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;udma7&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">xfer_mask</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ATA_SHIFT_UDMA</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;nohrst&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">lflags</span>		<span class="o">=</span> <span class="n">ATA_LFLAG_NO_HRST</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;nosrst&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">lflags</span>		<span class="o">=</span> <span class="n">ATA_LFLAG_NO_SRST</span> <span class="p">},</span>
		<span class="p">{</span> <span class="s">&quot;norst&quot;</span><span class="p">,</span>	<span class="p">.</span><span class="n">lflags</span>		<span class="o">=</span> <span class="n">ATA_LFLAG_NO_HRST</span> <span class="o">|</span> <span class="n">ATA_LFLAG_NO_SRST</span> <span class="p">},</span>
	<span class="p">};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_force_param</span> <span class="o">*</span><span class="n">match_fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_matches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* find where this param ends and update *cur */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="cm">/* parse */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">strstrip</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">parse_val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">strstrip</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">strstrip</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* parse id */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">force_ent</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">endp</span> <span class="o">||</span> <span class="o">*</span><span class="n">endp</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;invalid device&quot;</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">force_ent</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">endp</span> <span class="o">||</span> <span class="o">*</span><span class="n">endp</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;invalid port/link&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">parse_val:</span>
	<span class="cm">/* parse val, allow shortcuts so that both 1.5 and 1.5Gbps work */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">force_tbl</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_force_param</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">force_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">nr_matches</span><span class="o">++</span><span class="p">;</span>
		<span class="n">match_fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr_matches</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_matches</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;unknown value&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_matches</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;ambigious value&quot;</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">force_ent</span><span class="o">-&gt;</span><span class="n">param</span> <span class="o">=</span> <span class="o">*</span><span class="n">match_fp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">ata_parse_force_param</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_port</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">last_device</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* calculate maximum number of params and allocate force_tbl */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">ata_force_param_buf</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
			<span class="n">size</span><span class="o">++</span><span class="p">;</span>

	<span class="n">ata_force_tbl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ata_force_tbl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_force_tbl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ata: failed to extend force table, &quot;</span>
		       <span class="s">&quot;libata.force ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* parse and populate the table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cur</span> <span class="o">=</span> <span class="n">ata_force_param_buf</span><span class="p">;</span> <span class="o">*</span><span class="n">cur</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ata_force_ent</span> <span class="n">te</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_parse_force_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reason</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ata: failed to parse force &quot;</span>
			       <span class="s">&quot;parameter </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cur</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">te</span><span class="p">.</span><span class="n">port</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">te</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">last_port</span><span class="p">;</span>
			<span class="n">te</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">last_device</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ata_force_tbl</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">te</span><span class="p">;</span>

		<span class="n">last_port</span> <span class="o">=</span> <span class="n">te</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
		<span class="n">last_device</span> <span class="o">=</span> <span class="n">te</span><span class="p">.</span><span class="n">device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ata_force_tbl_size</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ata_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ata_parse_force_param</span><span class="p">();</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_sff_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ata_force_tbl</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">libata_transport_init</span><span class="p">();</span>
	<span class="n">ata_scsi_transport_template</span> <span class="o">=</span> <span class="n">ata_attach_transport</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_scsi_transport_template</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_sff_exit</span><span class="p">();</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;libata version &quot;</span> <span class="n">DRV_VERSION</span> <span class="s">&quot; loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ata_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ata_release_transport</span><span class="p">(</span><span class="n">ata_scsi_transport_template</span><span class="p">);</span>
	<span class="n">libata_transport_exit</span><span class="p">();</span>
	<span class="n">ata_sff_exit</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ata_force_tbl</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">ata_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ata_exit</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">ratelimit</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">ata_ratelimit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ratelimit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_msleep - ATA EH owner aware msleep</span>
<span class="cm"> *	@ap: ATA port to attribute the sleep to</span>
<span class="cm"> *	@msecs: duration to sleep in milliseconds</span>
<span class="cm"> *</span>
<span class="cm"> *	Sleeps @msecs.  If the current task is owner of @ap&#39;s EH, the</span>
<span class="cm"> *	ownership is released before going to sleep and reacquired</span>
<span class="cm"> *	after the sleep is complete.  IOW, other ports sharing the</span>
<span class="cm"> *	@ap-&gt;host will be allowed to own the EH while this task is</span>
<span class="cm"> *	sleeping.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Might sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_msleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">owns_eh</span> <span class="o">=</span> <span class="n">ap</span> <span class="o">&amp;&amp;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">eh_owner</span> <span class="o">==</span> <span class="n">current</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owns_eh</span><span class="p">)</span>
		<span class="n">ata_eh_release</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">msleep</span><span class="p">(</span><span class="n">msecs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owns_eh</span><span class="p">)</span>
		<span class="n">ata_eh_acquire</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_wait_register - wait until register value changes</span>
<span class="cm"> *	@ap: ATA port to wait register for, can be NULL</span>
<span class="cm"> *	@reg: IO-mapped register</span>
<span class="cm"> *	@mask: Mask to apply to read register value</span>
<span class="cm"> *	@val: Wait condition</span>
<span class="cm"> *	@interval: polling interval in milliseconds</span>
<span class="cm"> *	@timeout: timeout in milliseconds</span>
<span class="cm"> *</span>
<span class="cm"> *	Waiting for some bits of register to change is a common</span>
<span class="cm"> *	operation for ATA controllers.  This function reads 32bit LE</span>
<span class="cm"> *	IO-mapped register @reg and tests for the following condition.</span>
<span class="cm"> *</span>
<span class="cm"> *	(*@reg &amp; mask) != val</span>
<span class="cm"> *</span>
<span class="cm"> *	If the condition is met, it returns; otherwise, the process is</span>
<span class="cm"> *	repeated after @interval_msec until timeout.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	The final register value.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">ata_wait_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Calculate timeout _after_ the first read to make sure</span>
<span class="cm">	 * preceding writes reach the controller before starting to</span>
<span class="cm">	 * eat away the timeout.</span>
<span class="cm">	 */</span>
	<span class="n">deadline</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dummy port_ops</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_dummy_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">AC_ERR_SYSTEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_dummy_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* truly dummy */</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_dummy_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">qc_prep</span>		<span class="o">=</span> <span class="n">ata_noop_qc_prep</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_issue</span>		<span class="o">=</span> <span class="n">ata_dummy_qc_issue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_handler</span>		<span class="o">=</span> <span class="n">ata_dummy_error_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="n">ata_dummy_port_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">port_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_dummy_port_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Utility print functions</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_port_printk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%sata%u: %pV&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ata_port_printk</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">ata_link_printk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">)</span> <span class="o">||</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">slave_link</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%sata%u.%02u: %pV&quot;</span><span class="p">,</span>
			   <span class="n">level</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%sata%u: %pV&quot;</span><span class="p">,</span>
			   <span class="n">level</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ata_link_printk</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">ata_dev_printk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%sata%u.%02u: %pV&quot;</span><span class="p">,</span>
		   <span class="n">level</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">,</span>
		   <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ata_dev_printk</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ata_print_version</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ata_print_version</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * libata is essentially a library of internal helper functions for</span>
<span class="cm"> * low-level ATA host controller drivers.  As such, the API/ABI is</span>
<span class="cm"> * likely to change as new drivers are added and updated.</span>
<span class="cm"> * Do not depend on ABI/API stability.</span>
<span class="cm"> */</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_deb_timing_normal</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_deb_timing_hotplug</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_deb_timing_long</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_base_port_ops</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_port_ops</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_dummy_port_ops</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_dummy_port_info</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_link_next</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_dev_next</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_std_bios_param</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_scsi_unlock_native_capacity</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_init</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_alloc</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_alloc_pinfo</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_slave_link_init</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_start</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_register</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_activate</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_detach</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sg_init</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_qc_complete</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_qc_complete_multiple</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">atapi_cmd_type</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_tf_to_fis</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_tf_from_fis</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pack_xfermask</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_unpack_xfermask</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_xfer_mask2mode</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_xfer_mode2mask</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_xfer_mode2shift</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_mode_string</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_id_xfermask</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_do_set_mode</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_std_qc_defer</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_noop_qc_prep</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_dev_disable</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_set_spd</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_wait_after_reset</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_link_debounce</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_link_resume</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_link_scr_lpm</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_std_prereset</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_link_hardreset</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_std_hardreset</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_std_postreset</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_dev_classify</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_dev_pair</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_ratelimit</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_msleep</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_wait_register</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_scsi_queuecmd</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_scsi_slave_config</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_scsi_slave_destroy</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_scsi_change_queue_depth</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__ata_change_queue_depth</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_scr_valid</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_scr_read</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_scr_write</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_scr_write_flush</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_link_online</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_link_offline</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_suspend</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_host_resume</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_id_string</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_id_c_string</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_do_dev_read_id</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_scsi_simulate</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pio_need_iordy</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_timing_find_mode</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_timing_compute</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_timing_merge</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_timing_cycle2mode</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_test_config_bits</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_remove_one</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_device_do_suspend</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_device_do_resume</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_device_suspend</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_device_resume</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__ata_ehi_push_desc</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_ehi_push_desc</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_ehi_clear_desc</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_port_desc</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_port_pbar_desc</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_port_schedule_eh</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_link_abort</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_port_abort</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_port_freeze</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_async_notification</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_eh_freeze_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_eh_thaw_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_eh_qc_complete</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_eh_qc_retry</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_eh_analyze_ncq_error</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_do_eh</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_std_error_handler</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_cable_40wire</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_cable_80wire</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_cable_unknown</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_cable_ignore</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_cable_sata</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
