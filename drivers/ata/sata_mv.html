<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ata › sata_mv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sata_mv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * sata_mv.c - Marvell SATA support</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2008-2009: Marvell Corporation, all rights reserved.</span>
<span class="cm"> * Copyright 2005: EMC Corporation, all rights reserved.</span>
<span class="cm"> * Copyright 2005 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Originally written by Brett Russ.</span>
<span class="cm"> * Extensive overhaul and enhancement by Mark Lord &lt;mlord@pobox.com&gt;.</span>
<span class="cm"> *</span>
<span class="cm"> * Please ALWAYS copy linux-ide@vger.kernel.org on emails.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * sata_mv TODO list:</span>
<span class="cm"> *</span>
<span class="cm"> * --&gt; Develop a low-power-consumption strategy, and implement it.</span>
<span class="cm"> *</span>
<span class="cm"> * --&gt; Add sysfs attributes for per-chip / per-HC IRQ coalescing thresholds.</span>
<span class="cm"> *</span>
<span class="cm"> * --&gt; [Experiment, Marvell value added] Is it possible to use target</span>
<span class="cm"> *       mode to cross-connect two Linux boxes with Marvell cards?  If so,</span>
<span class="cm"> *       creating LibATA target mode support would be very interesting.</span>
<span class="cm"> *</span>
<span class="cm"> *       Target mode, for those without docs, is the ability to directly</span>
<span class="cm"> *       connect two SATA ports.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * 80x1-B2 errata PCI#11:</span>
<span class="cm"> *</span>
<span class="cm"> * Users of the 6041/6081 Rev.B2 chips (current is C0)</span>
<span class="cm"> * should be careful to insert those cards only onto PCI-X bus #0,</span>
<span class="cm"> * and only in device slots 0..7, not higher.  The chips may not</span>
<span class="cm"> * work correctly otherwise  (note: this is a pretty rare condition).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/ata_platform.h&gt;</span>
<span class="cp">#include &lt;linux/mbus.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>

<span class="cp">#define DRV_NAME	&quot;sata_mv&quot;</span>
<span class="cp">#define DRV_VERSION	&quot;1.28&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * module options</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">msi</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">msi</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">msi</span><span class="p">,</span> <span class="s">&quot;Enable use of PCI MSI (0=off, 1=on)&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">irq_coalescing_io_count</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">irq_coalescing_io_count</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq_coalescing_io_count</span><span class="p">,</span>
		 <span class="s">&quot;IRQ coalescing I/O count threshold (0..255)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">irq_coalescing_usecs</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">irq_coalescing_usecs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq_coalescing_usecs</span><span class="p">,</span>
		 <span class="s">&quot;IRQ coalescing time threshold in usecs&quot;</span><span class="p">);</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* BAR&#39;s are enumerated in terms of pci_resource_start() terms */</span>
	<span class="n">MV_PRIMARY_BAR</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* offset 0x10: memory space */</span>
	<span class="n">MV_IO_BAR</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* offset 0x18: IO space */</span>
	<span class="n">MV_MISC_BAR</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* offset 0x1c: FLASH, NVRAM, SRAM */</span>

	<span class="n">MV_MAJOR_REG_AREA_SZ</span>	<span class="o">=</span> <span class="mh">0x10000</span><span class="p">,</span>	<span class="cm">/* 64KB */</span>
	<span class="n">MV_MINOR_REG_AREA_SZ</span>	<span class="o">=</span> <span class="mh">0x2000</span><span class="p">,</span>	<span class="cm">/* 8KB */</span>

	<span class="cm">/* For use with both IRQ coalescing methods (&quot;all ports&quot; or &quot;per-HC&quot; */</span>
	<span class="n">COAL_CLOCKS_PER_USEC</span>	<span class="o">=</span> <span class="mi">150</span><span class="p">,</span>		<span class="cm">/* for calculating COAL_TIMEs */</span>
	<span class="n">MAX_COAL_TIME_THRESHOLD</span>	<span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="cm">/* internal clocks count */</span>
	<span class="n">MAX_COAL_IO_COUNT</span>	<span class="o">=</span> <span class="mi">255</span><span class="p">,</span>		<span class="cm">/* completed I/O count */</span>

	<span class="n">MV_PCI_REG_BASE</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per-chip (&quot;all ports&quot;) interrupt coalescing feature.</span>
<span class="cm">	 * This is only for GEN_II / GEN_IIE hardware.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Coalescing defers the interrupt until either the IO_THRESHOLD</span>
<span class="cm">	 * (count of completed I/Os) is met, or the TIME_THRESHOLD is met.</span>
<span class="cm">	 */</span>
	<span class="n">COAL_REG_BASE</span>		<span class="o">=</span> <span class="mh">0x18000</span><span class="p">,</span>
	<span class="n">IRQ_COAL_CAUSE</span>		<span class="o">=</span> <span class="p">(</span><span class="n">COAL_REG_BASE</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">),</span>
	<span class="n">ALL_PORTS_COAL_IRQ</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* all ports irq event */</span>

	<span class="n">IRQ_COAL_IO_THRESHOLD</span>   <span class="o">=</span> <span class="p">(</span><span class="n">COAL_REG_BASE</span> <span class="o">+</span> <span class="mh">0xcc</span><span class="p">),</span>
	<span class="n">IRQ_COAL_TIME_THRESHOLD</span> <span class="o">=</span> <span class="p">(</span><span class="n">COAL_REG_BASE</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 * Registers for the (unused here) transaction coalescing feature:</span>
<span class="cm">	 */</span>
	<span class="n">TRAN_COAL_CAUSE_LO</span>	<span class="o">=</span> <span class="p">(</span><span class="n">COAL_REG_BASE</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">),</span>
	<span class="n">TRAN_COAL_CAUSE_HI</span>	<span class="o">=</span> <span class="p">(</span><span class="n">COAL_REG_BASE</span> <span class="o">+</span> <span class="mh">0x8c</span><span class="p">),</span>

	<span class="n">SATAHC0_REG_BASE</span>	<span class="o">=</span> <span class="mh">0x20000</span><span class="p">,</span>
	<span class="n">FLASH_CTL</span>		<span class="o">=</span> <span class="mh">0x1046c</span><span class="p">,</span>
	<span class="n">GPIO_PORT_CTL</span>		<span class="o">=</span> <span class="mh">0x104f0</span><span class="p">,</span>
	<span class="n">RESET_CFG</span>		<span class="o">=</span> <span class="mh">0x180d8</span><span class="p">,</span>

	<span class="n">MV_PCI_REG_SZ</span>		<span class="o">=</span> <span class="n">MV_MAJOR_REG_AREA_SZ</span><span class="p">,</span>
	<span class="n">MV_SATAHC_REG_SZ</span>	<span class="o">=</span> <span class="n">MV_MAJOR_REG_AREA_SZ</span><span class="p">,</span>
	<span class="n">MV_SATAHC_ARBTR_REG_SZ</span>	<span class="o">=</span> <span class="n">MV_MINOR_REG_AREA_SZ</span><span class="p">,</span>		<span class="cm">/* arbiter */</span>
	<span class="n">MV_PORT_REG_SZ</span>		<span class="o">=</span> <span class="n">MV_MINOR_REG_AREA_SZ</span><span class="p">,</span>

	<span class="n">MV_MAX_Q_DEPTH</span>		<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="n">MV_MAX_Q_DEPTH_MASK</span>	<span class="o">=</span> <span class="n">MV_MAX_Q_DEPTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* CRQB needs alignment on a 1KB boundary. Size == 1KB</span>
<span class="cm">	 * CRPB needs alignment on a 256B boundary. Size == 256B</span>
<span class="cm">	 * ePRD (SG) entries need alignment on a 16B boundary. Size == 16B</span>
<span class="cm">	 */</span>
	<span class="n">MV_CRQB_Q_SZ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">MV_MAX_Q_DEPTH</span><span class="p">),</span>
	<span class="n">MV_CRPB_Q_SZ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">MV_MAX_Q_DEPTH</span><span class="p">),</span>
	<span class="n">MV_MAX_SG_CT</span>		<span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
	<span class="n">MV_SG_TBL_SZ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">MV_MAX_SG_CT</span><span class="p">),</span>

	<span class="cm">/* Determine hc from 0-7 port: hc = port &gt;&gt; MV_PORT_HC_SHIFT */</span>
	<span class="n">MV_PORT_HC_SHIFT</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">MV_PORTS_PER_HC</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MV_PORT_HC_SHIFT</span><span class="p">),</span> <span class="cm">/* 4 */</span>
	<span class="cm">/* Determine hc port from 0-7 port: hardport = port &amp; MV_PORT_MASK */</span>
	<span class="n">MV_PORT_MASK</span>		<span class="o">=</span> <span class="p">(</span><span class="n">MV_PORTS_PER_HC</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>   <span class="cm">/* 3 */</span>

	<span class="cm">/* Host Flags */</span>
	<span class="n">MV_FLAG_DUAL_HC</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">),</span>  <span class="cm">/* two SATA Host Controllers */</span>

	<span class="n">MV_COMMON_FLAGS</span>		<span class="o">=</span> <span class="n">ATA_FLAG_SATA</span> <span class="o">|</span> <span class="n">ATA_FLAG_PIO_POLLING</span><span class="p">,</span>

	<span class="n">MV_GEN_I_FLAGS</span>		<span class="o">=</span> <span class="n">MV_COMMON_FLAGS</span> <span class="o">|</span> <span class="n">ATA_FLAG_NO_ATAPI</span><span class="p">,</span>

	<span class="n">MV_GEN_II_FLAGS</span>		<span class="o">=</span> <span class="n">MV_COMMON_FLAGS</span> <span class="o">|</span> <span class="n">ATA_FLAG_NCQ</span> <span class="o">|</span>
				  <span class="n">ATA_FLAG_PMP</span> <span class="o">|</span> <span class="n">ATA_FLAG_ACPI_SATA</span><span class="p">,</span>

	<span class="n">MV_GEN_IIE_FLAGS</span>	<span class="o">=</span> <span class="n">MV_GEN_II_FLAGS</span> <span class="o">|</span> <span class="n">ATA_FLAG_AN</span><span class="p">,</span>

	<span class="n">CRQB_FLAG_READ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">CRQB_TAG_SHIFT</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CRQB_IOID_SHIFT</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* CRQB Gen-II/IIE IO Id shift */</span>
	<span class="n">CRQB_PMP_SHIFT</span>		<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>	<span class="cm">/* CRQB Gen-II/IIE PMP shift */</span>
	<span class="n">CRQB_HOSTQ_SHIFT</span>	<span class="o">=</span> <span class="mi">17</span><span class="p">,</span>	<span class="cm">/* CRQB Gen-II/IIE HostQueTag shift */</span>
	<span class="n">CRQB_CMD_ADDR_SHIFT</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">CRQB_CMD_CS</span>		<span class="o">=</span> <span class="p">(</span><span class="mh">0x2</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>
	<span class="n">CRQB_CMD_LAST</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>

	<span class="n">CRPB_FLAG_STATUS_SHIFT</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">CRPB_IOID_SHIFT_6</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* CRPB Gen-II IO Id shift */</span>
	<span class="n">CRPB_IOID_SHIFT_7</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* CRPB Gen-IIE IO Id shift */</span>

	<span class="n">EPRD_FLAG_END_OF_TBL</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">),</span>

	<span class="cm">/* PCI interface registers */</span>

	<span class="n">MV_PCI_COMMAND</span>		<span class="o">=</span> <span class="mh">0xc00</span><span class="p">,</span>
	<span class="n">MV_PCI_COMMAND_MWRCOM</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* PCI Master Write Combining */</span>
	<span class="n">MV_PCI_COMMAND_MRDTRIG</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>	<span class="cm">/* PCI Master Read Trigger */</span>

	<span class="n">PCI_MAIN_CMD_STS</span>	<span class="o">=</span> <span class="mh">0xd30</span><span class="p">,</span>
	<span class="n">STOP_PCI_MASTER</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">PCI_MASTER_EMPTY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">GLOB_SFT_RST</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>

	<span class="n">MV_PCI_MODE</span>		<span class="o">=</span> <span class="mh">0xd00</span><span class="p">,</span>
	<span class="n">MV_PCI_MODE_MASK</span>	<span class="o">=</span> <span class="mh">0x30</span><span class="p">,</span>

	<span class="n">MV_PCI_EXP_ROM_BAR_CTL</span>	<span class="o">=</span> <span class="mh">0xd2c</span><span class="p">,</span>
	<span class="n">MV_PCI_DISC_TIMER</span>	<span class="o">=</span> <span class="mh">0xd04</span><span class="p">,</span>
	<span class="n">MV_PCI_MSI_TRIGGER</span>	<span class="o">=</span> <span class="mh">0xc38</span><span class="p">,</span>
	<span class="n">MV_PCI_SERR_MASK</span>	<span class="o">=</span> <span class="mh">0xc28</span><span class="p">,</span>
	<span class="n">MV_PCI_XBAR_TMOUT</span>	<span class="o">=</span> <span class="mh">0x1d04</span><span class="p">,</span>
	<span class="n">MV_PCI_ERR_LOW_ADDRESS</span>	<span class="o">=</span> <span class="mh">0x1d40</span><span class="p">,</span>
	<span class="n">MV_PCI_ERR_HIGH_ADDRESS</span>	<span class="o">=</span> <span class="mh">0x1d44</span><span class="p">,</span>
	<span class="n">MV_PCI_ERR_ATTRIBUTE</span>	<span class="o">=</span> <span class="mh">0x1d48</span><span class="p">,</span>
	<span class="n">MV_PCI_ERR_COMMAND</span>	<span class="o">=</span> <span class="mh">0x1d50</span><span class="p">,</span>

	<span class="n">PCI_IRQ_CAUSE</span>		<span class="o">=</span> <span class="mh">0x1d58</span><span class="p">,</span>
	<span class="n">PCI_IRQ_MASK</span>		<span class="o">=</span> <span class="mh">0x1d5c</span><span class="p">,</span>
	<span class="n">PCI_UNMASK_ALL_IRQS</span>	<span class="o">=</span> <span class="mh">0x7fffff</span><span class="p">,</span>	<span class="cm">/* bits 22-0 */</span>

	<span class="n">PCIE_IRQ_CAUSE</span>		<span class="o">=</span> <span class="mh">0x1900</span><span class="p">,</span>
	<span class="n">PCIE_IRQ_MASK</span>		<span class="o">=</span> <span class="mh">0x1910</span><span class="p">,</span>
	<span class="n">PCIE_UNMASK_ALL_IRQS</span>	<span class="o">=</span> <span class="mh">0x40a</span><span class="p">,</span>	<span class="cm">/* assorted bits */</span>

	<span class="cm">/* Host Controller Main Interrupt Cause/Mask registers (1 per-chip) */</span>
	<span class="n">PCI_HC_MAIN_IRQ_CAUSE</span>	<span class="o">=</span> <span class="mh">0x1d60</span><span class="p">,</span>
	<span class="n">PCI_HC_MAIN_IRQ_MASK</span>	<span class="o">=</span> <span class="mh">0x1d64</span><span class="p">,</span>
	<span class="n">SOC_HC_MAIN_IRQ_CAUSE</span>	<span class="o">=</span> <span class="mh">0x20020</span><span class="p">,</span>
	<span class="n">SOC_HC_MAIN_IRQ_MASK</span>	<span class="o">=</span> <span class="mh">0x20024</span><span class="p">,</span>
	<span class="n">ERR_IRQ</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* shift by (2 * port #) */</span>
	<span class="n">DONE_IRQ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* shift by (2 * port #) */</span>
	<span class="n">HC0_IRQ_PEND</span>		<span class="o">=</span> <span class="mh">0x1ff</span><span class="p">,</span>	<span class="cm">/* bits 0-8 = HC0&#39;s ports */</span>
	<span class="n">HC_SHIFT</span>		<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>		<span class="cm">/* bits 9-17 = HC1&#39;s ports */</span>
	<span class="n">DONE_IRQ_0_3</span>		<span class="o">=</span> <span class="mh">0x000000aa</span><span class="p">,</span>	<span class="cm">/* DONE_IRQ ports 0,1,2,3 */</span>
	<span class="n">DONE_IRQ_4_7</span>		<span class="o">=</span> <span class="p">(</span><span class="n">DONE_IRQ_0_3</span> <span class="o">&lt;&lt;</span> <span class="n">HC_SHIFT</span><span class="p">),</span>  <span class="cm">/* 4,5,6,7 */</span>
	<span class="n">PCI_ERR</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">),</span>
	<span class="n">TRAN_COAL_LO_DONE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span>	<span class="cm">/* transaction coalescing */</span>
	<span class="n">TRAN_COAL_HI_DONE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">),</span>	<span class="cm">/* transaction coalescing */</span>
	<span class="n">PORTS_0_3_COAL_DONE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* HC0 IRQ coalescing */</span>
	<span class="n">PORTS_4_7_COAL_DONE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span>	<span class="cm">/* HC1 IRQ coalescing */</span>
	<span class="n">ALL_PORTS_COAL_DONE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span>	<span class="cm">/* GEN_II(E) IRQ coalescing */</span>
	<span class="n">GPIO_INT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">),</span>
	<span class="n">SELF_INT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">),</span>
	<span class="n">TWSI_INT</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
	<span class="n">HC_MAIN_RSVD</span>		<span class="o">=</span> <span class="p">(</span><span class="mh">0x7f</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">),</span>	<span class="cm">/* bits 31-25 */</span>
	<span class="n">HC_MAIN_RSVD_5</span>		<span class="o">=</span> <span class="p">(</span><span class="mh">0x1fff</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">),</span> <span class="cm">/* bits 31-19 */</span>
	<span class="n">HC_MAIN_RSVD_SOC</span>	<span class="o">=</span> <span class="p">(</span><span class="mh">0x3fffffb</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>     <span class="cm">/* bits 31-9, 7-6 */</span>

	<span class="cm">/* SATAHC registers */</span>
	<span class="n">HC_CFG</span>			<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>

	<span class="n">HC_IRQ_CAUSE</span>		<span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
	<span class="n">DMA_IRQ</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* shift by port # */</span>
	<span class="n">HC_COAL_IRQ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* IRQ coalescing */</span>
	<span class="n">DEV_IRQ</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* shift by port # */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per-HC (Host-Controller) interrupt coalescing feature.</span>
<span class="cm">	 * This is present on all chip generations.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Coalescing defers the interrupt until either the IO_THRESHOLD</span>
<span class="cm">	 * (count of completed I/Os) is met, or the TIME_THRESHOLD is met.</span>
<span class="cm">	 */</span>
	<span class="n">HC_IRQ_COAL_IO_THRESHOLD</span>	<span class="o">=</span> <span class="mh">0x000c</span><span class="p">,</span>
	<span class="n">HC_IRQ_COAL_TIME_THRESHOLD</span>	<span class="o">=</span> <span class="mh">0x0010</span><span class="p">,</span>

	<span class="n">SOC_LED_CTRL</span>		<span class="o">=</span> <span class="mh">0x2c</span><span class="p">,</span>
	<span class="n">SOC_LED_CTRL_BLINK</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* Active LED blink */</span>
	<span class="n">SOC_LED_CTRL_ACT_PRESENCE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* Multiplex dev presence */</span>
						<span class="cm">/*  with dev activity LED */</span>

	<span class="cm">/* Shadow block registers */</span>
	<span class="n">SHD_BLK</span>			<span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span>
	<span class="n">SHD_CTL_AST</span>		<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>		<span class="cm">/* ofs from SHD_BLK */</span>

	<span class="cm">/* SATA registers */</span>
	<span class="n">SATA_STATUS</span>		<span class="o">=</span> <span class="mh">0x300</span><span class="p">,</span>  <span class="cm">/* ctrl, err regs follow status */</span>
	<span class="n">SATA_ACTIVE</span>		<span class="o">=</span> <span class="mh">0x350</span><span class="p">,</span>
	<span class="n">FIS_IRQ_CAUSE</span>		<span class="o">=</span> <span class="mh">0x364</span><span class="p">,</span>
	<span class="n">FIS_IRQ_CAUSE_AN</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>	<span class="cm">/* async notification */</span>

	<span class="n">LTMODE</span>			<span class="o">=</span> <span class="mh">0x30c</span><span class="p">,</span>	<span class="cm">/* requires read-after-write */</span>
	<span class="n">LTMODE_BIT8</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* unknown, but necessary */</span>

	<span class="n">PHY_MODE2</span>		<span class="o">=</span> <span class="mh">0x330</span><span class="p">,</span>
	<span class="n">PHY_MODE3</span>		<span class="o">=</span> <span class="mh">0x310</span><span class="p">,</span>

	<span class="n">PHY_MODE4</span>		<span class="o">=</span> <span class="mh">0x314</span><span class="p">,</span>	<span class="cm">/* requires read-after-write */</span>
	<span class="n">PHY_MODE4_CFG_MASK</span>	<span class="o">=</span> <span class="mh">0x00000003</span><span class="p">,</span>	<span class="cm">/* phy internal config field */</span>
	<span class="n">PHY_MODE4_CFG_VALUE</span>	<span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>	<span class="cm">/* phy internal config field */</span>
	<span class="n">PHY_MODE4_RSVD_ZEROS</span>	<span class="o">=</span> <span class="mh">0x5de3fffa</span><span class="p">,</span>	<span class="cm">/* Gen2e always write zeros */</span>
	<span class="n">PHY_MODE4_RSVD_ONES</span>	<span class="o">=</span> <span class="mh">0x00000005</span><span class="p">,</span>	<span class="cm">/* Gen2e always write ones */</span>

	<span class="n">SATA_IFCTL</span>		<span class="o">=</span> <span class="mh">0x344</span><span class="p">,</span>
	<span class="n">SATA_TESTCTL</span>		<span class="o">=</span> <span class="mh">0x348</span><span class="p">,</span>
	<span class="n">SATA_IFSTAT</span>		<span class="o">=</span> <span class="mh">0x34c</span><span class="p">,</span>
	<span class="n">VENDOR_UNIQUE_FIS</span>	<span class="o">=</span> <span class="mh">0x35c</span><span class="p">,</span>

	<span class="n">FISCFG</span>			<span class="o">=</span> <span class="mh">0x360</span><span class="p">,</span>
	<span class="n">FISCFG_WAIT_DEV_ERR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* wait for host on DevErr */</span>
	<span class="n">FISCFG_SINGLE_SYNC</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>	<span class="cm">/* SYNC on DMA activation */</span>

	<span class="n">PHY_MODE9_GEN2</span>		<span class="o">=</span> <span class="mh">0x398</span><span class="p">,</span>
	<span class="n">PHY_MODE9_GEN1</span>		<span class="o">=</span> <span class="mh">0x39c</span><span class="p">,</span>
	<span class="n">PHYCFG_OFS</span>		<span class="o">=</span> <span class="mh">0x3a0</span><span class="p">,</span>	<span class="cm">/* only in 65n devices */</span>

	<span class="n">MV5_PHY_MODE</span>		<span class="o">=</span> <span class="mh">0x74</span><span class="p">,</span>
	<span class="n">MV5_LTMODE</span>		<span class="o">=</span> <span class="mh">0x30</span><span class="p">,</span>
	<span class="n">MV5_PHY_CTL</span>		<span class="o">=</span> <span class="mh">0x0C</span><span class="p">,</span>
	<span class="n">SATA_IFCFG</span>		<span class="o">=</span> <span class="mh">0x050</span><span class="p">,</span>

	<span class="n">MV_M2_PREAMP_MASK</span>	<span class="o">=</span> <span class="mh">0x7e0</span><span class="p">,</span>

	<span class="cm">/* Port registers */</span>
	<span class="n">EDMA_CFG</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">EDMA_CFG_Q_DEPTH</span>	<span class="o">=</span> <span class="mh">0x1f</span><span class="p">,</span>		<span class="cm">/* max device queue depth */</span>
	<span class="n">EDMA_CFG_NCQ</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>	<span class="cm">/* for R/W FPDMA queued */</span>
	<span class="n">EDMA_CFG_NCQ_GO_ON_ERR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span>	<span class="cm">/* continue on error */</span>
	<span class="n">EDMA_CFG_RD_BRST_EXT</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>	<span class="cm">/* read burst 512B */</span>
	<span class="n">EDMA_CFG_WR_BUFF_LEN</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>	<span class="cm">/* write buffer 512B */</span>
	<span class="n">EDMA_CFG_EDMA_FBS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>	<span class="cm">/* EDMA FIS-Based Switching */</span>
	<span class="n">EDMA_CFG_FBS</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">),</span>	<span class="cm">/* FIS-Based Switching */</span>

	<span class="n">EDMA_ERR_IRQ_CAUSE</span>	<span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
	<span class="n">EDMA_ERR_IRQ_MASK</span>	<span class="o">=</span> <span class="mh">0xc</span><span class="p">,</span>
	<span class="n">EDMA_ERR_D_PAR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* UDMA data parity err */</span>
	<span class="n">EDMA_ERR_PRD_PAR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* UDMA PRD parity err */</span>
	<span class="n">EDMA_ERR_DEV</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* device error */</span>
	<span class="n">EDMA_ERR_DEV_DCON</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>	<span class="cm">/* device disconnect */</span>
	<span class="n">EDMA_ERR_DEV_CON</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* device connected */</span>
	<span class="n">EDMA_ERR_SERR</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>	<span class="cm">/* SError bits [WBDST] raised */</span>
	<span class="n">EDMA_ERR_SELF_DIS</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>	<span class="cm">/* Gen II/IIE self-disable */</span>
	<span class="n">EDMA_ERR_SELF_DIS_5</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* Gen I self-disable */</span>
	<span class="n">EDMA_ERR_BIST_ASYNC</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* BIST FIS or Async Notify */</span>
	<span class="n">EDMA_ERR_TRANS_IRQ_7</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* Gen IIE transprt layer irq */</span>
	<span class="n">EDMA_ERR_CRQB_PAR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>	<span class="cm">/* CRQB parity error */</span>
	<span class="n">EDMA_ERR_CRPB_PAR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>	<span class="cm">/* CRPB parity error */</span>
	<span class="n">EDMA_ERR_INTRL_PAR</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>	<span class="cm">/* internal parity error */</span>
	<span class="n">EDMA_ERR_IORDY</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>	<span class="cm">/* IORdy timeout */</span>

	<span class="n">EDMA_ERR_LNK_CTRL_RX</span>	<span class="o">=</span> <span class="p">(</span><span class="mh">0xf</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>	<span class="cm">/* link ctrl rx error */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_RX_0</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">),</span>	<span class="cm">/* transient: CRC err */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_RX_1</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">),</span>	<span class="cm">/* transient: FIFO err */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_RX_2</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">),</span>	<span class="cm">/* fatal: caught SYNC */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_RX_3</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">),</span>	<span class="cm">/* transient: FIS rx err */</span>

	<span class="n">EDMA_ERR_LNK_DATA_RX</span>	<span class="o">=</span> <span class="p">(</span><span class="mh">0xf</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">),</span>	<span class="cm">/* link data rx error */</span>

	<span class="n">EDMA_ERR_LNK_CTRL_TX</span>	<span class="o">=</span> <span class="p">(</span><span class="mh">0x1f</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span>	<span class="cm">/* link ctrl tx error */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_TX_0</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">),</span>	<span class="cm">/* transient: CRC err */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_TX_1</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">),</span>	<span class="cm">/* transient: FIFO err */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_TX_2</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">),</span>	<span class="cm">/* transient: caught SYNC */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_TX_3</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>	<span class="cm">/* transient: caught DMAT */</span>
	<span class="n">EDMA_ERR_LNK_CTRL_TX_4</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">),</span>	<span class="cm">/* transient: FIS collision */</span>

	<span class="n">EDMA_ERR_LNK_DATA_TX</span>	<span class="o">=</span> <span class="p">(</span><span class="mh">0x1f</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">),</span>	<span class="cm">/* link data tx error */</span>

	<span class="n">EDMA_ERR_TRANS_PROTO</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">),</span>	<span class="cm">/* transport protocol error */</span>
	<span class="n">EDMA_ERR_OVERRUN_5</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
	<span class="n">EDMA_ERR_UNDERRUN_5</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>

	<span class="n">EDMA_ERR_IRQ_TRANSIENT</span>  <span class="o">=</span> <span class="n">EDMA_ERR_LNK_CTRL_RX_0</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_LNK_CTRL_RX_1</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_LNK_CTRL_RX_3</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_LNK_CTRL_TX</span><span class="p">,</span>

	<span class="n">EDMA_EH_FREEZE</span>		<span class="o">=</span> <span class="n">EDMA_ERR_D_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_PRD_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_DEV_DCON</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_DEV_CON</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_SERR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_SELF_DIS</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_CRQB_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_CRPB_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_INTRL_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_IORDY</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_LNK_CTRL_RX_2</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_LNK_DATA_RX</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_LNK_DATA_TX</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_TRANS_PROTO</span><span class="p">,</span>

	<span class="n">EDMA_EH_FREEZE_5</span>	<span class="o">=</span> <span class="n">EDMA_ERR_D_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_PRD_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_DEV_DCON</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_DEV_CON</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_OVERRUN_5</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_UNDERRUN_5</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_SELF_DIS_5</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_CRQB_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_CRPB_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_INTRL_PAR</span> <span class="o">|</span>
				  <span class="n">EDMA_ERR_IORDY</span><span class="p">,</span>

	<span class="n">EDMA_REQ_Q_BASE_HI</span>	<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">EDMA_REQ_Q_IN_PTR</span>	<span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>		<span class="cm">/* also contains BASE_LO */</span>

	<span class="n">EDMA_REQ_Q_OUT_PTR</span>	<span class="o">=</span> <span class="mh">0x18</span><span class="p">,</span>
	<span class="n">EDMA_REQ_Q_PTR_SHIFT</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>

	<span class="n">EDMA_RSP_Q_BASE_HI</span>	<span class="o">=</span> <span class="mh">0x1c</span><span class="p">,</span>
	<span class="n">EDMA_RSP_Q_IN_PTR</span>	<span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">EDMA_RSP_Q_OUT_PTR</span>	<span class="o">=</span> <span class="mh">0x24</span><span class="p">,</span>		<span class="cm">/* also contains BASE_LO */</span>
	<span class="n">EDMA_RSP_Q_PTR_SHIFT</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">EDMA_CMD</span>		<span class="o">=</span> <span class="mh">0x28</span><span class="p">,</span>		<span class="cm">/* EDMA command register */</span>
	<span class="n">EDMA_EN</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* enable EDMA */</span>
	<span class="n">EDMA_DS</span>			<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* disable EDMA; self-negated */</span>
	<span class="n">EDMA_RESET</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* reset eng/trans/link/phy */</span>

	<span class="n">EDMA_STATUS</span>		<span class="o">=</span> <span class="mh">0x30</span><span class="p">,</span>		<span class="cm">/* EDMA engine status */</span>
	<span class="n">EDMA_STATUS_CACHE_EMPTY</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>	<span class="cm">/* GenIIe command cache empty */</span>
	<span class="n">EDMA_STATUS_IDLE</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>	<span class="cm">/* GenIIe EDMA enabled/idle */</span>

	<span class="n">EDMA_IORDY_TMOUT</span>	<span class="o">=</span> <span class="mh">0x34</span><span class="p">,</span>
	<span class="n">EDMA_ARB_CFG</span>		<span class="o">=</span> <span class="mh">0x38</span><span class="p">,</span>

	<span class="n">EDMA_HALTCOND</span>		<span class="o">=</span> <span class="mh">0x60</span><span class="p">,</span>		<span class="cm">/* GenIIe halt conditions */</span>
	<span class="n">EDMA_UNKNOWN_RSVD</span>	<span class="o">=</span> <span class="mh">0x6C</span><span class="p">,</span>		<span class="cm">/* GenIIe unknown/reserved */</span>

	<span class="n">BMDMA_CMD</span>		<span class="o">=</span> <span class="mh">0x224</span><span class="p">,</span>	<span class="cm">/* bmdma command register */</span>
	<span class="n">BMDMA_STATUS</span>		<span class="o">=</span> <span class="mh">0x228</span><span class="p">,</span>	<span class="cm">/* bmdma status register */</span>
	<span class="n">BMDMA_PRD_LOW</span>		<span class="o">=</span> <span class="mh">0x22c</span><span class="p">,</span>	<span class="cm">/* bmdma PRD addr 31:0 */</span>
	<span class="n">BMDMA_PRD_HIGH</span>		<span class="o">=</span> <span class="mh">0x230</span><span class="p">,</span>	<span class="cm">/* bmdma PRD addr 63:32 */</span>

	<span class="cm">/* Host private flags (hp_flags) */</span>
	<span class="n">MV_HP_FLAG_MSI</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">MV_HP_ERRATA_50XXB0</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">MV_HP_ERRATA_50XXB2</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
	<span class="n">MV_HP_ERRATA_60X1B2</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
	<span class="n">MV_HP_ERRATA_60X1C0</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>
	<span class="n">MV_HP_GEN_I</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>	<span class="cm">/* Generation I: 50xx */</span>
	<span class="n">MV_HP_GEN_II</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>	<span class="cm">/* Generation II: 60xx */</span>
	<span class="n">MV_HP_GEN_IIE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>	<span class="cm">/* Generation IIE: 6042/7042 */</span>
	<span class="n">MV_HP_PCIE</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>	<span class="cm">/* PCIe bus/regs: 7042 */</span>
	<span class="n">MV_HP_CUT_THROUGH</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>	<span class="cm">/* can use EDMA cut-through */</span>
	<span class="n">MV_HP_FLAG_SOC</span>		<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>	<span class="cm">/* SystemOnChip, no PCI */</span>
	<span class="n">MV_HP_QUIRK_LED_BLINK_EN</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>	<span class="cm">/* is led blinking enabled? */</span>

	<span class="cm">/* Port private flags (pp_flags) */</span>
	<span class="n">MV_PP_FLAG_EDMA_EN</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>	<span class="cm">/* is EDMA engine enabled? */</span>
	<span class="n">MV_PP_FLAG_NCQ_EN</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>	<span class="cm">/* is EDMA set up for NCQ? */</span>
	<span class="n">MV_PP_FLAG_FBS_EN</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>	<span class="cm">/* is EDMA set up for FBS? */</span>
	<span class="n">MV_PP_FLAG_DELAYED_EH</span>	<span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>	<span class="cm">/* delayed dev err handling */</span>
	<span class="n">MV_PP_FLAG_FAKE_ATA_BUSY</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* ignore initial ATA_DRDY */</span>
<span class="p">};</span>

<span class="cp">#define IS_GEN_I(hpriv) ((hpriv)-&gt;hp_flags &amp; MV_HP_GEN_I)</span>
<span class="cp">#define IS_GEN_II(hpriv) ((hpriv)-&gt;hp_flags &amp; MV_HP_GEN_II)</span>
<span class="cp">#define IS_GEN_IIE(hpriv) ((hpriv)-&gt;hp_flags &amp; MV_HP_GEN_IIE)</span>
<span class="cp">#define IS_PCIE(hpriv) ((hpriv)-&gt;hp_flags &amp; MV_HP_PCIE)</span>
<span class="cp">#define IS_SOC(hpriv) ((hpriv)-&gt;hp_flags &amp; MV_HP_FLAG_SOC)</span>

<span class="cp">#define WINDOW_CTRL(i)		(0x20030 + ((i) &lt;&lt; 4))</span>
<span class="cp">#define WINDOW_BASE(i)		(0x20034 + ((i) &lt;&lt; 4))</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* DMA boundary 0xffff is required by the s/g splitting</span>
<span class="cm">	 * we need on /length/ in mv_fill-sg().</span>
<span class="cm">	 */</span>
	<span class="n">MV_DMA_BOUNDARY</span>		<span class="o">=</span> <span class="mh">0xffffU</span><span class="p">,</span>

	<span class="cm">/* mask of register bits containing lower 32 bits</span>
<span class="cm">	 * of EDMA request queue DMA address</span>
<span class="cm">	 */</span>
	<span class="n">EDMA_REQ_Q_BASE_LO_MASK</span>	<span class="o">=</span> <span class="mh">0xfffffc00U</span><span class="p">,</span>

	<span class="cm">/* ditto, for response queue */</span>
	<span class="n">EDMA_RSP_Q_BASE_LO_MASK</span>	<span class="o">=</span> <span class="mh">0xffffff00U</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">chip_type</span> <span class="p">{</span>
	<span class="n">chip_504x</span><span class="p">,</span>
	<span class="n">chip_508x</span><span class="p">,</span>
	<span class="n">chip_5080</span><span class="p">,</span>
	<span class="n">chip_604x</span><span class="p">,</span>
	<span class="n">chip_608x</span><span class="p">,</span>
	<span class="n">chip_6042</span><span class="p">,</span>
	<span class="n">chip_7042</span><span class="p">,</span>
	<span class="n">chip_soc</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Command ReQuest Block: 32B */</span>
<span class="k">struct</span> <span class="n">mv_crqb</span> <span class="p">{</span>
	<span class="n">__le32</span>			<span class="n">sg_addr</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">sg_addr_hi</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">ctrl_flags</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">ata_cmd</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mv_crqb_iie</span> <span class="p">{</span>
	<span class="n">__le32</span>			<span class="n">addr</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">len</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">ata_cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Command ResPonse Block: 8B */</span>
<span class="k">struct</span> <span class="n">mv_crpb</span> <span class="p">{</span>
	<span class="n">__le16</span>			<span class="n">id</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">tmstmp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* EDMA Physical Region Descriptor (ePRD); A.K.A. SG */</span>
<span class="k">struct</span> <span class="n">mv_sg</span> <span class="p">{</span>
	<span class="n">__le32</span>			<span class="n">addr</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">flags_size</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">addr_hi</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We keep a local cache of a few frequently accessed port</span>
<span class="cm"> * registers here, to avoid having to read them (very slow)</span>
<span class="cm"> * when switching between EDMA and non-EDMA modes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mv_cached_regs</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">fiscfg</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">ltmode</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">haltcond</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">unknown_rsvd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_crqb</span>		<span class="o">*</span><span class="n">crqb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">crqb_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_crpb</span>		<span class="o">*</span><span class="n">crpb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">crpb_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_sg</span>		<span class="o">*</span><span class="n">sg_tbl</span><span class="p">[</span><span class="n">MV_MAX_Q_DEPTH</span><span class="p">];</span>
	<span class="n">dma_addr_t</span>		<span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">MV_MAX_Q_DEPTH</span><span class="p">];</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">req_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">resp_idx</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">pp_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_cached_regs</span>	<span class="n">cached</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">delayed_eh_pmp_map</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mv_port_signal</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">amps</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">pre</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="p">{</span>
	<span class="n">u32</span>			<span class="n">hp_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> 		<span class="n">board_idx</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">main_irq_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_signal</span>	<span class="n">signal</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mv_hw_ops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">n_ports</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">main_irq_cause_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">main_irq_mask_addr</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">irq_cause_offset</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">irq_mask_offset</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">unmask_all_irqs</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_HAVE_CLK)</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>              <span class="o">**</span><span class="n">port_clks</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * These consistent DMA memory pools give us guaranteed</span>
<span class="cm">	 * alignment for hardware-accessed data structures,</span>
<span class="cm">	 * and less memory waste in accomplishing the alignment.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">crqb_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">crpb_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pool</span>		<span class="o">*</span><span class="n">sg_tbl_pool</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mv_hw_ops</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">phy_errata</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enable_leds</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">read_preamp</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_hc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_hc</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_flash</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reset_bus</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_scr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_scr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv5_scr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv5_scr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_port_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_qc_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_qc_prep_iie</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mv_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_eh_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_eh_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv6_dev_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mv5_phy_errata</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv5_enable_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv5_read_preamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv5_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_hc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv5_reset_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv5_reset_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mv6_phy_errata</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv6_enable_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv6_read_preamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv6_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_hc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv6_reset_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_soc_enable_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_soc_read_preamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_soc_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_hc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_soc_reset_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_soc_reset_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_soc_65n_phy_errata</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_reset_pci_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_reset_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_no</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_stop_edma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_stop_edma_engine</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_edma_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_ncq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_edma</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_pmp_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pmp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_pmp_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">mv_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_pmp_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_process_crpb_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_sff_irq_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_check_atapi_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_bmdma_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_bmdma_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mv_bmdma_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u8</span>   <span class="n">mv_bmdma_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">mv_sff_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>

<span class="cm">/* .sg_tablesize is (MV_MAX_SG_CT / 2) in the structures below</span>
<span class="cm"> * because we have to allow room for worst case splitting of</span>
<span class="cm"> * PRDs for 64K boundaries in mv_fill_sg().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">mv5_sht</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ATA_BASE_SHT</span><span class="p">(</span><span class="n">DRV_NAME</span><span class="p">),</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">MV_MAX_SG_CT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_boundary</span>		<span class="o">=</span> <span class="n">MV_DMA_BOUNDARY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">mv6_sht</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ATA_NCQ_SHT</span><span class="p">(</span><span class="n">DRV_NAME</span><span class="p">),</span>
	<span class="p">.</span><span class="n">can_queue</span>		<span class="o">=</span> <span class="n">MV_MAX_Q_DEPTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">MV_MAX_SG_CT</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_boundary</span>		<span class="o">=</span> <span class="n">MV_DMA_BOUNDARY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">mv5_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_sff_port_ops</span><span class="p">,</span>

	<span class="p">.</span><span class="n">lost_interrupt</span>		<span class="o">=</span> <span class="n">ATA_OP_NULL</span><span class="p">,</span>

	<span class="p">.</span><span class="n">qc_defer</span>		<span class="o">=</span> <span class="n">mv_qc_defer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_prep</span>		<span class="o">=</span> <span class="n">mv_qc_prep</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_issue</span>		<span class="o">=</span> <span class="n">mv_qc_issue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">freeze</span>			<span class="o">=</span> <span class="n">mv_eh_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span>			<span class="o">=</span> <span class="n">mv_eh_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hardreset</span>		<span class="o">=</span> <span class="n">mv_hardreset</span><span class="p">,</span>

	<span class="p">.</span><span class="n">scr_read</span>		<span class="o">=</span> <span class="n">mv5_scr_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scr_write</span>		<span class="o">=</span> <span class="n">mv5_scr_write</span><span class="p">,</span>

	<span class="p">.</span><span class="n">port_start</span>		<span class="o">=</span> <span class="n">mv_port_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">port_stop</span>		<span class="o">=</span> <span class="n">mv_port_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">mv6_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_bmdma_port_ops</span><span class="p">,</span>

	<span class="p">.</span><span class="n">lost_interrupt</span>		<span class="o">=</span> <span class="n">ATA_OP_NULL</span><span class="p">,</span>

	<span class="p">.</span><span class="n">qc_defer</span>		<span class="o">=</span> <span class="n">mv_qc_defer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_prep</span>		<span class="o">=</span> <span class="n">mv_qc_prep</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_issue</span>		<span class="o">=</span> <span class="n">mv_qc_issue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">dev_config</span>             <span class="o">=</span> <span class="n">mv6_dev_config</span><span class="p">,</span>

	<span class="p">.</span><span class="n">freeze</span>			<span class="o">=</span> <span class="n">mv_eh_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span>			<span class="o">=</span> <span class="n">mv_eh_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hardreset</span>		<span class="o">=</span> <span class="n">mv_hardreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">softreset</span>		<span class="o">=</span> <span class="n">mv_softreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pmp_hardreset</span>		<span class="o">=</span> <span class="n">mv_pmp_hardreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pmp_softreset</span>		<span class="o">=</span> <span class="n">mv_softreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_handler</span>		<span class="o">=</span> <span class="n">mv_pmp_error_handler</span><span class="p">,</span>

	<span class="p">.</span><span class="n">scr_read</span>		<span class="o">=</span> <span class="n">mv_scr_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scr_write</span>		<span class="o">=</span> <span class="n">mv_scr_write</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sff_check_status</span>	<span class="o">=</span> <span class="n">mv_sff_check_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_irq_clear</span>		<span class="o">=</span> <span class="n">mv_sff_irq_clear</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_atapi_dma</span>	<span class="o">=</span> <span class="n">mv_check_atapi_dma</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_setup</span>		<span class="o">=</span> <span class="n">mv_bmdma_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_start</span>		<span class="o">=</span> <span class="n">mv_bmdma_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_stop</span>		<span class="o">=</span> <span class="n">mv_bmdma_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_status</span>		<span class="o">=</span> <span class="n">mv_bmdma_status</span><span class="p">,</span>

	<span class="p">.</span><span class="n">port_start</span>		<span class="o">=</span> <span class="n">mv_port_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">port_stop</span>		<span class="o">=</span> <span class="n">mv_port_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">mv_iie_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv6_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_config</span>		<span class="o">=</span> <span class="n">ATA_OP_NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_prep</span>		<span class="o">=</span> <span class="n">mv_qc_prep_iie</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="n">mv_port_info</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>  <span class="cm">/* chip_504x */</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">MV_GEN_I_FLAGS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv5_ops</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>  <span class="cm">/* chip_508x */</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">MV_GEN_I_FLAGS</span> <span class="o">|</span> <span class="n">MV_FLAG_DUAL_HC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv5_ops</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>  <span class="cm">/* chip_5080 */</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">MV_GEN_I_FLAGS</span> <span class="o">|</span> <span class="n">MV_FLAG_DUAL_HC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv5_ops</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>  <span class="cm">/* chip_604x */</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">MV_GEN_II_FLAGS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv6_ops</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>  <span class="cm">/* chip_608x */</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">MV_GEN_II_FLAGS</span> <span class="o">|</span> <span class="n">MV_FLAG_DUAL_HC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv6_ops</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>  <span class="cm">/* chip_6042 */</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">MV_GEN_IIE_FLAGS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_iie_ops</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>  <span class="cm">/* chip_7042 */</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">MV_GEN_IIE_FLAGS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_iie_ops</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>  <span class="cm">/* chip_soc */</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">MV_GEN_IIE_FLAGS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_iie_ops</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">mv_pci_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x5040</span><span class="p">),</span> <span class="n">chip_504x</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x5041</span><span class="p">),</span> <span class="n">chip_504x</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x5080</span><span class="p">),</span> <span class="n">chip_5080</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x5081</span><span class="p">),</span> <span class="n">chip_508x</span> <span class="p">},</span>
	<span class="cm">/* RocketRAID 1720/174x have different identifiers */</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">TTI</span><span class="p">,</span> <span class="mh">0x1720</span><span class="p">),</span> <span class="n">chip_6042</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">TTI</span><span class="p">,</span> <span class="mh">0x1740</span><span class="p">),</span> <span class="n">chip_6042</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">TTI</span><span class="p">,</span> <span class="mh">0x1742</span><span class="p">),</span> <span class="n">chip_6042</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x6040</span><span class="p">),</span> <span class="n">chip_604x</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x6041</span><span class="p">),</span> <span class="n">chip_604x</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x6042</span><span class="p">),</span> <span class="n">chip_6042</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x6080</span><span class="p">),</span> <span class="n">chip_608x</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x6081</span><span class="p">),</span> <span class="n">chip_608x</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">ADAPTEC2</span><span class="p">,</span> <span class="mh">0x0241</span><span class="p">),</span> <span class="n">chip_604x</span> <span class="p">},</span>

	<span class="cm">/* Adaptec 1430SA */</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">ADAPTEC2</span><span class="p">,</span> <span class="mh">0x0243</span><span class="p">),</span> <span class="n">chip_7042</span> <span class="p">},</span>

	<span class="cm">/* Marvell 7042 support */</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">MARVELL</span><span class="p">,</span> <span class="mh">0x7042</span><span class="p">),</span> <span class="n">chip_7042</span> <span class="p">},</span>

	<span class="cm">/* Highpoint RocketRAID PCIe series */</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">TTI</span><span class="p">,</span> <span class="mh">0x2300</span><span class="p">),</span> <span class="n">chip_7042</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">TTI</span><span class="p">,</span> <span class="mh">0x2310</span><span class="p">),</span> <span class="n">chip_7042</span> <span class="p">},</span>

	<span class="p">{</span> <span class="p">}</span>			<span class="cm">/* terminate list */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mv_hw_ops</span> <span class="n">mv5xxx_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">phy_errata</span>		<span class="o">=</span> <span class="n">mv5_phy_errata</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_leds</span>		<span class="o">=</span> <span class="n">mv5_enable_leds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_preamp</span>		<span class="o">=</span> <span class="n">mv5_read_preamp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_hc</span>		<span class="o">=</span> <span class="n">mv5_reset_hc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_flash</span>		<span class="o">=</span> <span class="n">mv5_reset_flash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_bus</span>		<span class="o">=</span> <span class="n">mv5_reset_bus</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mv_hw_ops</span> <span class="n">mv6xxx_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">phy_errata</span>		<span class="o">=</span> <span class="n">mv6_phy_errata</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_leds</span>		<span class="o">=</span> <span class="n">mv6_enable_leds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_preamp</span>		<span class="o">=</span> <span class="n">mv6_read_preamp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_hc</span>		<span class="o">=</span> <span class="n">mv6_reset_hc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_flash</span>		<span class="o">=</span> <span class="n">mv6_reset_flash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_bus</span>		<span class="o">=</span> <span class="n">mv_reset_pci_bus</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mv_hw_ops</span> <span class="n">mv_soc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">phy_errata</span>		<span class="o">=</span> <span class="n">mv6_phy_errata</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_leds</span>		<span class="o">=</span> <span class="n">mv_soc_enable_leds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_preamp</span>		<span class="o">=</span> <span class="n">mv_soc_read_preamp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_hc</span>		<span class="o">=</span> <span class="n">mv_soc_reset_hc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_flash</span>		<span class="o">=</span> <span class="n">mv_soc_reset_flash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_bus</span>		<span class="o">=</span> <span class="n">mv_soc_reset_bus</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mv_hw_ops</span> <span class="n">mv_soc_65n_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">phy_errata</span>		<span class="o">=</span> <span class="n">mv_soc_65n_phy_errata</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_leds</span>		<span class="o">=</span> <span class="n">mv_soc_enable_leds</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_hc</span>		<span class="o">=</span> <span class="n">mv_soc_reset_hc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_flash</span>		<span class="o">=</span> <span class="n">mv_soc_reset_flash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_bus</span>		<span class="o">=</span> <span class="n">mv_soc_reset_bus</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">writelfl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">readl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>	<span class="cm">/* flush to avoid PCI posted write */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv_hc_from_port</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port</span> <span class="o">&gt;&gt;</span> <span class="n">MV_PORT_HC_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv_hardport_from_port</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">port</span> <span class="o">&amp;</span> <span class="n">MV_PORT_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Consolidate some rather tricky bit shift calculations.</span>
<span class="cm"> * This is hot-path stuff, so not a function.</span>
<span class="cm"> * Simple code, with two return values, so macro rather than inline.</span>
<span class="cm"> *</span>
<span class="cm"> * port is the sole input, in range 0..7.</span>
<span class="cm"> * shift is one output, for use with main_irq_cause / main_irq_mask registers.</span>
<span class="cm"> * hardport is the other output, in range 0..3.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that port and hardport may be the same variable in some cases.</span>
<span class="cm"> */</span>
<span class="cp">#define MV_PORT_TO_SHIFT_AND_HARDPORT(port, shift, hardport)	\</span>
<span class="cp">{								\</span>
<span class="cp">	shift    = mv_hc_from_port(port) * HC_SHIFT;		\</span>
<span class="cp">	hardport = mv_hardport_from_port(port);			\</span>
<span class="cp">	shift   += hardport * 2;				\</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">mv_hc_base</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">SATAHC0_REG_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="n">hc</span> <span class="o">*</span> <span class="n">MV_SATAHC_REG_SZ</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">mv_hc_base_from_port</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mv_hc_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">mv_hc_from_port</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">mv_port_base</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>  <span class="n">mv_hc_base_from_port</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">MV_SATAHC_ARBTR_REG_SZ</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">mv_hardport_from_port</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">*</span> <span class="n">MV_PORT_REG_SZ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">mv5_phy_base</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base_from_port</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span> <span class="o">=</span> <span class="p">(</span><span class="n">mv_hardport_from_port</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x100UL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">mv_host_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">mv_ap_base</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mv_host_base</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mv_get_hc_count</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">port_flags</span> <span class="o">&amp;</span> <span class="n">MV_FLAG_DUAL_HC</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_save_cached_regs - (re-)initialize cached port registers</span>
<span class="cm"> *      @ap: the port whose registers we are caching</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialize the local cache of port registers,</span>
<span class="cm"> *	so that reading them over and over again can</span>
<span class="cm"> *	be avoided on the hotter paths of this driver.</span>
<span class="cm"> *	This saves a few microseconds each time we switch</span>
<span class="cm"> *	to/from EDMA mode to perform (eg.) a drive cache flush.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_save_cached_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">.</span><span class="n">fiscfg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">FISCFG</span><span class="p">);</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">.</span><span class="n">ltmode</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">LTMODE</span><span class="p">);</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">.</span><span class="n">haltcond</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_HALTCOND</span><span class="p">);</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">.</span><span class="n">unknown_rsvd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_UNKNOWN_RSVD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_write_cached_reg - write to a cached port register</span>
<span class="cm"> *      @addr: hardware address of the register</span>
<span class="cm"> *      @old: pointer to cached value of the register</span>
<span class="cm"> *      @new: new value for the register</span>
<span class="cm"> *</span>
<span class="cm"> *	Write a new value to a cached register,</span>
<span class="cm"> *	but only if the value is different from before.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mv_write_cached_reg</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="n">u32</span> <span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">!=</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">laddr</span><span class="p">;</span>
		<span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Workaround for 88SX60x1-B2 FEr SATA#13:</span>
<span class="cm">		 * Read-after-write is needed to prevent generating 64-bit</span>
<span class="cm">		 * write cycles on the PCI bus for SATA interface registers</span>
<span class="cm">		 * at offsets ending in 0x4 or 0xc.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Looks like a lot of fuss, but it avoids an unnecessary</span>
<span class="cm">		 * +1 usec read-after-write delay for unaffected registers.</span>
<span class="cm">		 */</span>
		<span class="n">laddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">laddr</span> <span class="o">&gt;=</span> <span class="mh">0x300</span> <span class="o">&amp;&amp;</span> <span class="n">laddr</span> <span class="o">&lt;=</span> <span class="mh">0x33c</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">laddr</span> <span class="o">&amp;=</span> <span class="mh">0x000f</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">laddr</span> <span class="o">==</span> <span class="mh">0x4</span> <span class="o">||</span> <span class="n">laddr</span> <span class="o">==</span> <span class="mh">0xc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">writelfl</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span> <span class="cm">/* read after write */</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span> <span class="cm">/* unaffected by the errata */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_set_edma_ptrs</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize request queue</span>
<span class="cm">	 */</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">req_idx</span> <span class="o">&amp;=</span> <span class="n">MV_MAX_Q_DEPTH_MASK</span><span class="p">;</span>	<span class="cm">/* paranoia */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">req_idx</span> <span class="o">&lt;&lt;</span> <span class="n">EDMA_REQ_Q_PTR_SHIFT</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb_dma</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_REQ_Q_BASE_HI</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb_dma</span> <span class="o">&amp;</span> <span class="n">EDMA_REQ_Q_BASE_LO_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">index</span><span class="p">,</span>
		 <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_REQ_Q_IN_PTR</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_REQ_Q_OUT_PTR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * initialize response queue</span>
<span class="cm">	 */</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">resp_idx</span> <span class="o">&amp;=</span> <span class="n">MV_MAX_Q_DEPTH_MASK</span><span class="p">;</span>	<span class="cm">/* paranoia */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">resp_idx</span> <span class="o">&lt;&lt;</span> <span class="n">EDMA_RSP_Q_PTR_SHIFT</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb_dma</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_RSP_Q_BASE_HI</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_RSP_Q_IN_PTR</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb_dma</span> <span class="o">&amp;</span> <span class="n">EDMA_RSP_Q_BASE_LO_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">index</span><span class="p">,</span>
		 <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_RSP_Q_OUT_PTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_write_main_irq_mask</span><span class="p">(</span><span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * When writing to the main_irq_mask in hardware,</span>
<span class="cm">	 * we must ensure exclusivity between the interrupt coalescing bits</span>
<span class="cm">	 * and the corresponding individual port DONE_IRQ bits.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that this register is really an &quot;IRQ enable&quot; register,</span>
<span class="cm">	 * not an &quot;IRQ mask&quot; register as Marvell&#39;s naming might suggest.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ALL_PORTS_COAL_DONE</span> <span class="o">|</span> <span class="n">PORTS_0_3_COAL_DONE</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DONE_IRQ_0_3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ALL_PORTS_COAL_DONE</span> <span class="o">|</span> <span class="n">PORTS_4_7_COAL_DONE</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DONE_IRQ_4_7</span><span class="p">;</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_set_main_irq_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">disable_bits</span><span class="p">,</span> <span class="n">u32</span> <span class="n">enable_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">old_mask</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">;</span>

	<span class="n">old_mask</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask</span><span class="p">;</span>
	<span class="n">new_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">disable_bits</span><span class="p">)</span> <span class="o">|</span> <span class="n">enable_bits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mask</span> <span class="o">!=</span> <span class="n">old_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask</span> <span class="o">=</span> <span class="n">new_mask</span><span class="p">;</span>
		<span class="n">mv_write_main_irq_mask</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">hpriv</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_enable_port_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">,</span> <span class="n">hardport</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">disable_bits</span><span class="p">,</span> <span class="n">enable_bits</span><span class="p">;</span>

	<span class="n">MV_PORT_TO_SHIFT_AND_HARDPORT</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">hardport</span><span class="p">);</span>

	<span class="n">disable_bits</span> <span class="o">=</span> <span class="p">(</span><span class="n">DONE_IRQ</span> <span class="o">|</span> <span class="n">ERR_IRQ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">enable_bits</span>  <span class="o">=</span> <span class="n">port_bits</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">mv_set_main_irq_mask</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">disable_bits</span><span class="p">,</span> <span class="n">enable_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_clear_and_enable_port_irqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_irqs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hardport</span> <span class="o">=</span> <span class="n">mv_hardport_from_port</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base_from_port</span><span class="p">(</span>
				<span class="n">mv_host_base</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">hc_irq_cause</span><span class="p">;</span>

	<span class="cm">/* clear EDMA event indicators, if any */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_ERR_IRQ_CAUSE</span><span class="p">);</span>

	<span class="cm">/* clear pending irq events */</span>
	<span class="n">hc_irq_cause</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">DEV_IRQ</span> <span class="o">|</span> <span class="n">DMA_IRQ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">hardport</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">hc_irq_cause</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_CAUSE</span><span class="p">);</span>

	<span class="cm">/* clear FIS IRQ Cause */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_IIE</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">FIS_IRQ_CAUSE</span><span class="p">);</span>

	<span class="n">mv_enable_port_irqs</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">port_irqs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_set_irq_coalescing</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">usecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">hc_mmio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">coal_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clks</span><span class="p">,</span> <span class="n">is_dual_hc</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">n_ports</span> <span class="o">&gt;</span> <span class="n">MV_PORTS_PER_HC</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">coal_disable</span> <span class="o">=</span> <span class="n">PORTS_0_3_COAL_DONE</span> <span class="o">|</span> <span class="n">PORTS_4_7_COAL_DONE</span> <span class="o">|</span>
							<span class="n">ALL_PORTS_COAL_DONE</span><span class="p">;</span>

	<span class="cm">/* Disable IRQ coalescing if either threshold is zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usecs</span> <span class="o">||</span> <span class="o">!</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clks</span> <span class="o">=</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Respect maximum limits of the hardware */</span>
		<span class="n">clks</span> <span class="o">=</span> <span class="n">usecs</span> <span class="o">*</span> <span class="n">COAL_CLOCKS_PER_USEC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clks</span> <span class="o">&gt;</span> <span class="n">MAX_COAL_TIME_THRESHOLD</span><span class="p">)</span>
			<span class="n">clks</span> <span class="o">=</span> <span class="n">MAX_COAL_TIME_THRESHOLD</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_COAL_IO_COUNT</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">MAX_COAL_IO_COUNT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mv_set_main_irq_mask</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">coal_disable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_dual_hc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * GEN_II/GEN_IIE with dual host controllers:</span>
<span class="cm">		 * one set of global thresholds for the entire chip.</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">clks</span><span class="p">,</span>  <span class="n">mmio</span> <span class="o">+</span> <span class="n">IRQ_COAL_TIME_THRESHOLD</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">IRQ_COAL_IO_THRESHOLD</span><span class="p">);</span>
		<span class="cm">/* clear leftover coal IRQ bit */</span>
		<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="n">ALL_PORTS_COAL_IRQ</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">IRQ_COAL_CAUSE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
			<span class="n">coal_enable</span> <span class="o">=</span> <span class="n">ALL_PORTS_COAL_DONE</span><span class="p">;</span>
		<span class="n">clks</span> <span class="o">=</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* force clearing of regular regs below */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All chips: independent thresholds for each HC on the chip.</span>
<span class="cm">	 */</span>
	<span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base_from_port</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">clks</span><span class="p">,</span>  <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_COAL_TIME_THRESHOLD</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_COAL_IO_THRESHOLD</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="n">HC_COAL_IRQ</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_CAUSE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="n">coal_enable</span> <span class="o">|=</span> <span class="n">PORTS_0_3_COAL_DONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_dual_hc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base_from_port</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">MV_PORTS_PER_HC</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">clks</span><span class="p">,</span>  <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_COAL_TIME_THRESHOLD</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_COAL_IO_THRESHOLD</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="n">HC_COAL_IRQ</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_CAUSE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
			<span class="n">coal_enable</span> <span class="o">|=</span> <span class="n">PORTS_4_7_COAL_DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mv_set_main_irq_mask</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">coal_enable</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_start_edma - Enable eDMA engine</span>
<span class="cm"> *      @base: port base address</span>
<span class="cm"> *      @pp: port private data</span>
<span class="cm"> *</span>
<span class="cm"> *      Verify the local cache of the eDMA state is accurate with a</span>
<span class="cm"> *      WARN_ON.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_start_edma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">want_ncq</span> <span class="o">=</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_NCQ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">using_ncq</span> <span class="o">=</span> <span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_NCQ_EN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want_ncq</span> <span class="o">!=</span> <span class="n">using_ncq</span><span class="p">)</span>
			<span class="n">mv_stop_edma</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

		<span class="n">mv_edma_cfg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">want_ncq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">mv_set_edma_ptrs</span><span class="p">(</span><span class="n">port_mmio</span><span class="p">,</span> <span class="n">hpriv</span><span class="p">,</span> <span class="n">pp</span><span class="p">);</span>
		<span class="n">mv_clear_and_enable_port_irqs</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">port_mmio</span><span class="p">,</span> <span class="n">DONE_IRQ</span><span class="o">|</span><span class="n">ERR_IRQ</span><span class="p">);</span>

		<span class="n">writelfl</span><span class="p">(</span><span class="n">EDMA_EN</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CMD</span><span class="p">);</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">|=</span> <span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_wait_for_edma_empty_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">empty_idle</span> <span class="o">=</span> <span class="p">(</span><span class="n">EDMA_STATUS_CACHE_EMPTY</span> <span class="o">|</span> <span class="n">EDMA_STATUS_IDLE</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">per_loop</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">per_loop</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for the EDMA engine to finish transactions in progress.</span>
<span class="cm">	 * No idea what a good &quot;timeout&quot; value might be, but measurements</span>
<span class="cm">	 * indicate that it often requires hundreds of microseconds</span>
<span class="cm">	 * with two drives in-use.  So we use the 15msec value above</span>
<span class="cm">	 * as a rough guess at what even more drives might require.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">edma_stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">edma_stat</span> <span class="o">&amp;</span> <span class="n">empty_idle</span><span class="p">)</span> <span class="o">==</span> <span class="n">empty_idle</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">per_loop</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* ata_port_info(ap, &quot;%s: %u+ usecs\n&quot;, __func__, i); */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_stop_edma_engine - Disable eDMA engine</span>
<span class="cm"> *      @port_mmio: io base address</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_stop_edma_engine</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Disable eDMA.  The disable bit auto clears. */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">EDMA_DS</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CMD</span><span class="p">);</span>

	<span class="cm">/* Wait for the chip to confirm eDMA is off. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CMD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">EDMA_EN</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_stop_edma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">;</span>
	<span class="n">mv_wait_for_edma_empty_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mv_stop_edma_engine</span><span class="p">(</span><span class="n">port_mmio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_port_err</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;Unable to stop eDMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mv_edma_cfg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef ATA_DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_dump_mem</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%p: &quot;</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">bytes</span> <span class="o">&amp;&amp;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%08x &quot;</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">b</span><span class="p">));</span>
			<span class="n">b</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_dump_pci_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef ATA_DEBUG</span>
	<span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dw</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;%02x: &quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">bytes</span> <span class="o">&amp;&amp;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dw</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%08x &quot;</span><span class="p">,</span> <span class="n">dw</span><span class="p">);</span>
			<span class="n">b</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_dump_all_regs</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio_base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef ATA_DEBUG</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_base</span> <span class="o">=</span> <span class="n">mv_hc_base</span><span class="p">(</span><span class="n">mmio_base</span><span class="p">,</span>
					   <span class="n">port</span> <span class="o">&gt;&gt;</span> <span class="n">MV_PORT_HC_SHIFT</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_port</span><span class="p">,</span> <span class="n">num_ports</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">start_hc</span><span class="p">,</span> <span class="n">num_hcs</span><span class="p">,</span> <span class="n">hc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_hc</span> <span class="o">=</span> <span class="n">start_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">num_ports</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>		<span class="cm">/* shld be benign for 4 port devs */</span>
		<span class="n">num_hcs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">start_hc</span> <span class="o">=</span> <span class="n">port</span> <span class="o">&gt;&gt;</span> <span class="n">MV_PORT_HC_SHIFT</span><span class="p">;</span>
		<span class="n">start_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
		<span class="n">num_ports</span> <span class="o">=</span> <span class="n">num_hcs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;All registers for port(s) %u-%u:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start_port</span><span class="p">,</span>
		<span class="n">num_ports</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">num_ports</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">start_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;PCI config space regs:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mv_dump_pci_cfg</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x68</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;PCI regs:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mv_dump_mem</span><span class="p">(</span><span class="n">mmio_base</span><span class="o">+</span><span class="mh">0xc00</span><span class="p">,</span> <span class="mh">0x3c</span><span class="p">);</span>
	<span class="n">mv_dump_mem</span><span class="p">(</span><span class="n">mmio_base</span><span class="o">+</span><span class="mh">0xd00</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">);</span>
	<span class="n">mv_dump_mem</span><span class="p">(</span><span class="n">mmio_base</span><span class="o">+</span><span class="mh">0xf00</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">);</span>
	<span class="n">mv_dump_mem</span><span class="p">(</span><span class="n">mmio_base</span><span class="o">+</span><span class="mh">0x1d00</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">hc</span> <span class="o">=</span> <span class="n">start_hc</span><span class="p">;</span> <span class="n">hc</span> <span class="o">&lt;</span> <span class="n">start_hc</span> <span class="o">+</span> <span class="n">num_hcs</span><span class="p">;</span> <span class="n">hc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hc_base</span> <span class="o">=</span> <span class="n">mv_hc_base</span><span class="p">(</span><span class="n">mmio_base</span><span class="p">,</span> <span class="n">hc</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;HC regs (HC %i):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hc</span><span class="p">);</span>
		<span class="n">mv_dump_mem</span><span class="p">(</span><span class="n">hc_base</span><span class="p">,</span> <span class="mh">0x1c</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">start_port</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">start_port</span> <span class="o">+</span> <span class="n">num_ports</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port_base</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio_base</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EDMA regs (port %i):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">mv_dump_mem</span><span class="p">(</span><span class="n">port_base</span><span class="p">,</span> <span class="mh">0x54</span><span class="p">);</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;SATA regs (port %i):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">mv_dump_mem</span><span class="p">(</span><span class="n">port_base</span><span class="o">+</span><span class="mh">0x300</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv_scr_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sc_reg_in</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCR_STATUS</span>:
	<span class="k">case</span> <span class="n">SCR_CONTROL</span>:
	<span class="k">case</span> <span class="n">SCR_ERROR</span>:
		<span class="n">ofs</span> <span class="o">=</span> <span class="n">SATA_STATUS</span> <span class="o">+</span> <span class="p">(</span><span class="n">sc_reg_in</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCR_ACTIVE</span>:
		<span class="n">ofs</span> <span class="o">=</span> <span class="n">SATA_ACTIVE</span><span class="p">;</span>   <span class="cm">/* active is not with the others */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="mh">0xffffffffU</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ofs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_scr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">mv_scr_offset</span><span class="p">(</span><span class="n">sc_reg_in</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">!=</span> <span class="mh">0xffffffffU</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mv_ap_base</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">)</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_scr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">mv_scr_offset</span><span class="p">(</span><span class="n">sc_reg_in</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">!=</span> <span class="mh">0xffffffffU</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">)</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc_reg_in</span> <span class="o">==</span> <span class="n">SCR_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Workaround for 88SX60x1 FEr SATA#26:</span>
<span class="cm">			 *</span>
<span class="cm">			 * COMRESETs have to take care not to accidentally</span>
<span class="cm">			 * put the drive to sleep when writing SCR_CONTROL.</span>
<span class="cm">			 * Setting bits 12..15 prevents this problem.</span>
<span class="cm">			 *</span>
<span class="cm">			 * So if we see an outbound COMMRESET, set those bits.</span>
<span class="cm">			 * Ditto for the followup write that clears the reset.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The proprietary driver does this for</span>
<span class="cm">			 * all chip versions, and so do we.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">val</span> <span class="o">|=</span> <span class="mh">0xf000</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv6_dev_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Deal with Gen-II (&quot;mv6&quot;) hardware quirks/restrictions:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Gen-II does not support NCQ over a port multiplier</span>
<span class="cm">	 *  (no FIS-based switching).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_NCQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DFLAG_NCQ</span><span class="p">;</span>
			<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">adev</span><span class="p">,</span>
				<span class="s">&quot;NCQ disabled for command-based switching</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_qc_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t allow new commands if we&#39;re in a delayed EH state</span>
<span class="cm">	 * for NCQ and/or FIS-based switching.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_DELAYED_EH</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ATA_DEFER_PORT</span><span class="p">;</span>

	<span class="cm">/* PIO commands need exclusive link: no other commands [DMA or PIO]</span>
<span class="cm">	 * can run concurrently.</span>
<span class="cm">	 * set excl_link when we want to send a PIO command in DMA mode</span>
<span class="cm">	 * or a non-NCQ command in NCQ mode.</span>
<span class="cm">	 * When we receive a command from that link, and there are no</span>
<span class="cm">	 * outstanding commands, mark a flag to clear excl_link and let</span>
<span class="cm">	 * the command go through.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">excl_link</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">excl_link</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ATA_DEFER_PORT</span><span class="p">;</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_QCFLAG_CLEAR_EXCL</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">ATA_DEFER_PORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the port is completely idle, then allow the new qc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The port is operating in host queuing mode (EDMA) with NCQ</span>
<span class="cm">	 * enabled, allow multiple NCQ commands.  EDMA also allows</span>
<span class="cm">	 * queueing multiple DMA commands but libata core currently</span>
<span class="cm">	 * doesn&#39;t allow it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_NCQ_EN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_ncq</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">excl_link</span> <span class="o">=</span> <span class="n">link</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ATA_DEFER_PORT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ATA_DEFER_PORT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_config_fbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_ncq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_fbs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">fiscfg</span><span class="p">,</span>   <span class="o">*</span><span class="n">old_fiscfg</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">.</span><span class="n">fiscfg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ltmode</span><span class="p">,</span>   <span class="o">*</span><span class="n">old_ltmode</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">.</span><span class="n">ltmode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">haltcond</span><span class="p">,</span> <span class="o">*</span><span class="n">old_haltcond</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">.</span><span class="n">haltcond</span><span class="p">;</span>

	<span class="n">ltmode</span>   <span class="o">=</span> <span class="o">*</span><span class="n">old_ltmode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">LTMODE_BIT8</span><span class="p">;</span>
	<span class="n">haltcond</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_haltcond</span> <span class="o">|</span> <span class="n">EDMA_ERR_DEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">want_fbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fiscfg</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_fiscfg</span> <span class="o">|</span> <span class="n">FISCFG_SINGLE_SYNC</span><span class="p">;</span>
		<span class="n">ltmode</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_ltmode</span> <span class="o">|</span> <span class="n">LTMODE_BIT8</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want_ncq</span><span class="p">)</span>
			<span class="n">haltcond</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EDMA_ERR_DEV</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fiscfg</span> <span class="o">|=</span>  <span class="n">FISCFG_WAIT_DEV_ERR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fiscfg</span> <span class="o">=</span> <span class="o">*</span><span class="n">old_fiscfg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FISCFG_SINGLE_SYNC</span> <span class="o">|</span> <span class="n">FISCFG_WAIT_DEV_ERR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">mv_write_cached_reg</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">FISCFG</span><span class="p">,</span> <span class="n">old_fiscfg</span><span class="p">,</span> <span class="n">fiscfg</span><span class="p">);</span>
	<span class="n">mv_write_cached_reg</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">LTMODE</span><span class="p">,</span> <span class="n">old_ltmode</span><span class="p">,</span> <span class="n">ltmode</span><span class="p">);</span>
	<span class="n">mv_write_cached_reg</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_HALTCOND</span><span class="p">,</span> <span class="n">old_haltcond</span><span class="p">,</span> <span class="n">haltcond</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_60x1_errata_sata25</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_ncq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">;</span>

	<span class="cm">/* workaround for 88SX60x1 FEr SATA#25 (part 1) */</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">GPIO_PORT_CTL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">want_ncq</span><span class="p">)</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">old</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">!=</span> <span class="n">old</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">GPIO_PORT_CTL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_bmdma_enable - set a magic bit on GEN_IIE to allow bmdma</span>
<span class="cm"> *	@ap: Port being initialized</span>
<span class="cm"> *</span>
<span class="cm"> *	There are two DMA modes on these chips:  basic DMA, and EDMA.</span>
<span class="cm"> *</span>
<span class="cm"> *	Bit-0 of the &quot;EDMA RESERVED&quot; register enables/disables use</span>
<span class="cm"> *	of basic DMA on the GEN_IIE versions of the chips.</span>
<span class="cm"> *</span>
<span class="cm"> *	This bit survives EDMA resets, and must be set for basic DMA</span>
<span class="cm"> *	to function, and should be cleared when EDMA is active.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_bmdma_enable_iie</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable_bmdma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new</span><span class="p">,</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">.</span><span class="n">unknown_rsvd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_bmdma</span><span class="p">)</span>
		<span class="n">new</span> <span class="o">=</span> <span class="o">*</span><span class="n">old</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">new</span> <span class="o">=</span> <span class="o">*</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mv_write_cached_reg</span><span class="p">(</span><span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">+</span> <span class="n">EDMA_UNKNOWN_RSVD</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * SOC chips have an issue whereby the HDD LEDs don&#39;t always blink</span>
<span class="cm"> * during I/O when NCQ is enabled. Enabling a special &quot;LED blink&quot; mode</span>
<span class="cm"> * of the SOC takes care of it, generating a steady blink rate when</span>
<span class="cm"> * any drive on the chip is active.</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately, the blink mode is a global hardware setting for the SOC,</span>
<span class="cm"> * so we must use it whenever at least one port on the SOC has NCQ enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * We turn &quot;LED blink&quot; off when NCQ is not in use anywhere, because the normal</span>
<span class="cm"> * LED operation works then, and provides better (more accurate) feedback.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this code assumes that an SOC never has more than one HC onboard.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_led_blink_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_mmio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">led_ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="n">MV_HP_QUIRK_LED_BLINK_EN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_QUIRK_LED_BLINK_EN</span><span class="p">;</span>
	<span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base_from_port</span><span class="p">(</span><span class="n">mv_host_base</span><span class="p">(</span><span class="n">host</span><span class="p">),</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>
	<span class="n">led_ctrl</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">SOC_LED_CTRL</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">led_ctrl</span> <span class="o">|</span> <span class="n">SOC_LED_CTRL_BLINK</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">SOC_LED_CTRL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_led_blink_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_mmio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">led_ctrl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="n">MV_HP_QUIRK_LED_BLINK_EN</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* disable led-blink only if no ports are using NCQ */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">this_ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">this_ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_NCQ_EN</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_HP_QUIRK_LED_BLINK_EN</span><span class="p">;</span>
	<span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base_from_port</span><span class="p">(</span><span class="n">mv_host_base</span><span class="p">(</span><span class="n">host</span><span class="p">),</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>
	<span class="n">led_ctrl</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">SOC_LED_CTRL</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">led_ctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOC_LED_CTRL_BLINK</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">SOC_LED_CTRL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_edma_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_ncq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_edma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span>    <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span>    <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="cm">/* set up non-NCQ EDMA configuration */</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">EDMA_CFG_Q_DEPTH</span><span class="p">;</span>		<span class="cm">/* always 0x1f for *all* chips */</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span>
	  <span class="o">~</span><span class="p">(</span><span class="n">MV_PP_FLAG_FBS_EN</span> <span class="o">|</span> <span class="n">MV_PP_FLAG_NCQ_EN</span> <span class="o">|</span> <span class="n">MV_PP_FLAG_FAKE_ATA_BUSY</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>	<span class="cm">/* enab config burst size mask */</span>

	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_II</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">EDMA_CFG_RD_BRST_EXT</span> <span class="o">|</span> <span class="n">EDMA_CFG_WR_BUFF_LEN</span><span class="p">;</span>
		<span class="n">mv_60x1_errata_sata25</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">want_ncq</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_IIE</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">want_fbs</span> <span class="o">=</span> <span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Possible future enhancement:</span>
<span class="cm">		 *</span>
<span class="cm">		 * The chip can use FBS with non-NCQ, if we allow it,</span>
<span class="cm">		 * But first we need to have the error handling in place</span>
<span class="cm">		 * for this mode (datasheet section 7.3.15.4.2.3).</span>
<span class="cm">		 * So disallow non-NCQ FBS for now.</span>
<span class="cm">		 */</span>
		<span class="n">want_fbs</span> <span class="o">&amp;=</span> <span class="n">want_ncq</span><span class="p">;</span>

		<span class="n">mv_config_fbs</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">want_ncq</span><span class="p">,</span> <span class="n">want_fbs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">want_fbs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">|=</span> <span class="n">MV_PP_FLAG_FBS_EN</span><span class="p">;</span>
			<span class="n">cfg</span> <span class="o">|=</span> <span class="n">EDMA_CFG_EDMA_FBS</span><span class="p">;</span> <span class="cm">/* FIS-based switching */</span>
		<span class="p">}</span>

		<span class="n">cfg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">);</span>	<span class="cm">/* do not mask PM field in rx&#39;d FIS */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want_edma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cfg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span> <span class="cm">/* enab 4-entry host queue cache */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_SOC</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
				<span class="n">cfg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">);</span> <span class="cm">/* enab early completion */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="n">MV_HP_CUT_THROUGH</span><span class="p">)</span>
			<span class="n">cfg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">);</span> <span class="cm">/* enab cut-thru (dis stor&amp;forwrd) */</span>
		<span class="n">mv_bmdma_enable_iie</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">!</span><span class="n">want_edma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_SOC</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">want_ncq</span><span class="p">)</span>
				<span class="n">mv_soc_led_blink_enable</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">mv_soc_led_blink_disable</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">want_ncq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">EDMA_CFG_NCQ</span><span class="p">;</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">|=</span>  <span class="n">MV_PP_FLAG_NCQ_EN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">writelfl</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_port_free_dma_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">crqb_pool</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb_dma</span><span class="p">);</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">crpb_pool</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb_dma</span><span class="p">);</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * For GEN_I, there&#39;s no NCQ, so we have only a single sg_tbl.</span>
<span class="cm">	 * For later hardware, we have one unique sg_tbl per NCQ tag.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tag</span> <span class="o">&lt;</span> <span class="n">MV_MAX_Q_DEPTH</span><span class="p">;</span> <span class="o">++</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl</span><span class="p">[</span><span class="n">tag</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
				<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">sg_tbl_pool</span><span class="p">,</span>
					      <span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span>
					      <span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">tag</span><span class="p">]);</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_port_start - Port specific init/start routine.</span>
<span class="cm"> *      @ap: ATA channel to manipulate</span>
<span class="cm"> *</span>
<span class="cm"> *      Allocate and point to DMA memory, init port private memory,</span>
<span class="cm"> *      zero indices.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

	<span class="n">pp</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>

	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">crqb_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MV_CRQB_Q_SZ</span><span class="p">);</span>

	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">crpb_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb_dma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_port_free_dma_mem</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MV_CRPB_Q_SZ</span><span class="p">);</span>

	<span class="cm">/* 6041/6081 Rev. &quot;C0&quot; (and newer) are okay with async notify */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="n">MV_HP_ERRATA_60X1C0</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_FLAG_AN</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For GEN_I, there&#39;s no NCQ, so we only allocate a single sg_tbl.</span>
<span class="cm">	 * For later hardware, we need one unique sg_tbl per NCQ tag.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tag</span> <span class="o">&lt;</span> <span class="n">MV_MAX_Q_DEPTH</span><span class="p">;</span> <span class="o">++</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">sg_tbl_pool</span><span class="p">,</span>
					      <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">tag</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl</span><span class="p">[</span><span class="n">tag</span><span class="p">])</span>
				<span class="k">goto</span> <span class="n">out_port_free_dma_mem</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>     <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mv_save_cached_regs</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">mv_edma_cfg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_port_free_dma_mem:</span>
	<span class="n">mv_port_free_dma_mem</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_port_stop - Port specific cleanup/stop routine.</span>
<span class="cm"> *      @ap: ATA channel to manipulate</span>
<span class="cm"> *</span>
<span class="cm"> *      Stop DMA, cleanup port memory.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      This routine uses the host lock to protect the DMA stop.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_port_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mv_stop_edma</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">mv_enable_port_irqs</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mv_port_free_dma_mem</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_fill_sg - Fill out the Marvell ePRD (scatter gather) entries</span>
<span class="cm"> *      @qc: queued command whose SG list to source from</span>
<span class="cm"> *</span>
<span class="cm"> *      Populate the SG list and mark the last entry.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_fill_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_sg</span> <span class="o">*</span><span class="n">mv_sg</span><span class="p">,</span> <span class="o">*</span><span class="n">last_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">si</span><span class="p">;</span>

	<span class="n">mv_sg</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl</span><span class="p">[</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">];</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">sg_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sg_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sg_len</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mh">0x10000</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="mh">0x10000</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

			<span class="n">mv_sg</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
			<span class="n">mv_sg</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">mv_sg</span><span class="o">-&gt;</span><span class="n">flags_size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
			<span class="n">mv_sg</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">sg_len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">last_sg</span> <span class="o">=</span> <span class="n">mv_sg</span><span class="p">;</span>
			<span class="n">mv_sg</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">last_sg</span><span class="p">))</span>
		<span class="n">last_sg</span><span class="o">-&gt;</span><span class="n">flags_size</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">EPRD_FLAG_END_OF_TBL</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span> <span class="cm">/* ensure data structure is visible to the chipset */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="n">cmdw</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data</span><span class="p">,</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span> <span class="o">|</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="n">CRQB_CMD_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRQB_CMD_CS</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">last</span> <span class="o">?</span> <span class="n">CRQB_CMD_LAST</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cmdw</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_sff_irq_clear - Clear hardware interrupt after DMA.</span>
<span class="cm"> *	@ap: Port associated with this ATA transaction.</span>
<span class="cm"> *</span>
<span class="cm"> *	We need this only for ATAPI bmdma transactions,</span>
<span class="cm"> *	as otherwise we experience spurious interrupts</span>
<span class="cm"> *	after libata-sff handles the bmdma interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_sff_irq_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mv_clear_and_enable_port_irqs</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">),</span> <span class="n">ERR_IRQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_check_atapi_dma - Filter ATAPI cmds which are unsuitable for DMA.</span>
<span class="cm"> *	@qc: queued command to check for chipset/DMA compatibility.</span>
<span class="cm"> *</span>
<span class="cm"> *	The bmdma engines cannot handle speculative data sizes</span>
<span class="cm"> *	(bytecount under/over flow).  So only allow DMA for</span>
<span class="cm"> *	data transfer commands with known data sizes.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_check_atapi_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">READ_6</span>:
		<span class="k">case</span> <span class="n">READ_10</span>:
		<span class="k">case</span> <span class="n">READ_12</span>:
		<span class="k">case</span> <span class="n">WRITE_6</span>:
		<span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="k">case</span> <span class="n">WRITE_12</span>:
		<span class="k">case</span> <span class="n">GPCMD_READ_CD</span>:
		<span class="k">case</span> <span class="n">GPCMD_SEND_DVD_STRUCTURE</span>:
		<span class="k">case</span> <span class="n">GPCMD_SEND_CUE_SHEET</span>:
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* DMA is safe */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span> <span class="cm">/* use PIO instead */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_bmdma_setup - Set up BMDMA transaction</span>
<span class="cm"> *	@qc: queued command to prepare DMA for.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_bmdma_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">mv_fill_sg</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/* clear all DMA cmd bits */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">BMDMA_CMD</span><span class="p">);</span>

	<span class="cm">/* load PRD table addr. */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span>
		<span class="n">port_mmio</span> <span class="o">+</span> <span class="n">BMDMA_PRD_HIGH</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">],</span>
		<span class="n">port_mmio</span> <span class="o">+</span> <span class="n">BMDMA_PRD_LOW</span><span class="p">);</span>

	<span class="cm">/* issue r/w command */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_exec_command</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_bmdma_start - Start a BMDMA transaction</span>
<span class="cm"> *	@qc: queued command to start DMA on.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_bmdma_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">rw</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ATA_DMA_WR</span><span class="p">)</span> <span class="o">|</span> <span class="n">ATA_DMA_START</span><span class="p">;</span>

	<span class="cm">/* start host DMA transaction */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">BMDMA_CMD</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_bmdma_stop - Stop BMDMA transfer</span>
<span class="cm"> *	@qc: queued command to stop DMA on.</span>
<span class="cm"> *</span>
<span class="cm"> *	Clears the ATA_DMA_START flag in the bmdma control register</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_bmdma_stop_ap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/* clear start/stop bit */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">BMDMA_CMD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_START</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DMA_START</span><span class="p">;</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">BMDMA_CMD</span><span class="p">);</span>

		<span class="cm">/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */</span>
		<span class="n">ata_sff_dma_pause</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_bmdma_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mv_bmdma_stop_ap</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_bmdma_status - Read BMDMA status</span>
<span class="cm"> *	@ap: port for which to retrieve DMA status.</span>
<span class="cm"> *</span>
<span class="cm"> *	Read and return equivalent of the sff BMDMA status register.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">mv_bmdma_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Other bits are valid only if ATA_DMA_ACTIVE==0,</span>
<span class="cm">	 * and the ATA_DMA_INTR bit doesn&#39;t exist.</span>
<span class="cm">	 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">BMDMA_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_ACTIVE</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ATA_DMA_ACTIVE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_ERR</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_ERR</span><span class="p">)</span> <span class="o">|</span> <span class="n">ATA_DMA_INTR</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Just because DMA_ACTIVE is 0 (DMA completed),</span>
<span class="cm">		 * this does _not_ mean the device is &quot;done&quot;.</span>
<span class="cm">		 * So we should not yet be signalling ATA_DMA_INTR</span>
<span class="cm">		 * in some cases.  Eg. DSM/TRIM, and perhaps others.</span>
<span class="cm">		 */</span>
		<span class="n">mv_bmdma_stop_ap</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">altstatus_addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ATA_DMA_INTR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_rw_multi_errata_sata24</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Workaround for 88SX60x1 FEr SATA#24.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Chip may corrupt WRITEs if multi_count &gt;= 4kB.</span>
<span class="cm">	 * Note that READs are unaffected.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It&#39;s not clear if this errata really means &quot;4K bytes&quot;,</span>
<span class="cm">	 * or if it always happens for multi_count &gt; 7</span>
<span class="cm">	 * regardless of device sector_size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So, for safety, any write with multi_count &gt; 7</span>
<span class="cm">	 * gets converted here into a regular PIO write instead:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_multi_taskfile</span><span class="p">(</span><span class="n">tf</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">ATA_CMD_WRITE_MULTI</span>:
				<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_PIO_WRITE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">ATA_CMD_WRITE_MULTI_FUA_EXT</span>:
				<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_TFLAG_FUA</span><span class="p">;</span> <span class="cm">/* ugh */</span>
				<span class="cm">/* fall through */</span>
			<span class="k">case</span> <span class="n">ATA_CMD_WRITE_MULTI_EXT</span>:
				<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_PIO_WRITE_EXT</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_qc_prep - Host specific command preparation.</span>
<span class="cm"> *      @qc: queued command to prepare</span>
<span class="cm"> *</span>
<span class="cm"> *      This routine simply redirects to the general purpose routine</span>
<span class="cm"> *      if command is not DMA.  Else, it handles prep of the CRQB</span>
<span class="cm"> *      (command request block), does some sanity checking, and calls</span>
<span class="cm"> *      the SG load routine.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">cw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">in_index</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_PROT_DMA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_DSM</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="cm">/* fall-thru */</span>
	<span class="k">case</span> <span class="n">ATA_PROT_NCQ</span>:
		<span class="k">break</span><span class="p">;</span>	<span class="cm">/* continue below */</span>
	<span class="k">case</span> <span class="n">ATA_PROT_PIO</span>:
		<span class="n">mv_rw_multi_errata_sata24</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill in command request block</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">CRQB_FLAG_READ</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">MV_MAX_Q_DEPTH</span> <span class="o">&lt;=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&lt;&lt;</span> <span class="n">CRQB_TAG_SHIFT</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">CRQB_PMP_SHIFT</span><span class="p">;</span>

	<span class="cm">/* get current queue index from software */</span>
	<span class="n">in_index</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">req_idx</span><span class="p">;</span>

	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">[</span><span class="n">in_index</span><span class="p">].</span><span class="n">sg_addr</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">[</span><span class="n">in_index</span><span class="p">].</span><span class="n">sg_addr_hi</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">[</span><span class="n">in_index</span><span class="p">].</span><span class="n">ctrl_flags</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">cw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">[</span><span class="n">in_index</span><span class="p">].</span><span class="n">ata_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Sadly, the CRQB cannot accommodate all registers--there are</span>
<span class="cm">	 * only 11 bytes...so we must pick and choose required</span>
<span class="cm">	 * registers based on the command.  So, we drop feature and</span>
<span class="cm">	 * hob_feature for [RW] DMA commands, but they are needed for</span>
<span class="cm">	 * NCQ.  NCQ will drop hob_nsect, which is not needed there</span>
<span class="cm">	 * (nsect is used only for the tag; feat/hob_feat hold true nsect).</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_CMD_READ</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_READ_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_FUA_EXT</span>:
		<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_CMD_FPDMA_READ</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_FPDMA_WRITE</span>:
		<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span><span class="p">,</span> <span class="n">ATA_REG_FEATURE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">,</span> <span class="n">ATA_REG_FEATURE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* The only other commands EDMA supports in non-queued and</span>
<span class="cm">		 * non-NCQ mode are: [RW] STREAM DMA and W DMA FUA EXT, none</span>
<span class="cm">		 * of which are defined/used by Linux.  If we get here, this</span>
<span class="cm">		 * driver needs work.</span>
<span class="cm">		 *</span>
<span class="cm">		 * FIXME: modify libata to give qc_prep a return value and</span>
<span class="cm">		 * return error here.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span><span class="p">,</span> <span class="n">ATA_REG_LBAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span><span class="p">,</span> <span class="n">ATA_REG_LBAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span><span class="p">,</span> <span class="n">ATA_REG_LBAH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span><span class="p">,</span> <span class="n">ATA_REG_LBAH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">ATA_REG_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mv_crqb_pack_cmd</span><span class="p">(</span><span class="n">cw</span><span class="o">++</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="n">ATA_REG_CMD</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* last */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_DMAMAP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mv_fill_sg</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_qc_prep_iie - Host specific command preparation.</span>
<span class="cm"> *      @qc: queued command to prepare</span>
<span class="cm"> *</span>
<span class="cm"> *      This routine simply redirects to the general purpose routine</span>
<span class="cm"> *      if command is not DMA.  Else, it handles prep of the CRQB</span>
<span class="cm"> *      (command request block), does some sanity checking, and calls</span>
<span class="cm"> *      the SG load routine.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_qc_prep_iie</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_crqb_iie</span> <span class="o">*</span><span class="n">crqb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">in_index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">ATA_PROT_DMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">ATA_PROT_NCQ</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_DSM</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>  <span class="cm">/* use bmdma for this */</span>

	<span class="cm">/* Fill in Gen IIE command request block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">CRQB_FLAG_READ</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">MV_MAX_Q_DEPTH</span> <span class="o">&lt;=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&lt;&lt;</span> <span class="n">CRQB_TAG_SHIFT</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&lt;&lt;</span> <span class="n">CRQB_HOSTQ_SHIFT</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">CRQB_PMP_SHIFT</span><span class="p">;</span>

	<span class="cm">/* get current queue index from software */</span>
	<span class="n">in_index</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">req_idx</span><span class="p">;</span>

	<span class="n">crqb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mv_crqb_iie</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb</span><span class="p">[</span><span class="n">in_index</span><span class="p">];</span>
	<span class="n">crqb</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">crqb</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">sg_tbl_dma</span><span class="p">[</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">crqb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">crqb</span><span class="o">-&gt;</span><span class="n">ata_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="n">crqb</span><span class="o">-&gt;</span><span class="n">ata_cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="n">crqb</span><span class="o">-&gt;</span><span class="n">ata_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="n">crqb</span><span class="o">-&gt;</span><span class="n">ata_cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_DMAMAP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mv_fill_sg</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_sff_check_status - fetch device status, if valid</span>
<span class="cm"> *	@ap: ATA port to fetch status from</span>
<span class="cm"> *</span>
<span class="cm"> *	When using command issue via mv_qc_issue_fis(),</span>
<span class="cm"> *	the initial ATA_BUSY state does not show up in the</span>
<span class="cm"> *	ATA status (shadow) register.  This can confuse libata!</span>
<span class="cm"> *</span>
<span class="cm"> *	So we have a hook here to fake ATA_BUSY for that situation,</span>
<span class="cm"> *	until the first time a BUSY, DRQ, or ERR bit is seen.</span>
<span class="cm"> *</span>
<span class="cm"> *	The rest of the time, it simply returns the ATA status register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">mv_sff_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">status_addr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_FAKE_ATA_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_BUSY</span> <span class="o">|</span> <span class="n">ATA_DRQ</span> <span class="o">|</span> <span class="n">ATA_ERR</span><span class="p">))</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_PP_FLAG_FAKE_ATA_BUSY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">stat</span> <span class="o">=</span> <span class="n">ATA_BUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_send_fis - Send a FIS, using the &quot;Vendor-Unique FIS&quot; register</span>
<span class="cm"> *	@fis: fis to be sent</span>
<span class="cm"> *	@nwords: number of 32-bit words in the fis</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv_send_fis</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">fis</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nwords</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">ifctl</span><span class="p">,</span> <span class="n">old_ifctl</span><span class="p">,</span> <span class="n">ifstat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span> <span class="n">final_word</span> <span class="o">=</span> <span class="n">nwords</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Initiate FIS transmission mode */</span>
	<span class="n">old_ifctl</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFCTL</span><span class="p">);</span>
	<span class="n">ifctl</span> <span class="o">=</span> <span class="mh">0x100</span> <span class="o">|</span> <span class="p">(</span><span class="n">old_ifctl</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">ifctl</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFCTL</span><span class="p">);</span>

	<span class="cm">/* Send all words of the FIS except for the final word */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">final_word</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">fis</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">VENDOR_UNIQUE_FIS</span><span class="p">);</span>

	<span class="cm">/* Flag end-of-transmission, and then send the final word */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">ifctl</span> <span class="o">|</span> <span class="mh">0x200</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFCTL</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">fis</span><span class="p">[</span><span class="n">final_word</span><span class="p">],</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">VENDOR_UNIQUE_FIS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for FIS transmission to complete.</span>
<span class="cm">	 * This typically takes just a single iteration.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ifstat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFSTAT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ifstat</span> <span class="o">&amp;</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">timeout</span><span class="p">);</span>

	<span class="cm">/* Restore original port configuration */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">old_ifctl</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFCTL</span><span class="p">);</span>

	<span class="cm">/* See if it worked */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ifstat</span> <span class="o">&amp;</span> <span class="mh">0x3000</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_port_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;%s transmission error, ifstat=%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">__func__</span><span class="p">,</span> <span class="n">ifstat</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">AC_ERR_OTHER</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	mv_qc_issue_fis - Issue a command directly as a FIS</span>
<span class="cm"> *	@qc: queued command to start</span>
<span class="cm"> *</span>
<span class="cm"> *	Note that the ATA shadow registers are not updated</span>
<span class="cm"> *	after command issue, so the device will appear &quot;READY&quot;</span>
<span class="cm"> *	if polled, even while it is BUSY processing the command.</span>
<span class="cm"> *</span>
<span class="cm"> *	So we use a status hook to fake ATA_BUSY until the drive changes state.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: we don&#39;t get updated shadow regs on *completion*</span>
<span class="cm"> *	of non-data commands. So avoid sending them via this function,</span>
<span class="cm"> *	as they will appear to have completed immediately.</span>
<span class="cm"> *</span>
<span class="cm"> *	GEN_IIE has special registers that we could get the result tf from,</span>
<span class="cm"> *	but earlier chipsets do not.  For now, we ignore those registers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv_qc_issue_fis</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fis</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ata_tf_to_fis</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">fis</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mv_send_fis</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fis</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">fis</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATAPI_PROT_PIO</span>:
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">|=</span> <span class="n">MV_PP_FLAG_FAKE_ATA_BUSY</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">ATAPI_PROT_NODATA</span>:
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_FIRST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_PROT_PIO</span>:
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">|=</span> <span class="n">MV_PP_FLAG_FAKE_ATA_BUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_FIRST</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_LAST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
		<span class="n">ata_sff_queue_pio_task</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_qc_issue - Initiate a command to the host</span>
<span class="cm"> *      @qc: queued command to start</span>
<span class="cm"> *</span>
<span class="cm"> *      This routine simply redirects to the general purpose routine</span>
<span class="cm"> *      if command is not DMA.  Else, it sanity checks our local</span>
<span class="cm"> *      caches of the request producer/consumer indices then enables</span>
<span class="cm"> *      DMA and bumps the request producer index.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">limit_warnings</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">in_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_irqs</span><span class="p">;</span>

	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_PP_FLAG_FAKE_ATA_BUSY</span><span class="p">;</span> <span class="cm">/* paranoia */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_PROT_DMA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_DSM</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_setup</span><span class="p">)</span>  <span class="cm">/* no bmdma on GEN_I */</span>
				<span class="k">return</span> <span class="n">AC_ERR_OTHER</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>  <span class="cm">/* use bmdma for this */</span>
		<span class="p">}</span>
		<span class="cm">/* fall thru */</span>
	<span class="k">case</span> <span class="n">ATA_PROT_NCQ</span>:
		<span class="n">mv_start_edma</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">port_mmio</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">);</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">req_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">req_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MV_MAX_Q_DEPTH_MASK</span><span class="p">;</span>
		<span class="n">in_index</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">req_idx</span> <span class="o">&lt;&lt;</span> <span class="n">EDMA_REQ_Q_PTR_SHIFT</span><span class="p">;</span>

		<span class="cm">/* Write the request in pointer to kick the EDMA to life */</span>
		<span class="n">writelfl</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crqb_dma</span> <span class="o">&amp;</span> <span class="n">EDMA_REQ_Q_BASE_LO_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">in_index</span><span class="p">,</span>
					<span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_REQ_Q_IN_PTR</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATA_PROT_PIO</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Errata SATA#16, SATA#24: warn if multiple DRQs expected.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Someday, we might implement special polling workarounds</span>
<span class="cm">		 * for these, but it all seems rather unnecessary since we</span>
<span class="cm">		 * normally use only DMA for commands which transfer more</span>
<span class="cm">		 * than a single block of data.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Much of the time, this could just work regardless.</span>
<span class="cm">		 * So for now, just log the incident, and allow the attempt.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit_warnings</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">/</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">limit_warnings</span><span class="p">;</span>
			<span class="n">ata_link_warn</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">DRV_NAME</span>
				      <span class="s">&quot;: attempting PIO w/multiple DRQ: &quot;</span>
				      <span class="s">&quot;this may fail due to h/w errata</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* drop through */</span>
	<span class="k">case</span> <span class="n">ATA_PROT_NODATA</span>:
	<span class="k">case</span> <span class="n">ATAPI_PROT_PIO</span>:
	<span class="k">case</span> <span class="n">ATAPI_PROT_NODATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PIO_POLLING</span><span class="p">)</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
		<span class="n">port_irqs</span> <span class="o">=</span> <span class="n">ERR_IRQ</span><span class="p">;</span>	<span class="cm">/* mask device interrupt when polling */</span>
	<span class="k">else</span>
		<span class="n">port_irqs</span> <span class="o">=</span> <span class="n">ERR_IRQ</span> <span class="o">|</span> <span class="n">DONE_IRQ</span><span class="p">;</span>	<span class="cm">/* unmask all interrupts */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re about to send a non-EDMA capable command to the</span>
<span class="cm">	 * port.  Turn off EDMA so there won&#39;t be problems accessing</span>
<span class="cm">	 * shadow block, etc registers.</span>
<span class="cm">	 */</span>
	<span class="n">mv_stop_edma</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">mv_clear_and_enable_port_irqs</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">),</span> <span class="n">port_irqs</span><span class="p">);</span>
	<span class="n">mv_pmp_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_READ_LOG_EXT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Workaround for 88SX60x1 FEr SATA#25 (part 2).</span>
<span class="cm">		 *</span>
<span class="cm">		 * After any NCQ error, the READ_LOG_EXT command</span>
<span class="cm">		 * from libata-eh *must* use mv_qc_issue_fis().</span>
<span class="cm">		 * Otherwise it might fail, due to chip errata.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Rather than special-case it, we&#39;ll just *always*</span>
<span class="cm">		 * use this method here for READ_LOG_EXT, making for</span>
<span class="cm">		 * easier testing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_II</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">mv_qc_issue_fis</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ata_bmdma_qc_issue</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="nf">mv_get_active_qc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_NCQ_EN</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">qc</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_pmp_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmp</span><span class="p">,</span> <span class="n">pmp_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_DELAYED_EH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Perform NCQ error analysis on failed PMPs</span>
<span class="cm">		 * before we freeze the port entirely.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The failed PMPs are marked earlier by mv_pmp_eh_prep().</span>
<span class="cm">		 */</span>
		<span class="n">pmp_map</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">delayed_eh_pmp_map</span><span class="p">;</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_PP_FLAG_DELAYED_EH</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pmp_map</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pmp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">this_pmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pmp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmp_map</span> <span class="o">&amp;</span> <span class="n">this_pmp</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">[</span><span class="n">pmp</span><span class="p">];</span>
				<span class="n">pmp_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">this_pmp</span><span class="p">;</span>
				<span class="n">ata_eh_analyze_ncq_error</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ata_port_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sata_pmp_error_handler</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv_get_err_pmp_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_TESTCTL</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_pmp_eh_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmp_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pmp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize EH info for PMPs which saw device errors</span>
<span class="cm">	 */</span>
	<span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pmp_map</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pmp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">this_pmp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmp_map</span> <span class="o">&amp;</span> <span class="n">this_pmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">[</span><span class="n">pmp</span><span class="p">];</span>

			<span class="n">pmp_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">this_pmp</span><span class="p">;</span>
			<span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">;</span>
			<span class="n">ata_ehi_clear_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">);</span>
			<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;dev err&quot;</span><span class="p">);</span>
			<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_DEV</span><span class="p">;</span>
			<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
			<span class="n">ata_link_abort</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_req_q_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">in_ptr</span><span class="p">,</span> <span class="n">out_ptr</span><span class="p">;</span>

	<span class="n">in_ptr</span>  <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_REQ_Q_IN_PTR</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">EDMA_REQ_Q_PTR_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MV_MAX_Q_DEPTH_MASK</span><span class="p">;</span>
	<span class="n">out_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_REQ_Q_OUT_PTR</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">EDMA_REQ_Q_PTR_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MV_MAX_Q_DEPTH_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">in_ptr</span> <span class="o">==</span> <span class="n">out_ptr</span><span class="p">);</span>	<span class="cm">/* 1 == queue_is_empty */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_handle_fbs_ncq_dev_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">failed_links</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_map</span><span class="p">,</span> <span class="n">new_map</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Device error during FBS+NCQ operation:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set a port flag to prevent further I/O being enqueued.</span>
<span class="cm">	 * Leave the EDMA running to drain outstanding commands from this port.</span>
<span class="cm">	 * Perform the post-mortem/EH only when all responses are complete.</span>
<span class="cm">	 * Follow recovery sequence from 6042/7042 datasheet (7.3.15.4.2.2).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_DELAYED_EH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">|=</span> <span class="n">MV_PP_FLAG_DELAYED_EH</span><span class="p">;</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">delayed_eh_pmp_map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">old_map</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">delayed_eh_pmp_map</span><span class="p">;</span>
	<span class="n">new_map</span> <span class="o">=</span> <span class="n">old_map</span> <span class="o">|</span> <span class="n">mv_get_err_pmp_map</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_map</span> <span class="o">!=</span> <span class="n">new_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">delayed_eh_pmp_map</span> <span class="o">=</span> <span class="n">new_map</span><span class="p">;</span>
		<span class="n">mv_pmp_eh_prep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">new_map</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">old_map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">failed_links</span> <span class="o">=</span> <span class="n">hweight16</span><span class="p">(</span><span class="n">new_map</span><span class="p">);</span>

	<span class="n">ata_port_info</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span>
		      <span class="s">&quot;%s: pmp_map=%04x qc_map=%04x failed_links=%d nr_active_links=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">__func__</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">delayed_eh_pmp_map</span><span class="p">,</span>
		      <span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span><span class="p">,</span> <span class="n">failed_links</span><span class="p">,</span>
		      <span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_active_links</span> <span class="o">&lt;=</span> <span class="n">failed_links</span> <span class="o">&amp;&amp;</span> <span class="n">mv_req_q_empty</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mv_process_crpb_entries</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">pp</span><span class="p">);</span>
		<span class="n">mv_stop_edma</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">mv_eh_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">ata_port_info</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;%s: done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* handled */</span>
	<span class="p">}</span>
	<span class="n">ata_port_info</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;%s: waiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* handled */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_handle_fbs_non_ncq_dev_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Possible future enhancement:</span>
<span class="cm">	 *</span>
<span class="cm">	 * FBS+non-NCQ operation is not yet implemented.</span>
<span class="cm">	 * See related notes in mv_edma_cfg().</span>
<span class="cm">	 *</span>
<span class="cm">	 * Device error during FBS+non-NCQ operation:</span>
<span class="cm">	 *</span>
<span class="cm">	 * We need to snapshot the shadow registers for each failed command.</span>
<span class="cm">	 * Follow recovery sequence from 6042/7042 datasheet (7.3.15.4.2.3).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* not handled */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_handle_dev_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">edma_err_cause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* EDMA was not active: not handled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_FBS_EN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* FBS was not active: not handled */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_DEV</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* non DEV error: not handled */</span>
	<span class="n">edma_err_cause</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EDMA_ERR_IRQ_TRANSIENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">EDMA_ERR_DEV</span> <span class="o">|</span> <span class="n">EDMA_ERR_SELF_DIS</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* other problems: not handled */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_NCQ_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * EDMA should NOT have self-disabled for this case.</span>
<span class="cm">		 * If it did, then something is wrong elsewhere,</span>
<span class="cm">		 * and we cannot handle it here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_SELF_DIS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_port_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;%s: err_cause=0x%x pp_flags=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">__func__</span><span class="p">,</span> <span class="n">edma_err_cause</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* not handled */</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">mv_handle_fbs_ncq_dev_err</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * EDMA should have self-disabled for this case.</span>
<span class="cm">		 * If it did not, then something is wrong elsewhere,</span>
<span class="cm">		 * and we cannot handle it here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_SELF_DIS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ata_port_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;%s: err_cause=0x%x pp_flags=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">__func__</span><span class="p">,</span> <span class="n">edma_err_cause</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* not handled */</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">mv_handle_fbs_non_ncq_dev_err</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* not handled */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_unexpected_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">edma_was_enabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">when</span> <span class="o">=</span> <span class="s">&quot;idle&quot;</span><span class="p">;</span>

	<span class="n">ata_ehi_clear_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edma_was_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">when</span> <span class="o">=</span> <span class="s">&quot;EDMA enabled&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">))</span>
			<span class="n">when</span> <span class="o">=</span> <span class="s">&quot;polling&quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;unexpected device interrupt while %s&quot;</span><span class="p">,</span> <span class="n">when</span><span class="p">);</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_OTHER</span><span class="p">;</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span>   <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
	<span class="n">ata_port_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_err_intr - Handle error interrupts on the port</span>
<span class="cm"> *      @ap: ATA channel to manipulate</span>
<span class="cm"> *</span>
<span class="cm"> *      Most cases require a full reset of the chip&#39;s state machine,</span>
<span class="cm"> *      which also performs a COMRESET.</span>
<span class="cm"> *      Also, if the port disabled DMA, update our cached copy to match.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_err_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">edma_err_cause</span><span class="p">,</span> <span class="n">eh_freeze_mask</span><span class="p">,</span> <span class="n">serr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fis_cause</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read and clear the SError and err_cause bits.</span>
<span class="cm">	 * For GenIIe, if EDMA_ERR_TRANS_IRQ_7 is set, we also must read/clear</span>
<span class="cm">	 * the FIS_IRQ_CAUSE register before clearing edma_err_cause.</span>
<span class="cm">	 */</span>
	<span class="n">sata_scr_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serr</span><span class="p">);</span>
	<span class="n">sata_scr_write_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_ERROR</span><span class="p">,</span> <span class="n">serr</span><span class="p">);</span>

	<span class="n">edma_err_cause</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_ERR_IRQ_CAUSE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_IIE</span><span class="p">(</span><span class="n">hpriv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_TRANS_IRQ_7</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fis_cause</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">FIS_IRQ_CAUSE</span><span class="p">);</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="o">~</span><span class="n">fis_cause</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">FIS_IRQ_CAUSE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="o">~</span><span class="n">edma_err_cause</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_ERR_IRQ_CAUSE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_DEV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Device errors during FIS-based switching operation</span>
<span class="cm">		 * require special handling.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mv_handle_dev_err</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">edma_err_cause</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qc</span> <span class="o">=</span> <span class="n">mv_get_active_qc</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">ata_ehi_clear_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">);</span>
	<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;edma_err_cause=%08x pp_flags=%08x&quot;</span><span class="p">,</span>
			  <span class="n">edma_err_cause</span><span class="p">,</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_IIE</span><span class="p">(</span><span class="n">hpriv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_TRANS_IRQ_7</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;fis_cause=%08x&quot;</span><span class="p">,</span> <span class="n">fis_cause</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fis_cause</span> <span class="o">&amp;</span> <span class="n">FIS_IRQ_CAUSE_AN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">ec</span> <span class="o">=</span> <span class="n">edma_err_cause</span> <span class="o">&amp;</span>
			       <span class="o">~</span><span class="p">(</span><span class="n">EDMA_ERR_TRANS_IRQ_7</span> <span class="o">|</span> <span class="n">EDMA_ERR_IRQ_TRANSIENT</span><span class="p">);</span>
			<span class="n">sata_async_notification</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span> <span class="cm">/* Just an AN; no need for the nukes */</span>
			<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;SDB notify&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * All generations share these EDMA error cause bits:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_DEV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_DEV</span><span class="p">;</span>
		<span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
		<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;dev error&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EDMA_ERR_D_PAR</span> <span class="o">|</span> <span class="n">EDMA_ERR_PRD_PAR</span> <span class="o">|</span>
			<span class="n">EDMA_ERR_CRQB_PAR</span> <span class="o">|</span> <span class="n">EDMA_ERR_CRPB_PAR</span> <span class="o">|</span>
			<span class="n">EDMA_ERR_INTRL_PAR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_ATA_BUS</span><span class="p">;</span>
		<span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
		<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;parity error&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EDMA_ERR_DEV_DCON</span> <span class="o">|</span> <span class="n">EDMA_ERR_DEV_CON</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_ehi_hotplugged</span><span class="p">(</span><span class="n">ehi</span><span class="p">);</span>
		<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_DEV_DCON</span> <span class="o">?</span>
			<span class="s">&quot;dev disconnect&quot;</span> <span class="o">:</span> <span class="s">&quot;dev connect&quot;</span><span class="p">);</span>
		<span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Gen-I has a different SELF_DIS bit,</span>
<span class="cm">	 * different FREEZE bits, and no SERR bit:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">eh_freeze_mask</span> <span class="o">=</span> <span class="n">EDMA_EH_FREEZE_5</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_SELF_DIS_5</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">;</span>
			<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;EDMA self-disable&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">eh_freeze_mask</span> <span class="o">=</span> <span class="n">EDMA_EH_FREEZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_SELF_DIS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">;</span>
			<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;EDMA self-disable&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">EDMA_ERR_SERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;SError=%08x&quot;</span><span class="p">,</span> <span class="n">serr</span><span class="p">);</span>
			<span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_ATA_BUS</span><span class="p">;</span>
			<span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err_mask</span> <span class="o">=</span> <span class="n">AC_ERR_OTHER</span><span class="p">;</span>
		<span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">serror</span> <span class="o">|=</span> <span class="n">serr</span><span class="p">;</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">|=</span> <span class="n">action</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">err_mask</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">err_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span> <span class="o">==</span> <span class="n">AC_ERR_DEV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Cannot do ata_port_freeze() here,</span>
<span class="cm">		 * because it would kill PIO access,</span>
<span class="cm">		 * which is needed for further diagnosis.</span>
<span class="cm">		 */</span>
		<span class="n">mv_eh_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">edma_err_cause</span> <span class="o">&amp;</span> <span class="n">eh_freeze_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note to self: ata_port_freeze() calls ata_port_abort()</span>
<span class="cm">		 */</span>
		<span class="n">ata_port_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">abort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">abort</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span>
			<span class="n">ata_link_abort</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ata_port_abort</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mv_process_crpb_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">mv_crpb</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncq_enabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ata_status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">edma_status</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * edma_status from a response queue entry:</span>
<span class="cm">	 *   LSB is from EDMA_ERR_IRQ_CAUSE (non-NCQ only).</span>
<span class="cm">	 *   MSB is saved ATA status from command completion.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ncq_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">err_cause</span> <span class="o">=</span> <span class="n">edma_status</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EDMA_ERR_DEV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_cause</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Error will be seen/handled by</span>
<span class="cm">			 * mv_err_intr().  So do nothing at all here.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ata_status</span> <span class="o">=</span> <span class="n">edma_status</span> <span class="o">&gt;&gt;</span> <span class="n">CRPB_FLAG_STATUS_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac_err_mask</span><span class="p">(</span><span class="n">ata_status</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/* else: leave it for mv_err_intr() */</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_process_crpb_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">in_index</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">work_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">done_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ncq_enabled</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_NCQ_EN</span><span class="p">);</span>

	<span class="cm">/* Get the hardware queue position index */</span>
	<span class="n">in_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_RSP_Q_IN_PTR</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">EDMA_RSP_Q_PTR_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MV_MAX_Q_DEPTH_MASK</span><span class="p">;</span>

	<span class="cm">/* Process new responses from since the last time we looked */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">in_index</span> <span class="o">!=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">resp_idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">mv_crpb</span> <span class="o">*</span><span class="n">response</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb</span><span class="p">[</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">resp_idx</span><span class="p">];</span>

		<span class="n">pp</span><span class="o">-&gt;</span><span class="n">resp_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">resp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MV_MAX_Q_DEPTH_MASK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* 50xx: no NCQ, only one command active at a time */</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Gen II/IIE: get command tag from CRPB entry */</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mv_process_crpb_response</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">ncq_enabled</span><span class="p">))</span>
			<span class="n">done_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tag</span><span class="p">;</span>
		<span class="n">work_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_qc_complete_multiple</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">qc_active</span> <span class="o">^</span> <span class="n">done_mask</span><span class="p">);</span>

		<span class="cm">/* Update the software queue position index in hardware */</span>
		<span class="n">writelfl</span><span class="p">((</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">crpb_dma</span> <span class="o">&amp;</span> <span class="n">EDMA_RSP_Q_BASE_LO_MASK</span><span class="p">)</span> <span class="o">|</span>
			 <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">resp_idx</span> <span class="o">&lt;&lt;</span> <span class="n">EDMA_RSP_Q_PTR_SHIFT</span><span class="p">),</span>
			 <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_RSP_Q_OUT_PTR</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_port_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_cause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">edma_was_enabled</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Grab a snapshot of the EDMA_EN flag setting,</span>
<span class="cm">	 * so that we have a consistent view for this port,</span>
<span class="cm">	 * even if something we call of our routines changes it.</span>
<span class="cm">	 */</span>
	<span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">edma_was_enabled</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Process completed CRPB response(s) before other events.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edma_was_enabled</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port_cause</span> <span class="o">&amp;</span> <span class="n">DONE_IRQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mv_process_crpb_entries</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">pp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;</span> <span class="n">MV_PP_FLAG_DELAYED_EH</span><span class="p">)</span>
			<span class="n">mv_handle_fbs_ncq_dev_err</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Handle chip-reported errors, or continue on to handle PIO.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">port_cause</span> <span class="o">&amp;</span> <span class="n">ERR_IRQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mv_err_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edma_was_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span> <span class="o">=</span> <span class="n">mv_get_active_qc</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span>
			<span class="n">ata_bmdma_port_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mv_unexpected_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">edma_was_enabled</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_host_intr - Handle all interrupts on the given host controller</span>
<span class="cm"> *      @host: host specific structure</span>
<span class="cm"> *      @main_irq_cause: Main interrupt cause register for the chip.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_host_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="n">u32</span> <span class="n">main_irq_cause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">hc_mmio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">port</span><span class="p">;</span>

	<span class="cm">/* If asserted, clear the &quot;all ports&quot; IRQ coalescing bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">main_irq_cause</span> <span class="o">&amp;</span> <span class="n">ALL_PORTS_COAL_DONE</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="n">ALL_PORTS_COAL_IRQ</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">IRQ_COAL_CAUSE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">hardport</span><span class="p">,</span> <span class="n">port_cause</span><span class="p">;</span>

		<span class="n">MV_PORT_TO_SHIFT_AND_HARDPORT</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">hardport</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Each hc within the host has its own hc_irq_cause register,</span>
<span class="cm">		 * where the interrupting ports bits get ack&#39;d.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hardport</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* first port on this hc ? */</span>
			<span class="n">u32</span> <span class="n">hc_cause</span> <span class="o">=</span> <span class="p">(</span><span class="n">main_irq_cause</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HC0_IRQ_PEND</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">port_mask</span><span class="p">,</span> <span class="n">ack_irqs</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Skip this entire hc if nothing pending for any ports</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hc_cause</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">port</span> <span class="o">+=</span> <span class="n">MV_PORTS_PER_HC</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * We don&#39;t need/want to read the hc_irq_cause register,</span>
<span class="cm">			 * because doing so hurts performance, and</span>
<span class="cm">			 * main_irq_cause already gives us everything we need.</span>
<span class="cm">			 *</span>
<span class="cm">			 * But we do have to *write* to the hc_irq_cause to ack</span>
<span class="cm">			 * the ports that we are handling this time through.</span>
<span class="cm">			 *</span>
<span class="cm">			 * This requires that we create a bitmap for those</span>
<span class="cm">			 * ports which interrupted us, and use that bitmap</span>
<span class="cm">			 * to ack (only) those ports via hc_irq_cause.</span>
<span class="cm">			 */</span>
			<span class="n">ack_irqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hc_cause</span> <span class="o">&amp;</span> <span class="n">PORTS_0_3_COAL_DONE</span><span class="p">)</span>
				<span class="n">ack_irqs</span> <span class="o">=</span> <span class="n">HC_COAL_IRQ</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">MV_PORTS_PER_HC</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">port</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">port_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">DONE_IRQ</span> <span class="o">|</span> <span class="n">ERR_IRQ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hc_cause</span> <span class="o">&amp;</span> <span class="n">port_mask</span><span class="p">)</span>
					<span class="n">ack_irqs</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DMA_IRQ</span> <span class="o">|</span> <span class="n">DEV_IRQ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base_from_port</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
			<span class="n">writelfl</span><span class="p">(</span><span class="o">~</span><span class="n">ack_irqs</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_CAUSE</span><span class="p">);</span>
			<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Handle interrupts signalled for this port:</span>
<span class="cm">		 */</span>
		<span class="n">port_cause</span> <span class="o">=</span> <span class="p">(</span><span class="n">main_irq_cause</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DONE_IRQ</span> <span class="o">|</span> <span class="n">ERR_IRQ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port_cause</span><span class="p">)</span>
			<span class="n">mv_port_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">port_cause</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">handled</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_pci_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err_mask</span><span class="p">,</span> <span class="n">printed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_cause</span><span class="p">;</span>

	<span class="n">err_cause</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_cause_offset</span><span class="p">);</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI ERROR; PCI IRQ cause=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_cause</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;All regs @ PCI error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mv_dump_all_regs</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">writelfl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_cause_offset</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_link_offline</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">;</span>
			<span class="n">ata_ehi_clear_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printed</span><span class="o">++</span><span class="p">)</span>
				<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span>
					<span class="s">&quot;PCI err cause 0x%08x&quot;</span><span class="p">,</span> <span class="n">err_cause</span><span class="p">);</span>
			<span class="n">err_mask</span> <span class="o">=</span> <span class="n">AC_ERR_HOST_BUS</span><span class="p">;</span>
			<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
			<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span>
				<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">err_mask</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">err_mask</span><span class="p">;</span>

			<span class="n">ata_port_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* handled */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_interrupt - Main interrupt event handler</span>
<span class="cm"> *      @irq: unused</span>
<span class="cm"> *      @dev_instance: private data; in this case the host structure</span>
<span class="cm"> *</span>
<span class="cm"> *      Read the read only register to determine if any host</span>
<span class="cm"> *      controllers have pending interrupts.  If so, call lower level</span>
<span class="cm"> *      routine to handle.  Also check for PCI errors which are only</span>
<span class="cm"> *      reported here.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      This routine holds the host lock while processing pending</span>
<span class="cm"> *      interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">mv_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">using_msi</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="n">MV_HP_FLAG_MSI</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">main_irq_cause</span><span class="p">,</span> <span class="n">pending_irqs</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* for MSI:  block new interrupts while in here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">using_msi</span><span class="p">)</span>
		<span class="n">mv_write_main_irq_mask</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hpriv</span><span class="p">);</span>

	<span class="n">main_irq_cause</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_cause_addr</span><span class="p">);</span>
	<span class="n">pending_irqs</span>   <span class="o">=</span> <span class="n">main_irq_cause</span> <span class="o">&amp;</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Deal with cases where we either have nothing pending, or have read</span>
<span class="cm">	 * a bogus register value which can indicate HW removal or PCI fault.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pending_irqs</span> <span class="o">&amp;&amp;</span> <span class="n">main_irq_cause</span> <span class="o">!=</span> <span class="mh">0xffffffffU</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">pending_irqs</span> <span class="o">&amp;</span> <span class="n">PCI_ERR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_SOC</span><span class="p">(</span><span class="n">hpriv</span><span class="p">)))</span>
			<span class="n">handled</span> <span class="o">=</span> <span class="n">mv_pci_error</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">handled</span> <span class="o">=</span> <span class="n">mv_host_intr</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">pending_irqs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* for MSI: unmask; interrupt cause bits will retrigger now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">using_msi</span><span class="p">)</span>
		<span class="n">mv_write_main_irq_mask</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask</span><span class="p">,</span> <span class="n">hpriv</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv5_scr_offset</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sc_reg_in</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCR_STATUS</span>:
	<span class="k">case</span> <span class="n">SCR_ERROR</span>:
	<span class="k">case</span> <span class="n">SCR_CONTROL</span>:
		<span class="n">ofs</span> <span class="o">=</span> <span class="n">sc_reg_in</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="mh">0xffffffffU</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ofs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv5_scr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">mv5_phy_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">mv5_scr_offset</span><span class="p">(</span><span class="n">sc_reg_in</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">!=</span> <span class="mh">0xffffffffU</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv5_scr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sc_reg_in</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">mv5_phy_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">mv5_scr_offset</span><span class="p">(</span><span class="n">sc_reg_in</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">!=</span> <span class="mh">0xffffffffU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv5_reset_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">early_5080</span><span class="p">;</span>

	<span class="n">early_5080</span> <span class="o">=</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="mh">0x5080</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">early_5080</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_EXP_ROM_BAR_CTL</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_EXP_ROM_BAR_CTL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mv_reset_pci_bus</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">mmio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv5_reset_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0fcfffff</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">FLASH_CTL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv5_read_preamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">phy_mmio</span> <span class="o">=</span> <span class="n">mv5_phy_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phy_mmio</span> <span class="o">+</span> <span class="n">MV5_PHY_MODE</span><span class="p">);</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">pre</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x1800</span><span class="p">;</span>	<span class="cm">/* bits 12:11 */</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">amps</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">;</span>	<span class="cm">/* bits 7:5 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv5_enable_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">GPIO_PORT_CTL</span><span class="p">);</span>

	<span class="cm">/* FIXME: handle MV_HP_ERRATA_50XXB2 errata */</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_EXP_ROM_BAR_CTL</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_EXP_ROM_BAR_CTL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv5_phy_errata</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">phy_mmio</span> <span class="o">=</span> <span class="n">mv5_phy_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">11</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fix_apm_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="n">MV_HP_ERRATA_50XXB0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fix_apm_sq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phy_mmio</span> <span class="o">+</span> <span class="n">MV5_LTMODE</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">phy_mmio</span> <span class="o">+</span> <span class="n">MV5_LTMODE</span><span class="p">);</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phy_mmio</span> <span class="o">+</span> <span class="n">MV5_PHY_CTL</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x3</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">phy_mmio</span> <span class="o">+</span> <span class="n">MV5_PHY_CTL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phy_mmio</span> <span class="o">+</span> <span class="n">MV5_PHY_MODE</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">pre</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">amps</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">phy_mmio</span> <span class="o">+</span> <span class="n">MV5_PHY_MODE</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#undef ZERO</span>
<span class="cp">#define ZERO(reg) writel(0, port_mmio + (reg))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv5_reset_hc_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">mv_reset_channel</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x028</span><span class="p">);</span>	<span class="cm">/* command */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x11f</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CFG</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x004</span><span class="p">);</span>	<span class="cm">/* timer */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x008</span><span class="p">);</span>	<span class="cm">/* irq err cause */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x00c</span><span class="p">);</span>	<span class="cm">/* irq err mask */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x010</span><span class="p">);</span>	<span class="cm">/* rq bah */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x014</span><span class="p">);</span>	<span class="cm">/* rq inp */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x018</span><span class="p">);</span>	<span class="cm">/* rq outp */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x01c</span><span class="p">);</span>	<span class="cm">/* respq bah */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x024</span><span class="p">);</span>	<span class="cm">/* respq outp */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x020</span><span class="p">);</span>	<span class="cm">/* respq inp */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x02c</span><span class="p">);</span>	<span class="cm">/* test control */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xbc</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_IORDY_TMOUT</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#undef ZERO</span>

<span class="cp">#define ZERO(reg) writel(0, hc_mmio + (reg))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv5_reset_one_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">hc</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x00c</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x010</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x014</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x018</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hc_mmio</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="mh">0x1c1c1c1c</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="mh">0x03030303</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#undef ZERO</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv5_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_hc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hc</span><span class="p">,</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">hc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hc</span> <span class="o">&lt;</span> <span class="n">n_hc</span><span class="p">;</span> <span class="n">hc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">MV_PORTS_PER_HC</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span>
			<span class="n">mv5_reset_hc_port</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">hc</span> <span class="o">*</span> <span class="n">MV_PORTS_PER_HC</span><span class="p">)</span> <span class="o">+</span> <span class="n">port</span><span class="p">);</span>

		<span class="n">mv5_reset_one_hc</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">,</span> <span class="n">hc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#undef ZERO</span>
<span class="cp">#define ZERO(reg) writel(0, mmio + (reg))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_reset_pci_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_MODE</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="mh">0xff00ffff</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_MODE</span><span class="p">);</span>

	<span class="n">ZERO</span><span class="p">(</span><span class="n">MV_PCI_DISC_TIMER</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="n">MV_PCI_MSI_TRIGGER</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x000100ff</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_XBAR_TMOUT</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="n">MV_PCI_SERR_MASK</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_cause_offset</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_mask_offset</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="n">MV_PCI_ERR_LOW_ADDRESS</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="n">MV_PCI_ERR_HIGH_ADDRESS</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="n">MV_PCI_ERR_ATTRIBUTE</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="n">MV_PCI_ERR_COMMAND</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#undef ZERO</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv6_reset_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">mv5_reset_flash</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">GPIO_PORT_CTL</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">GPIO_PORT_CTL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv6_reset_hc - Perform the 6xxx global soft reset</span>
<span class="cm"> *      @mmio: base address of the HBA</span>
<span class="cm"> *</span>
<span class="cm"> *      This routine only applies to 6xxx parts.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv6_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_hc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">PCI_MAIN_CMD_STS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/* Following procedure defined in PCI &quot;main command and status</span>
<span class="cm">	 * register&quot; table.</span>
<span class="cm">	 */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">t</span> <span class="o">|</span> <span class="n">STOP_PCI_MASTER</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PCI_MASTER_EMPTY</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">PCI_MASTER_EMPTY</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: PCI master won&#39;t flush</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set reset */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">t</span> <span class="o">|</span> <span class="n">GLOB_SFT_RST</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">GLOB_SFT_RST</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">GLOB_SFT_RST</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: can&#39;t set global reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear reset and *reenable the PCI master* (not mentioned in spec) */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">GLOB_SFT_RST</span> <span class="o">|</span> <span class="n">STOP_PCI_MASTER</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">GLOB_SFT_RST</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GLOB_SFT_RST</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: can&#39;t clear global reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv6_read_preamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">RESET_CFG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">amps</span> <span class="o">=</span> <span class="mh">0x7</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">pre</span> <span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE2</span><span class="p">);</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">amps</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x700</span><span class="p">;</span>	<span class="cm">/* bits 10:8 */</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">pre</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">;</span>	<span class="cm">/* bits 7:5 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv6_enable_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x00000060</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">GPIO_PORT_CTL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv6_phy_errata</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">u32</span> <span class="n">hp_flags</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fix_phy_mode2</span> <span class="o">=</span>
		<span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MV_HP_ERRATA_60X1B2</span> <span class="o">|</span> <span class="n">MV_HP_ERRATA_60X1C0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">fix_phy_mode4</span> <span class="o">=</span>
		<span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MV_HP_ERRATA_60X1B2</span> <span class="o">|</span> <span class="n">MV_HP_ERRATA_60X1C0</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">m2</span><span class="p">,</span> <span class="n">m3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fix_phy_mode2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m2</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE2</span><span class="p">);</span>
		<span class="n">m2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">m2</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE2</span><span class="p">);</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

		<span class="n">m2</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE2</span><span class="p">);</span>
		<span class="n">m2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE2</span><span class="p">);</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Gen-II/IIe PHY_MODE3 errata RM#2:</span>
<span class="cm">	 * Achieves better receiver noise performance than the h/w default:</span>
<span class="cm">	 */</span>
	<span class="n">m3</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE3</span><span class="p">);</span>
	<span class="n">m3</span> <span class="o">=</span> <span class="p">(</span><span class="n">m3</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x5555601</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>

	<span class="cm">/* Guideline 88F5182 (GL# SATA-S11) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SOC</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="n">m3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x1c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fix_phy_mode4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">m4</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE4</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Enforce reserved-bit restrictions on GenIIe devices only.</span>
<span class="cm">		 * For earlier chipsets, force only the internal config field</span>
<span class="cm">		 *  (workaround for errata FEr SATA#10 part 1).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_IIE</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
			<span class="n">m4</span> <span class="o">=</span> <span class="p">(</span><span class="n">m4</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PHY_MODE4_RSVD_ZEROS</span><span class="p">)</span> <span class="o">|</span> <span class="n">PHY_MODE4_RSVD_ONES</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">m4</span> <span class="o">=</span> <span class="p">(</span><span class="n">m4</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PHY_MODE4_CFG_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">PHY_MODE4_CFG_VALUE</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">m4</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Workaround for 60x1-B2 errata SATA#13:</span>
<span class="cm">	 * Any write to PHY_MODE4 (above) may corrupt PHY_MODE3,</span>
<span class="cm">	 * so we must always rewrite PHY_MODE3 after PHY_MODE4.</span>
<span class="cm">	 * Or ensure we use writelfl() when writing PHY_MODE4.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">m3</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE3</span><span class="p">);</span>

	<span class="cm">/* Revert values of pre-emphasis and signal amps to the saved ones */</span>
	<span class="n">m2</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE2</span><span class="p">);</span>

	<span class="n">m2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_M2_PREAMP_MASK</span><span class="p">;</span>
	<span class="n">m2</span> <span class="o">|=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">amps</span><span class="p">;</span>
	<span class="n">m2</span> <span class="o">|=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">port</span><span class="p">].</span><span class="n">pre</span><span class="p">;</span>
	<span class="n">m2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="cm">/* according to mvSata 3.6.1, some IIE values are fixed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_IIE</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">m2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xC30FF01F</span><span class="p">;</span>
		<span class="n">m2</span> <span class="o">|=</span> <span class="mh">0x0000900F</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* TODO: use the generic LED interface to configure the SATA Presence */</span>
<span class="cm">/* &amp; Acitivy LEDs on the board */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_enable_leds</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_read_preamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE2</span><span class="p">);</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">amps</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x700</span><span class="p">;</span>	<span class="cm">/* bits 10:8 */</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">pre</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">;</span>	<span class="cm">/* bits 7:5 */</span>
<span class="p">}</span>

<span class="cp">#undef ZERO</span>
<span class="cp">#define ZERO(reg) writel(0, port_mmio + (reg))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_reset_hc_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
					<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">mv_reset_channel</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x028</span><span class="p">);</span>		<span class="cm">/* command */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x101f</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CFG</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x004</span><span class="p">);</span>		<span class="cm">/* timer */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x008</span><span class="p">);</span>		<span class="cm">/* irq err cause */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x00c</span><span class="p">);</span>		<span class="cm">/* irq err mask */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x010</span><span class="p">);</span>		<span class="cm">/* rq bah */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x014</span><span class="p">);</span>		<span class="cm">/* rq inp */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x018</span><span class="p">);</span>		<span class="cm">/* rq outp */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x01c</span><span class="p">);</span>		<span class="cm">/* respq bah */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x024</span><span class="p">);</span>		<span class="cm">/* respq outp */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x020</span><span class="p">);</span>		<span class="cm">/* respq inp */</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x02c</span><span class="p">);</span>		<span class="cm">/* test control */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x800</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_IORDY_TMOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#undef ZERO</span>

<span class="cp">#define ZERO(reg) writel(0, hc_mmio + (reg))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_reset_one_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x00c</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x010</span><span class="p">);</span>
	<span class="n">ZERO</span><span class="p">(</span><span class="mh">0x014</span><span class="p">);</span>

<span class="p">}</span>

<span class="cp">#undef ZERO</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_soc_reset_hc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_hc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mv_soc_reset_hc_port</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">mv_soc_reset_one_hc</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_reset_flash</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_reset_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_soc_65n_phy_errata</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">reg</span><span class="p">;</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE3</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span>	<span class="cm">/* SELMUPF (bits 28:27) to 1 */</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">);</span>	<span class="cm">/* SELMUPI (bits 30:29) to 1 */</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE3</span><span class="p">);</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE4</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x1</span><span class="p">;</span>	<span class="cm">/* SATU_OD8 (bit 0) to 0, reserved bit 16 must be set */</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE4</span><span class="p">);</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE9_GEN2</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>	<span class="cm">/* TXAMP[3:0] (bits 3:0) to 8 */</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="mh">0x8</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">);</span>	<span class="cm">/* TXAMP[4] (bit 14) to 0 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE9_GEN2</span><span class="p">);</span>

	<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE9_GEN1</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">;</span>	<span class="cm">/* TXAMP[3:0] (bits 3:0) to 8 */</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="mh">0x8</span><span class="p">;</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">);</span>	<span class="cm">/* TXAMP[4] (bit 14) to 0 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">PHY_MODE9_GEN1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	soc_is_65 - check if the soc is 65 nano device</span>
<span class="cm"> *</span>
<span class="cm"> *	Detect the type of the SoC, this is done by reading the PHYCFG_OFS</span>
<span class="cm"> *	register, this register should contain non-zero value and it exists only</span>
<span class="cm"> *	in the 65 nano devices, when reading it from older devices we get 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">soc_is_65n</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port0_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">port0_mmio</span> <span class="o">+</span> <span class="n">PHYCFG_OFS</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_setup_ifcfg</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_gen2i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ifcfg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFCFG</span><span class="p">);</span>

	<span class="n">ifcfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifcfg</span> <span class="o">&amp;</span> <span class="mh">0xf7f</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x9b1000</span><span class="p">;</span>	<span class="cm">/* from chip spec */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">want_gen2i</span><span class="p">)</span>
		<span class="n">ifcfg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>		<span class="cm">/* enable gen2i speed */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">ifcfg</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFCFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_reset_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port_no</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The datasheet warns against setting EDMA_RESET when EDMA is active</span>
<span class="cm">	 * (but doesn&#39;t say what the problem might be).  So we first try</span>
<span class="cm">	 * to disable the EDMA engine before doing the EDMA_RESET operation.</span>
<span class="cm">	 */</span>
	<span class="n">mv_stop_edma_engine</span><span class="p">(</span><span class="n">port_mmio</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">EDMA_RESET</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CMD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Enable 3.0gb/s link speed: this survives EDMA_RESET */</span>
		<span class="n">mv_setup_ifcfg</span><span class="p">(</span><span class="n">port_mmio</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Strobing EDMA_RESET here causes a hard reset of the SATA transport,</span>
<span class="cm">	 * link, and physical layers.  It resets all SATA interface registers</span>
<span class="cm">	 * (except for SATA_IFCFG), and issues a COMRESET to the dev.</span>
<span class="cm">	 */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">EDMA_RESET</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CMD</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>	<span class="cm">/* allow reset propagation */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CMD</span><span class="p">);</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">phy_errata</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">,</span> <span class="n">port_no</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_pmp_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pmp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sata_pmp_supported</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFCTL</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="n">pmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">)</span> <span class="o">|</span> <span class="n">pmp</span><span class="p">;</span>
			<span class="n">writelfl</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SATA_IFCTL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_pmp_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mv_pmp_select</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="n">sata_srst_pmp</span><span class="p">(</span><span class="n">link</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">sata_std_hardreset</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mv_pmp_select</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="n">sata_srst_pmp</span><span class="p">(</span><span class="n">link</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ata_sff_softreset</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_port_priv</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sstatus</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">online</span><span class="p">;</span>

	<span class="n">mv_reset_channel</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MV_PP_FLAG_EDMA_EN</span><span class="p">;</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_flags</span> <span class="o">&amp;=</span>
	  <span class="o">~</span><span class="p">(</span><span class="n">MV_PP_FLAG_FBS_EN</span> <span class="o">|</span> <span class="n">MV_PP_FLAG_NCQ_EN</span> <span class="o">|</span> <span class="n">MV_PP_FLAG_FAKE_ATA_BUSY</span><span class="p">);</span>

	<span class="cm">/* Workaround for errata FEr SATA#10 (part 2) */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timing</span> <span class="o">=</span>
				<span class="n">sata_ehc_deb_timing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_link_hardreset</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">deadline</span> <span class="o">+</span> <span class="n">extra</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">online</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">online</span> <span class="o">?</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">:</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="n">sata_scr_read</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">SCR_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sstatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">attempts</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">sstatus</span> <span class="o">==</span> <span class="mh">0x121</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Force 1.5gb/s link speed and try again */</span>
			<span class="n">mv_setup_ifcfg</span><span class="p">(</span><span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span>
				<span class="n">extra</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span> <span class="cm">/* only extend it once, max */</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sstatus</span> <span class="o">!=</span> <span class="mh">0x0</span> <span class="o">&amp;&amp;</span> <span class="n">sstatus</span> <span class="o">!=</span> <span class="mh">0x113</span> <span class="o">&amp;&amp;</span> <span class="n">sstatus</span> <span class="o">!=</span> <span class="mh">0x123</span><span class="p">);</span>
	<span class="n">mv_save_cached_regs</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">mv_edma_cfg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_eh_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mv_stop_edma</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">mv_enable_port_irqs</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_eh_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hardport</span> <span class="o">=</span> <span class="n">mv_hardport_from_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base_from_port</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_ap_base</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">hc_irq_cause</span><span class="p">;</span>

	<span class="cm">/* clear EDMA errors on this port */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_ERR_IRQ_CAUSE</span><span class="p">);</span>

	<span class="cm">/* clear pending irq events */</span>
	<span class="n">hc_irq_cause</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">DEV_IRQ</span> <span class="o">|</span> <span class="n">DMA_IRQ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">hardport</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">hc_irq_cause</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_CAUSE</span><span class="p">);</span>

	<span class="n">mv_enable_port_irqs</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ERR_IRQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_port_init - Perform some early initialization on a single port.</span>
<span class="cm"> *      @port: libata data structure storing shadow register addresses</span>
<span class="cm"> *      @port_mmio: base address of the port</span>
<span class="cm"> *</span>
<span class="cm"> *      Initialize shadow register mmio addresses, clear outstanding</span>
<span class="cm"> *      interrupts on the port, and unmask interrupts for the future</span>
<span class="cm"> *      start of the port.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_port_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>  <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">serr</span><span class="p">,</span> <span class="o">*</span><span class="n">shd_base</span> <span class="o">=</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">SHD_BLK</span><span class="p">;</span>

	<span class="cm">/* PIO related setup</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">data_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_REG_DATA</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">error_addr</span> <span class="o">=</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">feature_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_REG_ERR</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">nsect_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_REG_NSECT</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">lbal_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_REG_LBAL</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">lbam_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_REG_LBAM</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">lbah_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_REG_LBAH</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">device_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_REG_DEVICE</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">=</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">command_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">ATA_REG_STATUS</span><span class="p">);</span>
	<span class="cm">/* special case: control/altstatus doesn&#39;t have ATA_REG_ address */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">altstatus_addr</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ctl_addr</span> <span class="o">=</span> <span class="n">shd_base</span> <span class="o">+</span> <span class="n">SHD_CTL_AST</span><span class="p">;</span>

	<span class="cm">/* Clear any currently outstanding port interrupt conditions */</span>
	<span class="n">serr</span> <span class="o">=</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">mv_scr_offset</span><span class="p">(</span><span class="n">SCR_ERROR</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">serr</span><span class="p">),</span> <span class="n">serr</span><span class="p">);</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_ERR_IRQ_CAUSE</span><span class="p">);</span>

	<span class="cm">/* unmask all non-transient EDMA error interrupts */</span>
	<span class="n">writelfl</span><span class="p">(</span><span class="o">~</span><span class="n">EDMA_ERR_IRQ_TRANSIENT</span><span class="p">,</span> <span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_ERR_IRQ_MASK</span><span class="p">);</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;EDMA cfg=0x%08x EDMA IRQ err cause/mask=0x%08x/0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_CFG</span><span class="p">),</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_ERR_IRQ_CAUSE</span><span class="p">),</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">port_mmio</span> <span class="o">+</span> <span class="n">EDMA_ERR_IRQ_MASK</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mv_in_pcix_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SOC</span><span class="p">(</span><span class="n">hpriv</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">IS_PCIE</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* not PCI-X capable */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_MODE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">MV_PCI_MODE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* conventional PCI mode */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* chip is in PCI-X mode */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_pci_cut_through_okay</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mv_in_pcix_mode</span><span class="p">(</span><span class="n">host</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_COMMAND</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">MV_PCI_COMMAND_MRDTRIG</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* not okay */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* okay */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_60x1b2_errata_pci7</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="cm">/* workaround for 60x1-B2 errata PCI#7 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mv_in_pcix_mode</span><span class="p">(</span><span class="n">host</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_COMMAND</span><span class="p">);</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MV_PCI_COMMAND_MWRCOM</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">MV_PCI_COMMAND</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_chip_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">board_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hp_flags</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">board_idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">chip_5080</span>:
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv5xxx_ops</span><span class="p">;</span>
		<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_GEN_I</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x1</span>:
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_50XXB0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x3</span>:
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_50XXB2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Applying 50XXB2 workarounds to unknown rev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_50XXB2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">chip_504x</span>:
	<span class="k">case</span> <span class="n">chip_508x</span>:
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv5xxx_ops</span><span class="p">;</span>
		<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_GEN_I</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x0</span>:
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_50XXB0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x3</span>:
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_50XXB2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Applying B2 workarounds to unknown rev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_50XXB2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">chip_604x</span>:
	<span class="k">case</span> <span class="n">chip_608x</span>:
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv6xxx_ops</span><span class="p">;</span>
		<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_GEN_II</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x7</span>:
			<span class="n">mv_60x1b2_errata_pci7</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_60X1B2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x9</span>:
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_60X1C0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Applying B2 workarounds to unknown rev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_60X1B2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">chip_7042</span>:
		<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_PCIE</span> <span class="o">|</span> <span class="n">MV_HP_CUT_THROUGH</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_TTI</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="mh">0x2300</span> <span class="o">||</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="mh">0x2310</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Highpoint RocketRAID PCIe 23xx series cards:</span>
<span class="cm">			 *</span>
<span class="cm">			 * Unconfigured drives are treated as &quot;Legacy&quot;</span>
<span class="cm">			 * by the BIOS, and it overwrites sector 8 with</span>
<span class="cm">			 * a &quot;Lgcy&quot; metadata block prior to Linux boot.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Configured drives (RAID or JBOD) leave sector 8</span>
<span class="cm">			 * alone, but instead overwrite a high numbered</span>
<span class="cm">			 * sector for the RAID metadata.  This sector can</span>
<span class="cm">			 * be determined exactly, by truncating the physical</span>
<span class="cm">			 * drive capacity to a nice even GB value.</span>
<span class="cm">			 *</span>
<span class="cm">			 * RAID metadata is at: (dev-&gt;n_sectors &amp; ~0xfffff)</span>
<span class="cm">			 *</span>
<span class="cm">			 * Warn the user, lest they think we&#39;re just buggy.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: Highpoint RocketRAID&quot;</span>
				<span class="s">&quot; BIOS CORRUPTS DATA on all attached drives,&quot;</span>
				<span class="s">&quot; regardless of if/how they are configured.&quot;</span>
				<span class="s">&quot; BEWARE!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: For data safety, do not&quot;</span>
				<span class="s">&quot; use sectors 8-9 on </span><span class="se">\&quot;</span><span class="s">Legacy</span><span class="se">\&quot;</span><span class="s"> drives,&quot;</span>
				<span class="s">&quot; and avoid the final two gigabytes on&quot;</span>
				<span class="s">&quot; all RocketRAID BIOS initialized drives.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* drop through */</span>
	<span class="k">case</span> <span class="n">chip_6042</span>:
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv6xxx_ops</span><span class="p">;</span>
		<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_GEN_IIE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">board_idx</span> <span class="o">==</span> <span class="n">chip_6042</span> <span class="o">&amp;&amp;</span> <span class="n">mv_pci_cut_through_okay</span><span class="p">(</span><span class="n">host</span><span class="p">))</span>
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_CUT_THROUGH</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x2</span>: <span class="cm">/* Rev.B0: the first/only public release */</span>
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_60X1C0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Applying 60X1C0 workarounds to unknown rev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_ERRATA_60X1C0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">chip_soc</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">soc_is_65n</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
			<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_soc_65n_ops</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mv_soc_ops</span><span class="p">;</span>
		<span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_FLAG_SOC</span> <span class="o">|</span> <span class="n">MV_HP_GEN_IIE</span> <span class="o">|</span>
			<span class="n">MV_HP_ERRATA_60X1C0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG: invalid board index %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">board_idx</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">=</span> <span class="n">hp_flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hp_flags</span> <span class="o">&amp;</span> <span class="n">MV_HP_PCIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_cause_offset</span>	<span class="o">=</span> <span class="n">PCIE_IRQ_CAUSE</span><span class="p">;</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_mask_offset</span>	<span class="o">=</span> <span class="n">PCIE_IRQ_MASK</span><span class="p">;</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">unmask_all_irqs</span>	<span class="o">=</span> <span class="n">PCIE_UNMASK_ALL_IRQS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_cause_offset</span>	<span class="o">=</span> <span class="n">PCI_IRQ_CAUSE</span><span class="p">;</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_mask_offset</span>	<span class="o">=</span> <span class="n">PCI_IRQ_MASK</span><span class="p">;</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">unmask_all_irqs</span>	<span class="o">=</span> <span class="n">PCI_UNMASK_ALL_IRQS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_init_host - Perform some early initialization of the host.</span>
<span class="cm"> *	@host: ATA host to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *      If possible, do an early global reset of the host.  Then do</span>
<span class="cm"> *      our port init and clear/unmask all/relevant host interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_init_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_hc</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">hc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">mv_chip_id</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">board_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SOC</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_cause_addr</span> <span class="o">=</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">SOC_HC_MAIN_IRQ_CAUSE</span><span class="p">;</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask_addr</span>  <span class="o">=</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">SOC_HC_MAIN_IRQ_MASK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_cause_addr</span> <span class="o">=</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">PCI_HC_MAIN_IRQ_CAUSE</span><span class="p">;</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask_addr</span>  <span class="o">=</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">PCI_HC_MAIN_IRQ_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize shadow irq mask with register&#39;s value */</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">main_irq_mask_addr</span><span class="p">);</span>

	<span class="cm">/* global interrupt mask: 0 == mask everything */</span>
	<span class="n">mv_set_main_irq_mask</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">n_hc</span> <span class="o">=</span> <span class="n">mv_get_hc_count</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_preamp</span><span class="p">)</span>
			<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_preamp</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">mmio</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">reset_hc</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">,</span> <span class="n">n_hc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">reset_flash</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">);</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">reset_bus</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">mmio</span><span class="p">);</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable_leds</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">mmio</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

		<span class="n">mv_port_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">,</span> <span class="n">port_mmio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">hc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hc</span> <span class="o">&lt;</span> <span class="n">n_hc</span><span class="p">;</span> <span class="n">hc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">hc_mmio</span> <span class="o">=</span> <span class="n">mv_hc_base</span><span class="p">(</span><span class="n">mmio</span><span class="p">,</span> <span class="n">hc</span><span class="p">);</span>

		<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;HC%i: HC config=0x%08x HC IRQ cause &quot;</span>
			<span class="s">&quot;(before clear)=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hc</span><span class="p">,</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_CFG</span><span class="p">),</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_CAUSE</span><span class="p">));</span>

		<span class="cm">/* Clear any currently outstanding hc interrupt conditions */</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hc_mmio</span> <span class="o">+</span> <span class="n">HC_IRQ_CAUSE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_SOC</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Clear any currently outstanding host interrupt conditions */</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_cause_offset</span><span class="p">);</span>

		<span class="cm">/* and unmask interrupt generation for host regs */</span>
		<span class="n">writelfl</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">unmask_all_irqs</span><span class="p">,</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">irq_mask_offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * enable only global host interrupts for now.</span>
<span class="cm">	 * The per-port interrupts get done later as ports are set up.</span>
<span class="cm">	 */</span>
	<span class="n">mv_set_main_irq_mask</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PCI_ERR</span><span class="p">);</span>
	<span class="n">mv_set_irq_coalescing</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">irq_coalescing_io_count</span><span class="p">,</span>
				    <span class="n">irq_coalescing_usecs</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_create_dma_pools</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">crqb_pool</span>   <span class="o">=</span> <span class="n">dmam_pool_create</span><span class="p">(</span><span class="s">&quot;crqb_q&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">MV_CRQB_Q_SZ</span><span class="p">,</span>
							     <span class="n">MV_CRQB_Q_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">crqb_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">crpb_pool</span>   <span class="o">=</span> <span class="n">dmam_pool_create</span><span class="p">(</span><span class="s">&quot;crpb_q&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">MV_CRPB_Q_SZ</span><span class="p">,</span>
							     <span class="n">MV_CRPB_Q_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">crpb_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">sg_tbl_pool</span> <span class="o">=</span> <span class="n">dmam_pool_create</span><span class="p">(</span><span class="s">&quot;sg_tbl&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">MV_SG_TBL_SZ</span><span class="p">,</span>
							     <span class="n">MV_SG_TBL_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">sg_tbl_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_conf_mbus_windows</span><span class="p">(</span><span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">mbus_dram_target_info</span> <span class="o">*</span><span class="n">dram</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">WINDOW_CTRL</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">WINDOW_BASE</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dram</span><span class="o">-&gt;</span><span class="n">num_cs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">mbus_dram_window</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">dram</span><span class="o">-&gt;</span><span class="n">cs</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">writel</span><span class="p">(((</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">mbus_attr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">dram</span><span class="o">-&gt;</span><span class="n">mbus_dram_target_id</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">WINDOW_CTRL</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">WINDOW_BASE</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_platform_probe - handle a positive probe of an soc Marvell</span>
<span class="cm"> *      host</span>
<span class="cm"> *      @pdev: platform device found</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_platform_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mv_sata_platform_data</span> <span class="o">*</span><span class="n">mv_platform_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mbus_dram_target_info</span> <span class="o">*</span><span class="n">dram</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="n">ppi</span><span class="p">[]</span> <span class="o">=</span>
	    <span class="p">{</span> <span class="o">&amp;</span><span class="n">mv_port_info</span><span class="p">[</span><span class="n">chip_soc</span><span class="p">],</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_ports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_HAVE_CLK)</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">ata_print_version_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Simple resource validation ..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">num_resources</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid number of resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the register base first</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* allocate host */</span>
	<span class="n">mv_platform_data</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="n">n_ports</span> <span class="o">=</span> <span class="n">mv_platform_data</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">ata_host_alloc_pinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="n">n_ports</span><span class="p">);</span>
	<span class="n">hpriv</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hpriv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span> <span class="o">||</span> <span class="o">!</span><span class="n">hpriv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_HAVE_CLK)</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_ports</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">hpriv</span><span class="p">;</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">n_ports</span> <span class="o">=</span> <span class="n">n_ports</span><span class="p">;</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">board_idx</span> <span class="o">=</span> <span class="n">chip_soc</span><span class="p">;</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">iomap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">devm_ioremap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				   <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">-=</span> <span class="n">SATAHC0_REG_BASE</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_HAVE_CLK)</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span>
		<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot get optional clkdev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clk_prepare_enable</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">port_number</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">port_number</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">port_number</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]))</span>
			<span class="n">clk_prepare_enable</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * (Re-)program MBUS remapping windows if we are asked to.</span>
<span class="cm">	 */</span>
	<span class="n">dram</span> <span class="o">=</span> <span class="n">mv_mbus_dram_info</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dram</span><span class="p">)</span>
		<span class="n">mv_conf_mbus_windows</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">dram</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">mv_create_dma_pools</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* initialize adapter */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mv_init_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;slots %u ports %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">MV_MAX_Q_DEPTH</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_host_activate</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mv_interrupt</span><span class="p">,</span>
			       <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mv6_sht</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
<span class="cp">#if defined(CONFIG_HAVE_CLK)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clk_disable_unprepare</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">clk_disable_unprepare</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]);</span>
			<span class="n">clk_put</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *      mv_platform_remove    -       unplug a platform interface</span>
<span class="cm"> *      @pdev: platform device</span>
<span class="cm"> *</span>
<span class="cm"> *      A platform bus SATA device has been unplugged. Perform the needed</span>
<span class="cm"> *      cleanup. Also called on module unload for any active devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">mv_platform_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_HAVE_CLK)</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">ata_host_detach</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_HAVE_CLK)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clk_disable_unprepare</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="n">clk_put</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">clk_disable_unprepare</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]);</span>
			<span class="n">clk_put</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">port_clks</span><span class="p">[</span><span class="n">port</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_platform_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ata_host_suspend</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_platform_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mbus_dram_target_info</span> <span class="o">*</span><span class="n">dram</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * (Re-)program MBUS remapping windows if we are asked to.</span>
<span class="cm">		 */</span>
		<span class="n">dram</span> <span class="o">=</span> <span class="n">mv_mbus_dram_info</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dram</span><span class="p">)</span>
			<span class="n">mv_conf_mbus_windows</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="n">dram</span><span class="p">);</span>

		<span class="cm">/* initialize adapter */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mv_init_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: Error during HW init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ata_host_resume</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define mv_platform_suspend NULL</span>
<span class="cp">#define mv_platform_resume NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">mv_platform_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>			<span class="o">=</span> <span class="n">mv_platform_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>			<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">mv_platform_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span>		<span class="o">=</span> <span class="n">mv_platform_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>			<span class="o">=</span> <span class="n">mv_platform_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>			<span class="o">=</span> <span class="p">{</span>
				   <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
				   <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
				  <span class="p">},</span>
<span class="p">};</span>


<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_pci_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_pci_device_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">mv_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>		<span class="o">=</span> <span class="n">mv_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>			<span class="o">=</span> <span class="n">mv_pci_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>			<span class="o">=</span> <span class="n">ata_pci_remove_one</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span>		<span class="o">=</span> <span class="n">ata_pci_device_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>			<span class="o">=</span> <span class="n">mv_pci_device_resume</span><span class="p">,</span>
<span class="cp">#endif</span>

<span class="p">};</span>

<span class="cm">/* move to PCI layer or libata core? */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_go_64</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;64-bit DMA enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;32-bit DMA enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;32-bit consistent DMA enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_print_info - Dump key info to kernel log for perusal.</span>
<span class="cm"> *      @host: ATA host to print info about</span>
<span class="cm"> *</span>
<span class="cm"> *      FIXME: complete this.</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mv_print_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">scc</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scc_s</span><span class="p">,</span> <span class="o">*</span><span class="n">gen</span><span class="p">;</span>

	<span class="cm">/* Use this to determine the HW stepping of the chip so we know</span>
<span class="cm">	 * what errata to workaround</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CLASS_DEVICE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scc_s</span> <span class="o">=</span> <span class="s">&quot;SCSI&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scc</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span>
		<span class="n">scc_s</span> <span class="o">=</span> <span class="s">&quot;RAID&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">scc_s</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="n">gen</span> <span class="o">=</span> <span class="s">&quot;I&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_II</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="n">gen</span> <span class="o">=</span> <span class="s">&quot;II&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_GEN_IIE</span><span class="p">(</span><span class="n">hpriv</span><span class="p">))</span>
		<span class="n">gen</span> <span class="o">=</span> <span class="s">&quot;IIE&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">gen</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Gen-%s %u slots %u ports %s mode IRQ via %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">gen</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">MV_MAX_Q_DEPTH</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">,</span>
		 <span class="n">scc_s</span><span class="p">,</span> <span class="p">(</span><span class="n">MV_HP_FLAG_MSI</span> <span class="o">&amp;</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;MSI&quot;</span> <span class="o">:</span> <span class="s">&quot;INTx&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      mv_pci_init_one - handle a positive probe of a PCI Marvell host</span>
<span class="cm"> *      @pdev: PCI device found</span>
<span class="cm"> *      @ent: PCI device ID entry for the matched host</span>
<span class="cm"> *</span>
<span class="cm"> *      LOCKING:</span>
<span class="cm"> *      Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_pci_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">board_idx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="n">ppi</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">mv_port_info</span><span class="p">[</span><span class="n">board_idx</span><span class="p">],</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mv_host_priv</span> <span class="o">*</span><span class="n">hpriv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n_ports</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ata_print_version_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">);</span>

	<span class="cm">/* allocate host */</span>
	<span class="n">n_ports</span> <span class="o">=</span> <span class="n">mv_get_hc_count</span><span class="p">(</span><span class="n">ppi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">*</span> <span class="n">MV_PORTS_PER_HC</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">ata_host_alloc_pinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="n">n_ports</span><span class="p">);</span>
	<span class="n">hpriv</span> <span class="o">=</span> <span class="n">devm_kzalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hpriv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span> <span class="o">||</span> <span class="o">!</span><span class="n">hpriv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">hpriv</span><span class="p">;</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">n_ports</span> <span class="o">=</span> <span class="n">n_ports</span><span class="p">;</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">board_idx</span> <span class="o">=</span> <span class="n">board_idx</span><span class="p">;</span>

	<span class="cm">/* acquire resources */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcim_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcim_iomap_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">MV_PRIMARY_BAR</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
		<span class="n">pcim_pin_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">iomap</span> <span class="o">=</span> <span class="n">pcim_iomap_table</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iomap</span><span class="p">[</span><span class="n">MV_PRIMARY_BAR</span><span class="p">];</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_go_64</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">mv_create_dma_pools</span><span class="p">(</span><span class="n">hpriv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">port_mmio</span> <span class="o">=</span> <span class="n">mv_port_base</span><span class="p">(</span><span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">port_mmio</span> <span class="o">-</span> <span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

		<span class="n">ata_port_pbar_desc</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">MV_PRIMARY_BAR</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;mmio&quot;</span><span class="p">);</span>
		<span class="n">ata_port_pbar_desc</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">MV_PRIMARY_BAR</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="s">&quot;port&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* initialize adapter */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mv_init_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Enable message-switched interrupts, if requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msi</span> <span class="o">&amp;&amp;</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hpriv</span><span class="o">-&gt;</span><span class="n">hp_flags</span> <span class="o">|=</span> <span class="n">MV_HP_FLAG_MSI</span><span class="p">;</span>

	<span class="n">mv_dump_pci_cfg</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x68</span><span class="p">);</span>
	<span class="n">mv_print_info</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_try_set_mwi</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ata_host_activate</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">mv_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				 <span class="n">IS_GEN_I</span><span class="p">(</span><span class="n">hpriv</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">mv5_sht</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">mv6_sht</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mv_pci_device_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_device_do_resume</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* initialize adapter */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">mv_init_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ata_host_resume</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mv_platform_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="n">mv_platform_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mv_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mv_platform_driver</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mv_pci_driver</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">mv_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mv_pci_driver</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mv_platform_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Brett Russ&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SCSI low-level driver for Marvell SATA controllers&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">mv_pci_tbl</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:&quot;</span> <span class="n">DRV_NAME</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">mv_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">mv_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
