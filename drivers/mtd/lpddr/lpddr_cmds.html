<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › lpddr › lpddr_cmds.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpddr_cmds.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * LPDDR flash memory device operations. This module provides read, write,</span>
<span class="cm"> * erase, lock/unlock support for LPDDR flash memories</span>
<span class="cm"> * (C) 2008 Korolev Alexey &lt;akorolev@infradead.org&gt;</span>
<span class="cm"> * (C) 2008 Vasiliy Leonenko &lt;vasiliy.leonenko@gmail.com&gt;</span>
<span class="cm"> * Many thanks to Roman Borisov for initial enabling</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version 2</span>
<span class="cm"> * of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> * TODO:</span>
<span class="cm"> * Implement VPP management</span>
<span class="cm"> * Implement XIP support</span>
<span class="cm"> * Implement OTP support</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/mtd/pfow.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/qinfo.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lpddr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpddr_write_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpddr_writev</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vecs</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpddr_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpddr_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpddr_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpddr_point</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">mtdbuf</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpddr_unpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">get_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">chip_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">put_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="nf">lpddr_cmdset</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip_shared</span> <span class="o">*</span><span class="n">shared</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numchips</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">mtd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mtd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Failed to allocate memory for MTD device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">MTD_NORFLASH</span><span class="p">;</span>

	<span class="cm">/* Fill in the default mtd operations */</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read</span> <span class="o">=</span> <span class="n">lpddr_read</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">MTD_NORFLASH</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MTD_CAP_NORFLASH</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MTD_BIT_WRITEABLE</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_erase</span> <span class="o">=</span> <span class="n">lpddr_erase</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write</span> <span class="o">=</span> <span class="n">lpddr_write_buffers</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_writev</span> <span class="o">=</span> <span class="n">lpddr_writev</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">lpddr_lock</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_unlock</span> <span class="o">=</span> <span class="n">lpddr_unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_is_linear</span><span class="p">(</span><span class="n">map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_point</span> <span class="o">=</span> <span class="n">lpddr_point</span><span class="p">;</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_unpoint</span> <span class="o">=</span> <span class="n">lpddr_unpoint</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">DevSizeShift</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">UniformBlockSizeShift</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">BufSizeShift</span><span class="p">;</span>

	<span class="n">shared</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">flchip_shared</span><span class="p">)</span> <span class="o">*</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shared</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lpddr</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">numchips</span> <span class="o">=</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="o">/</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">HWPartsNum</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numchips</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shared</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">writing</span> <span class="o">=</span> <span class="n">shared</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">erasing</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">HWPartsNum</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shared</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="cm">/* those should be reset too since</span>
<span class="cm">			   they create memory references. */</span>
			<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
			<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mtd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lpddr_cmdset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_for_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chip_op_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeo</span><span class="p">,</span> <span class="n">reset_timeo</span><span class="p">,</span> <span class="n">sleep_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dsr</span><span class="p">;</span>
	<span class="n">flstate_t</span> <span class="n">chip_state</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set our timeout to 8 times the expected delay */</span>
	<span class="n">timeo</span> <span class="o">=</span> <span class="n">chip_op_time</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
		<span class="n">timeo</span> <span class="o">=</span> <span class="mi">500000</span><span class="p">;</span>
	<span class="n">reset_timeo</span> <span class="o">=</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="n">sleep_time</span> <span class="o">=</span> <span class="n">chip_op_time</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">dsr</span> <span class="o">=</span> <span class="n">CMDVAL</span><span class="p">(</span><span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">pfow_base</span> <span class="o">+</span> <span class="n">PFOW_DSR</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_READY_STATUS</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Flash timeout error state %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chip_state</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* OK Still waiting. Drop the lock, wait a while and retry. */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sleep_time</span> <span class="o">&gt;=</span> <span class="mi">1000000</span><span class="o">/</span><span class="n">HZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Half of the normal delay still remaining</span>
<span class="cm">			 * can be performed with a sleeping delay instead</span>
<span class="cm">			 * of busy waiting.</span>
<span class="cm">			 */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="o">/</span><span class="mi">1000</span><span class="p">);</span>
			<span class="n">timeo</span> <span class="o">-=</span> <span class="n">sleep_time</span><span class="p">;</span>
			<span class="n">sleep_time</span> <span class="o">=</span> <span class="mi">1000000</span><span class="o">/</span><span class="n">HZ</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">timeo</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">chip_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Someone&#39;s suspended the operation: sleep */</span>
			<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">||</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">write_suspended</span><span class="p">)</span>  <span class="p">{</span>
			<span class="cm">/* Suspend has occurred while sleep: reset timeout */</span>
			<span class="n">timeo</span> <span class="o">=</span> <span class="n">reset_timeo</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">write_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* check status for errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear DSR*/</span>
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">DSR_ERR</span><span class="p">)),</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">pfow_base</span> <span class="o">+</span> <span class="n">PFOW_DSR</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;%s: Bad status on wait: 0x%x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dsr</span><span class="p">);</span>
		<span class="n">print_drs_error</span><span class="p">(</span><span class="n">dsr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

 <span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FL_WRITING</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">FL_ERASING</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_SYNCING</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * OK. We have possibility for contension on the write/erase</span>
<span class="cm">		 * operations which are global to the real chip and not per</span>
<span class="cm">		 * partition.  So let&#39;s fight it over in the partition which</span>
<span class="cm">		 * currently has authority on the operation.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The rules are as follows:</span>
<span class="cm">		 *</span>
<span class="cm">		 * - any write operation must own shared-&gt;writing.</span>
<span class="cm">		 *</span>
<span class="cm">		 * - any erase operation must own _both_ shared-&gt;writing and</span>
<span class="cm">		 *   shared-&gt;erasing.</span>
<span class="cm">		 *</span>
<span class="cm">		 * - contension arbitration is handled in the owner&#39;s context.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The &#39;shared&#39; struct can be read and/or written only when</span>
<span class="cm">		 * its lock is taken.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">flchip_shared</span> <span class="o">*</span><span class="n">shared</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">contender</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">contender</span> <span class="o">=</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">contender</span> <span class="o">&amp;&amp;</span> <span class="n">contender</span> <span class="o">!=</span> <span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The engine to perform desired operation on this</span>
<span class="cm">			 * partition is already in use by someone else.</span>
<span class="cm">			 * Let&#39;s fight over it in the context of the chip</span>
<span class="cm">			 * currently using it.  If it is possible to suspend,</span>
<span class="cm">			 * that other partition will do just that, otherwise</span>
<span class="cm">			 * it&#39;ll happily send us to sleep.  In any case, when</span>
<span class="cm">			 * get_chip returns success we&#39;re clear to go ahead.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contender</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">contender</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contender</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contender</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="cm">/* We should not own chip if it is already in FL_SYNCING</span>
<span class="cm">			 * state. Put contender and retry. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FL_SYNCING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">contender</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contender</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contender</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Check if we have suspended erase on this chip.</span>
<span class="cm">		   Must sleep in such a case. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FL_ERASING</span> <span class="o">&amp;&amp;</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">erasing</span>
		    <span class="o">&amp;&amp;</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">erasing</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">FL_ERASING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We now own it */</span>
		<span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FL_ERASING</span><span class="p">)</span>
			<span class="n">shared</span><span class="o">-&gt;</span><span class="n">erasing</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">chip_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="cm">/* Prevent setting state FL_SYNCING for chip in suspended state. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">FL_SYNCING</span> <span class="o">==</span> <span class="n">mode</span> <span class="o">&amp;&amp;</span> <span class="n">FL_READY</span> <span class="o">!=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sleep</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FL_READY</span>:
	<span class="k">case</span> <span class="n">FL_JEDEC_QUERY</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FL_ERASING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">SuspEraseSupp</span> <span class="o">||</span>
			<span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FL_READY</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">FL_POINT</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">sleep</span><span class="p">;</span>

		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="n">LPDDR_SUSPEND</span><span class="p">),</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">pfow_base</span> <span class="o">+</span> <span class="n">PFOW_PROGRAM_ERASE_SUSPEND</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">FL_ERASING</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_ERASE_SUSPENDING</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Oops. something got wrong. */</span>
			<span class="cm">/* Resume and pretend we weren&#39;t here.  */</span>
			<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: suspend operation failed.&quot;</span>
					<span class="s">&quot;State may be wrong </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Erase suspend */</span>
	<span class="k">case</span> <span class="n">FL_POINT</span>:
		<span class="cm">/* Only if there&#39;s no operation suspended... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FL_READY</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">FL_READY</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
<span class="nl">sleep:</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">flchip_shared</span> <span class="o">*</span><span class="n">shared</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">==</span> <span class="n">chip</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">FL_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We own the ability to write, but we&#39;re done */</span>
			<span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">=</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">erasing</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">&amp;&amp;</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">!=</span> <span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* give back the ownership */</span>
				<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">loaner</span> <span class="o">=</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span><span class="p">;</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loaner</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">loaner</span><span class="p">);</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loaner</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">shared</span><span class="o">-&gt;</span><span class="n">erasing</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">erasing</span> <span class="o">==</span> <span class="n">chip</span> <span class="o">&amp;&amp;</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">writing</span> <span class="o">!=</span> <span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We own the ability to erase without the ability</span>
<span class="cm">			 * to write, which means the erase was suspended</span>
<span class="cm">			 * and some other partition is currently writing.</span>
<span class="cm">			 * Don&#39;t let the switch below mess things up since</span>
<span class="cm">			 * we don&#39;t have ownership to resume anything.</span>
<span class="cm">			 */</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FL_ERASING</span>:
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="n">LPDDR_RESUME</span><span class="p">),</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">pfow_base</span> <span class="o">+</span> <span class="n">PFOW_COMMAND_CODE</span><span class="p">);</span>
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="n">LPDDR_START_EXECUTION</span><span class="p">),</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">pfow_base</span> <span class="o">+</span> <span class="n">PFOW_COMMAND_EXECUTE</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_ERASING</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FL_READY</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: put_chip() called with oldstate %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_write_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">**</span><span class="n">pvec</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pvec_seek</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="n">map_word</span> <span class="n">datum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">wbufsize</span><span class="p">,</span> <span class="n">word_gap</span><span class="p">,</span> <span class="n">words</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vec_seek</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prog_buf_ofs</span><span class="p">;</span>

	<span class="n">wbufsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">BufSizeShift</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">FL_WRITING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Figure out the number of words to write */</span>
	<span class="n">word_gap</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">adr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">words</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">word_gap</span> <span class="o">+</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">word_gap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">words</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">word_gap</span> <span class="o">=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">-</span> <span class="n">word_gap</span><span class="p">;</span>
		<span class="n">adr</span> <span class="o">-=</span> <span class="n">word_gap</span><span class="p">;</span>
		<span class="n">datum</span> <span class="o">=</span> <span class="n">map_word_ff</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Write data */</span>
	<span class="cm">/* Get the program buffer offset from PFOW register data first*/</span>
	<span class="n">prog_buf_ofs</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">pfow_base</span> <span class="o">+</span> <span class="n">CMDVAL</span><span class="p">(</span><span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">pfow_base</span> <span class="o">+</span> <span class="n">PFOW_PROGRAM_BUFFER_OFFSET</span><span class="p">));</span>
	<span class="n">vec</span> <span class="o">=</span> <span class="o">*</span><span class="n">pvec</span><span class="p">;</span>
	<span class="n">vec_seek</span> <span class="o">=</span> <span class="o">*</span><span class="n">pvec_seek</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">-</span> <span class="n">word_gap</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">vec_seek</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">vec_seek</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">word_gap</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)))</span>
			<span class="n">datum</span> <span class="o">=</span> <span class="n">map_word_ff</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>

		<span class="n">datum</span> <span class="o">=</span> <span class="n">map_word_load_partial</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">datum</span><span class="p">,</span>
				<span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">vec_seek</span><span class="p">,</span> <span class="n">word_gap</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">word_gap</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">||</span> <span class="n">word_gap</span> <span class="o">==</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">datum</span><span class="p">,</span> <span class="n">prog_buf_ofs</span><span class="p">);</span>
			<span class="n">prog_buf_ofs</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
			<span class="n">word_gap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vec_seek</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vec_seek</span> <span class="o">==</span> <span class="n">vec</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vec</span><span class="o">++</span><span class="p">;</span>
			<span class="n">vec_seek</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pvec</span> <span class="o">=</span> <span class="n">vec</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pvec_seek</span> <span class="o">=</span> <span class="n">vec_seek</span><span class="p">;</span>

	<span class="cm">/* GO GO GO */</span>
	<span class="n">send_pfow_command</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">LPDDR_BUFF_PROGRAM</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">wbufsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_WRITING</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">ProgBufferTime</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;%s Buffer program error: %d at %lx; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">out:</span>	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_erase_oneblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">FL_ERASING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">send_pfow_command</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">LPDDR_BLOCK_ERASE</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_ERASING</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">BlockEraseTime</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;%s Erase block error %d at : %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpddr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">FL_READY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">map_copy_from</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpddr_point</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">mtdbuf</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">last_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* ofs: offset within the first chip that the first read should start */</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">-</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>
	<span class="o">*</span><span class="n">mtdbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thislen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&gt;=</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* We cannot point across chips that are virtually disjoint */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_end</span><span class="p">)</span>
			<span class="n">last_end</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">!=</span> <span class="n">last_end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">+</span> <span class="n">ofs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span>
			<span class="n">thislen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">thislen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="cm">/* get the chip */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">FL_POINT</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_POINT</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ref_point_counter</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">retlen</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">thislen</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">last_end</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
		<span class="n">chipnum</span><span class="o">++</span><span class="p">;</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpddr_unpoint</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="cm">/* ofs: offset within the first chip that the first read should start */</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">-</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thislen</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

		<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&gt;=</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">+</span> <span class="n">ofs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span>
			<span class="n">thislen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">thislen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FL_POINT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ref_point_counter</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ref_point_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Warning: unpoint called on non&quot;</span>
					<span class="s">&quot;pointed region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">thislen</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chipnum</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpddr_write_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="n">vec</span><span class="p">;</span>

	<span class="n">vec</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">vec</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">lpddr_writev</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">retlen</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpddr_writev</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vecs</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">vec_seek</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wbufsize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">BufSizeShift</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">vecs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">chipnum</span> <span class="o">=</span> <span class="n">to</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>

	<span class="n">ofs</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">vec_seek</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* We must not cross write block boundaries */</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">wbufsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wbufsize</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_write_buffer</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span>
					  <span class="n">ofs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vecs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec_seek</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">retlen</span><span class="p">)</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>

		<span class="cm">/* Be nice and reschedule with the chip in a usable</span>
<span class="cm">		 * state for other processes */</span>
		<span class="n">cond_resched</span><span class="p">();</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpddr_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">UniformBlockSizeShift</span><span class="p">;</span>

	<span class="n">ofs</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_erase_oneblock</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_DONE</span><span class="p">;</span>
	<span class="n">mtd_erase_callback</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DO_XXLOCK_LOCK		1</span>
<span class="cp">#define DO_XXLOCK_UNLOCK	2</span>
<span class="kt">int</span> <span class="nf">do_xxlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">];</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">FL_LOCKING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thunk</span> <span class="o">==</span> <span class="n">DO_XXLOCK_LOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_pfow_command</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">LPDDR_LOCK_BLOCK</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">adr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_LOCKING</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">thunk</span> <span class="o">==</span> <span class="n">DO_XXLOCK_UNLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_pfow_command</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">LPDDR_UNLOCK_BLOCK</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">adr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_UNLOCKING</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: block unlock error status %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpddr_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_xxlock</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">DO_XXLOCK_LOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpddr_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_xxlock</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">DO_XXLOCK_UNLOCK</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">word_program</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">curval</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpddr_private</span> <span class="o">*</span><span class="n">lpddr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">&gt;&gt;</span> <span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">];</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">FL_WRITING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">send_pfow_command</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">LPDDR_WORD_PROGRAM</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="p">(</span><span class="n">map_word</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">curval</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">lpddr</span><span class="o">-&gt;</span><span class="n">qinfo</span><span class="o">-&gt;</span><span class="n">SingleWordProgTime</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;%s word_program error at: %llx; val: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">curval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Alexey Korolev &lt;akorolev@infradead.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MTD driver for LPDDR flash chips&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
