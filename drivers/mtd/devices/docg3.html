<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › devices › docg3.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>docg3.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Handles the M-Systems DiskOnChip G3 chip</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Robert Jarzmik</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/partitions.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/bitrev.h&gt;</span>
<span class="cp">#include &lt;linux/bch.h&gt;</span>

<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &quot;docg3.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * This driver handles the DiskOnChip G3 flash memory.</span>
<span class="cm"> *</span>
<span class="cm"> * As no specification is available from M-Systems/Sandisk, this drivers lacks</span>
<span class="cm"> * several functions available on the chip, as :</span>
<span class="cm"> *  - IPL write</span>
<span class="cm"> *</span>
<span class="cm"> * The bus data width (8bits versus 16bits) is not handled (if_cfg flag), and</span>
<span class="cm"> * the driver assumes a 16bits data bus.</span>
<span class="cm"> *</span>
<span class="cm"> * DocG3 relies on 2 ECC algorithms, which are handled in hardware :</span>
<span class="cm"> *  - a 1 byte Hamming code stored in the OOB for each page</span>
<span class="cm"> *  - a 7 bytes BCH code stored in the OOB for each page</span>
<span class="cm"> * The BCH ECC is :</span>
<span class="cm"> *  - BCH is in GF(2^14)</span>
<span class="cm"> *  - BCH is over data of 520 bytes (512 page + 7 page_info bytes</span>
<span class="cm"> *                                   + 1 hamming byte)</span>
<span class="cm"> *  - BCH can correct up to 4 bits (t = 4)</span>
<span class="cm"> *  - BCH syndroms are calculated in hardware, and checked in hardware as well</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reliable_mode</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">reliable_mode</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">reliable_mode</span><span class="p">,</span> <span class="s">&quot;Set the docg3 mode (0=normal MLC, 1=fast, &quot;</span>
		 <span class="s">&quot;2=reliable) : MLC normal operations are in normal mode&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct docg3_oobinfo - DiskOnChip G3 OOB layout</span>
<span class="cm"> * @eccbytes: 8 bytes are used (1 for Hamming ECC, 7 for BCH ECC)</span>
<span class="cm"> * @eccpos: ecc positions (byte 7 is Hamming ECC, byte 8-14 are BCH ECC)</span>
<span class="cm"> * @oobfree: free pageinfo bytes (byte 0 until byte 6, byte 15</span>
<span class="cm"> * @oobavail: 8 available bytes remaining after ECC toll</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="n">docg3_oobinfo</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">eccbytes</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eccpos</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">},</span>
	<span class="p">.</span><span class="n">oobfree</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">oobavail</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">doc_readb</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">val</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">trace_docg3_io</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">doc_readw</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">val</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">trace_docg3_io</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">doc_writeb</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">trace_docg3_io</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">doc_writew</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">trace_docg3_io</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">doc_flash_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">DOC_FLASHCOMMAND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">doc_flash_sequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u8</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">DOC_FLASHSEQUENCE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">doc_flash_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">DOC_FLASHADDRESS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">part_probes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;cmdlinepart&quot;</span><span class="p">,</span> <span class="s">&quot;saftlpart&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_register_readb</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">DOC_READADDRESS</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">doc_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">doc_vdbg</span><span class="p">(</span><span class="s">&quot;Read register %04x : %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_register_readw</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">DOC_READADDRESS</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">doc_readw</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">doc_vdbg</span><span class="p">(</span><span class="s">&quot;Read register %04x : %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_delay - delay docg3 operations</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @nbNOPs: the number of NOPs to issue</span>
<span class="cm"> *</span>
<span class="cm"> * As no specification is available, the right timings between chip commands are</span>
<span class="cm"> * unknown. The only available piece of information are the observed nops on a</span>
<span class="cm"> * working docg3 chip.</span>
<span class="cm"> * Therefore, doc_delay relies on a busy loop of NOPs, instead of scheduler</span>
<span class="cm"> * friendlier msleep() functions or blocking mdelay().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_delay</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbNOPs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">doc_vdbg</span><span class="p">(</span><span class="s">&quot;NOP x %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nbNOPs</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbNOPs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DOC_NOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_prot_seq_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctrl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DOC_CTRL_PROTECTION_ERROR</span> <span class="o">|</span> <span class="n">DOC_CTRL_SEQUENCE_ERROR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_is_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">DOC_CTRL_FLASHREADY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_wait_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">maxWaitCycles</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">doc_is_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">maxWaitCycles</span><span class="o">--</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxWaitCycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_reset_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
	<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_RESET</span><span class="p">);</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_RESET</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_wait_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_reset_seq() -&gt; isReady=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span> <span class="o">?</span> <span class="s">&quot;false&quot;</span> <span class="o">:</span> <span class="s">&quot;true&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_read_data_area - Read data from data area</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @buf: the buffer to fill in (might be NULL is dummy reads)</span>
<span class="cm"> * @len: the length to read</span>
<span class="cm"> * @first: first time read, DOC_READADDRESS should be set</span>
<span class="cm"> *</span>
<span class="cm"> * Reads bytes from flash data. Handles the single byte / even bytes reads.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_read_data_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">first</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cdr</span><span class="p">,</span> <span class="n">len4</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data16</span><span class="p">,</span> <span class="o">*</span><span class="n">dst16</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">data8</span><span class="p">,</span> <span class="o">*</span><span class="n">dst8</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_read_data_area(buf=%p, len=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">cdr</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">len4</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">cdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
		<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_IOSPACE_DATA</span><span class="p">,</span> <span class="n">DOC_READADDRESS</span><span class="p">);</span>
	<span class="n">dst16</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len4</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data16</span> <span class="o">=</span> <span class="n">doc_readw</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_IOSPACE_DATA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dst16</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">dst16</span> <span class="o">=</span> <span class="n">data16</span><span class="p">;</span>
			<span class="n">dst16</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_IOSPACE_DATA</span> <span class="o">|</span> <span class="n">DOC_READADDR_ONE_BYTE</span><span class="p">,</span>
			   <span class="n">DOC_READADDRESS</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dst8</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">dst16</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cdr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data8</span> <span class="o">=</span> <span class="n">doc_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_IOSPACE_DATA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dst8</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">dst8</span> <span class="o">=</span> <span class="n">data8</span><span class="p">;</span>
				<span class="n">dst8</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_write_data_area - Write data into data area</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @buf: the buffer to get input bytes from</span>
<span class="cm"> * @len: the length to write</span>
<span class="cm"> *</span>
<span class="cm"> * Writes bytes into flash data. Handles the single byte / even bytes writes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_write_data_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cdr</span><span class="p">,</span> <span class="n">len4</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">src16</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">src8</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_write_data_area(buf=%p, len=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">cdr</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">len4</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">cdr</span><span class="p">;</span>

	<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_IOSPACE_DATA</span><span class="p">,</span> <span class="n">DOC_READADDRESS</span><span class="p">);</span>
	<span class="n">src16</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len4</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="o">*</span><span class="n">src16</span><span class="p">,</span> <span class="n">DOC_IOSPACE_DATA</span><span class="p">);</span>
		<span class="n">src16</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">src8</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">src16</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cdr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_IOSPACE_DATA</span> <span class="o">|</span> <span class="n">DOC_READADDR_ONE_BYTE</span><span class="p">,</span>
			   <span class="n">DOC_READADDRESS</span><span class="p">);</span>
		<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="o">*</span><span class="n">src8</span><span class="p">,</span> <span class="n">DOC_IOSPACE_DATA</span><span class="p">);</span>
		<span class="n">src8</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_set_data_mode - Sets the flash to normal or reliable data mode</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> *</span>
<span class="cm"> * The reliable data mode is a bit slower than the fast mode, but less errors</span>
<span class="cm"> * occur.  Entering the reliable mode cannot be done without entering the fast</span>
<span class="cm"> * mode first.</span>
<span class="cm"> *</span>
<span class="cm"> * In reliable mode, pages 2*n and 2*n+1 are clones. Writing to page 0 of blocks</span>
<span class="cm"> * (4,5) make the hardware write also to page 1 of blocks blocks(4,5). Reading</span>
<span class="cm"> * from page 0 of blocks (4,5) or from page 1 of blocks (4,5) gives the same</span>
<span class="cm"> * result, which is a logical and between bytes from page 0 and page 1 (which is</span>
<span class="cm"> * consistent with the fact that writing to a page is _clearing_ bits of that</span>
<span class="cm"> * page).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_set_reliable_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strmode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;normal&quot;</span><span class="p">,</span> <span class="s">&quot;fast&quot;</span><span class="p">,</span> <span class="s">&quot;reliable&quot;</span><span class="p">,</span> <span class="s">&quot;invalid&quot;</span> <span class="p">};</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_set_reliable_mode(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strmode</span><span class="p">[</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span><span class="p">]);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_SET_FASTMODE</span><span class="p">);</span>
		<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_FAST_MODE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_SET_RELIABLEMODE</span><span class="p">);</span>
		<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_FAST_MODE</span><span class="p">);</span>
		<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_RELIABLE_MODE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">doc_err</span><span class="p">(</span><span class="s">&quot;doc_set_reliable_mode(): invalid mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_set_asic_mode - Set the ASIC mode</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @mode: the mode</span>
<span class="cm"> *</span>
<span class="cm"> * The ASIC can work in 3 modes :</span>
<span class="cm"> *  - RESET: all registers are zeroed</span>
<span class="cm"> *  - NORMAL: receives and handles commands</span>
<span class="cm"> *  - POWERDOWN: minimal poweruse, flash parts shut off</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_set_asic_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">doc_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_IOSPACE_IPL</span><span class="p">);</span>

	<span class="n">mode</span> <span class="o">|=</span> <span class="n">DOC_ASICMODE_MDWREN</span><span class="p">;</span>
	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_set_asic_mode(%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">DOC_ASICMODE</span><span class="p">);</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="o">~</span><span class="n">mode</span><span class="p">,</span> <span class="n">DOC_ASICMODECONFIRM</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_set_device_id - Sets the devices id for cascaded G3 chips</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @id: the chip to select (amongst 0, 1, 2, 3)</span>
<span class="cm"> *</span>
<span class="cm"> * There can be 4 cascaded G3 chips. This function selects the one which will</span>
<span class="cm"> * should be the active one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_set_device_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_set_device_id(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">DOC_DEVICESELECT</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DOC_CTRL_VIOLATION</span><span class="p">;</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">DOC_CTRL_CE</span><span class="p">;</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_set_extra_page_mode - Change flash page layout</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> *</span>
<span class="cm"> * Normally, the flash page is split into the data (512 bytes) and the out of</span>
<span class="cm"> * band data (16 bytes). For each, 4 more bytes can be accessed, where the wear</span>
<span class="cm"> * leveling counters are stored.  To access this last area of 4 bytes, a special</span>
<span class="cm"> * mode must be input to the flash ASIC.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if no error occurred, -EIO else.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_set_extra_page_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fctrl</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_set_extra_page_mode()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_PAGE_SIZE_532</span><span class="p">);</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PAGE_SIZE_532</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">fctrl</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fctrl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DOC_CTRL_PROTECTION_ERROR</span> <span class="o">|</span> <span class="n">DOC_CTRL_SEQUENCE_ERROR</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_setup_addr_sector - Setup blocks/page/ofs address for one plane</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @sector: the sector</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_setup_addr_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sector</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">doc_flash_address</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">sector</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">doc_flash_address</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">doc_flash_address</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_setup_writeaddr_sector - Setup blocks/page/ofs address for one plane</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @sector: the sector</span>
<span class="cm"> * @ofs: the offset in the page, between 0 and (512 + 16 + 512)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_setup_writeaddr_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">doc_flash_address</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">doc_flash_address</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">sector</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">doc_flash_address</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">doc_flash_address</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_seek - Set both flash planes to the specified block, page for reading</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @block0: the first plane block index</span>
<span class="cm"> * @block1: the second plane block index</span>
<span class="cm"> * @page: the page index within the block</span>
<span class="cm"> * @wear: if true, read will occur on the 4 extra bytes of the wear area</span>
<span class="cm"> * @ofs: offset in page to read</span>
<span class="cm"> *</span>
<span class="cm"> * Programs the flash even and odd planes to the specific block and page.</span>
<span class="cm"> * Alternatively, programs the flash to the wear area of the specified page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read_seek</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">wear</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sector</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_seek(blocks=(%d,%d), page=%d, ofs=%d, wear=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">wear</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wear</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_SET_PLANE1</span><span class="p">);</span>
		<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_READ_PLANE1</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_SET_PLANE2</span><span class="p">);</span>
		<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_READ_PLANE2</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">doc_set_reliable_mode</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wear</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_set_extra_page_mode</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_READ</span><span class="p">);</span>
	<span class="n">sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">block0</span> <span class="o">&lt;&lt;</span> <span class="n">DOC_ADDR_BLOCK_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;</span> <span class="n">DOC_ADDR_PAGE_MASK</span><span class="p">);</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PROG_BLOCK_ADDR</span><span class="p">);</span>
	<span class="n">doc_setup_addr_sector</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">sector</span><span class="p">);</span>

	<span class="n">sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">block1</span> <span class="o">&lt;&lt;</span> <span class="n">DOC_ADDR_BLOCK_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;</span> <span class="n">DOC_ADDR_PAGE_MASK</span><span class="p">);</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PROG_BLOCK_ADDR</span><span class="p">);</span>
	<span class="n">doc_setup_addr_sector</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">sector</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_write_seek - Set both flash planes to the specified block, page for writing</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @block0: the first plane block index</span>
<span class="cm"> * @block1: the second plane block index</span>
<span class="cm"> * @page: the page index within the block</span>
<span class="cm"> * @ofs: offset in page to write</span>
<span class="cm"> *</span>
<span class="cm"> * Programs the flash even and odd planes to the specific block and page.</span>
<span class="cm"> * Alternatively, programs the flash to the wear area of the specified page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write_seek</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sector</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_write_seek(blocks=(%d,%d), page=%d, ofs=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>

	<span class="n">doc_set_reliable_mode</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_SET_PLANE1</span><span class="p">);</span>
		<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_READ_PLANE1</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_SET_PLANE2</span><span class="p">);</span>
		<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_READ_PLANE2</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_PAGE_SETUP</span><span class="p">);</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PROG_CYCLE1</span><span class="p">);</span>

	<span class="n">sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">block0</span> <span class="o">&lt;&lt;</span> <span class="n">DOC_ADDR_BLOCK_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;</span> <span class="n">DOC_ADDR_PAGE_MASK</span><span class="p">);</span>
	<span class="n">doc_setup_writeaddr_sector</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>

	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PROG_CYCLE3</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_wait_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PROG_CYCLE1</span><span class="p">);</span>
	<span class="n">sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">block1</span> <span class="o">&lt;&lt;</span> <span class="n">DOC_ADDR_BLOCK_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;</span> <span class="n">DOC_ADDR_PAGE_MASK</span><span class="p">);</span>
	<span class="n">doc_setup_writeaddr_sector</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * doc_read_page_ecc_init - Initialize hardware ECC engine</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @len: the number of bytes covered by the ECC (BCH covered)</span>
<span class="cm"> *</span>
<span class="cm"> * The function does initialize the hardware ECC engine to compute the Hamming</span>
<span class="cm"> * ECC (on 1 byte) and the BCH hardware ECC (on 7 bytes).</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if succeeded, -EIO on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read_page_ecc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ECCCONF0_READ_MODE</span>
		   <span class="o">|</span> <span class="n">DOC_ECCCONF0_BCH_ENABLE</span> <span class="o">|</span> <span class="n">DOC_ECCCONF0_HAMMING_ENABLE</span>
		   <span class="o">|</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">DOC_ECCCONF0_DATA_BYTES_MASK</span><span class="p">),</span>
		   <span class="n">DOC_ECCCONF0</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">doc_wait_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_write_page_ecc_init - Initialize hardware BCH ECC engine</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @len: the number of bytes covered by the ECC (BCH covered)</span>
<span class="cm"> *</span>
<span class="cm"> * The function does initialize the hardware ECC engine to compute the Hamming</span>
<span class="cm"> * ECC (on 1 byte) and the BCH hardware ECC (on 7 bytes).</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if succeeded, -EIO on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write_page_ecc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ECCCONF0_WRITE_MODE</span>
		   <span class="o">|</span> <span class="n">DOC_ECCCONF0_BCH_ENABLE</span> <span class="o">|</span> <span class="n">DOC_ECCCONF0_HAMMING_ENABLE</span>
		   <span class="o">|</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="n">DOC_ECCCONF0_DATA_BYTES_MASK</span><span class="p">),</span>
		   <span class="n">DOC_ECCCONF0</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">doc_wait_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_ecc_disable - Disable Hamming and BCH ECC hardware calculator</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> *</span>
<span class="cm"> * Disables the hardware ECC generator and checker, for unchecked reads (as when</span>
<span class="cm"> * reading OOB only or write status byte).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_ecc_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_writew</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ECCCONF0_READ_MODE</span><span class="p">,</span> <span class="n">DOC_ECCCONF0</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_hamming_ecc_init - Initialize hardware Hamming ECC engine</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @nb_bytes: the number of bytes covered by the ECC (Hamming covered)</span>
<span class="cm"> *</span>
<span class="cm"> * This function programs the ECC hardware to compute the hamming code on the</span>
<span class="cm"> * last provided N bytes to the hardware generator.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_hamming_ecc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ecc_conf1</span><span class="p">;</span>

	<span class="n">ecc_conf1</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ECCCONF1</span><span class="p">);</span>
	<span class="n">ecc_conf1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DOC_ECCCONF1_HAMMING_BITS_MASK</span><span class="p">;</span>
	<span class="n">ecc_conf1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">nb_bytes</span> <span class="o">&amp;</span> <span class="n">DOC_ECCCONF1_HAMMING_BITS_MASK</span><span class="p">);</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">ecc_conf1</span><span class="p">,</span> <span class="n">DOC_ECCCONF1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_ecc_bch_fix_data - Fix if need be read data from flash</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @buf: the buffer of read data (512 + 7 + 1 bytes)</span>
<span class="cm"> * @hwecc: the hardware calculated ECC.</span>
<span class="cm"> *         It&#39;s in fact recv_ecc ^ calc_ecc, where recv_ecc was read from OOB</span>
<span class="cm"> *         area data, and calc_ecc the ECC calculated by the hardware generator.</span>
<span class="cm"> *</span>
<span class="cm"> * Checks if the received data matches the ECC, and if an error is detected,</span>
<span class="cm"> * tries to fix the bit flips (at most 4) in the buffer buf.  As the docg3</span>
<span class="cm"> * understands the (data, ecc, syndroms) in an inverted order in comparison to</span>
<span class="cm"> * the BCH library, the function reverses the order of bits (ie. bit7 and bit0,</span>
<span class="cm"> * bit6 and bit 1, ...) for all ECC data.</span>
<span class="cm"> *</span>
<span class="cm"> * The hardware ecc unit produces oob_ecc ^ calc_ecc.  The kernel&#39;s bch</span>
<span class="cm"> * algorithm is used to decode this.  However the hw operates on page</span>
<span class="cm"> * data in a bit order that is the reverse of that of the bch alg,</span>
<span class="cm"> * requiring that the bits be reversed on the result.  Thanks to Ivan</span>
<span class="cm"> * Djelic for his analysis.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns number of fixed bits (0, 1, 2, 3, 4) or -EBADMSG if too many bit</span>
<span class="cm"> * errors were detected and cannot be fixed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_ecc_bch_fix_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hwecc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ecc</span><span class="p">[</span><span class="n">DOC_ECC_BCH_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">errorpos</span><span class="p">[</span><span class="n">DOC_ECC_BCH_T</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">numerrs</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DOC_ECC_BCH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ecc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitrev8</span><span class="p">(</span><span class="n">hwecc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">numerrs</span> <span class="o">=</span> <span class="n">decode_bch</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">bch</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			     <span class="n">DOC_ECC_BCH_COVERED_BYTES</span><span class="p">,</span>
			     <span class="nb">NULL</span><span class="p">,</span> <span class="n">ecc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">errorpos</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">numerrs</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numerrs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numerrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">errorpos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">errorpos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">7</span> <span class="o">-</span> <span class="p">(</span><span class="n">errorpos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numerrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">errorpos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">DOC_ECC_BCH_COVERED_BYTES</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
			<span class="cm">/* error is located in data, correct it */</span>
			<span class="n">change_bit</span><span class="p">(</span><span class="n">errorpos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">buf</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_ecc_bch_fix_data: flipped %d bits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">numerrs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">numerrs</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * doc_read_page_prepare - Prepares reading data from a flash page</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @block0: the first plane block index on flash memory</span>
<span class="cm"> * @block1: the second plane block index on flash memory</span>
<span class="cm"> * @page: the page index in the block</span>
<span class="cm"> * @offset: the offset in the page (must be a multiple of 4)</span>
<span class="cm"> *</span>
<span class="cm"> * Prepares the page to be read in the flash memory :</span>
<span class="cm"> *   - tell ASIC to map the flash pages</span>
<span class="cm"> *   - tell ASIC to be in read mode</span>
<span class="cm"> *</span>
<span class="cm"> * After a call to this method, a call to doc_read_page_finish is mandatory,</span>
<span class="cm"> * to end the read cycle of the flash.</span>
<span class="cm"> *</span>
<span class="cm"> * Read data from a flash page. The length to be read must be between 0 and</span>
<span class="cm"> * (page_size + oob_size + wear_size), ie. 532, and a multiple of 4 (because</span>
<span class="cm"> * the extra bytes reading is not implemented).</span>
<span class="cm"> *</span>
<span class="cm"> * As pages are grouped by 2 (in 2 planes), reading from a page must be done</span>
<span class="cm"> * in two steps:</span>
<span class="cm"> *  - one read of 512 bytes at offset 0</span>
<span class="cm"> *  - one read of 512 bytes at offset 512 + 16</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, -EIO if a read error occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read_page_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block1</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">wear_area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_read_page_prepare(blocks=(%d,%d), page=%d, ofsInPage=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">DOC_LAYOUT_WEAR_OFFSET</span><span class="p">)</span>
		<span class="n">wear_area</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wear_area</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">DOC_LAYOUT_PAGE_OOB_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_reset_seq</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Program the flash address block and page */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_seek</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">wear_area</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_READ_ALL_PLANES</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">doc_wait_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>

	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_SET_ADDR_READ</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
	<span class="n">doc_flash_address</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">doc_wait_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>

	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_READ_FLASH</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DOC_DATAEND</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_read_page_getbytes - Reads bytes from a prepared page</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @len: the number of bytes to be read (must be a multiple of 4)</span>
<span class="cm"> * @buf: the buffer to be filled in (or NULL is forget bytes)</span>
<span class="cm"> * @first: 1 if first time read, DOC_READADDRESS should be set</span>
<span class="cm"> * @last_odd: 1 if last read ended up on an odd byte</span>
<span class="cm"> *</span>
<span class="cm"> * Reads bytes from a prepared page. There is a trickery here : if the last read</span>
<span class="cm"> * ended up on an odd offset in the 1024 bytes double page, ie. between the 2</span>
<span class="cm"> * planes, the first byte must be read apart. If a word (16bit) read was used,</span>
<span class="cm"> * the read would return the byte of plane 2 as low *and* high endian, which</span>
<span class="cm"> * will mess the read.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read_page_getbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_odd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_odd</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc_read_data_area</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
		<span class="n">doc_read_data_area</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">buf</span> <span class="o">?</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">doc_read_data_area</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_write_page_putbytes - Writes bytes into a prepared page</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @len: the number of bytes to be written</span>
<span class="cm"> * @buf: the buffer of input bytes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_write_page_putbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_write_data_area</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_get_bch_hw_ecc - Get hardware calculated BCH ECC</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @hwecc:  the array of 7 integers where the hardware ecc will be stored</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_get_bch_hw_ecc</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hwecc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DOC_ECC_BCH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hwecc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_BCH_HW_ECC</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_page_finish - Ends reading/writing of a flash page</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_page_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DOC_DATAEND</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_read_page_finish - Ends reading of a flash page</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> *</span>
<span class="cm"> * As a side effect, resets the chip selector to 0. This ensures that after each</span>
<span class="cm"> * read operation, the floor 0 is selected. Therefore, if the systems halts, the</span>
<span class="cm"> * reboot will boot on floor 0, where the IPL is.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_read_page_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">doc_page_finish</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * calc_block_sector - Calculate blocks, pages and ofs.</span>

<span class="cm"> * @from: offset in flash</span>
<span class="cm"> * @block0: first plane block index calculated</span>
<span class="cm"> * @block1: second plane block index calculated</span>
<span class="cm"> * @page: page calculated</span>
<span class="cm"> * @ofs: offset in page</span>
<span class="cm"> * @reliable: 0 if docg3 in normal mode, 1 if docg3 in fast mode, 2 if docg3 in</span>
<span class="cm"> * reliable mode.</span>
<span class="cm"> *</span>
<span class="cm"> * The calculation is based on the reliable/normal mode. In normal mode, the 64</span>
<span class="cm"> * pages of a block are available. In reliable mode, as pages 2*n and 2*n+1 are</span>
<span class="cm"> * clones, only 32 pages per block are available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">calc_block_sector</span><span class="p">(</span><span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">block0</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">block1</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="o">*</span><span class="n">ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reliable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uint</span> <span class="n">sector</span><span class="p">,</span> <span class="n">pages_biblock</span><span class="p">;</span>

	<span class="n">pages_biblock</span> <span class="o">=</span> <span class="n">DOC_LAYOUT_PAGES_PER_BLOCK</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_NBPLANES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reliable</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">reliable</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">pages_biblock</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">sector</span> <span class="o">=</span> <span class="n">from</span> <span class="o">/</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
	<span class="o">*</span><span class="n">block0</span> <span class="o">=</span> <span class="n">sector</span> <span class="o">/</span> <span class="n">pages_biblock</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_NBPLANES</span><span class="p">;</span>
	<span class="o">*</span><span class="n">block1</span> <span class="o">=</span> <span class="o">*</span><span class="n">block0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">sector</span> <span class="o">%</span> <span class="n">pages_biblock</span><span class="p">;</span>
	<span class="o">*</span><span class="n">page</span> <span class="o">/=</span> <span class="n">DOC_LAYOUT_NBPLANES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reliable</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">reliable</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="o">*</span><span class="n">page</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ofs</span> <span class="o">=</span> <span class="n">DOC_LAYOUT_PAGE_OOB_SIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_read_oob - Read out of band bytes from flash</span>
<span class="cm"> * @mtd: the device</span>
<span class="cm"> * @from: the offset from first block and first page, in bytes, aligned on page</span>
<span class="cm"> *        size</span>
<span class="cm"> * @ops: the mtd oob structure</span>
<span class="cm"> *</span>
<span class="cm"> * Reads flash memory OOB area of pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if read successful, of -EIO, -EINVAL if an error occurred</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">oobbuf</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobbuf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">datbuf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">ooblen</span><span class="p">,</span> <span class="n">nbdata</span><span class="p">,</span> <span class="n">nboob</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hwecc</span><span class="p">[</span><span class="n">DOC_ECC_BCH_SIZE</span><span class="p">],</span> <span class="n">eccconf1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_bitflips</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oobbuf</span><span class="p">)</span>
		<span class="n">ooblen</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooblen</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ooblen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oobbuf</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">)</span>
		<span class="n">oobbuf</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooboffs</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_read_oob(from=%lld, mode=%d, data=(%p:%zu), oob=(%p:%zu))</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">from</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">oobbuf</span><span class="p">,</span> <span class="n">ooblen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ooblen</span> <span class="o">%</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobretlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skip</span> <span class="o">=</span> <span class="n">from</span> <span class="o">%</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ooblen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">calc_block_sector</span><span class="p">(</span><span class="n">from</span> <span class="o">-</span> <span class="n">skip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofs</span><span class="p">,</span>
			<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span><span class="p">);</span>
		<span class="n">nbdata</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span> <span class="o">-</span> <span class="n">skip</span><span class="p">);</span>
		<span class="n">nboob</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">ooblen</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_page_prepare</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_page_ecc_init</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ECC_BCH_TOTAL_BYTES</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_in_read</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_page_getbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">skip</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_in_read</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_page_getbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">nbdata</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skip</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">nbdata</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_in_read</span><span class="p">;</span>
		<span class="n">doc_read_page_getbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span>
				       <span class="n">DOC_LAYOUT_PAGE_SIZE</span> <span class="o">-</span> <span class="n">nbdata</span> <span class="o">-</span> <span class="n">skip</span><span class="p">,</span>
				       <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">skip</span> <span class="o">+</span> <span class="n">nbdata</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_page_getbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">nboob</span><span class="p">,</span> <span class="n">oobbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">nboob</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_in_read</span><span class="p">;</span>
		<span class="n">doc_read_page_getbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span> <span class="o">-</span> <span class="n">nboob</span><span class="p">,</span>
				       <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nboob</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">doc_get_bch_hw_ecc</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">hwecc</span><span class="p">);</span>
		<span class="n">eccconf1</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ECCCONF1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nboob</span> <span class="o">&gt;=</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;OOB - INFO: %02x:%02x:%02x:%02x:%02x:%02x:%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">oobbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				<span class="n">oobbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
			<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;OOB - HAMMING: %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
			<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;OOB - BCH_ECC: %02x:%02x:%02x:%02x:%02x:%02x:%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">oobbuf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
				<span class="n">oobbuf</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">14</span><span class="p">]);</span>
			<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;OOB - UNUSED: %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oobbuf</span><span class="p">[</span><span class="mi">15</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;ECC checks: ECCConf1=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">eccconf1</span><span class="p">);</span>
		<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;ECC HW_ECC: %02x:%02x:%02x:%02x:%02x:%02x:%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hwecc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hwecc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hwecc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">hwecc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">hwecc</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			<span class="n">hwecc</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">hwecc</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_prot_seq_error</span><span class="p">(</span><span class="n">docg3</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_in_read</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">block0</span> <span class="o">&gt;=</span> <span class="n">DOC_LAYOUT_BLOCK_FIRST_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">eccconf1</span> <span class="o">&amp;</span> <span class="n">DOC_ECCCONF1_BCH_SYNDROM_ERR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">eccconf1</span> <span class="o">&amp;</span> <span class="n">DOC_ECCCONF1_PAGE_IS_WRITTEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">MTD_OPS_RAW</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">nbdata</span> <span class="o">==</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_ecc_bch_fix_data</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">hwecc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecc_stats</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecc_stats</span><span class="p">.</span><span class="n">corrected</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="n">max_bitflips</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_bitflips</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">max_bitflips</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">doc_read_page_finish</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span> <span class="o">+=</span> <span class="n">nbdata</span><span class="p">;</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobretlen</span> <span class="o">+=</span> <span class="n">nboob</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">nbdata</span><span class="p">;</span>
		<span class="n">oobbuf</span> <span class="o">+=</span> <span class="n">nboob</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">nbdata</span><span class="p">;</span>
		<span class="n">ooblen</span> <span class="o">-=</span> <span class="n">nboob</span><span class="p">;</span>
		<span class="n">from</span> <span class="o">+=</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
		<span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">err_in_read:</span>
	<span class="n">doc_read_page_finish</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_read - Read bytes from flash</span>
<span class="cm"> * @mtd: the device</span>
<span class="cm"> * @from: the offset from first block and first page, in bytes, aligned on page</span>
<span class="cm"> *        size</span>
<span class="cm"> * @len: the number of bytes to read (must be a multiple of 4)</span>
<span class="cm"> * @retlen: the number of bytes actually read</span>
<span class="cm"> * @buf: the filled in buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Reads flash memory pages. This function does not read the OOB chunk, but only</span>
<span class="cm"> * the page data.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if read successful, of -EIO, -EINVAL if an error occurred</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
	     <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="n">ops</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ops</span><span class="p">));</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">datbuf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MTD_OPS_AUTO_OOB</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>
	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">retlen</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_reload_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="n">DOC_LAYOUT_BLOCK_BBT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nbpages</span><span class="p">,</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">bbt</span><span class="p">;</span>

	<span class="n">nbpages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">max_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">page</span> <span class="o">&lt;</span> <span class="n">nbpages</span><span class="p">);</span> <span class="n">page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_page_prepare</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					    <span class="n">page</span> <span class="o">+</span> <span class="n">DOC_LAYOUT_PAGE_BBT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_read_page_ecc_init</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span>
						     <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">doc_read_page_getbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">,</span>
					       <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">doc_read_page_finish</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_block_isbad - Checks whether a block is good or not</span>
<span class="cm"> * @mtd: the device</span>
<span class="cm"> * @from: the offset to find the correct block</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if block is bad, 0 if block is good</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_block_isbad</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">is_good</span><span class="p">;</span>

	<span class="n">calc_block_sector</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofs</span><span class="p">,</span>
		<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span><span class="p">);</span>
	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_block_isbad(from=%lld) =&gt; block=(%d,%d), page=%d, ofs=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">from</span><span class="p">,</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block0</span> <span class="o">&lt;</span> <span class="n">DOC_LAYOUT_BLOCK_FIRST_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block1</span> <span class="o">&gt;</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">max_block</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">is_good</span> <span class="o">=</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">bbt</span><span class="p">[</span><span class="n">block0</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">block0</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">is_good</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/**</span>
<span class="c"> * doc_get_erase_count - Get block erase count</span>
<span class="c"> * @docg3: the device</span>
<span class="c"> * @from: the offset in which the block is.</span>
<span class="c"> *</span>
<span class="c"> * Get the number of times a block was erased. The number is the maximum of</span>
<span class="c"> * erase times between first and second plane (which should be equal normally).</span>
<span class="c"> *</span>
<span class="c"> * Returns The number of erases, or -EINVAL or -EIO on error.</span>
<span class="c"> */</span>
<span class="c">static int doc_get_erase_count(struct docg3 *docg3, loff_t from)</span>
<span class="c">{</span>
<span class="c">	u8 buf[DOC_LAYOUT_WEAR_SIZE];</span>
<span class="c">	int ret, plane1_erase_count, plane2_erase_count;</span>
<span class="c">	int block0, block1, page, ofs;</span>

<span class="c">	doc_dbg(&quot;doc_get_erase_count(from=%lld, buf=%p)\n&quot;, from, buf);</span>
<span class="c">	if (from % DOC_LAYOUT_PAGE_SIZE)</span>
<span class="c">		return -EINVAL;</span>
<span class="c">	calc_block_sector(from, &amp;block0, &amp;block1, &amp;page, &amp;ofs, docg3-&gt;reliable);</span>
<span class="c">	if (block1 &gt; docg3-&gt;max_block)</span>
<span class="c">		return -EINVAL;</span>

<span class="c">	ret = doc_reset_seq(docg3);</span>
<span class="c">	if (!ret)</span>
<span class="c">		ret = doc_read_page_prepare(docg3, block0, block1, page,</span>
<span class="c">					    ofs + DOC_LAYOUT_WEAR_OFFSET, 0);</span>
<span class="c">	if (!ret)</span>
<span class="c">		ret = doc_read_page_getbytes(docg3, DOC_LAYOUT_WEAR_SIZE,</span>
<span class="c">					     buf, 1, 0);</span>
<span class="c">	doc_read_page_finish(docg3);</span>

<span class="c">	if (ret || (buf[0] != DOC_ERASE_MARK) || (buf[2] != DOC_ERASE_MARK))</span>
<span class="c">		return -EIO;</span>
<span class="c">	plane1_erase_count = (u8)(~buf[1]) | ((u8)(~buf[4]) &lt;&lt; 8)</span>
<span class="c">		| ((u8)(~buf[5]) &lt;&lt; 16);</span>
<span class="c">	plane2_erase_count = (u8)(~buf[3]) | ((u8)(~buf[6]) &lt;&lt; 8)</span>
<span class="c">		| ((u8)(~buf[7]) &lt;&lt; 16);</span>

<span class="c">	return max(plane1_erase_count, plane2_erase_count);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * doc_get_op_status - get erase/write operation status</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> *</span>
<span class="cm"> * Queries the status from the chip, and returns it</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the status (bits DOC_PLANES_STATUS_*)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_get_op_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_PLANES_STATUS</span><span class="p">);</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PLANES_STATUS</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

	<span class="n">doc_ecc_disable</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="n">doc_read_data_area</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_write_erase_wait_status - wait for write or erase completion</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for the chip to be ready again after erase or write operation, and check</span>
<span class="cm"> * erase/write status.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if erase successful, -EIO if erase/write issue, -ETIMEOUT if</span>
<span class="cm"> * timeout</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write_erase_wait_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">doc_is_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doc_is_ready</span><span class="p">(</span><span class="n">docg3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;Timeout reached and the chip is still not ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">doc_get_op_status</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">DOC_PLANES_STATUS_FAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;Erase/Write failed on (a) plane(s), status = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">status</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">doc_page_finish</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_erase_block - Erase a couple of blocks</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @block0: the first block to erase (leftmost plane)</span>
<span class="cm"> * @block1: the second block to erase (rightmost plane)</span>
<span class="cm"> *</span>
<span class="cm"> * Erase both blocks, and return operation status</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if erase successful, -EIO if erase issue, -ETIMEOUT if chip not</span>
<span class="cm"> * ready for too long</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_erase_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">sector</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_erase_block(blocks=(%d,%d))</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_reset_seq</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">doc_set_reliable_mode</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="n">doc_flash_sequence</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_SEQ_ERASE</span><span class="p">);</span>

	<span class="n">sector</span> <span class="o">=</span> <span class="n">block0</span> <span class="o">&lt;&lt;</span> <span class="n">DOC_ADDR_BLOCK_SHIFT</span><span class="p">;</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PROG_BLOCK_ADDR</span><span class="p">);</span>
	<span class="n">doc_setup_addr_sector</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">sector</span><span class="p">);</span>
	<span class="n">sector</span> <span class="o">=</span> <span class="n">block1</span> <span class="o">&lt;&lt;</span> <span class="n">DOC_ADDR_BLOCK_SHIFT</span><span class="p">;</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PROG_BLOCK_ADDR</span><span class="p">);</span>
	<span class="n">doc_setup_addr_sector</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">sector</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_ERASECYCLE2</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_prot_seq_error</span><span class="p">(</span><span class="n">docg3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">doc_err</span><span class="p">(</span><span class="s">&quot;Erase blocks %d,%d error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">doc_write_erase_wait_status</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_erase - Erase a portion of the chip</span>
<span class="cm"> * @mtd: the device</span>
<span class="cm"> * @info: the erase info</span>
<span class="cm"> *</span>
<span class="cm"> * Erase a bunch of contiguous blocks, by pairs, as a &quot;mtd&quot; page of 1024 is</span>
<span class="cm"> * split into 2 pages of 512 bytes on 2 contiguous blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if erase successful, -EINVAL if addressing error, -EIO if erase</span>
<span class="cm"> * issue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_erase(from=%lld, len=%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_PENDING</span><span class="p">;</span>
	<span class="n">calc_block_sector</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">||</span> <span class="n">page</span> <span class="o">||</span> <span class="n">ofs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset_err</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">calc_block_sector</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofs</span><span class="p">,</span>
			  <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
	<span class="n">doc_set_reliable_mode</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span> <span class="o">-=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASING</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_erase_block</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">);</span>
		<span class="n">block0</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">block1</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset_err</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_DONE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">reset_err:</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_FAILED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_write_page - Write a single page to the chip</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @to: the offset from first block and first page, in bytes, aligned on page</span>
<span class="cm"> *      size</span>
<span class="cm"> * @buf: buffer to get bytes from</span>
<span class="cm"> * @oob: buffer to get out of band bytes from (can be NULL if no OOB should be</span>
<span class="cm"> *       written)</span>
<span class="cm"> * @autoecc: if 0, all 16 bytes from OOB are taken, regardless of HW Hamming or</span>
<span class="cm"> *           BCH computations. If 1, only bytes 0-7 and byte 15 are taken,</span>
<span class="cm"> *           remaining ones are filled with hardware Hamming and BCH</span>
<span class="cm"> *           computations. Its value is not meaningfull is oob == NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * Write one full page (ie. 1 page split on two planes), of 512 bytes, with the</span>
<span class="cm"> * OOB data. The OOB ECC is automatically computed by the hardware Hamming and</span>
<span class="cm"> * BCH generator if autoecc is not null.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if write successful, -EIO if write error, -EAGAIN if timeout</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">oob</span><span class="p">,</span> <span class="kt">int</span> <span class="n">autoecc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hwecc</span><span class="p">[</span><span class="n">DOC_ECC_BCH_SIZE</span><span class="p">],</span> <span class="n">hamming</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_write_page(to=%lld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="n">calc_block_sector</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span><span class="p">);</span>

	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_reset_seq</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Program the flash address block and page */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_write_seek</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">doc_write_page_ecc_init</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ECC_BCH_TOTAL_BYTES</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">doc_write_page_putbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oob</span> <span class="o">&amp;&amp;</span> <span class="n">autoecc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc_write_page_putbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_PAGEINFO_SZ</span><span class="p">,</span> <span class="n">oob</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">oob</span> <span class="o">+=</span> <span class="n">DOC_LAYOUT_OOB_UNUSED_OFS</span><span class="p">;</span>

		<span class="n">hamming</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_HAMMINGPARITY</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">doc_write_page_putbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_HAMMING_SZ</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">hamming</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">doc_get_bch_hw_ecc</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">hwecc</span><span class="p">);</span>
		<span class="n">doc_write_page_putbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_BCH_SZ</span><span class="p">,</span> <span class="n">hwecc</span><span class="p">);</span>
		<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">doc_write_page_putbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_UNUSED_SZ</span><span class="p">,</span> <span class="n">oob</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oob</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">autoecc</span><span class="p">)</span>
		<span class="n">doc_write_page_putbytes</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">,</span> <span class="n">oob</span><span class="p">);</span>

	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">doc_page_finish</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">doc_flash_command</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CMD_PROG_CYCLE2</span><span class="p">);</span>
	<span class="n">doc_delay</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The wait status will perform another doc_page_finish() call, but that</span>
<span class="cm">	 * seems to please the docg3, so leave it.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_write_erase_wait_status</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">doc_read_page_finish</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_guess_autoecc - Guess autoecc mode from mbd_oob_ops</span>
<span class="cm"> * @ops: the oob operations</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 or 1 if success, -EINVAL if invalid oob mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_guess_autoecc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">autoecc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MTD_OPS_PLACE_OOB</span>:
	<span class="k">case</span> <span class="n">MTD_OPS_AUTO_OOB</span>:
		<span class="n">autoecc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MTD_OPS_RAW</span>:
		<span class="n">autoecc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">autoecc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">autoecc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_fill_autooob - Fill a 16 bytes OOB from 8 non-ECC bytes</span>
<span class="cm"> * @dst: the target 16 bytes OOB buffer</span>
<span class="cm"> * @oobsrc: the source 8 bytes non-ECC OOB buffer</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_fill_autooob</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">oobsrc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">oobsrc</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_PAGEINFO_SZ</span><span class="p">);</span>
	<span class="n">dst</span><span class="p">[</span><span class="n">DOC_LAYOUT_OOB_UNUSED_OFS</span><span class="p">]</span> <span class="o">=</span> <span class="n">oobsrc</span><span class="p">[</span><span class="n">DOC_LAYOUT_OOB_PAGEINFO_SZ</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_backup_oob - Backup OOB into docg3 structure</span>
<span class="cm"> * @docg3: the device</span>
<span class="cm"> * @to: the page offset in the chip</span>
<span class="cm"> * @ops: the OOB size and buffer</span>
<span class="cm"> *</span>
<span class="cm"> * As the docg3 should write a page with its OOB in one pass, and some userland</span>
<span class="cm"> * applications do write_oob() to setup the OOB and then write(), store the OOB</span>
<span class="cm"> * into a temporary storage. This is very dangerous, as 2 concurrent</span>
<span class="cm"> * applications could store an OOB, and then write their pages (which will</span>
<span class="cm"> * result into one having its OOB corrupted).</span>
<span class="cm"> *</span>
<span class="cm"> * The only reliable way would be for userland to call doc_write_oob() with both</span>
<span class="cm"> * the page data _and_ the OOB area.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if success, -EINVAL if ops content invalid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_backup_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ooblen</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooblen</span><span class="p">,</span> <span class="n">autoecc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ooblen</span> <span class="o">!=</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">autoecc</span> <span class="o">=</span> <span class="n">doc_guess_autoecc</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">autoecc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">autoecc</span><span class="p">;</span>

	<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">oob_write_ofs</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">oob_autoecc</span> <span class="o">=</span> <span class="n">autoecc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MTD_OPS_AUTO_OOB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc_fill_autooob</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">oob_write_buf</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobbuf</span><span class="p">);</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobretlen</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">oob_write_buf</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobbuf</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">);</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobretlen</span> <span class="o">=</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_write_oob - Write out of band bytes to flash</span>
<span class="cm"> * @mtd: the device</span>
<span class="cm"> * @ofs: the offset from first block and first page, in bytes, aligned on page</span>
<span class="cm"> *       size</span>
<span class="cm"> * @ops: the mtd oob structure</span>
<span class="cm"> *</span>
<span class="cm"> * Either write OOB data into a temporary buffer, for the subsequent write</span>
<span class="cm"> * page. The provided OOB should be 16 bytes long. If a data buffer is provided</span>
<span class="cm"> * as well, issue the page write.</span>
<span class="cm"> * Or provide data without OOB, and then a all zeroed OOB will be used (ECC will</span>
<span class="cm"> * still be filled in if asked for).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 is successful, EINVAL if length is not 14 bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">autoecc</span><span class="p">,</span> <span class="n">oobdelta</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">oobbuf</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobbuf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">datbuf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">ooblen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">oob</span><span class="p">[</span><span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oobbuf</span><span class="p">)</span>
		<span class="n">ooblen</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooblen</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ooblen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oobbuf</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">)</span>
		<span class="n">oobbuf</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooboffs</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_write_oob(from=%lld, mode=%d, data=(%p:%zu), oob=(%p:%zu))</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ofs</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">oobbuf</span><span class="p">,</span> <span class="n">ooblen</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MTD_OPS_PLACE_OOB</span>:
	<span class="k">case</span> <span class="n">MTD_OPS_RAW</span>:
		<span class="n">oobdelta</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MTD_OPS_AUTO_OOB</span>:
		<span class="n">oobdelta</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecclayout</span><span class="o">-&gt;</span><span class="n">oobavail</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">oobdelta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">%</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ooblen</span> <span class="o">%</span> <span class="n">oobdelta</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ofs</span> <span class="o">%</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">ooblen</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ooblen</span> <span class="o">/</span> <span class="n">oobdelta</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobretlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ooblen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ooblen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">doc_backup_oob</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>

	<span class="n">autoecc</span> <span class="o">=</span> <span class="n">doc_guess_autoecc</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">autoecc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">autoecc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">oob</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">oob</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">==</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">oob_write_ofs</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">oob</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">oob_write_buf</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ooblen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MTD_OPS_AUTO_OOB</span><span class="p">)</span>
			<span class="n">doc_fill_autooob</span><span class="p">(</span><span class="n">oob</span><span class="p">,</span> <span class="n">oobbuf</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ooblen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">oob</span><span class="p">,</span> <span class="n">oobbuf</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_write_page</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">oob</span><span class="p">,</span> <span class="n">autoecc</span><span class="p">);</span>

		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ooblen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oobbuf</span> <span class="o">+=</span> <span class="n">oobdelta</span><span class="p">;</span>
			<span class="n">ooblen</span> <span class="o">-=</span> <span class="n">oobdelta</span><span class="p">;</span>
			<span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobretlen</span> <span class="o">+=</span> <span class="n">oobdelta</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span> <span class="o">+=</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_write - Write a buffer to the chip</span>
<span class="cm"> * @mtd: the device</span>
<span class="cm"> * @to: the offset from first block and first page, in bytes, aligned on page</span>
<span class="cm"> *      size</span>
<span class="cm"> * @len: the number of bytes to write (must be a full page size, ie. 512)</span>
<span class="cm"> * @retlen: the number of bytes actually written (0 or 512)</span>
<span class="cm"> * @buf: the buffer to get bytes from</span>
<span class="cm"> *</span>
<span class="cm"> * Writes data to the chip.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if write successful, -EIO if write error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="n">ops</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;doc_write(to=%lld, len=%zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">datbuf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">oobbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">ooblen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">ooboffs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>
	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">retlen</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="nf">sysfs_dev2docg3</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">floor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">**</span><span class="n">docg3_floors</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">floor</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">floor</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">floor</span> <span class="o">&gt;=</span> <span class="n">DOC_MAX_NBFLOORS</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">docg3_floors</span><span class="p">[</span><span class="n">floor</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dps0_is_key_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">sysfs_dev2docg3</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dps0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
	<span class="n">dps0</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DPS0_STATUS</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">dps0</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_KEY_OK</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dps1_is_key_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">sysfs_dev2docg3</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dps1</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
	<span class="n">dps1</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DPS1_STATUS</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">dps1</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_KEY_OK</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dps0_insert_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">sysfs_dev2docg3</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">DOC_LAYOUT_DPS_KEY_LENGTH</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DOC_LAYOUT_DPS_KEY_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DOC_DPS0_KEY</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dps1_insert_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">sysfs_dev2docg3</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">DOC_LAYOUT_DPS_KEY_LENGTH</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DOC_LAYOUT_DPS_KEY_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DOC_DPS1_KEY</span><span class="p">);</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define FLOOR_SYSFS(id) { \</span>
<span class="cp">	__ATTR(f##id##_dps0_is_keylocked, S_IRUGO, dps0_is_key_locked, NULL), \</span>
<span class="cp">	__ATTR(f##id##_dps1_is_keylocked, S_IRUGO, dps1_is_key_locked, NULL), \</span>
<span class="cp">	__ATTR(f##id##_dps0_protection_key, S_IWUGO, NULL, dps0_insert_key), \</span>
<span class="cp">	__ATTR(f##id##_dps1_protection_key, S_IWUGO, NULL, dps1_insert_key), \</span>
<span class="cp">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">doc_sys_attrs</span><span class="p">[</span><span class="n">DOC_MAX_NBFLOORS</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">FLOOR_SYSFS</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">FLOOR_SYSFS</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">FLOOR_SYSFS</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">FLOOR_SYSFS</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_register_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">docg3_cascade</span> <span class="o">*</span><span class="n">cascade</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">DOC_MAX_NBFLOORS</span> <span class="o">&amp;&amp;</span>
		     <span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="n">floor</span><span class="p">];</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doc_sys_attrs</span><span class="p">[</span><span class="n">floor</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doc_sys_attrs</span><span class="p">[</span><span class="n">floor</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">floor</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_unregister_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">docg3_cascade</span> <span class="o">*</span><span class="n">cascade</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">floor</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">DOC_MAX_NBFLOORS</span> <span class="o">&amp;&amp;</span> <span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="n">floor</span><span class="p">];</span>
	     <span class="n">floor</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">device_remove_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doc_sys_attrs</span><span class="p">[</span><span class="n">floor</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Debug sysfs entries</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_flashctrl_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fctrl</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">fctrl</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
		 <span class="s">&quot;FlashControl : 0x%02x (%s,CE# %s,%s,%s,flash %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">fctrl</span><span class="p">,</span>
		 <span class="n">fctrl</span> <span class="o">&amp;</span> <span class="n">DOC_CTRL_VIOLATION</span> <span class="o">?</span> <span class="s">&quot;protocol violation&quot;</span> <span class="o">:</span> <span class="s">&quot;-&quot;</span><span class="p">,</span>
		 <span class="n">fctrl</span> <span class="o">&amp;</span> <span class="n">DOC_CTRL_CE</span> <span class="o">?</span> <span class="s">&quot;active&quot;</span> <span class="o">:</span> <span class="s">&quot;inactive&quot;</span><span class="p">,</span>
		 <span class="n">fctrl</span> <span class="o">&amp;</span> <span class="n">DOC_CTRL_PROTECTION_ERROR</span> <span class="o">?</span> <span class="s">&quot;protection error&quot;</span> <span class="o">:</span> <span class="s">&quot;-&quot;</span><span class="p">,</span>
		 <span class="n">fctrl</span> <span class="o">&amp;</span> <span class="n">DOC_CTRL_SEQUENCE_ERROR</span> <span class="o">?</span> <span class="s">&quot;sequence error&quot;</span> <span class="o">:</span> <span class="s">&quot;-&quot;</span><span class="p">,</span>
		 <span class="n">fctrl</span> <span class="o">&amp;</span> <span class="n">DOC_CTRL_FLASHREADY</span> <span class="o">?</span> <span class="s">&quot;ready&quot;</span> <span class="o">:</span> <span class="s">&quot;not ready&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEBUGFS_RO_ATTR</span><span class="p">(</span><span class="n">flashcontrol</span><span class="p">,</span> <span class="n">dbg_flashctrl_show</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_asicmode_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pctrl</span><span class="p">,</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">pctrl</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ASICMODE</span><span class="p">);</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">pctrl</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
			 <span class="s">&quot;%04x : RAM_WE=%d,RSTIN_RESET=%d,BDETCT_RESET=%d,WRITE_ENABLE=%d,POWERDOWN=%d,MODE=%d%d (&quot;</span><span class="p">,</span>
			 <span class="n">pctrl</span><span class="p">,</span>
			 <span class="n">pctrl</span> <span class="o">&amp;</span> <span class="n">DOC_ASICMODE_RAM_WE</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="n">pctrl</span> <span class="o">&amp;</span> <span class="n">DOC_ASICMODE_RSTIN_RESET</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="n">pctrl</span> <span class="o">&amp;</span> <span class="n">DOC_ASICMODE_BDETCT_RESET</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="n">pctrl</span> <span class="o">&amp;</span> <span class="n">DOC_ASICMODE_MDWREN</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="n">pctrl</span> <span class="o">&amp;</span> <span class="n">DOC_ASICMODE_POWERDOWN</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="n">mode</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DOC_ASICMODE_RESET</span>:
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DOC_ASICMODE_NORMAL</span>:
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;normal&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DOC_ASICMODE_POWERDOWN</span>:
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;powerdown&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEBUGFS_RO_ATTR</span><span class="p">(</span><span class="n">asic_mode</span><span class="p">,</span> <span class="n">dbg_asicmode_show</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_device_id_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">id</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DEVICESELECT</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;DeviceId = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEBUGFS_RO_ATTR</span><span class="p">(</span><span class="n">device_id</span><span class="p">,</span> <span class="n">dbg_device_id_show</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_protection_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">protect</span><span class="p">,</span> <span class="n">dps0</span><span class="p">,</span> <span class="n">dps0_low</span><span class="p">,</span> <span class="n">dps0_high</span><span class="p">,</span> <span class="n">dps1</span><span class="p">,</span> <span class="n">dps1_low</span><span class="p">,</span> <span class="n">dps1_high</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">protect</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_PROTECTION</span><span class="p">);</span>
	<span class="n">dps0</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DPS0_STATUS</span><span class="p">);</span>
	<span class="n">dps0_low</span> <span class="o">=</span> <span class="n">doc_register_readw</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DPS0_ADDRLOW</span><span class="p">);</span>
	<span class="n">dps0_high</span> <span class="o">=</span> <span class="n">doc_register_readw</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DPS0_ADDRHIGH</span><span class="p">);</span>
	<span class="n">dps1</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DPS1_STATUS</span><span class="p">);</span>
	<span class="n">dps1_low</span> <span class="o">=</span> <span class="n">doc_register_readw</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DPS1_ADDRLOW</span><span class="p">);</span>
	<span class="n">dps1_high</span> <span class="o">=</span> <span class="n">doc_register_readw</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_DPS1_ADDRHIGH</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Protection = 0x%02x (&quot;</span><span class="p">,</span>
			 <span class="n">protect</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protect</span> <span class="o">&amp;</span> <span class="n">DOC_PROTECT_FOUNDRY_OTP_LOCK</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;FOUNDRY_OTP_LOCK,&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protect</span> <span class="o">&amp;</span> <span class="n">DOC_PROTECT_CUSTOMER_OTP_LOCK</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;CUSTOMER_OTP_LOCK,&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protect</span> <span class="o">&amp;</span> <span class="n">DOC_PROTECT_LOCK_INPUT</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;LOCK_INPUT,&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protect</span> <span class="o">&amp;</span> <span class="n">DOC_PROTECT_STICKY_LOCK</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;STICKY_LOCK,&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protect</span> <span class="o">&amp;</span> <span class="n">DOC_PROTECT_PROTECTION_ENABLED</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;PROTECTION ON,&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protect</span> <span class="o">&amp;</span> <span class="n">DOC_PROTECT_IPL_DOWNLOAD_LOCK</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;IPL_DOWNLOAD_LOCK,&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protect</span> <span class="o">&amp;</span> <span class="n">DOC_PROTECT_PROTECTION_ERROR</span><span class="p">)</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;PROTECT_ERR,&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;NO_PROTECT_ERR&quot;</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;DPS0 = 0x%02x : &quot;</span>
			 <span class="s">&quot;Protected area [0x%x - 0x%x] : OTP=%d, READ=%d, &quot;</span>
			 <span class="s">&quot;WRITE=%d, HW_LOCK=%d, KEY_OK=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">dps0</span><span class="p">,</span> <span class="n">dps0_low</span><span class="p">,</span> <span class="n">dps0_high</span><span class="p">,</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps0</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_OTP_PROTECTED</span><span class="p">),</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps0</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_READ_PROTECTED</span><span class="p">),</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps0</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_WRITE_PROTECTED</span><span class="p">),</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps0</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_HW_LOCK_ENABLED</span><span class="p">),</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps0</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_KEY_OK</span><span class="p">));</span>
	<span class="n">pos</span> <span class="o">+=</span> <span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;DPS1 = 0x%02x : &quot;</span>
			 <span class="s">&quot;Protected area [0x%x - 0x%x] : OTP=%d, READ=%d, &quot;</span>
			 <span class="s">&quot;WRITE=%d, HW_LOCK=%d, KEY_OK=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">dps1</span><span class="p">,</span> <span class="n">dps1_low</span><span class="p">,</span> <span class="n">dps1_high</span><span class="p">,</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps1</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_OTP_PROTECTED</span><span class="p">),</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps1</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_READ_PROTECTED</span><span class="p">),</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps1</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_WRITE_PROTECTED</span><span class="p">),</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps1</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_HW_LOCK_ENABLED</span><span class="p">),</span>
			 <span class="o">!!</span><span class="p">(</span><span class="n">dps1</span> <span class="o">&amp;</span> <span class="n">DOC_DPS_KEY_OK</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEBUGFS_RO_ATTR</span><span class="p">(</span><span class="n">protection</span><span class="p">,</span> <span class="n">dbg_protection_show</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">doc_dbg_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;docg3&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;flashcontrol&quot;</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">docg3</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">flashcontrol_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;asic_mode&quot;</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
					    <span class="n">docg3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asic_mode_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;device_id&quot;</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
					    <span class="n">docg3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device_id_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;protection&quot;</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
					    <span class="n">docg3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">protection_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">debugfs_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">doc_dbg_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">debugfs_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_set_driver_info - Fill the mtd_info structure and docg3 structure</span>
<span class="cm"> * @chip_id: The chip ID of the supported chip</span>
<span class="cm"> * @mtd: The structure to fill</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">doc_set_driver_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">chip_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg</span><span class="p">;</span>

	<span class="n">cfg</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CONFIGURATION</span><span class="p">);</span>
	<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">if_cfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">DOC_CONF_IF_CFG</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span> <span class="o">=</span> <span class="n">reliable_mode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chip_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DOC_CHIPID_G3</span>:
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;docg3.%d&quot;</span><span class="p">,</span>
				      <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
		<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">max_block</span> <span class="o">=</span> <span class="mi">2047</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">MTD_NANDFLASH</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MTD_CAP_NANDFLASH</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">max_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_BLOCK_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">=</span> <span class="n">DOC_LAYOUT_BLOCK_SIZE</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_NBPLANES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">reliable</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writebufsize</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">=</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span> <span class="o">=</span> <span class="n">DOC_LAYOUT_OOB_SIZE</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_erase</span> <span class="o">=</span> <span class="n">doc_erase</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read</span> <span class="o">=</span> <span class="n">doc_read</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write</span> <span class="o">=</span> <span class="n">doc_write</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read_oob</span> <span class="o">=</span> <span class="n">doc_read_oob</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write_oob</span> <span class="o">=</span> <span class="n">doc_write_oob</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_block_isbad</span> <span class="o">=</span> <span class="n">doc_block_isbad</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecclayout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">docg3_oobinfo</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">=</span> <span class="n">DOC_ECC_BCH_T</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_probe_device - Check if a device is available</span>
<span class="cm"> * @base: the io space where the device is probed</span>
<span class="cm"> * @floor: the floor of the probed device</span>
<span class="cm"> * @dev: the device</span>
<span class="cm"> * @cascade: the cascade of chips this devices will belong to</span>
<span class="cm"> *</span>
<span class="cm"> * Checks whether a device at the specified IO range, and floor is available.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a mtd_info struct if there is a device, ENODEV if none found, ENOMEM</span>
<span class="cm"> * if a memory allocation failed. If floor 0 is checked, a reset of the ASIC is</span>
<span class="cm"> * launched.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span> <span class="n">__init</span>
<span class="nf">doc_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3_cascade</span> <span class="o">*</span><span class="n">cascade</span><span class="p">,</span> <span class="kt">int</span> <span class="n">floor</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">bbt_nbpages</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">chip_id</span><span class="p">,</span> <span class="n">chip_id_inv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">docg3</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">docg3</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">docg3</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem1</span><span class="p">;</span>
	<span class="n">mtd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtd</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem2</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">docg3</span><span class="p">;</span>
	<span class="n">bbt_nbpages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">max_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				   <span class="mi">8</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">);</span>
	<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">bbt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bbt_nbpages</span> <span class="o">*</span> <span class="n">DOC_LAYOUT_PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">bbt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem3</span><span class="p">;</span>

	<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">floor</span><span class="p">;</span>
	<span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span> <span class="o">=</span> <span class="n">cascade</span><span class="p">;</span>
	<span class="n">doc_set_device_id</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">floor</span><span class="p">)</span>
		<span class="n">doc_set_asic_mode</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ASICMODE_RESET</span><span class="p">);</span>
	<span class="n">doc_set_asic_mode</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ASICMODE_NORMAL</span><span class="p">);</span>

	<span class="n">chip_id</span> <span class="o">=</span> <span class="n">doc_register_readw</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CHIPID</span><span class="p">);</span>
	<span class="n">chip_id_inv</span> <span class="o">=</span> <span class="n">doc_register_readw</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_CHIPID_INV</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip_id</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="o">~</span><span class="n">chip_id_inv</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">nomem3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">chip_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DOC_CHIPID_G3</span>:
		<span class="n">doc_info</span><span class="p">(</span><span class="s">&quot;Found a G3 DiskOnChip at addr %p, floor %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">floor</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">doc_err</span><span class="p">(</span><span class="s">&quot;Chip id %04x is not a DiskOnChip G3 chip</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip_id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">nomem3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">doc_set_driver_info</span><span class="p">(</span><span class="n">chip_id</span><span class="p">,</span> <span class="n">mtd</span><span class="p">);</span>

	<span class="n">doc_hamming_ecc_init</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_LAYOUT_OOB_PAGEINFO_SZ</span><span class="p">);</span>
	<span class="n">doc_reload_bbt</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mtd</span><span class="p">;</span>

<span class="nl">nomem3:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
<span class="nl">nomem2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
<span class="nl">nomem1:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_release_device - Release a docg3 floor</span>
<span class="cm"> * @mtd: the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc_release_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">mtd_device_unregister</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">bbt</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * docg3_resume - Awakens docg3 floor</span>
<span class="cm"> * @pdev: platfrom device</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 (always successful)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">docg3_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">docg3_cascade</span> <span class="o">*</span><span class="n">cascade</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">**</span><span class="n">docg3_floors</span><span class="p">,</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">;</span>

	<span class="n">cascade</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">docg3_floors</span> <span class="o">=</span> <span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">;</span>
	<span class="n">mtd</span> <span class="o">=</span> <span class="n">docg3_floors</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;docg3_resume()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">doc_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_IOSPACE_IPL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * docg3_suspend - Put in low power mode the docg3 floor</span>
<span class="cm"> * @pdev: platform device</span>
<span class="cm"> * @state: power state</span>
<span class="cm"> *</span>
<span class="cm"> * Shuts off most of docg3 circuitery to lower power consumption.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if suspend succeeded, -EIO if chip refused suspend</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">docg3_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">floor</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">docg3_cascade</span> <span class="o">*</span><span class="n">cascade</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">**</span><span class="n">docg3_floors</span><span class="p">,</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">pwr_down</span><span class="p">;</span>

	<span class="n">cascade</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">docg3_floors</span> <span class="o">=</span> <span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">DOC_MAX_NBFLOORS</span><span class="p">;</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtd</span> <span class="o">=</span> <span class="n">docg3_floors</span><span class="p">[</span><span class="n">floor</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtd</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

		<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">DOC_DEVICESELECT</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DOC_CTRL_VIOLATION</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DOC_CTRL_CE</span><span class="p">;</span>
		<span class="n">doc_writeb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">DOC_FLASHCONTROL</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usleep_range</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">);</span>
			<span class="n">pwr_down</span> <span class="o">=</span> <span class="n">doc_register_readb</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_POWERMODE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pwr_down</span> <span class="o">&amp;</span> <span class="n">DOC_POWERDOWN_READY</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pwr_down</span> <span class="o">&amp;</span> <span class="n">DOC_POWERDOWN_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">doc_dbg</span><span class="p">(</span><span class="s">&quot;docg3_suspend(): floor %d powerdown ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">floor</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">doc_err</span><span class="p">(</span><span class="s">&quot;docg3_suspend(): floor %d powerdown failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">floor</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mtd</span> <span class="o">=</span> <span class="n">docg3_floors</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">docg3</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">doc_set_asic_mode</span><span class="p">(</span><span class="n">docg3</span><span class="p">,</span> <span class="n">DOC_ASICMODE_POWERDOWN</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * doc_probe - Probe the IO space for a DiskOnChip G3 chip</span>
<span class="cm"> * @pdev: platform device</span>
<span class="cm"> *</span>
<span class="cm"> * Probes for a G3 chip at the specified IO space in the platform data</span>
<span class="cm"> * ressources. The floor 0 must be available.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ENOMEM, -ENXIO on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">docg3_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">ress</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">docg3_cascade</span> <span class="o">*</span><span class="n">cascade</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">ress</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No I/O memory resource defined</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">noress</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">ress</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">DOC_IOSPACE_SIZE</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cascade</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cascade</span><span class="p">)</span> <span class="o">*</span> <span class="n">DOC_MAX_NBFLOORS</span><span class="p">,</span>
			  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cascade</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem1</span><span class="p">;</span>
	<span class="n">cascade</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cascade</span><span class="o">-&gt;</span><span class="n">bch</span> <span class="o">=</span> <span class="n">init_bch</span><span class="p">(</span><span class="n">DOC_ECC_BCH_M</span><span class="p">,</span> <span class="n">DOC_ECC_BCH_T</span><span class="p">,</span>
			     <span class="n">DOC_ECC_BCH_PRIMPOLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">bch</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">DOC_MAX_NBFLOORS</span><span class="p">;</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtd</span> <span class="o">=</span> <span class="n">doc_probe_device</span><span class="p">(</span><span class="n">cascade</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mtd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_probe</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtd</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">floor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">notfound</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="n">floor</span><span class="p">]</span> <span class="o">=</span> <span class="n">mtd</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_device_parse_register</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">part_probes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_probe</span><span class="p">;</span>
		<span class="n">found</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_register_sysfs</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cascade</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_probe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">notfound</span><span class="p">;</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cascade</span><span class="p">);</span>
	<span class="n">doc_dbg_register</span><span class="p">(</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">notfound:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No supported DiskOnChip found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">err_probe:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">bch</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">DOC_MAX_NBFLOORS</span><span class="p">;</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="n">floor</span><span class="p">])</span>
			<span class="n">doc_release_device</span><span class="p">(</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="n">floor</span><span class="p">]);</span>
<span class="nl">nomem2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cascade</span><span class="p">);</span>
<span class="nl">nomem1:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="nl">noress:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * docg3_release - Release the driver</span>
<span class="cm"> * @pdev: the platform device</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">docg3_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">docg3_cascade</span> <span class="o">*</span><span class="n">cascade</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">docg3</span> <span class="o">*</span><span class="n">docg3</span> <span class="o">=</span> <span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">cascade</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">floor</span><span class="p">;</span>

	<span class="n">doc_unregister_sysfs</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cascade</span><span class="p">);</span>
	<span class="n">doc_dbg_unregister</span><span class="p">(</span><span class="n">docg3</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">DOC_MAX_NBFLOORS</span><span class="p">;</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="n">floor</span><span class="p">])</span>
			<span class="n">doc_release_device</span><span class="p">(</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">floors</span><span class="p">[</span><span class="n">floor</span><span class="p">]);</span>

	<span class="n">free_bch</span><span class="p">(</span><span class="n">docg3</span><span class="o">-&gt;</span><span class="n">cascade</span><span class="o">-&gt;</span><span class="n">bch</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cascade</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">g3_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;docg3&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">docg3_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">docg3_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">docg3_release</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">docg3_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g3_driver</span><span class="p">,</span> <span class="n">docg3_probe</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">docg3_init</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">docg3_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g3_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">docg3_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Robert Jarzmik &lt;robert.jarzmik@free.fr&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MTD driver for DiskOnChip G3&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
