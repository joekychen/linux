<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › devices › doc2000.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>doc2000.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux driver for Disk-On-Chip 2000 and Millennium</span>
<span class="cm"> * (c) 1999 Machine Vision Holdings, Inc.</span>
<span class="cm"> * (c) 1999, 2000 David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/errno.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nand.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/doc2000.h&gt;</span>

<span class="cp">#define DOC_SUPPORT_2000</span>
<span class="cp">#define DOC_SUPPORT_2000TSOP</span>
<span class="cp">#define DOC_SUPPORT_MILLENNIUM</span>

<span class="cp">#ifdef DOC_SUPPORT_2000</span>
<span class="cp">#define DoC_is_2000(doc) (doc-&gt;ChipID == DOC_ChipID_Doc2k)</span>
<span class="cp">#else</span>
<span class="cp">#define DoC_is_2000(doc) (0)</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(DOC_SUPPORT_2000TSOP) || defined(DOC_SUPPORT_MILLENNIUM)</span>
<span class="cp">#define DoC_is_Millennium(doc) (doc-&gt;ChipID == DOC_ChipID_DocMil)</span>
<span class="cp">#else</span>
<span class="cp">#define DoC_is_Millennium(doc) (0)</span>
<span class="cp">#endif</span>

<span class="cm">/* #define ECC_DEBUG */</span>

<span class="cm">/* I have no idea why some DoC chips can not use memcpy_from|to_io().</span>
<span class="cm"> * This may be due to the different revisions of the ASIC controller built-in or</span>
<span class="cm"> * simplily a QA/Bug issue. Who knows ?? If you have trouble, please uncomment</span>
<span class="cm"> * this:</span>
<span class="cm"> #undef USE_MEMCPY</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_read_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_write_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_write_oob_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_erase</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">doc2klist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* Perform the required delay cycles by reading from the appropriate register */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DoC_Delay</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cycles</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cycles</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">DOCStatus</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_DoC_WaitReady</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;_DoC_WaitReady called for out-of-line wait</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Out-of-line routine to wait for chip response */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* issue 2 read from NOP register after reading from CDSNControl register</span>
<span class="cm">	   	see Software Requirement 11.4 item 2. */</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;_DoC_WaitReady timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">DoC_WaitReady</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="cm">/* This is inline, to optimise the common case, where it&#39;s ready instantly */</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 4 read form NOP register should be issued in prior to the read from CDSNControl</span>
<span class="cm">	   see Software Requirement 11.4 item 2. */</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B</span><span class="p">))</span>
		<span class="cm">/* Call the out-of-line routine to wait */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>

	<span class="cm">/* issue 2 read from NOP register after reading from CDSNControl register</span>
<span class="cm">	   see Software Requirement 11.4 item 2. */</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* DoC_Command: Send a flash command to the flash chip through the CDSN Slow IO register to</span>
<span class="cm">   bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is</span>
<span class="cm">   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">DoC_Command</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xtraflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_2000</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
		<span class="n">xtraflags</span> <span class="o">|=</span> <span class="n">CDSN_CTRL_FLASH_IO</span><span class="p">;</span>

	<span class="cm">/* Assert the CLE (Command Latch Enable) line to the flash chip */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">xtraflags</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CLE</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="cm">/* Software requirement 11.4.3 for Millennium */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>

	<span class="cm">/* Send the command */</span>
	<span class="n">WriteDOC_</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>

	<span class="cm">/* Lower the CLE line */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">xtraflags</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="cm">/* Software requirement 11.4.3 for Millennium */</span>

	<span class="cm">/* Wait for the chip to respond - Software requirement 11.4.1 (extended for any command) */</span>
	<span class="k">return</span> <span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DoC_Address: Set the current address for the flash chip through the CDSN Slow IO register to</span>
<span class="cm">   bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is</span>
<span class="cm">   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">DoC_Address</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numbytes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xtraflags1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xtraflags2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_2000</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
		<span class="n">xtraflags1</span> <span class="o">|=</span> <span class="n">CDSN_CTRL_FLASH_IO</span><span class="p">;</span>

	<span class="cm">/* Assert the ALE (Address Latch Enable) line to the flash chip */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">xtraflags1</span> <span class="o">|</span> <span class="n">CDSN_CTRL_ALE</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>

	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="cm">/* Software requirement 11.4.3 for Millennium */</span>

	<span class="cm">/* Send the address */</span>
	<span class="cm">/* Devices with 256-byte page are addressed as:</span>
<span class="cm">	   Column (bits 0-7), Page (bits 8-15, 16-23, 24-31)</span>
<span class="cm">	   * there is no device on the market with page256</span>
<span class="cm">	   and more than 24 bits.</span>
<span class="cm">	   Devices with 512-byte page are addressed as:</span>
<span class="cm">	   Column (bits 0-7), Page (bits 9-16, 17-24, 25-31)</span>
<span class="cm">	   * 25-31 is sent only if the chip support it.</span>
<span class="cm">	   * bit 8 changes the read command to be sent</span>
<span class="cm">	   (NAND_CMD_READ0 or NAND_CMD_READ1).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numbytes</span> <span class="o">==</span> <span class="n">ADDR_COLUMN</span> <span class="o">||</span> <span class="n">numbytes</span> <span class="o">==</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
		<span class="n">WriteDOC_</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">page256</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">numbytes</span> <span class="o">==</span> <span class="n">ADDR_PAGE</span> <span class="o">||</span> <span class="n">numbytes</span> <span class="o">==</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">pageadrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
				<span class="n">WriteDOC</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
			<span class="n">WriteDOC_</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>

	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* Needed for some slow flash chips. mf. */</span>

	<span class="cm">/* FIXME: The SlowIO&#39;s for millennium could be replaced by</span>
<span class="cm">	   a single WritePipeTerm here. mf. */</span>

	<span class="cm">/* Lower the ALE line */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">xtraflags1</span> <span class="o">|</span> <span class="n">xtraflags2</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span>
		 <span class="n">CDSNControl</span><span class="p">);</span>

	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="cm">/* Software requirement 11.4.3 for Millennium */</span>

	<span class="cm">/* Wait for the chip to respond - Software requirement 11.4.1 */</span>
	<span class="k">return</span> <span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Read a buffer from DoC, taking care of Millennium odditys */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DoC_ReadBuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">int</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">modulus</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Read the data via the internal pipeline through CDSN IO register,</span>
<span class="cm">		   see Pipelined Read Operations 11.3 */</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>

		<span class="cm">/* Millennium should use the LastDataRead register - Pipeline Reads */</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* This is needed for correctly ECC calculation */</span>
		<span class="n">modulus</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">ioreg</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">modulus</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Write a buffer to DoC, taking care of Millennium odditys */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DoC_WriteBuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">WriteDOC_</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">ioreg</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* DoC_SelectChip: Select a given flash chip within the current floor */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">DoC_SelectChip</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="cm">/* Software requirement 11.4.4 before writing DeviceSelect */</span>
	<span class="cm">/* Deassert the CE line to eliminate glitches on the FCE# outputs */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="cm">/* Software requirement 11.4.3 for Millennium */</span>

	<span class="cm">/* Select the individual flash chip requested */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNDeviceSelect</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Reassert the CE line */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">CDSN_CTRL_CE</span> <span class="o">|</span> <span class="n">CDSN_CTRL_FLASH_IO</span> <span class="o">|</span> <span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span>
		 <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	<span class="cm">/* Software requirement 11.4.3 for Millennium */</span>

	<span class="cm">/* Wait for it to be ready */</span>
	<span class="k">return</span> <span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DoC_SelectFloor: Select a given floor (bank of flash chips) */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">DoC_SelectFloor</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">floor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="cm">/* Select the floor (bank) of chips required */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">floor</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">FloorSelect</span><span class="p">);</span>

	<span class="cm">/* Wait for the chip to be ready */</span>
	<span class="k">return</span> <span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DoC_IdentChip: Identify a given NAND chip given {floor,chip} */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">DoC_IdentChip</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mfr</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="cm">/* Page in the required floor/chip */</span>
	<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">floor</span><span class="p">);</span>
	<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* Reset the chip */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_Command</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">NAND_CMD_RESET</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;DoC_Command (reset) for %d,%d returned true</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">floor</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Read the NAND chip ID: 1. Send ReadID command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_Command</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">NAND_CMD_READID</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;DoC_Command (ReadID) for %d,%d returned true</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">floor</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read the NAND chip ID: 2. Send address byte zero */</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">ADDR_COLUMN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Read the manufacturer and device id codes from the device */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
		<span class="n">mfr</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>

		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* CDSN Slow IO register see Software Req 11.4 item 5. */</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">mfr</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>

		<span class="cm">/* CDSN Slow IO register see Software Req 11.4 item 5. */</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* No response - return failure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mfr</span> <span class="o">==</span> <span class="mh">0xff</span> <span class="o">||</span> <span class="n">mfr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check it&#39;s the same as the first chip we identified.</span>
<span class="cm">	 * M-Systems say that any given DiskOnChip device should only</span>
<span class="cm">	 * contain _one_ type of flash part, although that&#39;s not a</span>
<span class="cm">	 * hardware restriction. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">mfr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">mfr</span> <span class="o">==</span> <span class="n">mfr</span> <span class="o">&amp;&amp;</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* This is the same as the first */</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;Flash chip at floor %d, chip %d is different:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">floor</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print and store the manufacturer and ID codes. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Try to identify manufacturer */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nand_manuf_ids</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">id</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nand_manuf_ids</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">id</span> <span class="o">==</span> <span class="n">mfr</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;Flash chip found: Manufacturer ID: %2.2X, &quot;</span>
			       <span class="s">&quot;Chip ID: %2.2X (%s:%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mfr</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span>
			       <span class="n">nand_manuf_ids</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">mfr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">doc</span><span class="o">-&gt;</span><span class="n">mfr</span> <span class="o">=</span> <span class="n">mfr</span><span class="p">;</span>
				<span class="n">doc</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
				<span class="n">doc</span><span class="o">-&gt;</span><span class="n">chipshift</span> <span class="o">=</span>
					<span class="n">ffs</span><span class="p">((</span><span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chipsize</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">doc</span><span class="o">-&gt;</span><span class="n">page256</span> <span class="o">=</span> <span class="p">(</span><span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pagesize</span> <span class="o">==</span> <span class="mi">256</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">doc</span><span class="o">-&gt;</span><span class="n">pageadrlen</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chipshift</span> <span class="o">&gt;</span> <span class="mi">25</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">doc</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">=</span>
				    <span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">erasesize</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/* We haven&#39;t fully identified the chip. Print as much as we know. */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Unknown flash chip found: %2.2X %2.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">id</span><span class="p">,</span> <span class="n">mfr</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Please report to dwmw2@infradead.org</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* DoC_ScanChips: Find all NAND chips present in a DiskOnChip, and identify them */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">DoC_ScanChips</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxchips</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">floor</span><span class="p">,</span> <span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numchips</span><span class="p">[</span><span class="n">MAX_FLOORS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">mfr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* For each floor, find the number of valid chips it contains */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">MAX_FLOORS</span><span class="p">;</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">numchips</span><span class="p">[</span><span class="n">floor</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">chip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chip</span> <span class="o">&lt;</span> <span class="n">maxchips</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">DoC_IdentChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">numchips</span><span class="p">[</span><span class="n">floor</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If there are none at all that we recognise, bail */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;No flash chips recognised.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate an array to hold the information for each chip */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Nand</span><span class="p">)</span> <span class="o">*</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;No memory for allocating chip info structures</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Fill out the chip array with {floor, chipno} for each</span>
<span class="cm">	 * detected chip in the device. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">MAX_FLOORS</span><span class="p">;</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">chip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chip</span> <span class="o">&lt;</span> <span class="n">numchips</span><span class="p">[</span><span class="n">floor</span><span class="p">];</span> <span class="n">chip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">floor</span> <span class="o">=</span> <span class="n">floor</span><span class="p">;</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">chip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">curadr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">curmode</span> <span class="o">=</span> <span class="mh">0x50</span><span class="p">;</span>
			<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate and print the total size of the device */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%d flash chips found. Total DiskOnChip size: %ld MiB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">DoC2k_is_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doc1</span><span class="o">-&gt;</span><span class="n">physadr</span> <span class="o">==</span> <span class="n">doc2</span><span class="o">-&gt;</span><span class="n">physadr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Use the alias resolution register which was set aside for this</span>
<span class="cm">	 * purpose. If it&#39;s value is the same on both chips, they might</span>
<span class="cm">	 * be the same chip, and we write to one and check for a change in</span>
<span class="cm">	 * the other. It&#39;s unclear if this register is usuable in the</span>
<span class="cm">	 * DoC 2000 (it&#39;s in the Millennium docs), but it seems to work. */</span>
	<span class="n">tmp1</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc1</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
	<span class="n">tmp2</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc2</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">!=</span> <span class="n">tmp2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WriteDOC</span><span class="p">((</span><span class="n">tmp1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">doc1</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
	<span class="n">tmp2</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc2</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp2</span> <span class="o">==</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Restore register contents.  May not be necessary, but do it just to</span>
<span class="cm">	 * be safe. */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">doc1</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine is found from the docprobe code by symbol_get(),</span>
<span class="cm"> * which will bump the use count of this module. */</span>
<span class="kt">void</span> <span class="nf">DoC2k_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxchips</span><span class="p">;</span>

	<span class="cm">/* We must avoid being called twice for the same device. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">doc2klist</span><span class="p">)</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">doc2klist</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DoC2k_is_alias</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">this</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
			       <span class="s">&quot;Ignoring DiskOnChip 2000 at 0x%lX - already configured</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">this</span><span class="o">-&gt;</span><span class="n">physadr</span><span class="p">);</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">nextdoc</span><span class="p">)</span>
			<span class="n">old</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">nextdoc</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">switch</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ChipID</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DOC_ChipID_Doc2kTSOP</span>:
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DiskOnChip 2000 TSOP&quot;</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span> <span class="o">=</span> <span class="n">DoC_Mil_CDSN_IO</span><span class="p">;</span>
		<span class="cm">/* Pretend it&#39;s a Millennium */</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ChipID</span> <span class="o">=</span> <span class="n">DOC_ChipID_DocMil</span><span class="p">;</span>
		<span class="n">maxchips</span> <span class="o">=</span> <span class="n">MAX_CHIPS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DOC_ChipID_Doc2k</span>:
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DiskOnChip 2000&quot;</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span> <span class="o">=</span> <span class="n">DoC_2k_CDSN_IO</span><span class="p">;</span>
		<span class="n">maxchips</span> <span class="o">=</span> <span class="n">MAX_CHIPS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DOC_ChipID_DocMil</span>:
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DiskOnChip Millennium&quot;</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span> <span class="o">=</span> <span class="n">DoC_Mil_CDSN_IO</span><span class="p">;</span>
		<span class="n">maxchips</span> <span class="o">=</span> <span class="n">MAX_CHIPS_MIL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unknown ChipID 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ChipID</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s found at address 0x%lX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       <span class="n">this</span><span class="o">-&gt;</span><span class="n">physadr</span><span class="p">);</span>

	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">MTD_NANDFLASH</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MTD_CAP_NANDFLASH</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writebufsize</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_erase</span> <span class="o">=</span> <span class="n">doc_erase</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read</span> <span class="o">=</span> <span class="n">doc_read</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write</span> <span class="o">=</span> <span class="n">doc_write</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read_oob</span> <span class="o">=</span> <span class="n">doc_read_oob</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write_oob</span> <span class="o">=</span> <span class="n">doc_write_oob</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Ident all the chips present. */</span>
	<span class="n">DoC_ScanChips</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">maxchips</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">nextdoc</span> <span class="o">=</span> <span class="n">doc2klist</span><span class="p">;</span>
		<span class="n">doc2klist</span> <span class="o">=</span> <span class="n">mtd</span><span class="p">;</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">;</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">;</span>
		<span class="n">mtd_device_register</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">DoC2k_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="o">*</span> <span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">syndrome</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len256</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t allow a single read to cross a 512-byte block boundary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">from</span> <span class="o">|</span> <span class="mh">0x1ff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">((</span><span class="n">from</span> <span class="o">|</span> <span class="mh">0x1ff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>

		<span class="cm">/* The ECC will not be calculated correctly if less than 512 is read */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mh">0x200</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;ECC needs a full sector read (adr: %lx size %lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">from</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">len</span><span class="p">);</span>

		<span class="cm">/* printk(&quot;DoC_Read (adr: %lx size %lx)\n&quot;, (long) from, (long) len); */</span>


		<span class="cm">/* Find the chip which is to be used and select it */</span>
		<span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
			<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page256</span>
			     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">from</span> <span class="o">&amp;</span> <span class="mh">0x100</span><span class="p">))</span> <span class="o">?</span> <span class="n">NAND_CMD_READ1</span> <span class="o">:</span> <span class="n">NAND_CMD_READ0</span><span class="p">,</span>
			    <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
		<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">,</span>
			    <span class="n">CDSN_CTRL_ECC_IO</span><span class="p">);</span>

		<span class="cm">/* Prime the ECC engine */</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_EN</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

		<span class="cm">/* treat crossing 256-byte sector for 2M x 8bits devices */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page256</span> <span class="o">&amp;&amp;</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">from</span> <span class="o">|</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len256</span> <span class="o">=</span> <span class="p">(</span><span class="n">from</span> <span class="o">|</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>
			<span class="n">DoC_ReadBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len256</span><span class="p">);</span>

			<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_READ0</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
			<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">,</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len256</span><span class="p">,</span>
				    <span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="n">CDSN_CTRL_ECC_IO</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">DoC_ReadBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">len256</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">len256</span><span class="p">);</span>

		<span class="cm">/* Let the caller know we completed it */</span>
		<span class="o">*</span><span class="n">retlen</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Read the ECC data through the DiskOnChip ECC logic */</span>
		<span class="cm">/* Note: this will work even with 2M x 8bit devices as   */</span>
		<span class="cm">/*       they have 8 bytes of OOB per 256 page. mf.      */</span>
		<span class="n">DoC_ReadBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">eccbuf</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

		<span class="cm">/* Flush the pipeline */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_ECCStatus</span><span class="p">);</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_ECCStatus</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_ECCStatus</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Check the ECC Status */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nb_errors</span><span class="p">;</span>
			<span class="cm">/* There was an ECC error */</span>
<span class="cp">#ifdef ECC_DEBUG</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DiskOnChip ECC Error: Read at %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">from</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="cm">/* Read the ECC syndrome through the DiskOnChip ECC</span>
<span class="cm">			   logic.  These syndrome will be all ZERO when there</span>
<span class="cm">			   is no error */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">syndrome</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCSyndrome0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">nb_errors</span> <span class="o">=</span> <span class="n">doc_decode_ecc</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">);</span>

<span class="cp">#ifdef ECC_DEBUG</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Errors corrected: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nb_errors</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nb_errors</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We return error, but have actually done the</span>
<span class="cm">				   read. Not that this can be told to</span>
<span class="cm">				   user-space, via sys_read(), but at least</span>
<span class="cm">				   MTD-aware stuff can know about it by</span>
<span class="cm">				   checking *retlen */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="cp">#ifdef PSYCHO_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;ECC DATA at %lxB: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
		       <span class="n">eccbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="cp">#endif</span>

		<span class="cm">/* disable the ECC engine */</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span> <span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

		<span class="cm">/* according to 11.4.1, we need to wait for the busy line</span>
<span class="cm">	         * drop if we read to the end of the page.  */</span>
		<span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="p">((</span><span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">))</span>
		<span class="p">{</span>
		    <span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">from</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="o">*</span> <span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">di</span><span class="p">;</span> <span class="cm">/* Yes, DI is a hangover from when I was disassembling the binary driver */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len256</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t allow a single write to cross a 512-byte block boundary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">to</span> <span class="o">|</span> <span class="mh">0x1ff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">((</span><span class="n">to</span> <span class="o">|</span> <span class="mh">0x1ff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">to</span><span class="p">;</span>

		<span class="cm">/* The ECC will not be calculated correctly if less than 512 is written */</span>
<span class="cm">/* DBB-</span>
<span class="cm">		if (len != 0x200 &amp;&amp; eccbuf)</span>
<span class="cm">			printk(KERN_WARNING</span>
<span class="cm">			       &quot;ECC needs a full sector write (adr: %lx size %lx)\n&quot;,</span>
<span class="cm">			       (long) to, (long) len);</span>
<span class="cm">   -DBB */</span>

		<span class="cm">/* printk(&quot;DoC_Write (adr: %lx size %lx)\n&quot;, (long) to, (long) len); */</span>

		<span class="cm">/* Find the chip which is to be used and select it */</span>
		<span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">to</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
			<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

		<span class="cm">/* Set device to main plane of flash */</span>
		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_RESET</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page256</span>
			     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">to</span> <span class="o">&amp;</span> <span class="mh">0x100</span><span class="p">))</span> <span class="o">?</span> <span class="n">NAND_CMD_READ1</span> <span class="o">:</span> <span class="n">NAND_CMD_READ0</span><span class="p">,</span>
			    <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>

		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CDSN_CTRL_ECC_IO</span><span class="p">);</span>

		<span class="cm">/* Prime the ECC engine */</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_EN</span> <span class="o">|</span> <span class="n">DOC_ECC_RW</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

		<span class="cm">/* treat crossing 256-byte sector for 2M x 8bits devices */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page256</span> <span class="o">&amp;&amp;</span> <span class="n">to</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">to</span> <span class="o">|</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len256</span> <span class="o">=</span> <span class="p">(</span><span class="n">to</span> <span class="o">|</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">to</span><span class="p">;</span>
			<span class="n">DoC_WriteBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len256</span><span class="p">);</span>

			<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
			<span class="cm">/* There&#39;s an implicit DoC_WaitReady() in DoC_Command */</span>

			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
			<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error programming flash</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="cm">/* Error in programming */</span>
				<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">,</span> <span class="n">to</span> <span class="o">+</span> <span class="n">len256</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">CDSN_CTRL_ECC_IO</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">DoC_WriteBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">len256</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">len256</span><span class="p">);</span>

		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">CDSN_CTRL_ECC_IO</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">WriteDOC_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
			<span class="n">WriteDOC_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
			<span class="n">WriteDOC_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">CDSN_CTRL_ECC_IO</span> <span class="o">|</span> <span class="n">CDSN_CTRL_FLASH_IO</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span>
			 <span class="n">CDSNControl</span><span class="p">);</span>

		<span class="cm">/* Read the ECC data through the DiskOnChip ECC logic */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">di</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">di</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">di</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eccbuf</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCSyndrome0</span> <span class="o">+</span> <span class="n">di</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Reset the ECC engine */</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

<span class="cp">#ifdef PSYCHO_DEBUG</span>
		<span class="n">printk</span>
			<span class="p">(</span><span class="s">&quot;OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">to</span><span class="p">,</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			 <span class="n">eccbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="cp">#endif</span>
		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
		<span class="cm">/* There&#39;s an implicit DoC_WaitReady() in DoC_Command */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
			<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error programming flash</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* Error in programming */</span>
			<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Let the caller know we completed it */</span>
		<span class="o">*</span><span class="n">retlen</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

		<span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">x</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
			<span class="kt">size_t</span> <span class="n">dummy</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

			<span class="cm">/* Write the ECC data to flash */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">di</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">di</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="n">di</span><span class="o">++</span><span class="p">)</span>
				<span class="n">x</span><span class="p">[</span><span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="n">eccbuf</span><span class="p">[</span><span class="n">di</span><span class="p">];</span>

			<span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="mh">0x55</span><span class="p">;</span>
			<span class="n">x</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="mh">0x55</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_write_oob_nolock</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">to</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len256</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobbuf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">);</span>

	<span class="n">ofs</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooboffs</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

	<span class="cm">/* update address for 2M x 8bit devices. OOB starts on the second */</span>
	<span class="cm">/* page to maintain compatibility with doc_read_ecc. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page256</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">))</span>
			<span class="n">ofs</span> <span class="o">+=</span> <span class="mh">0x100</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ofs</span> <span class="o">-=</span> <span class="mh">0x8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_READOOB</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* treat crossing 8-byte OOB data for 2M x 8bit devices */</span>
	<span class="cm">/* Note: datasheet says it should automaticaly wrap to the */</span>
	<span class="cm">/*       next OOB block, but it didn&#39;t work here. mf.      */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page256</span> <span class="o">&amp;&amp;</span> <span class="n">ofs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len256</span> <span class="o">=</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="n">DoC_ReadBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len256</span><span class="p">);</span>

		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_READOOB</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
		<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x1ff</span><span class="p">),</span>
			    <span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DoC_ReadBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">len256</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">len256</span><span class="p">);</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="cm">/* Reading the full OOB data drops us off of the end of the page,</span>
<span class="cm">         * causing the flash device to go into busy mode, so we need</span>
<span class="cm">         * to wait until ready 11.4.1 and Toshiba TC58256FT docs */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write_oob_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="o">*</span> <span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len256</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="kt">int</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><pre><code> printk("doc_write_oob(%lx, %d): %2.2X %2.2X %2.2X %2.2X ... %2.2X %2.2X .. %2.2X %2.2X\n",(long)ofs, len,
</code></pre>

<p>buf[0], buf[1], buf[2], buf[3], buf[8], buf[9], buf[14],buf[15]);</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* Find the chip which is to be used and select it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

	<span class="cm">/* disable the ECC engine */</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

	<span class="cm">/* Reset the chip, see Software Requirement 11.4 item 1. */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_RESET</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>

	<span class="cm">/* issue the Read2 command to set the pointer to the Spare Data Area. */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_READOOB</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>

	<span class="cm">/* update address for 2M x 8bit devices. OOB starts on the second */</span>
	<span class="cm">/* page to maintain compatibility with doc_read_ecc. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page256</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">))</span>
			<span class="n">ofs</span> <span class="o">+=</span> <span class="mh">0x100</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ofs</span> <span class="o">-=</span> <span class="mh">0x8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* issue the Serial Data In command to initial the Page Program process */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* treat crossing 8-byte OOB data for 2M x 8bit devices */</span>
	<span class="cm">/* Note: datasheet says it should automaticaly wrap to the */</span>
	<span class="cm">/*       next OOB block, but it didn&#39;t work here. mf.      */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page256</span> <span class="o">&amp;&amp;</span> <span class="n">ofs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len256</span> <span class="o">=</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="n">DoC_WriteBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len256</span><span class="p">);</span>

		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* DoC_WaitReady() is implicit in DoC_Command */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
			<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error programming oob data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* There was an error */</span>
			<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_COLUMN_PAGE</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x1ff</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">DoC_WriteBuf</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">len256</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">len256</span><span class="p">);</span>

	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* DoC_WaitReady() is implicit in DoC_Command */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error programming oob data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* There was an error */</span>
		<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_write_oob_nolock</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">+</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooboffs</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobbuf</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">int</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

 	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASING</span><span class="p">;</span>

	<span class="cm">/* FIXME: Do this in the background. Use timers or schedule_task() */</span>
	<span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
			<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_ERASE1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">DoC_Address</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ADDR_PAGE</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_ERASE2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">DoC_Command</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
			<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ioreg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error erasing at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
			<span class="cm">/* There was an error */</span>
			<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_FAILED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">callback</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_DONE</span><span class="p">;</span>

 <span class="nl">callback:</span>
	<span class="n">mtd_erase_callback</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Module stuff</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_doc2000</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">doc2klist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="n">doc2klist</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nextdoc</span><span class="p">;</span>

		<span class="n">mtd_device_unregister</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

		<span class="n">iounmap</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_doc2000</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Woodhouse &lt;dwmw2@infradead.org&gt; et al.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MTD driver for DiskOnChip 2000 and Millennium&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
