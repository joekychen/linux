<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › devices › doc2001.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>doc2001.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux driver for Disk-On-Chip Millennium</span>
<span class="cm"> * (c) 1999 Machine Vision Holdings, Inc.</span>
<span class="cm"> * (c) 1999, 2000 David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/errno.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nand.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/doc2000.h&gt;</span>

<span class="cm">/* #define ECC_DEBUG */</span>

<span class="cm">/* I have no idea why some DoC chips can not use memcop_form|to_io().</span>
<span class="cm"> * This may be due to the different revisions of the ASIC controller built-in or</span>
<span class="cm"> * simplily a QA/Bug issue. Who knows ?? If you have trouble, please uncomment</span>
<span class="cm"> * this:*/</span>
<span class="cp">#undef USE_MEMCPY</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_read_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_write_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">doc_erase</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">docmillist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* Perform the required delay cycles by reading from the NOP register */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DoC_Delay</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">docptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cycles</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cycles</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_DoC_WaitReady</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">docptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;_DoC_WaitReady called for out-of-line wait</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Out-of-line routine to wait for chip response */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">c</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;_DoC_WaitReady timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">DoC_WaitReady</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">docptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is inline, to optimise the common case, where it&#39;s ready instantly */</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 4 read form NOP register should be issued in prior to the read from CDSNControl</span>
<span class="cm">	   see Software Requirement 11.4 item 2. */</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B</span><span class="p">))</span>
		<span class="cm">/* Call the out-of-line routine to wait */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">_DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>

	<span class="cm">/* issue 2 read from NOP register after reading from CDSNControl register</span>
<span class="cm">	   see Software Requirement 11.4 item 2. */</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* DoC_Command: Send a flash command to the flash chip through the CDSN IO register</span>
<span class="cm">   with the internal pipeline. Each of 4 delay cycles (read from the NOP register) is</span>
<span class="cm">   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">DoC_Command</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">docptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">command</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xtraflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Assert the CLE (Command Latch Enable) line to the flash chip */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">xtraflags</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CLE</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Send the command */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>

	<span class="cm">/* Lower the CLE line */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">xtraflags</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DoC_Address: Set the current address for the flash chip through the CDSN IO register</span>
<span class="cm">   with the internal pipeline. Each of 4 delay cycles (read from the NOP register) is</span>
<span class="cm">   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">DoC_Address</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">docptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numbytes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xtraflags1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xtraflags2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Assert the ALE (Address Latch Enable) line to the flash chip */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">xtraflags1</span> <span class="o">|</span> <span class="n">CDSN_CTRL_ALE</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Send the address */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">numbytes</span><span class="p">)</span>
	    <span class="p">{</span>
	    <span class="k">case</span> <span class="mi">1</span>:
		    <span class="cm">/* Send single byte, bits 0-7. */</span>
		    <span class="n">WriteDOC</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
		    <span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>
		    <span class="k">break</span><span class="p">;</span>
	    <span class="k">case</span> <span class="mi">2</span>:
		    <span class="cm">/* Send bits 9-16 followed by 17-23 */</span>
		    <span class="n">WriteDOC</span><span class="p">((</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
		    <span class="n">WriteDOC</span><span class="p">((</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="mi">17</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
		    <span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="k">case</span> <span class="mi">3</span>:
		    <span class="cm">/* Send 0-7, 9-16, then 17-23 */</span>
		    <span class="n">WriteDOC</span><span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
		    <span class="n">WriteDOC</span><span class="p">((</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
		    <span class="n">WriteDOC</span><span class="p">((</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="mi">17</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
		    <span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	    <span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	    <span class="p">}</span>

	<span class="cm">/* Lower the ALE line */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">xtraflags1</span> <span class="o">|</span> <span class="n">xtraflags2</span> <span class="o">|</span> <span class="n">CDSN_CTRL_CE</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DoC_SelectChip: Select a given flash chip within the current floor */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">DoC_SelectChip</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">docptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Select the individual flash chip requested */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNDeviceSelect</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Wait for it to be ready */</span>
	<span class="k">return</span> <span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DoC_SelectFloor: Select a given floor (bank of flash chips) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">DoC_SelectFloor</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="n">docptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">floor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Select the floor (bank) of chips required */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">floor</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">FloorSelect</span><span class="p">);</span>

	<span class="cm">/* Wait for the chip to be ready */</span>
	<span class="k">return</span> <span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* DoC_IdentChip: Identify a given NAND chip given {floor,chip} */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">DoC_IdentChip</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">floor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mfr</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>

	<span class="cm">/* Page in the required floor/chip</span>
<span class="cm">	   FIXME: is this supported by Millennium ?? */</span>
	<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">floor</span><span class="p">);</span>
	<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>

	<span class="cm">/* Reset the chip, see Software Requirement 11.4 item 1. */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">NAND_CMD_RESET</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>

	<span class="cm">/* Read the NAND chip ID: 1. Send ReadID command */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">NAND_CMD_READID</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>

	<span class="cm">/* Read the NAND chip ID: 2. Send address byte zero */</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="cm">/* Read the manufacturer and device id codes of the flash device through</span>
<span class="cm">	   CDSN IO register see Software Requirement 11.4 item 5.*/</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">mfr</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>

	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">id</span>  <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>

	<span class="cm">/* No response - return failure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mfr</span> <span class="o">==</span> <span class="mh">0xff</span> <span class="o">||</span> <span class="n">mfr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* FIXME: to deal with multi-flash on multi-Millennium case more carefully */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">id</span> <span class="o">==</span> <span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Try to identify manufacturer */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nand_manuf_ids</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">id</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nand_manuf_ids</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">id</span> <span class="o">==</span> <span class="n">mfr</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Flash chip found: Manufacturer ID: %2.2X, &quot;</span>
			       <span class="s">&quot;Chip ID: %2.2X (%s:%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">mfr</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">nand_manuf_ids</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
			<span class="n">doc</span><span class="o">-&gt;</span><span class="n">mfr</span> <span class="o">=</span> <span class="n">mfr</span><span class="p">;</span>
			<span class="n">doc</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
			<span class="n">doc</span><span class="o">-&gt;</span><span class="n">chipshift</span> <span class="o">=</span> <span class="n">ffs</span><span class="p">((</span><span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chipsize</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nand_flash_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* DoC_ScanChips: Find all NAND chips present in a DiskOnChip, and identify them */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DoC_ScanChips</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">floor</span><span class="p">,</span> <span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numchips</span><span class="p">[</span><span class="n">MAX_FLOORS_MIL</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">mfr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* For each floor, find the number of valid chips it contains */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">MAX_FLOORS_MIL</span><span class="p">;</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">numchips</span><span class="p">[</span><span class="n">floor</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">chip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chip</span> <span class="o">&lt;</span> <span class="n">MAX_CHIPS_MIL</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">DoC_IdentChip</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">numchips</span><span class="p">[</span><span class="n">floor</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* If there are none at all that we recognise, bail */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;No flash chips recognised.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate an array to hold the information for each chip */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Nand</span><span class="p">)</span> <span class="o">*</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">){</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;No memory for allocating chip info structures</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill out the chip array with {floor, chipno} for each</span>
<span class="cm">	 * detected chip in the device. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">floor</span> <span class="o">&lt;</span> <span class="n">MAX_FLOORS_MIL</span><span class="p">;</span> <span class="n">floor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">chip</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">chip</span> <span class="o">&lt;</span> <span class="n">numchips</span><span class="p">[</span><span class="n">floor</span><span class="p">]</span> <span class="p">;</span> <span class="n">chip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">floor</span> <span class="o">=</span> <span class="n">floor</span><span class="p">;</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">chip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">curadr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">curmode</span> <span class="o">=</span> <span class="mh">0x50</span><span class="p">;</span>
			<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate and print the total size of the device */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%d flash chips found. Total DiskOnChip size: %ld MiB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="p">,</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">totlen</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">DoCMil_is_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">doc2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">doc1</span><span class="o">-&gt;</span><span class="n">physadr</span> <span class="o">==</span> <span class="n">doc2</span><span class="o">-&gt;</span><span class="n">physadr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Use the alias resolution register which was set aside for this</span>
<span class="cm">	 * purpose. If it&#39;s value is the same on both chips, they might</span>
<span class="cm">	 * be the same chip, and we write to one and check for a change in</span>
<span class="cm">	 * the other. It&#39;s unclear if this register is usuable in the</span>
<span class="cm">	 * DoC 2000 (it&#39;s in the Millenium docs), but it seems to work. */</span>
	<span class="n">tmp1</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc1</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
	<span class="n">tmp2</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc2</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">!=</span> <span class="n">tmp2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WriteDOC</span><span class="p">((</span><span class="n">tmp1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">doc1</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
	<span class="n">tmp2</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc2</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp2</span> <span class="o">==</span> <span class="p">(</span><span class="n">tmp1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Restore register contents.  May not be necessary, but do it just to</span>
<span class="cm">	 * be safe. */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">doc1</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine is found from the docprobe code by symbol_get(),</span>
<span class="cm"> * which will bump the use count of this module. */</span>
<span class="kt">void</span> <span class="nf">DoCMil_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* We must avoid being called twice for the same device. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">docmillist</span><span class="p">)</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">docmillist</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DoCMil_is_alias</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">old</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Ignoring DiskOnChip Millennium at &quot;</span>
			       <span class="s">&quot;0x%lX - already configured</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">physadr</span><span class="p">);</span>
			<span class="n">iounmap</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">nextdoc</span><span class="p">)</span>
			<span class="n">old</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">nextdoc</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DiskOnChip Millennium&quot;</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;DiskOnChip Millennium found at address 0x%lX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">this</span><span class="o">-&gt;</span><span class="n">physadr</span><span class="p">);</span>

	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">MTD_NANDFLASH</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MTD_CAP_NANDFLASH</span><span class="p">;</span>

	<span class="cm">/* FIXME: erase size is not always 8KiB */</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writebufsize</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_erase</span> <span class="o">=</span> <span class="n">doc_erase</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read</span> <span class="o">=</span> <span class="n">doc_read</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write</span> <span class="o">=</span> <span class="n">doc_write</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read_oob</span> <span class="o">=</span> <span class="n">doc_read_oob</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write_oob</span> <span class="o">=</span> <span class="n">doc_write_oob</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Ident all the chips present. */</span>
	<span class="n">DoC_ScanChips</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">nextdoc</span> <span class="o">=</span> <span class="n">docmillist</span><span class="p">;</span>
		<span class="n">docmillist</span> <span class="o">=</span> <span class="n">mtd</span><span class="p">;</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span>  <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">;</span>
		<span class="n">mtd_device_register</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">DoCMil_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">syndrome</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)];</span>

	<span class="cm">/* Don&#39;t allow a single read to cross a 512-byte block boundary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">from</span> <span class="o">|</span> <span class="mh">0x1ff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="p">((</span><span class="n">from</span> <span class="o">|</span> <span class="mh">0x1ff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>

	<span class="cm">/* Find the chip which is to be used and select it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

	<span class="cm">/* issue the Read0 or Read1 command depend on which half of the page</span>
<span class="cm">	   we are accessing. Polling the Flash Ready bit after issue 3 bytes</span>
<span class="cm">	   address in Sequence Read Mode, see Software Requirement 11.4 item 1.*/</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>

	<span class="cm">/* init the ECC engine, see Reed-Solomon EDC/ECC 11.1 .*/</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_EN</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

	<span class="cm">/* Read the data via the internal pipeline through CDSN IO register,</span>
<span class="cm">	   see Pipelined Read Operations 11.3 */</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
<span class="cp">#ifndef USE_MEMCPY</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* N.B. you have to increase the source address in this way or the</span>
<span class="cm">		   ECC logic will not work properly */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">docptr</span> <span class="o">+</span> <span class="n">DoC_Mil_CDSN_IO</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>

	<span class="cm">/* Let the caller know we completed it */</span>
	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Read the ECC data from Spare Data Area,</span>
<span class="cm">	   see Reed-Solomon EDC/ECC 11.1 */</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
<span class="cp">#ifndef USE_MEMCPY</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* N.B. you have to increase the source address in this way or the</span>
<span class="cm">		   ECC logic will not work properly */</span>
		<span class="n">eccbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">eccbuf</span><span class="p">,</span> <span class="n">docptr</span> <span class="o">+</span> <span class="n">DoC_Mil_CDSN_IO</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">eccbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>

	<span class="cm">/* Flush the pipeline */</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

	<span class="cm">/* Check the ECC Status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nb_errors</span><span class="p">;</span>
		<span class="cm">/* There was an ECC error */</span>
<span class="cp">#ifdef ECC_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DiskOnChip ECC Error: Read at %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">from</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/* Read the ECC syndrome through the DiskOnChip ECC logic.</span>
<span class="cm">		   These syndrome will be all ZERO when there is no error */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">syndrome</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCSyndrome0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nb_errors</span> <span class="o">=</span> <span class="n">doc_decode_ecc</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">);</span>
<span class="cp">#ifdef ECC_DEBUG</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ECC Errors corrected: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nb_errors</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb_errors</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We return error, but have actually done the read. Not that</span>
<span class="cm">			   this can be told to user-space, via sys_read(), but at least</span>
<span class="cm">			   MTD-aware stuff can know about it by checking *retlen */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef PSYCHO_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ECC DATA at %lx: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
	       <span class="n">eccbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="cp">#endif</span>

	<span class="cm">/* disable the ECC engine */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span> <span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">to</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)];</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Don&#39;t allow a single write to cross a 512-byte block boundary */</span>
<span class="c">	if (to + len &gt; ( (to | 0x1ff) + 1))</span>
<span class="c">		len = ((to | 0x1ff) + 1) - to;</span>
<span class="cp">#else</span>
	<span class="cm">/* Don&#39;t allow writes which aren&#39;t exactly one block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span> <span class="o">||</span> <span class="n">len</span> <span class="o">!=</span> <span class="mh">0x200</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Find the chip which is to be used and select it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

	<span class="cm">/* Reset the chip, see Software Requirement 11.4 item 1. */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_RESET</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>
	<span class="cm">/* Set device to main plane of flash */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_READ0</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="cm">/* issue the Serial Data In command to initial the Page Program process */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>

	<span class="cm">/* init the ECC engine, see Reed-Solomon EDC/ECC 11.1 .*/</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_EN</span> <span class="o">|</span> <span class="n">DOC_ECC_RW</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

	<span class="cm">/* Write the data via the internal pipeline through CDSN IO register,</span>
<span class="cm">	   see Pipelined Write Operations 11.2 */</span>
<span class="cp">#ifndef USE_MEMCPY</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* N.B. you have to increase the source address in this way or the</span>
<span class="cm">		   ECC logic will not work properly */</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">docptr</span> <span class="o">+</span> <span class="n">DoC_Mil_CDSN_IO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>

	<span class="cm">/* Write ECC data to flash, the ECC info is generated by the DiskOnChip ECC logic</span>
<span class="cm">	   see Reed-Solomon EDC/ECC 11.1 */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>

	<span class="cm">/* Read the ECC data through the DiskOnChip ECC logic */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eccbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCSyndrome0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* ignore the ECC engine */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span> <span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

<span class="cp">#ifndef USE_MEMCPY</span>
	<span class="cm">/* Write the ECC data to flash */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* N.B. you have to increase the source address in this way or the</span>
<span class="cm">		   ECC logic will not work properly */</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">eccbuf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">docptr</span> <span class="o">+</span> <span class="n">DoC_Mil_CDSN_IO</span><span class="p">,</span> <span class="n">eccbuf</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* write the block status BLOCK_USED (0x5555) at the end of ECC data</span>
<span class="cm">	   FIXME: this is only a hack for programming the IPL area for LinuxBIOS</span>
<span class="cm">	   and should be replace with proper codes in user space utilities */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>

<span class="cp">#ifdef PSYCHO_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">to</span><span class="p">,</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
	       <span class="n">eccbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">eccbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Commit the Page Program command and wait for ready</span>
<span class="cm">	   see Software Requirement 11.4 item 1.*/</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>

	<span class="cm">/* Read the status of the flash device through CDSN IO register</span>
<span class="cm">	   see Software Requirement 11.4 item 5.*/</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Error programming flash</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Error in programming</span>
<span class="cm">		   FIXME: implement Bad Block Replacement (in nftl.c ??) */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>

	<span class="cm">/* Let the caller know we completed it */</span>
	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_read_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef USE_MEMCPY</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobbuf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">);</span>

	<span class="n">ofs</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooboffs</span><span class="p">;</span>

	<span class="cm">/* Find the chip which is to be used and select it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

	<span class="cm">/* disable the ECC engine */</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

	<span class="cm">/* issue the Read2 command to set the pointer to the Spare Data Area.</span>
<span class="cm">	   Polling the Flash Ready bit after issue 3 bytes address in</span>
<span class="cm">	   Sequence Read Mode, see Software Requirement 11.4 item 1.*/</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_READOOB</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>

	<span class="cm">/* Read the data out via the internal pipeline through CDSN IO register,</span>
<span class="cm">	   see Pipelined Read Operations 11.3 */</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
<span class="cp">#ifndef USE_MEMCPY</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* N.B. you have to increase the source address in this way or the</span>
<span class="cm">		   ECC logic will not work properly */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">docptr</span> <span class="o">+</span> <span class="n">DoC_Mil_CDSN_IO</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_write_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef USE_MEMCPY</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">oobbuf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">);</span>

	<span class="n">ofs</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ooboffs</span><span class="p">;</span>

	<span class="cm">/* Find the chip which is to be used and select it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

	<span class="cm">/* disable the ECC engine */</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
	<span class="n">WriteDOC</span> <span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>

	<span class="cm">/* Reset the chip, see Software Requirement 11.4 item 1. */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_RESET</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>
	<span class="cm">/* issue the Read2 command to set the pointer to the Spare Data Area. */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_READOOB</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>

	<span class="cm">/* issue the Serial Data In command to initial the Page Program process */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="cm">/* Write the data via the internal pipeline through CDSN IO register,</span>
<span class="cm">	   see Pipelined Write Operations 11.2 */</span>
<span class="cp">#ifndef USE_MEMCPY</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* N.B. you have to increase the source address in this way or the</span>
<span class="cm">		   ECC logic will not work properly */</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">docptr</span> <span class="o">+</span> <span class="n">DoC_Mil_CDSN_IO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>

	<span class="cm">/* Commit the Page Program command and wait for ready</span>
<span class="cm">	   see Software Requirement 11.4 item 1.*/</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>

	<span class="cm">/* Read the status of the flash device through CDSN IO register</span>
<span class="cm">	   see Software Requirement 11.4 item 5.*/</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Error programming oob data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* FIXME: implement Bad Block Replacement (in nftl.c ??) */</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">doc_erase</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Nand</span> <span class="o">*</span><span class="n">mychip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Erase not right size (%x != %x)n&quot;</span><span class="p">,</span>
		       <span class="n">len</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">);</span>

	<span class="cm">/* Find the chip which is to be used and select it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectFloor</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">);</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">!=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DoC_SelectChip</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">floor</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">mychip</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_PENDING</span><span class="p">;</span>

	<span class="cm">/* issue the Erase Setup command */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_ERASE1</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_Address</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="cm">/* Commit the Erase Start command and wait for ready</span>
<span class="cm">	   see Software Requirement 11.4 item 1.*/</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_ERASE2</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">docptr</span><span class="p">);</span>

	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASING</span><span class="p">;</span>

	<span class="cm">/* Read the status of the flash device through CDSN IO register</span>
<span class="cm">	   see Software Requirement 11.4 item 5.</span>
<span class="cm">	   FIXME: it seems that we are not wait long enough, some blocks are not</span>
<span class="cm">	   erased fully */</span>
	<span class="n">DoC_Command</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="n">CDSN_CTRL_WP</span><span class="p">);</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Error Erasing at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="cm">/* There was an error</span>
<span class="cm">		   FIXME: implement Bad Block Replacement (in nftl.c ??) */</span>
		<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_FAILED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_DONE</span><span class="p">;</span>
	<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>

	<span class="n">mtd_erase_callback</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Module stuff</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_doc2001</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">DiskOnChip</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">mtd</span><span class="o">=</span><span class="n">docmillist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="n">docmillist</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nextdoc</span><span class="p">;</span>

		<span class="n">mtd_device_unregister</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

		<span class="n">iounmap</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_doc2001</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Woodhouse &lt;dwmw2@infradead.org&gt; et al.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Alternative driver for DiskOnChip Millennium&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
