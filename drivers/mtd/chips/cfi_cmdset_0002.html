<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › chips › cfi_cmdset_0002.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>cfi_cmdset_0002.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Common Flash Interface support:</span>
<span class="cm"> *   AMD &amp; Fujitsu Standard Vendor Command Set (ID 0x0002)</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000 Crossnet Co. &lt;info@crossnet.co.jp&gt;</span>
<span class="cm"> * Copyright (C) 2004 Arcom Control Systems Ltd &lt;linux@arcom.com&gt;</span>
<span class="cm"> * Copyright (C) 2005 MontaVista Software Inc. &lt;source@mvista.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * 2_by_8 routines added by Simon Munton</span>
<span class="cm"> *</span>
<span class="cm"> * 4_by_16 work by Carolyn J. Smith</span>
<span class="cm"> *</span>
<span class="cm"> * XIP support hooks by Vitaly Wool (based on code for Intel flash</span>
<span class="cm"> * by Nicolas Pitre)</span>
<span class="cm"> *</span>
<span class="cm"> * 25/09/2008 Christopher Moore: TopBottom fixup for many Macronix with CFI V1.0</span>
<span class="cm"> *</span>
<span class="cm"> * Occasionally maintained by Thayne Harbaugh tharbaugh at lnxi dot com</span>
<span class="cm"> *</span>
<span class="cm"> * This code is GPL</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/map.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/cfi.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/xip.h&gt;</span>

<span class="cp">#define AMD_BOOTLOC_BUG</span>
<span class="cp">#define FORCE_WORD_WRITE 0</span>

<span class="cp">#define MAX_WORD_RETRIES 3</span>

<span class="cp">#define SST49LF004B	        0x0060</span>
<span class="cp">#define SST49LF040B	        0x0050</span>
<span class="cp">#define SST49LF008A		0x005a</span>
<span class="cp">#define AT49BV6416		0x00d6</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_write_words</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_write_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_erase_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_erase_varsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cfi_amdstd_sync</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_suspend</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cfi_amdstd_resume</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_secsi_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_amdstd_panic_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cfi_amdstd_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">cfi_cmdset_0002</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">cfi_amdstd_setup</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">get_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">put_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">);</span>
<span class="cp">#include &quot;fwh_lock.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_atmel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">cfi_atmel_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_chip_driver</span> <span class="n">cfi_amdstd_chipdrv</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="cm">/* Not usable directly */</span>
	<span class="p">.</span><span class="n">destroy</span>	<span class="o">=</span> <span class="n">cfi_amdstd_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;cfi_cmdset_0002&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span>
<span class="p">};</span>


<span class="cm">/* #define DEBUG_CFI_FEATURES */</span>


<span class="cp">#ifdef DEBUG_CFI_FEATURES</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfi_tell_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfi_pri_amdstd</span> <span class="o">*</span><span class="n">extp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">erase_suspend</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Not supported&quot;</span><span class="p">,</span> <span class="s">&quot;Read only&quot;</span><span class="p">,</span> <span class="s">&quot;Read/write&quot;</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">top_bottom</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;No WP&quot;</span><span class="p">,</span> <span class="s">&quot;8x8KiB sectors at top &amp; bottom, no WP&quot;</span><span class="p">,</span>
		<span class="s">&quot;Bottom boot&quot;</span><span class="p">,</span> <span class="s">&quot;Top boot&quot;</span><span class="p">,</span>
		<span class="s">&quot;Uniform, Bottom WP&quot;</span><span class="p">,</span> <span class="s">&quot;Uniform, Top WP&quot;</span>
	<span class="p">};</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Silicon revision: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">SiliconRevision</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Address sensitive unlock: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">SiliconRevision</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Not required&quot;</span> <span class="o">:</span> <span class="s">&quot;Required&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">EraseSuspend</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">erase_suspend</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Erase Suspend: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">erase_suspend</span><span class="p">[</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">EraseSuspend</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Erase Suspend: Unknown value %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">EraseSuspend</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">BlkProt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Block protection: Not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Block protection: %d sectors per group</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">BlkProt</span><span class="p">);</span>


	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Temporary block unprotect: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">extp</span><span class="o">-&gt;</span><span class="n">TmpBlkUnprotect</span> <span class="o">?</span> <span class="s">&quot;Supported&quot;</span> <span class="o">:</span> <span class="s">&quot;Not supported&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Block protect/unprotect scheme: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">BlkProtUnprot</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Number of simultaneous operations: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">SimultaneousOps</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Burst mode: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">extp</span><span class="o">-&gt;</span><span class="n">BurstMode</span> <span class="o">?</span> <span class="s">&quot;Supported&quot;</span> <span class="o">:</span> <span class="s">&quot;Not supported&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">PageMode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Page mode: Not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Page mode: %d word page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">PageMode</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Vpp Supply Minimum Program/Erase Voltage: %d.%d V</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">extp</span><span class="o">-&gt;</span><span class="n">VppMin</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">VppMin</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Vpp Supply Maximum Program/Erase Voltage: %d.%d V</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">extp</span><span class="o">-&gt;</span><span class="n">VppMax</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">VppMax</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">top_bottom</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Top/Bottom Boot Block: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">top_bottom</span><span class="p">[</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  Top/Bottom Boot Block: Unknown value %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef AMD_BOOTLOC_BUG</span>
<span class="cm">/* Wheee. Bring me the head of someone at AMD. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_amd_bootblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_pri_amdstd</span> <span class="o">*</span><span class="n">extp</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cmdset_priv</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">major</span> <span class="o">=</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">major</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">minor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x3131</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* CFI version 1.0 =&gt; don&#39;t trust bootloc */</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">mfr</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

		<span class="cm">/* AFAICS all 29LV400 with a bottom boot block have a device ID</span>
<span class="cm">		 * of 0x22BA in 16-bit mode and 0xBA in 8-bit mode.</span>
<span class="cm">		 * These were badly detected as they have the 0x80 bit set</span>
<span class="cm">		 * so treat them as a special case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="mh">0xBA</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="mh">0x22BA</span><span class="p">))</span> <span class="o">&amp;&amp;</span>

			<span class="cm">/* Macronix added CFI to their 2nd generation</span>
<span class="cm">			 * MX29LV400C B/T but AFAICS no other 29LV400 (AMD,</span>
<span class="cm">			 * Fujitsu, Spansion, EON, ESI and older Macronix)</span>
<span class="cm">			 * has CFI.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Therefore also check the manufacturer.</span>
<span class="cm">			 * This reduces the risk of false detection due to</span>
<span class="cm">			 * the 8-bit device ID.</span>
<span class="cm">			 */</span>
			<span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">mfr</span> <span class="o">==</span> <span class="n">CFI_MFR_MACRONIX</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: Macronix MX29LV400C with bottom boot block&quot;</span>
				<span class="s">&quot; detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* bottom boot */</span>
		<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: JEDEC Device ID is 0x%02X. Assuming broken CFI table.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* top boot */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* bottom boot */</span>
		<span class="p">}</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: AMD CFI PRI V%c.%c has no boot block field;&quot;</span>
			<span class="s">&quot; deduced %s from Device ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="s">&quot;bottom&quot;</span> <span class="o">:</span> <span class="s">&quot;top&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_use_write_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">BufWriteTimeoutTyp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Using buffer write method</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write</span> <span class="o">=</span> <span class="n">cfi_amdstd_write_buffers</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Atmel chips don&#39;t use the same PRI format as AMD chips */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_convert_atmel_pri</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_pri_amdstd</span> <span class="o">*</span><span class="n">extp</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cmdset_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_pri_atmel</span> <span class="n">atmel_pri</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atmel_pri</span><span class="p">,</span> <span class="n">extp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">atmel_pri</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">extp</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">extp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">5</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atmel_pri</span><span class="p">.</span><span class="n">Features</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span>
		<span class="n">extp</span><span class="o">-&gt;</span><span class="n">EraseSuspend</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Some chips got it backwards... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">AT49BV6416</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atmel_pri</span><span class="p">.</span><span class="n">BottomBoot</span><span class="p">)</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atmel_pri</span><span class="p">.</span><span class="n">BottomBoot</span><span class="p">)</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* burst write mode not supported */</span>
	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">BufWriteTimeoutTyp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">BufWriteTimeoutMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_use_secsi</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Setup for chips with a secsi area */</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read_user_prot_reg</span> <span class="o">=</span> <span class="n">cfi_amdstd_secsi_read</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read_fact_prot_reg</span> <span class="o">=</span> <span class="n">cfi_amdstd_secsi_read</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_use_erase_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_erase</span> <span class="o">=</span> <span class="n">cfi_amdstd_erase_chip</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some Atmel chips (e.g. the AT49BV6416) power-up with all sectors</span>
<span class="cm"> * locked by default.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_use_atmel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">cfi_atmel_lock</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_unlock</span> <span class="o">=</span> <span class="n">cfi_atmel_unlock</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MTD_POWERUP_LOCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_old_sst_eraseregion</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These flashes report two separate eraseblock regions based on the</span>
<span class="cm">	 * sector_erase-size and block_erase-size, although they both operate on the</span>
<span class="cm">	 * same memory. This is not allowed according to CFI, so we just pick the</span>
<span class="cm">	 * sector_erase-size.</span>
<span class="cm">	 */</span>
	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_sst39vf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="n">fixup_old_sst_eraseregion</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span> <span class="o">=</span> <span class="mh">0x5555</span><span class="p">;</span>
	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span> <span class="o">=</span> <span class="mh">0x2AAA</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_sst39vf_rev_b</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="n">fixup_old_sst_eraseregion</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span> <span class="o">=</span> <span class="mh">0x555</span><span class="p">;</span>
	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span> <span class="o">=</span> <span class="mh">0x2AA</span><span class="p">;</span>

	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">sector_erase_cmd</span> <span class="o">=</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0x50</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_sst38vf640x_sectorsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="n">fixup_sst39vf_rev_b</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * CFI reports 1024 sectors (0x03ff+1) of 64KBytes (0x0100*256) where</span>
<span class="cm">	 * it should report a size of 8KBytes (0x0020*256).</span>
<span class="cm">	 */</span>
	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x002003ff</span><span class="p">;</span>
	<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Bad 38VF640x CFI data; adjusting sector size from 64 to 8KiB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_s29gl064n_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x003f</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x0040</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Bad S29GL064N CFI data; adjust from 64 to 128 sectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_s29gl032n_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x007e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x0040</span><span class="p">;</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Bad S29GL032N CFI data; adjust from 127 to 63 sectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_s29ns512p_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  S29NS512P flash uses more than 8bits to report number of sectors,</span>
<span class="cm">	 * which is not permitted by CFI.</span>
<span class="cm">	 */</span>
	<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x020001ff</span><span class="p">;</span>
	<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Bad S29NS512P CFI data; adjust to 512 sectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used to fix CFI-Tables of chips without Extended Query Tables */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfi_fixup</span> <span class="n">cfi_nopri_fixup_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x234a</span><span class="p">,</span> <span class="n">fixup_sst39vf</span> <span class="p">},</span> <span class="cm">/* SST39VF1602 */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x234b</span><span class="p">,</span> <span class="n">fixup_sst39vf</span> <span class="p">},</span> <span class="cm">/* SST39VF1601 */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x235a</span><span class="p">,</span> <span class="n">fixup_sst39vf</span> <span class="p">},</span> <span class="cm">/* SST39VF3202 */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x235b</span><span class="p">,</span> <span class="n">fixup_sst39vf</span> <span class="p">},</span> <span class="cm">/* SST39VF3201 */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x235c</span><span class="p">,</span> <span class="n">fixup_sst39vf_rev_b</span> <span class="p">},</span> <span class="cm">/* SST39VF3202B */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x235d</span><span class="p">,</span> <span class="n">fixup_sst39vf_rev_b</span> <span class="p">},</span> <span class="cm">/* SST39VF3201B */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x236c</span><span class="p">,</span> <span class="n">fixup_sst39vf_rev_b</span> <span class="p">},</span> <span class="cm">/* SST39VF6402B */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x236d</span><span class="p">,</span> <span class="n">fixup_sst39vf_rev_b</span> <span class="p">},</span> <span class="cm">/* SST39VF6401B */</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfi_fixup</span> <span class="n">cfi_fixup_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">CFI_MFR_ATMEL</span><span class="p">,</span> <span class="n">CFI_ID_ANY</span><span class="p">,</span> <span class="n">fixup_convert_atmel_pri</span> <span class="p">},</span>
<span class="cp">#ifdef AMD_BOOTLOC_BUG</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="n">CFI_ID_ANY</span><span class="p">,</span> <span class="n">fixup_amd_bootblock</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMIC</span><span class="p">,</span> <span class="n">CFI_ID_ANY</span><span class="p">,</span> <span class="n">fixup_amd_bootblock</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_MACRONIX</span><span class="p">,</span> <span class="n">CFI_ID_ANY</span><span class="p">,</span> <span class="n">fixup_amd_bootblock</span> <span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x0050</span><span class="p">,</span> <span class="n">fixup_use_secsi</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x0053</span><span class="p">,</span> <span class="n">fixup_use_secsi</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x0055</span><span class="p">,</span> <span class="n">fixup_use_secsi</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x0056</span><span class="p">,</span> <span class="n">fixup_use_secsi</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x005C</span><span class="p">,</span> <span class="n">fixup_use_secsi</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x005F</span><span class="p">,</span> <span class="n">fixup_use_secsi</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x0c01</span><span class="p">,</span> <span class="n">fixup_s29gl064n_sectors</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x1301</span><span class="p">,</span> <span class="n">fixup_s29gl064n_sectors</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x1a00</span><span class="p">,</span> <span class="n">fixup_s29gl032n_sectors</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x1a01</span><span class="p">,</span> <span class="n">fixup_s29gl032n_sectors</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_AMD</span><span class="p">,</span> <span class="mh">0x3f00</span><span class="p">,</span> <span class="n">fixup_s29ns512p_sectors</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x536a</span><span class="p">,</span> <span class="n">fixup_sst38vf640x_sectorsize</span> <span class="p">},</span> <span class="cm">/* SST38VF6402 */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x536b</span><span class="p">,</span> <span class="n">fixup_sst38vf640x_sectorsize</span> <span class="p">},</span> <span class="cm">/* SST38VF6401 */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x536c</span><span class="p">,</span> <span class="n">fixup_sst38vf640x_sectorsize</span> <span class="p">},</span> <span class="cm">/* SST38VF6404 */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="mh">0x536d</span><span class="p">,</span> <span class="n">fixup_sst38vf640x_sectorsize</span> <span class="p">},</span> <span class="cm">/* SST38VF6403 */</span>
<span class="cp">#if !FORCE_WORD_WRITE</span>
	<span class="p">{</span> <span class="n">CFI_MFR_ANY</span><span class="p">,</span> <span class="n">CFI_ID_ANY</span><span class="p">,</span> <span class="n">fixup_use_write_buffers</span> <span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cfi_fixup</span> <span class="n">jedec_fixup_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="n">SST49LF004B</span><span class="p">,</span> <span class="n">fixup_use_fwh_lock</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="n">SST49LF040B</span><span class="p">,</span> <span class="n">fixup_use_fwh_lock</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_SST</span><span class="p">,</span> <span class="n">SST49LF008A</span><span class="p">,</span> <span class="n">fixup_use_fwh_lock</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cfi_fixup</span> <span class="n">fixup_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* The CFI vendor ids and the JEDEC vendor IDs appear</span>
<span class="cm">	 * to be common.  It is like the devices id&#39;s are as</span>
<span class="cm">	 * well.  This table is to pick all cases where</span>
<span class="cm">	 * we know that is the case.</span>
<span class="cm">	 */</span>
	<span class="p">{</span> <span class="n">CFI_MFR_ANY</span><span class="p">,</span> <span class="n">CFI_ID_ANY</span><span class="p">,</span> <span class="n">fixup_use_erase_chip</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">CFI_MFR_ATMEL</span><span class="p">,</span> <span class="n">AT49BV6416</span><span class="p">,</span> <span class="n">fixup_use_atmel_lock</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfi_fixup_major_minor</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cfi_pri_amdstd</span> <span class="o">*</span><span class="n">extp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">mfr</span> <span class="o">==</span> <span class="n">CFI_MFR_SAMSUNG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span> <span class="o">==</span> <span class="sc">&#39;3&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span> <span class="o">==</span> <span class="sc">&#39;3&#39;</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Samsung K8P2815UQB and K8D6x16UxM chips</span>
<span class="cm">			 * report major=0 / minor=0.</span>
<span class="cm">			 * K8D3x16UxC chips report major=3 / minor=3.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;  Fixing Samsung&#39;s Amd/Fujitsu&quot;</span>
			       <span class="s">&quot; Extended Query version to 1.%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span><span class="p">);</span>
			<span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * SST 38VF640x chips report major=0xFF / minor=0xFF.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">mfr</span> <span class="o">==</span> <span class="n">CFI_MFR_SST</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0536</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
		<span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="nf">cfi_cmdset_0002</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">primary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mtd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mtd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Failed to allocate memory for MTD device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">MTD_NORFLASH</span><span class="p">;</span>

	<span class="cm">/* Fill in the default mtd operations */</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_erase</span>   <span class="o">=</span> <span class="n">cfi_amdstd_erase_varsize</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_write</span>   <span class="o">=</span> <span class="n">cfi_amdstd_write_words</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_read</span>    <span class="o">=</span> <span class="n">cfi_amdstd_read</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_sync</span>    <span class="o">=</span> <span class="n">cfi_amdstd_sync</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_suspend</span> <span class="o">=</span> <span class="n">cfi_amdstd_suspend</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_resume</span>  <span class="o">=</span> <span class="n">cfi_amdstd_resume</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">flags</span>   <span class="o">=</span> <span class="n">MTD_CAP_NORFLASH</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span>    <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writebufsize</span> <span class="o">=</span> <span class="n">cfi_interleave</span><span class="p">(</span><span class="n">cfi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">MaxBufWriteSize</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): write buffer size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writebufsize</span><span class="p">);</span>

	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">_panic_write</span> <span class="o">=</span> <span class="n">cfi_amdstd_panic_write</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">reboot_notifier</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">cfi_amdstd_reboot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfi_mode</span><span class="o">==</span><span class="n">CFI_MODE_CFI</span><span class="p">){</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bootloc</span><span class="p">;</span>
		<span class="n">__u16</span> <span class="n">adr</span> <span class="o">=</span> <span class="n">primary</span><span class="o">?</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">P_ADR</span><span class="o">:</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">A_ADR</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cfi_pri_amdstd</span> <span class="o">*</span><span class="n">extp</span><span class="p">;</span>

		<span class="n">extp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cfi_pri_amdstd</span><span class="o">*</span><span class="p">)</span><span class="n">cfi_read_pri</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">extp</span><span class="p">),</span> <span class="s">&quot;Amd/Fujitsu&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extp</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It&#39;s a real CFI chip, not one for which the probe</span>
<span class="cm">			 * routine faked a CFI structure.</span>
<span class="cm">			 */</span>
			<span class="n">cfi_fixup_major_minor</span><span class="p">(</span><span class="n">cfi</span><span class="p">,</span> <span class="n">extp</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Valid primary extension versions are: 1.0, 1.1, 1.2, 1.3, 1.4, 1.5</span>
<span class="cm">			 * see: http://cs.ozerki.net/zap/pub/axim-x5/docs/cfi_r20.pdf, page 19 </span>
<span class="cm">			 *      http://www.spansion.com/Support/AppNotes/cfi_100_20011201.pdf</span>
<span class="cm">			 *      http://www.spansion.com/Support/Datasheets/s29ws-p_00_a12_e.pdf</span>
<span class="cm">			 *      http://www.spansion.com/Support/Datasheets/S29GL_128S_01GS_00_02_e.pdf</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span> <span class="o">!=</span> <span class="sc">&#39;1&#39;</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span> <span class="o">||</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span> <span class="o">&gt;</span> <span class="sc">&#39;5&#39;</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;  Unknown Amd/Fujitsu Extended Query &quot;</span>
				       <span class="s">&quot;version %c.%c (%#02x/%#02x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span><span class="p">,</span>
				       <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">extp</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;  Amd/Fujitsu Extended Query version %c.%c.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MajorVersion</span><span class="p">,</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">MinorVersion</span><span class="p">);</span>

			<span class="cm">/* Install our own private info structure */</span>
			<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cmdset_priv</span> <span class="o">=</span> <span class="n">extp</span><span class="p">;</span>

			<span class="cm">/* Apply cfi device specific fixups */</span>
			<span class="n">cfi_fixup</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">cfi_fixup_table</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_CFI_FEATURES</span>
			<span class="cm">/* Tell the user about it in lots of lovely detail */</span>
			<span class="n">cfi_tell_features</span><span class="p">(</span><span class="n">extp</span><span class="p">);</span>
<span class="cp">#endif</span>

			<span class="n">bootloc</span> <span class="o">=</span> <span class="n">extp</span><span class="o">-&gt;</span><span class="n">TopBottom</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">bootloc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">bootloc</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: CFI contains unrecognised boot &quot;</span>
				       <span class="s">&quot;bank location (%d). Assuming bottom.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bootloc</span><span class="p">);</span>
				<span class="n">bootloc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bootloc</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: Swapping erase regions for top-boot CFI table.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

				<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">;</span>
					<span class="n">__u32</span> <span class="n">swap</span><span class="p">;</span>

					<span class="n">swap</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
					<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
					<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/* Set the default CFI lock/unlock addresses */</span>
			<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span> <span class="o">=</span> <span class="mh">0x555</span><span class="p">;</span>
			<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span> <span class="o">=</span> <span class="mh">0x2aa</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cfi_fixup</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">cfi_nopri_fixup_table</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span> <span class="o">||</span> <span class="o">!</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="cm">/* CFI mode */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfi_mode</span> <span class="o">==</span> <span class="n">CFI_MODE_JEDEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Apply jedec specific fixups */</span>
		<span class="n">cfi_fixup</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">jedec_fixup_table</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Apply generic fixups */</span>
	<span class="n">cfi_fixup</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">fixup_table</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">word_write_time</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">WordWriteTimeoutTyp</span><span class="p">;</span>
		<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer_write_time</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">BufWriteTimeoutTyp</span><span class="p">;</span>
		<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">erase_time</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">BlockEraseTimeoutTyp</span><span class="p">;</span>
		<span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ref_point_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wq</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfi_amdstd_chipdrv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cfi_amdstd_setup</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">cfi_cmdset_0006</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">primary</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">alias</span><span class="p">(</span><span class="s">&quot;cfi_cmdset_0002&quot;</span><span class="p">)));</span>
<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">cfi_cmdset_0701</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">primary</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">alias</span><span class="p">(</span><span class="s">&quot;cfi_cmdset_0002&quot;</span><span class="p">)));</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cfi_cmdset_0002</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cfi_cmdset_0006</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cfi_cmdset_0701</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="nf">cfi_amdstd_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">devsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">DevSize</span><span class="p">)</span> <span class="o">*</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">interleave</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;number of %s chips: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfi_mode</span> <span class="o">==</span> <span class="n">CFI_MODE_CFI</span><span class="p">)</span><span class="o">?</span><span class="s">&quot;CFI&quot;</span><span class="o">:</span><span class="s">&quot;JEDEC&quot;</span><span class="p">,</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">);</span>
	<span class="cm">/* Select the correct geometry setup */</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">devsize</span> <span class="o">*</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">;</span>

	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">numeraseregions</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span> <span class="o">*</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">eraseregions</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_erase_region_info</span><span class="p">)</span>
				    <span class="o">*</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">numeraseregions</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">eraseregions</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Failed to allocate memory for MTD erase region info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">setup_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ernum</span><span class="p">,</span> <span class="n">ersize</span><span class="p">;</span>
		<span class="n">ersize</span> <span class="o">=</span> <span class="p">((</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xff</span><span class="p">)</span> <span class="o">*</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">interleave</span><span class="p">;</span>
		<span class="n">ernum</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">EraseRegionInfo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">&lt;</span> <span class="n">ersize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">=</span> <span class="n">ersize</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">eraseregions</span><span class="p">[(</span><span class="n">j</span><span class="o">*</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">devsize</span><span class="p">)</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">eraseregions</span><span class="p">[(</span><span class="n">j</span><span class="o">*</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">].</span><span class="n">erasesize</span> <span class="o">=</span> <span class="n">ersize</span><span class="p">;</span>
			<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">eraseregions</span><span class="p">[(</span><span class="n">j</span><span class="o">*</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">NumEraseRegions</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">].</span><span class="n">numblocks</span> <span class="o">=</span> <span class="n">ernum</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ersize</span> <span class="o">*</span> <span class="n">ernum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">devsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Argh */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Sum of regions (%lx) != total size of set of interleaved chips (%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">devsize</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">setup_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">reboot_notifier</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mtd</span><span class="p">;</span>

 <span class="nl">setup_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">eraseregions</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cmdset_priv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if the chip is ready.</span>
<span class="cm"> *</span>
<span class="cm"> * Ready is one of: read mode, query mode, erase-suspend-read mode (in any</span>
<span class="cm"> * non-suspended sector) and is indicated by no toggle bits toggling.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that anything more complicated than checking if no bits are toggling</span>
<span class="cm"> * (including checking DQ5 for an error status) is tricky to get working</span>
<span class="cm"> * correctly and is therefore not done	(particularly with interleaved chips</span>
<span class="cm"> * as each chip must be checked independently of the others).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__xipram</span> <span class="nf">chip_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_word</span> <span class="n">d</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">d</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">map_word_equal</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if the chip is ready and has the correct value.</span>
<span class="cm"> *</span>
<span class="cm"> * Ready is one of: read mode, query mode, erase-suspend-read mode (in any</span>
<span class="cm"> * non-suspended sector) and it is indicated by no bits toggling.</span>
<span class="cm"> *</span>
<span class="cm"> * Error are indicated by toggling bits or bits held with the wrong value,</span>
<span class="cm"> * or with bits toggling.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that anything more complicated than checking if no bits are toggling</span>
<span class="cm"> * (including checking DQ5 for an error status) is tricky to get working</span>
<span class="cm"> * correctly and is therefore not done	(particularly with interleaved chips</span>
<span class="cm"> * as each chip must be checked independently of the others).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__xipram</span> <span class="nf">chip_good</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">expected</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">map_word</span> <span class="n">oldd</span><span class="p">,</span> <span class="n">curd</span><span class="p">;</span>

	<span class="n">oldd</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">curd</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span>	<span class="n">map_word_equal</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">oldd</span><span class="p">,</span> <span class="n">curd</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">map_word_equal</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">curd</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_pri_amdstd</span> <span class="o">*</span><span class="n">cfip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cfi_pri_amdstd</span> <span class="o">*</span><span class="p">)</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cmdset_priv</span><span class="p">;</span>

 <span class="nl">resettime:</span>
	<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
 <span class="nl">retry:</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">FL_STATUS</span>:
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Waiting for chip to be ready timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">cfi_udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="cm">/* Someone else might have been playing with it. */</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="n">FL_READY</span>:
	<span class="k">case</span> <span class="n">FL_CFI_QUERY</span>:
	<span class="k">case</span> <span class="n">FL_JEDEC_QUERY</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FL_ERASING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfip</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">cfip</span><span class="o">-&gt;</span><span class="n">EraseSuspend</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x1</span><span class="o">|</span><span class="mh">0x2</span><span class="p">))</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FL_READY</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">FL_POINT</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FL_WRITING</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cfip</span><span class="o">-&gt;</span><span class="n">EraseSuspend</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">))))</span>
			<span class="k">goto</span> <span class="n">sleep</span><span class="p">;</span>

		<span class="cm">/* We could check to see if we&#39;re trying to access the sector</span>
<span class="cm">		 * that is currently being erased. However, no user will try</span>
<span class="cm">		 * anything like that so we just wait for the timeout. */</span>

		<span class="cm">/* Erase suspend */</span>
		<span class="cm">/* It&#39;s harmless to issue the Erase-Suspend and Erase-Resume</span>
<span class="cm">		 * commands when the erase algorithm isn&#39;t in progress. */</span>
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xB0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">in_progress_block_addr</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">FL_ERASING</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_ERASE_SUSPENDING</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Should have suspended the erase by now.</span>
<span class="cm">				 * Send an Erase-Resume command as either</span>
<span class="cm">				 * there was an error (so leave the erase</span>
<span class="cm">				 * routine to recover from it) or we trying to</span>
<span class="cm">				 * use the erase-in-progress sector. */</span>
				<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;MTD %s(): chip not ready after erase suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">cfi_udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="cm">/* Nobody will touch it while it&#39;s in state FL_ERASE_SUSPENDING.</span>
<span class="cm">			   So we can just loop here. */</span>
		<span class="p">}</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FL_XIP_WHILE_ERASING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">FL_READY</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">FL_POINT</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">cfip</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">cfip</span><span class="o">-&gt;</span><span class="n">EraseSuspend</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">sleep</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FL_SHUTDOWN</span>:
		<span class="cm">/* The machine is rebooting */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FL_POINT</span>:
		<span class="cm">/* Only if there&#39;s no operation suspended... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">FL_READY</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">FL_READY</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
	<span class="nl">sleep:</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">resettime</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FL_ERASING</span>:
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">sector_erase_cmd</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">in_progress_block_addr</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_ERASING</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FL_XIP_WHILE_ERASING</span>:
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span><span class="p">;</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FL_READY</span>:
	<span class="k">case</span> <span class="n">FL_STATUS</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;MTD: put_chip() called with oldstate %d!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MTD_XIP</span>

<span class="cm">/*</span>
<span class="cm"> * No interrupt what so ever can be serviced while the flash isn&#39;t in array</span>
<span class="cm"> * mode.  This is ensured by the xip_disable() and xip_enable() functions</span>
<span class="cm"> * enclosing any code path where the flash is known not to be in array mode.</span>
<span class="cm"> * And within a XIP disabled code path, only functions marked with __xipram</span>
<span class="cm"> * may be called and nothing else (it&#39;s a good thing to inspect generated</span>
<span class="cm"> * assembly to make sure inline functions were actually inlined and that gcc</span>
<span class="cm"> * didn&#39;t emit calls to its own support functions). Also configuring MTD CFI</span>
<span class="cm"> * support to a single buswidth and a single interleave is also recommended.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">xip_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* TODO: chips with no XIP use should ignore and return */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span> <span class="cm">/* ensure mmu mapping is up to date */</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__xipram</span> <span class="nf">xip_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_POINT</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">),</span> <span class="n">adr</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="n">xip_iprefetch</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a delay is required for the flash operation to complete, the</span>
<span class="cm"> * xip_udelay() function is polling for both the given timeout and pending</span>
<span class="cm"> * (but still masked) hardware interrupts.  Whenever there is an interrupt</span>
<span class="cm"> * pending then the flash erase operation is suspended, array mode restored</span>
<span class="cm"> * and interrupts unmasked.  Task scheduling might also happen at that</span>
<span class="cm"> * point.  The CPU eventually returns from the interrupt or the call to</span>
<span class="cm"> * schedule() and the suspended flash operation is resumed for the remaining</span>
<span class="cm"> * of the delay period.</span>
<span class="cm"> *</span>
<span class="cm"> * Warning: this function _will_ fool interrupt latency tracing tools.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__xipram</span> <span class="nf">xip_udelay</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_pri_amdstd</span> <span class="o">*</span><span class="n">extp</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cmdset_priv</span><span class="p">;</span>
	<span class="n">map_word</span> <span class="n">status</span><span class="p">,</span> <span class="n">OK</span> <span class="o">=</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">suspended</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">xip_currtime</span><span class="p">();</span>
	<span class="n">flstate_t</span> <span class="n">oldstate</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xip_irqpending</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">extp</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FL_ERASING</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">extp</span><span class="o">-&gt;</span><span class="n">EraseSuspend</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cfi_interleave_is_1</span><span class="p">(</span><span class="n">cfi</span><span class="p">)</span> <span class="o">||</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">FL_READY</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Let&#39;s suspend the erase operation when supported.</span>
<span class="cm">			 * Note that we currently don&#39;t try to suspend</span>
<span class="cm">			 * interleaved chips if there is already another</span>
<span class="cm">			 * operation suspended (imagine what happens</span>
<span class="cm">			 * when one chip was already done with the current</span>
<span class="cm">			 * operation while another chip suspended it, then</span>
<span class="cm">			 * we resume the whole thing at once).  Yes, it</span>
<span class="cm">			 * can happen!</span>
<span class="cm">			 */</span>
			<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">),</span> <span class="n">adr</span><span class="p">);</span>
			<span class="n">usec</span> <span class="o">-=</span> <span class="n">xip_elapsed_since</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
			<span class="n">suspended</span> <span class="o">=</span> <span class="n">xip_currtime</span><span class="p">();</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">xip_elapsed_since</span><span class="p">(</span><span class="n">suspended</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * The chip doesn&#39;t want to suspend</span>
<span class="cm">					 * after waiting for 100 msecs.</span>
<span class="cm">					 * This is a critical error but there</span>
<span class="cm">					 * is not much we can do here.</span>
<span class="cm">					 */</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">map_word_andequal</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">OK</span><span class="p">,</span> <span class="n">OK</span><span class="p">));</span>

			<span class="cm">/* Suspend succeeded */</span>
			<span class="n">oldstate</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_word_bitsset</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_XIP_WHILE_ERASING</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">),</span> <span class="n">adr</span><span class="p">);</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
			<span class="n">xip_iprefetch</span><span class="p">();</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">xip_iprefetch</span><span class="p">();</span>
			<span class="n">cond_resched</span><span class="p">();</span>

			<span class="cm">/*</span>
<span class="cm">			 * We&#39;re back.  However someone else might have</span>
<span class="cm">			 * decided to go write to the chip if we are in</span>
<span class="cm">			 * a suspended erase state.  If so let&#39;s wait</span>
<span class="cm">			 * until it&#39;s done.</span>
<span class="cm">			 */</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_XIP_WHILE_ERASING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
				<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
				<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">schedule</span><span class="p">();</span>
				<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Disallow XIP again */</span>
			<span class="n">local_irq_disable</span><span class="p">();</span>

			<span class="cm">/* Resume the write or erase operation */</span>
			<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">sector_erase_cmd</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">oldstate</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">xip_currtime</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">usec</span> <span class="o">&gt;=</span> <span class="mi">1000000</span><span class="o">/</span><span class="n">HZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try to save on CPU power when waiting delay</span>
<span class="cm">			 * is at least a system timer tick period.</span>
<span class="cm">			 * No need to be extremely accurate here.</span>
<span class="cm">			 */</span>
			<span class="n">xip_cpu_idle</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">map_word_andequal</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">OK</span><span class="p">,</span> <span class="n">OK</span><span class="p">)</span>
		 <span class="o">&amp;&amp;</span> <span class="n">xip_elapsed_since</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">usec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define UDELAY(map, chip, adr, usec)  xip_udelay(map, chip, adr, usec)</span>

<span class="cm">/*</span>
<span class="cm"> * The INVALIDATE_CACHED_RANGE() macro is normally used in parallel while</span>
<span class="cm"> * the flash is actively programming or erasing since we have to poll for</span>
<span class="cm"> * the operation to complete anyway.  We can&#39;t do that in a generic way with</span>
<span class="cm"> * a XIP setup so do it before the actual flash operation in this case</span>
<span class="cm"> * and stub it out from INVALIDATE_CACHE_UDELAY.</span>
<span class="cm"> */</span>
<span class="cp">#define XIP_INVAL_CACHED_RANGE(map, from, size)  \</span>
<span class="cp">	INVALIDATE_CACHED_RANGE(map, from, size)</span>

<span class="cp">#define INVALIDATE_CACHE_UDELAY(map, chip, adr, len, usec)  \</span>
<span class="cp">	UDELAY(map, chip, adr, usec)</span>

<span class="cm">/*</span>
<span class="cm"> * Extra notes:</span>
<span class="cm"> *</span>
<span class="cm"> * Activating this XIP support changes the way the code works a bit.  For</span>
<span class="cm"> * example the code to suspend the current process when concurrent access</span>
<span class="cm"> * happens is never executed because xip_udelay() will always return with the</span>
<span class="cm"> * same chip state as it was entered with.  This is why there is no care for</span>
<span class="cm"> * the presence of add_wait_queue() or schedule() calls from within a couple</span>
<span class="cm"> * xip_disable()&#39;d  areas of code, like in do_erase_oneblock for example.</span>
<span class="cm"> * The queueing and scheduling are always happening within xip_udelay().</span>
<span class="cm"> *</span>
<span class="cm"> * Similarly, get_chip() and put_chip() just happen to always be executed</span>
<span class="cm"> * with chip-&gt;state set to FL_READY (or FL_XIP_WHILE_*) where flash state</span>
<span class="cm"> * is in array mode, therefore never executing many cases therein and not</span>
<span class="cm"> * causing any problem with XIP.</span>
<span class="cm"> */</span>

<span class="cp">#else</span>

<span class="cp">#define xip_disable(map, chip, adr)</span>
<span class="cp">#define xip_enable(map, chip, adr)</span>
<span class="cp">#define XIP_INVAL_CACHED_RANGE(x...)</span>

<span class="cp">#define UDELAY(map, chip, adr, usec)  \</span>
<span class="cp">do {  \</span>
<span class="cp">	mutex_unlock(&amp;chip-&gt;mutex);  \</span>
<span class="cp">	cfi_udelay(usec);  \</span>
<span class="cp">	mutex_lock(&amp;chip-&gt;mutex);  \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define INVALIDATE_CACHE_UDELAY(map, chip, adr, len, usec)  \</span>
<span class="cp">do {  \</span>
<span class="cp">	mutex_unlock(&amp;chip-&gt;mutex);  \</span>
<span class="cp">	INVALIDATE_CACHED_RANGE(map, adr, len);  \</span>
<span class="cp">	cfi_udelay(usec);  \</span>
<span class="cp">	mutex_lock(&amp;chip-&gt;mutex);  \</span>
<span class="cp">} while (0)</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_read_onechip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cmd_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">adr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* Ensure cmd read/writes are aligned. */</span>
	<span class="n">cmd_addr</span> <span class="o">=</span> <span class="n">adr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">cmd_addr</span><span class="p">,</span> <span class="n">FL_READY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_POINT</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">),</span> <span class="n">cmd_addr</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">map_copy_from</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">cmd_addr</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ofs: offset within the first chip that the first read should start */</span>
	<span class="n">chipnum</span> <span class="o">=</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">from</span> <span class="o">-</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&lt;&lt;</span>  <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thislen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&gt;=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">+</span> <span class="n">ofs</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span>
			<span class="n">thislen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">thislen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_read_onechip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">thislen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="o">*</span><span class="n">retlen</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">thislen</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chipnum</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_read_secsi_onechip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

 <span class="nl">retry:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_READY</span><span class="p">){</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>

	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x88</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">map_copy_from</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x90</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_secsi_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ofs: offset within the first chip that the first read should start */</span>
	<span class="cm">/* 8 secsi bytes per chip */</span>
	<span class="n">chipnum</span><span class="o">=</span><span class="n">from</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">ofs</span><span class="o">=</span><span class="n">from</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thislen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&gt;=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">+</span> <span class="n">ofs</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">thislen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">thislen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_read_secsi_onechip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">thislen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="o">*</span><span class="n">retlen</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">thislen</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">thislen</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">chipnum</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__xipram</span> <span class="nf">do_write_oneword</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">datum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We use a 1ms + 1 jiffies generic timeout for writes (most devices</span>
<span class="cm">	 * have a max write time of a few hundreds usec). However, we should</span>
<span class="cm">	 * use the maximum timeout value given by the chip at probe time</span>
<span class="cm">	 * instead.  Unfortunately, struct flchip does have a field for</span>
<span class="cm">	 * maximum timeout, only for typical which can be far too short</span>
<span class="cm">	 * depending of the conditions.	 The &#39; + 1&#39; is to avoid having a</span>
<span class="cm">	 * timeout of 0 jiffies if HZ is smaller than 1000.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uWriteTimeout</span> <span class="o">=</span> <span class="p">(</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">map_word</span> <span class="n">oldd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">FL_WRITING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): WRITE 0x%.8lx(0x%.8lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">__func__</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">datum</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for a NOP for the case when the datum to write is already</span>
<span class="cm">	 * present - it saves time and works around buggy chips that corrupt</span>
<span class="cm">	 * data at other locations when 0xff is written to a location that</span>
<span class="cm">	 * already contains 0xff.</span>
<span class="cm">	 */</span>
	<span class="n">oldd</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_word_equal</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">oldd</span><span class="p">,</span> <span class="n">datum</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): NOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">op_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">XIP_INVAL_CACHED_RANGE</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">));</span>
	<span class="n">ENABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">xip_disable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
 <span class="nl">retry:</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xA0</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">datum</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_WRITING</span><span class="p">;</span>

	<span class="n">INVALIDATE_CACHE_UDELAY</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span>
				<span class="n">adr</span><span class="p">,</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">),</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">word_write_time</span><span class="p">);</span>

	<span class="cm">/* See comment above for timeout value. */</span>
	<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">uWriteTimeout</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_WRITING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Someone&#39;s suspended the write. Sleep */</span>
			<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="cm">/* FIXME */</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">)){</span>
			<span class="n">xip_enable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;MTD %s(): software timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">xip_disable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Latency issues. Drop the lock, wait a while and retry */</span>
		<span class="n">UDELAY</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Did we succeed? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip_good</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">datum</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* reset on all failures. */</span>
		<span class="n">map_write</span><span class="p">(</span> <span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="p">);</span>
		<span class="cm">/* FIXME - should have reset delay before continuing */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">retry_cnt</span> <span class="o">&lt;=</span> <span class="n">MAX_WORD_RETRIES</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">xip_enable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
 <span class="nl">op_done:</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="n">DISABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_write_words</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">chipstart</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">chipnum</span> <span class="o">=</span> <span class="n">to</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">to</span>  <span class="o">-</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&lt;&lt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>
	<span class="n">chipstart</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* If it&#39;s not bus-aligned, do the first byte write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bus_ofs</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">-</span> <span class="n">bus_ofs</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">map_word</span> <span class="n">tmp_buf</span><span class="p">;</span>

 <span class="nl">retry:</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Load &#39;tmp_buf&#39; with old contents of flash */</span>
		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">bus_ofs</span><span class="o">+</span><span class="n">chipstart</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

		<span class="cm">/* Number of bytes to copy from buffer */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>

		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">map_word_load_partial</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_write_oneword</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span>
				       <span class="n">bus_ofs</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">retlen</span><span class="p">)</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chipnum</span> <span class="o">++</span><span class="p">;</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">==</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We are now aligned, write as much as possible */</span>
	<span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">map_word</span> <span class="n">datum</span><span class="p">;</span>

		<span class="n">datum</span> <span class="o">=</span> <span class="n">map_word_load</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_write_oneword</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span>
				       <span class="n">ofs</span><span class="p">,</span> <span class="n">datum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">retlen</span><span class="p">)</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chipnum</span> <span class="o">++</span><span class="p">;</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">==</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">chipstart</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Write the trailing bytes if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">map_word</span> <span class="n">tmp_buf</span><span class="p">;</span>

 <span class="nl">retry1:</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_READY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">+</span> <span class="n">chipstart</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">map_word_load_partial</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_write_oneword</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span>
				<span class="n">ofs</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="p">(</span><span class="o">*</span><span class="n">retlen</span><span class="p">)</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * FIXME: interleaved mode not tested, and probably not supported!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__xipram</span> <span class="nf">do_write_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="cm">/* see comments in do_write_oneword() regarding uWriteTimeo. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uWriteTimeout</span> <span class="o">=</span> <span class="p">(</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cmd_adr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">z</span><span class="p">,</span> <span class="n">words</span><span class="p">;</span>
	<span class="n">map_word</span> <span class="n">datum</span><span class="p">;</span>

	<span class="n">adr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">cmd_adr</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">FL_WRITING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">datum</span> <span class="o">=</span> <span class="n">map_word_load</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): WRITE 0x%.8lx(0x%.8lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">__func__</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">datum</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>

	<span class="n">XIP_INVAL_CACHED_RANGE</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ENABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">xip_disable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">cmd_adr</span><span class="p">);</span>

	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Write Buffer Load */</span>
	<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0x25</span><span class="p">),</span> <span class="n">cmd_adr</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_WRITING_TO_BUFFER</span><span class="p">;</span>

	<span class="cm">/* Write length of data to come */</span>
	<span class="n">words</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="n">words</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cmd_adr</span><span class="p">);</span>
	<span class="cm">/* Write data */</span>
	<span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">words</span> <span class="o">*</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">datum</span> <span class="o">=</span> <span class="n">map_word_load</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">datum</span><span class="p">,</span> <span class="n">adr</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span>

		<span class="n">z</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">z</span> <span class="o">-=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>

	<span class="n">adr</span> <span class="o">+=</span> <span class="n">z</span><span class="p">;</span>

	<span class="cm">/* Write Buffer Program Confirm: GO GO GO */</span>
	<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0x29</span><span class="p">),</span> <span class="n">cmd_adr</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_WRITING</span><span class="p">;</span>

	<span class="n">INVALIDATE_CACHE_UDELAY</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span>
				<span class="n">adr</span><span class="p">,</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">),</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">word_write_time</span><span class="p">);</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">uWriteTimeout</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_WRITING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Someone&#39;s suspended the write. Sleep */</span>
			<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="cm">/* FIXME */</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xip_enable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">op_done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Latency issues. Drop the lock, wait a while and retry */</span>
		<span class="n">UDELAY</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* reset on all failures. */</span>
	<span class="n">map_write</span><span class="p">(</span> <span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="p">);</span>
	<span class="n">xip_enable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="cm">/* FIXME - should have reset delay before continuing */</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;MTD %s(): software timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">__func__</span> <span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
 <span class="nl">op_done:</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="n">DISABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_write_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wbufsize</span> <span class="o">=</span> <span class="n">cfi_interleave</span><span class="p">(</span><span class="n">cfi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="o">-&gt;</span><span class="n">MaxBufWriteSize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="n">chipnum</span> <span class="o">=</span> <span class="n">to</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">to</span>  <span class="o">-</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&lt;&lt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>

	<span class="cm">/* If it&#39;s not bus-aligned, do the first word write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">local_len</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">ofs</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local_len</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">local_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cfi_amdstd_write_words</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">+</span> <span class="p">(</span><span class="n">chipnum</span><span class="o">&lt;&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">),</span>
					     <span class="n">local_len</span><span class="p">,</span> <span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">local_len</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">local_len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">local_len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chipnum</span> <span class="o">++</span><span class="p">;</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">==</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Write buffer is worth it only if more than one word to write... */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We must not cross write block boundaries */</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">wbufsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wbufsize</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">))</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">size</span> <span class="o">%</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_write_buffer</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span>
				      <span class="n">ofs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">retlen</span><span class="p">)</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chipnum</span> <span class="o">++</span><span class="p">;</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">==</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">retlen_dregs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">cfi_amdstd_write_words</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">+</span> <span class="p">(</span><span class="n">chipnum</span><span class="o">&lt;&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">),</span>
					     <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen_dregs</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

		<span class="o">*</span><span class="n">retlen</span> <span class="o">+=</span> <span class="n">retlen_dregs</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for the flash chip to become ready to write data</span>
<span class="cm"> *</span>
<span class="cm"> * This is only called during the panic_write() path. When panic_write()</span>
<span class="cm"> * is called, the kernel is in the process of a panic, and will soon be</span>
<span class="cm"> * dead. Therefore we don&#39;t take any locks, and attempt to get access</span>
<span class="cm"> * to the chip as soon as possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_panic_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the driver thinks the chip is idle, and no toggle bits</span>
<span class="cm">	 * are changing, then the chip is actually idle for sure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FL_READY</span> <span class="o">&amp;&amp;</span> <span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try several times to reset the chip and then wait for it</span>
<span class="cm">	 * to become idle. The upper limit of a few milliseconds of</span>
<span class="cm">	 * delay isn&#39;t a big problem: the kernel is dying anyway. It</span>
<span class="cm">	 * is more important to save the messages.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* send the reset command */</span>
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>

		<span class="cm">/* wait for the chip to become ready */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* the chip never became ready */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out one word of data to a single flash chip during a kernel panic</span>
<span class="cm"> *</span>
<span class="cm"> * This is only called during the panic_write() path. When panic_write()</span>
<span class="cm"> * is called, the kernel is in the process of a panic, and will soon be</span>
<span class="cm"> * dead. Therefore we don&#39;t take any locks, and attempt to get access</span>
<span class="cm"> * to the chip as soon as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this routine is intentionally similar to</span>
<span class="cm"> * do_write_oneword(), in order to ease code maintenance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_panic_write_oneword</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="n">map_word</span> <span class="n">datum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uWriteTimeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">map_word</span> <span class="n">oldd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">adr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cfi_amdstd_panic_wait</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): PANIC WRITE 0x%.8lx(0x%.8lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">datum</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for a NOP for the case when the datum to write is already</span>
<span class="cm">	 * present - it saves time and works around buggy chips that corrupt</span>
<span class="cm">	 * data at other locations when 0xff is written to a location that</span>
<span class="cm">	 * already contains 0xff.</span>
<span class="cm">	 */</span>
	<span class="n">oldd</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_word_equal</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">oldd</span><span class="p">,</span> <span class="n">datum</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): NOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">op_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ENABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xA0</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">datum</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">uWriteTimeout</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip_good</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">datum</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* reset on all failures. */</span>
		<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="cm">/* FIXME - should have reset delay before continuing */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">retry_cnt</span> <span class="o">&lt;=</span> <span class="n">MAX_WORD_RETRIES</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">op_done:</span>
	<span class="n">DISABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out some data during a kernel panic</span>
<span class="cm"> *</span>
<span class="cm"> * This is used by the mtdoops driver to save the dying messages from a</span>
<span class="cm"> * kernel which has panic&#39;d.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine ignores all of the locking used throughout the rest of the</span>
<span class="cm"> * driver, in order to ensure that the data gets written out no matter what</span>
<span class="cm"> * state this driver (and the flash chip itself) was in when the kernel crashed.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this routine is intentionally similar to</span>
<span class="cm"> * cfi_amdstd_write_words(), in order to ease code maintenance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_panic_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">chipstart</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chipnum</span><span class="p">;</span>

	<span class="n">chipnum</span> <span class="o">=</span> <span class="n">to</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">;</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">to</span> <span class="o">-</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">&lt;&lt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">);</span>
	<span class="n">chipstart</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* If it&#39;s not bus aligned, do the first byte write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bus_ofs</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">-</span> <span class="n">bus_ofs</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">map_word</span> <span class="n">tmp_buf</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">cfi_amdstd_panic_wait</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span> <span class="n">bus_ofs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* Load &#39;tmp_buf&#39; with old contents of flash */</span>
		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">bus_ofs</span> <span class="o">+</span> <span class="n">chipstart</span><span class="p">);</span>

		<span class="cm">/* Number of bytes to copy from buffer */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">map_word_load_partial</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_panic_write_oneword</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span>
					     <span class="n">bus_ofs</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">retlen</span><span class="p">)</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chipnum</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">==</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We are now aligned, write as much as possible */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">map_word</span> <span class="n">datum</span><span class="p">;</span>

		<span class="n">datum</span> <span class="o">=</span> <span class="n">map_word_load</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_panic_write_oneword</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span>
					     <span class="n">ofs</span><span class="p">,</span> <span class="n">datum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">retlen</span><span class="p">)</span> <span class="o">+=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chipshift</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chipnum</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chipnum</span> <span class="o">==</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">chipstart</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">].</span><span class="n">start</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Write the trailing bytes if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map_bankwidth</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">map_word</span> <span class="n">tmp_buf</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">cfi_amdstd_panic_wait</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span> <span class="n">ofs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">map_read</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">+</span> <span class="n">chipstart</span><span class="p">);</span>

		<span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">map_word_load_partial</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_panic_write_oneword</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">chipnum</span><span class="p">],</span>
					     <span class="n">ofs</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="p">(</span><span class="o">*</span><span class="n">retlen</span><span class="p">)</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Handle devices with one erase region, that only implement</span>
<span class="cm"> * the chip erase command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__xipram</span> <span class="nf">do_erase_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">adr</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adr</span> <span class="o">=</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">FL_WRITING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): ERASE 0x%.8lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">__func__</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="p">);</span>

	<span class="n">XIP_INVAL_CACHED_RANGE</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">ENABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">xip_disable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>

	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_ERASING</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">in_progress_block_addr</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

	<span class="n">INVALIDATE_CACHE_UDELAY</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span>
				<span class="n">adr</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_time</span><span class="o">*</span><span class="mi">500</span><span class="p">);</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">*</span><span class="mi">20</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_ERASING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Someone&#39;s suspended the erase. Sleep */</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This erase was suspended and resumed.</span>
<span class="cm">			   Adjust the timeout */</span>
			<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">*</span><span class="mi">20</span><span class="p">);</span> <span class="cm">/* FIXME */</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;MTD %s(): software timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span> <span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Latency issues. Drop the lock, wait a while and retry */</span>
		<span class="n">UDELAY</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="mi">1000000</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Did we succeed? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip_good</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">map_word_ff</span><span class="p">(</span><span class="n">map</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* reset on all failures. */</span>
		<span class="n">map_write</span><span class="p">(</span> <span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="p">);</span>
		<span class="cm">/* FIXME - should have reset delay before continuing */</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="n">xip_enable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="n">DISABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__xipram</span> <span class="nf">do_erase_oneblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">thunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adr</span> <span class="o">+=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">FL_ERASING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): ERASE 0x%.8lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">__func__</span><span class="p">,</span> <span class="n">adr</span> <span class="p">);</span>

	<span class="n">XIP_INVAL_CACHED_RANGE</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ENABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">xip_disable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>

	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">sector_erase_cmd</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_ERASING</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">in_progress_block_addr</span> <span class="o">=</span> <span class="n">adr</span><span class="p">;</span>

	<span class="n">INVALIDATE_CACHE_UDELAY</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span>
				<span class="n">adr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_time</span><span class="o">*</span><span class="mi">500</span><span class="p">);</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">*</span><span class="mi">20</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">FL_ERASING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Someone&#39;s suspended the erase. Sleep */</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This erase was suspended and resumed.</span>
<span class="cm">			   Adjust the timeout */</span>
			<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span><span class="o">*</span><span class="mi">20</span><span class="p">);</span> <span class="cm">/* FIXME */</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">erase_suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip_ready</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xip_enable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xip_enable</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;MTD %s(): software timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span> <span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Latency issues. Drop the lock, wait a while and retry */</span>
		<span class="n">UDELAY</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="mi">1000000</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Did we succeed? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip_good</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">map_word_ff</span><span class="p">(</span><span class="n">map</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* reset on all failures. */</span>
		<span class="n">map_write</span><span class="p">(</span> <span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="p">);</span>
		<span class="cm">/* FIXME - should have reset delay before continuing */</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="n">DISABLE_VPP</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_erase_varsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ofs</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cfi_varsize_frob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">do_erase_oneblock</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_DONE</span><span class="p">;</span>
	<span class="n">mtd_erase_callback</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_erase_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_erase_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">MTD_ERASE_DONE</span><span class="p">;</span>
	<span class="n">mtd_erase_callback</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_atmel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">thunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">FL_LOCKING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_LOCKING</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): LOCK 0x%08lx len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span>
			 <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span>
			 <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span>
			 <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span>
			 <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock2</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span>
			 <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0x40</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">adr</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_atmel_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">adr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">thunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">FL_UNLOCKING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_UNLOCKING</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MTD %s(): LOCK 0x%08lx len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">cfi_send_gen_cmd</span><span class="p">(</span><span class="mh">0xAA</span><span class="p">,</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">addr_unlock1</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">cfi</span><span class="p">,</span>
			 <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">device_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0x70</span><span class="p">),</span> <span class="n">adr</span><span class="p">);</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
	<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">adr</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_atmel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfi_varsize_frob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">do_atmel_lock</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_atmel_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cfi_varsize_frob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">do_atmel_unlock</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfi_amdstd_sync</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="nl">retry:</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FL_READY</span>:
		<span class="k">case</span> <span class="n">FL_STATUS</span>:
		<span class="k">case</span> <span class="n">FL_CFI_QUERY</span>:
		<span class="k">case</span> <span class="n">FL_JEDEC_QUERY</span>:
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_SYNCING</span><span class="p">;</span>
			<span class="cm">/* No need to wake_up() on this state change -</span>
<span class="cm">			 * as the whole point is that nobody can do anything</span>
<span class="cm">			 * with the chip now anyway.</span>
<span class="cm">			 */</span>
		<span class="k">case</span> <span class="n">FL_SYNCING</span>:
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/* Not an idle state */</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

			<span class="n">schedule</span><span class="p">();</span>

			<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Unlock the chips again */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FL_SYNCING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span><span class="p">;</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FL_READY</span>:
		<span class="k">case</span> <span class="n">FL_STATUS</span>:
		<span class="k">case</span> <span class="n">FL_CFI_QUERY</span>:
		<span class="k">case</span> <span class="n">FL_JEDEC_QUERY</span>:
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_PM_SUSPENDED</span><span class="p">;</span>
			<span class="cm">/* No need to wake_up() on this state change -</span>
<span class="cm">			 * as the whole point is that nobody can do anything</span>
<span class="cm">			 * with the chip now anyway.</span>
<span class="cm">			 */</span>
		<span class="k">case</span> <span class="n">FL_PM_SUSPENDED</span>:
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Unlock the chips again */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FL_PM_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oldstate</span><span class="p">;</span>
				<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfi_amdstd_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">FL_PM_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_READY</span><span class="p">;</span>
			<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Argh. Chip not in PM_SUSPENDED state upon resume()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Ensure that the flash device is put back into read array mode before</span>
<span class="cm"> * unloading the driver or rebooting.  On some systems, rebooting while</span>
<span class="cm"> * the flash is in query/program/erase mode will prevent the CPU from</span>
<span class="cm"> * fetching the bootloader code, requiring a hard reset or power cycle.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flchip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cfi</span><span class="o">-&gt;</span><span class="n">numchips</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">chips</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">FL_SHUTDOWN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">map_write</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">CMD</span><span class="p">(</span><span class="mh">0xF0</span><span class="p">),</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">FL_SHUTDOWN</span><span class="p">;</span>
			<span class="n">put_chip</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cfi_amdstd_reboot</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>

	<span class="n">mtd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mtd_info</span><span class="p">,</span> <span class="n">reboot_notifier</span><span class="p">);</span>
	<span class="n">cfi_amdstd_reset</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cfi_amdstd_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">map_info</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cfi_private</span> <span class="o">*</span><span class="n">cfi</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">fldrv_priv</span><span class="p">;</span>

	<span class="n">cfi_amdstd_reset</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">reboot_notifier</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cmdset_priv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfi</span><span class="o">-&gt;</span><span class="n">cfiq</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cfi</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">eraseregions</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Crossnet Co. &lt;info@crossnet.co.jp&gt; et al.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;MTD chip driver for AMD/Fujitsu flash chips&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;cfi_cmdset_0006&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;cfi_cmdset_0701&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
