<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › ubi › kapi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>kapi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) International Business Machines Corp., 2006</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/* This file mostly implements UBI kernel API functions */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &quot;ubi.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_do_get_device_info - get information about UBI device.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @di: the information is stored here</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the same as &#39;ubi_get_device_info()&#39;, but it assumes the UBI</span>
<span class="cm"> * device is locked and cannot disappear.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubi_do_get_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_device_info</span> <span class="o">*</span><span class="n">di</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">ubi_num</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">leb_start</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">ro_mode</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">;</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">cdev</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_do_get_device_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_get_device_info - get information about UBI device.</span>
<span class="cm"> * @ubi_num: UBI device number</span>
<span class="cm"> * @di: the information is stored here</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 in case of success, %-EINVAL if the UBI device</span>
<span class="cm"> * number is invalid, and %-ENODEV if there is no such UBI device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_get_device_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_device_info</span> <span class="o">*</span><span class="n">di</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi_num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ubi_num</span> <span class="o">&gt;=</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_get_device</span><span class="p">(</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">ubi_do_get_device_info</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">di</span><span class="p">);</span>
	<span class="n">ubi_put_device</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_get_device_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_do_get_volume_info - get information about UBI volume.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol: volume description object</span>
<span class="cm"> * @vi: the information is stored here</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubi_do_get_volume_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ubi_volume_info</span> <span class="o">*</span><span class="n">vi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">ubi_num</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">used_bytes</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">used_bytes</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">corrupted</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">corrupted</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">upd_marker</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">upd_marker</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">alignment</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">usable_leb_size</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">usable_leb_size</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">vi</span><span class="o">-&gt;</span><span class="n">cdev</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_get_volume_info - get information about UBI volume.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> * @vi: the information is stored here</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubi_get_volume_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ubi_volume_info</span> <span class="o">*</span><span class="n">vi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubi_do_get_volume_info</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">,</span> <span class="n">vi</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_get_volume_info</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_open_volume - open UBI volume.</span>
<span class="cm"> * @ubi_num: UBI device number</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @mode: open mode</span>
<span class="cm"> *</span>
<span class="cm"> * The @mode parameter specifies if the volume should be opened in read-only</span>
<span class="cm"> * mode, read-write mode, or exclusive mode. The exclusive mode guarantees that</span>
<span class="cm"> * nobody else will be able to open this volume. UBI allows to have many volume</span>
<span class="cm"> * readers and one writer at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * If a static volume is being opened for the first time since boot, it will be</span>
<span class="cm"> * checked by this function, which means it will be fully read and the CRC</span>
<span class="cm"> * checksum of each logical eraseblock will be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns volume descriptor in case of success and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="nf">ubi_open_volume</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;open device %d, volume %d, mode %d&quot;</span><span class="p">,</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi_num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ubi_num</span> <span class="o">&gt;=</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">UBI_READONLY</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="n">UBI_READWRITE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">mode</span> <span class="o">!=</span> <span class="n">UBI_EXCLUSIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * First of all, we have to get the UBI device to prevent its removal.</span>
<span class="cm">	 */</span>
	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_get_device</span><span class="p">(</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put_ubi</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put_ubi</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
	<span class="n">vol</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">vol_id</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBI_READONLY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">exclusive</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">UBI_READWRITE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">exclusive</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">writers</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">writers</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">UBI_EXCLUSIVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">exclusive</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">writers</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">readers</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">exclusive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span> <span class="o">=</span> <span class="n">vol</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ckvol_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">checked</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is the first open - check the volume */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_check_volume</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ckvol_mutex</span><span class="p">);</span>
			<span class="n">ubi_close_volume</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;volume %d on UBI device %d is corrupted&quot;</span><span class="p">,</span>
				 <span class="n">vol_id</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">corrupted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">checked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ckvol_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">desc</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="nl">out_put_ubi:</span>
	<span class="n">ubi_put_device</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot open device %d, volume %d, error %d&quot;</span><span class="p">,</span>
		<span class="n">ubi_num</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_open_volume</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_open_volume_nm - open UBI volume by name.</span>
<span class="cm"> * @ubi_num: UBI device number</span>
<span class="cm"> * @name: volume name</span>
<span class="cm"> * @mode: open mode</span>
<span class="cm"> *</span>
<span class="cm"> * This function is similar to &#39;ubi_open_volume()&#39;, but opens a volume by name.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="nf">ubi_open_volume_nm</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;open device %d, volume %s, mode %d&quot;</span><span class="p">,</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">UBI_VOL_NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">UBI_VOL_NAME_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi_num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ubi_num</span> <span class="o">&gt;=</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_get_device</span><span class="p">(</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
	<span class="cm">/* Walk all volumes of this UBI device */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vol_id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ubi_open_volume</span><span class="p">(</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should put the UBI device even in case of success, because</span>
<span class="cm">	 * &#39;ubi_open_volume()&#39; took a reference as well.</span>
<span class="cm">	 */</span>
	<span class="n">ubi_put_device</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_open_volume_nm</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_open_volume_path - open UBI volume by its character device node path.</span>
<span class="cm"> * @pathname: volume character device node path</span>
<span class="cm"> * @mode: open mode</span>
<span class="cm"> *</span>
<span class="cm"> * This function is similar to &#39;ubi_open_volume()&#39;, but opens a volume the path</span>
<span class="cm"> * to its character device node.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="nf">ubi_open_volume_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">mod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;open volume %s, mode %d&quot;</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pathname</span> <span class="o">||</span> <span class="o">!*</span><span class="n">pathname</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">kern_path</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">mod</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>
	<span class="n">ubi_num</span> <span class="o">=</span> <span class="n">ubi_major2num</span><span class="p">(</span><span class="n">imajor</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">vol_id</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ubi_num</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ubi_open_volume</span><span class="p">(</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_open_volume_path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_close_volume - close UBI volume.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubi_close_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;close device %d, volume %d, mode %d&quot;</span><span class="p">,</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBI_READONLY</span>:
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBI_READWRITE</span>:
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">writers</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBI_EXCLUSIVE</span>:
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">exclusive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ubi_put_device</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_close_volume</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_leb_read - read data.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> * @lnum: logical eraseblock number to read from</span>
<span class="cm"> * @buf: buffer where to store the read data</span>
<span class="cm"> * @offset: offset within the logical eraseblock to read from</span>
<span class="cm"> * @len: how many bytes to read</span>
<span class="cm"> * @check: whether UBI has to check the read data&#39;s CRC or not.</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads data from offset @offset of logical eraseblock @lnum and</span>
<span class="cm"> * stores the data at @buf. When reading from static volumes, @check specifies</span>
<span class="cm"> * whether the data has to be checked or not. If yes, the whole logical</span>
<span class="cm"> * eraseblock will be read and its CRC checksum will be checked (i.e., the CRC</span>
<span class="cm"> * checksum is per-eraseblock). So checking may substantially slow down the</span>
<span class="cm"> * read speed. The @check argument is ignored for dynamic volumes.</span>
<span class="cm"> *</span>
<span class="cm"> * In case of success, this function returns zero. In case of failure, this</span>
<span class="cm"> * function returns a negative error code.</span>
<span class="cm"> *</span>
<span class="cm"> * %-EBADMSG error code is returned:</span>
<span class="cm"> * o for both static and dynamic volumes if MTD driver has detected a data</span>
<span class="cm"> *   integrity problem (unrecoverable ECC checksum mismatch in case of NAND);</span>
<span class="cm"> * o for static volumes in case of data CRC mismatch.</span>
<span class="cm"> *</span>
<span class="cm"> * If the volume is damaged because of an interrupted update this function just</span>
<span class="cm"> * returns immediately with %-EBADF error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_leb_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;read %d bytes from LEB %d:%d:%d&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">used_ebs</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">usable_leb_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">used_ebs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* Empty static UBI volume */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">used_ebs</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
		    <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">last_eb_bytes</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upd_marker</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_eba_read_leb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">check</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;mark volume %d as corrupted&quot;</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">);</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">corrupted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_leb_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_leb_write - write data.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> * @lnum: logical eraseblock number to write to</span>
<span class="cm"> * @buf: data to write</span>
<span class="cm"> * @offset: offset within the logical eraseblock where to write</span>
<span class="cm"> * @len: how many bytes to write</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes @len bytes of data from @buf to offset @offset of</span>
<span class="cm"> * logical eraseblock @lnum.</span>
<span class="cm"> *</span>
<span class="cm"> * This function takes care of physical eraseblock write failures. If write to</span>
<span class="cm"> * the physical eraseblock write operation fails, the logical eraseblock is</span>
<span class="cm"> * re-mapped to another physical eraseblock, the data is recovered, and the</span>
<span class="cm"> * write finishes. UBI has a pool of reserved physical eraseblocks for this.</span>
<span class="cm"> *</span>
<span class="cm"> * If all the data were successfully written, zero is returned. If an error</span>
<span class="cm"> * occurred and UBI has not been able to recover from it, this function returns</span>
<span class="cm"> * a negative error code. Note, in case of an error, it is possible that</span>
<span class="cm"> * something was still written to the flash media, but that may be some</span>
<span class="cm"> * garbage.</span>
<span class="cm"> *</span>
<span class="cm"> * If the volume is damaged because of an interrupted update this function just</span>
<span class="cm"> * returns immediately with %-EBADF code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_leb_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;write %d bytes to LEB %d:%d:%d&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">UBI_READONLY</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">usable_leb_size</span> <span class="o">||</span>
	    <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upd_marker</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ubi_eba_write_leb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_leb_write</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ubi_leb_change - change logical eraseblock atomically.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> * @lnum: logical eraseblock number to change</span>
<span class="cm"> * @buf: data to write</span>
<span class="cm"> * @len: how many bytes to write</span>
<span class="cm"> *</span>
<span class="cm"> * This function changes the contents of a logical eraseblock atomically. @buf</span>
<span class="cm"> * has to contain new logical eraseblock data, and @len - the length of the</span>
<span class="cm"> * data, which has to be aligned. The length may be shorter than the logical</span>
<span class="cm"> * eraseblock size, ant the logical eraseblock may be appended to more times</span>
<span class="cm"> * later on. This function guarantees that in case of an unclean reboot the old</span>
<span class="cm"> * contents is preserved. Returns zero in case of success and a negative error</span>
<span class="cm"> * code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_leb_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;atomically write %d bytes to LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">UBI_READONLY</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">len</span> <span class="o">&gt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">usable_leb_size</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upd_marker</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ubi_eba_atomic_leb_change</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_leb_change</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_leb_erase - erase logical eraseblock.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function un-maps logical eraseblock @lnum and synchronously erases the</span>
<span class="cm"> * correspondent physical eraseblock. Returns zero in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * If the volume is damaged because of an interrupted update this function just</span>
<span class="cm"> * returns immediately with %-EBADF code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_leb_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;erase LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">UBI_READONLY</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upd_marker</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_eba_unmap_leb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ubi_wl_flush</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_leb_erase</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_leb_unmap - un-map logical eraseblock.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function un-maps logical eraseblock @lnum and schedules the</span>
<span class="cm"> * corresponding physical eraseblock for erasure, so that it will eventually be</span>
<span class="cm"> * physically erased in background. This operation is much faster than the</span>
<span class="cm"> * erase operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike erase, the un-map operation does not guarantee that the logical</span>
<span class="cm"> * eraseblock will contain all 0xFF bytes when UBI is initialized again. For</span>
<span class="cm"> * example, if several logical eraseblocks are un-mapped, and an unclean reboot</span>
<span class="cm"> * happens after this, the logical eraseblocks will not necessarily be</span>
<span class="cm"> * un-mapped again when this MTD device is attached. They may actually be</span>
<span class="cm"> * mapped to the same physical eraseblocks again. So, this function has to be</span>
<span class="cm"> * used with care.</span>
<span class="cm"> *</span>
<span class="cm"> * In other words, when un-mapping a logical eraseblock, UBI does not store</span>
<span class="cm"> * any information about this on the flash media, it just marks the logical</span>
<span class="cm"> * eraseblock as &quot;un-mapped&quot; in RAM. If UBI is detached before the physical</span>
<span class="cm"> * eraseblock is physically erased, it will be mapped again to the same logical</span>
<span class="cm"> * eraseblock when the MTD device is attached again.</span>
<span class="cm"> *</span>
<span class="cm"> * The main and obvious use-case of this function is when the contents of a</span>
<span class="cm"> * logical eraseblock has to be re-written. Then it is much more efficient to</span>
<span class="cm"> * first un-map it, then write new data, rather than first erase it, then write</span>
<span class="cm"> * new data. Note, once new data has been written to the logical eraseblock,</span>
<span class="cm"> * UBI guarantees that the old contents has gone forever. In other words, if an</span>
<span class="cm"> * unclean reboot happens after the logical eraseblock has been un-mapped and</span>
<span class="cm"> * then written to, it will contain the last written data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure. If the volume is damaged because of an interrupted update</span>
<span class="cm"> * this function just returns immediately with %-EBADF code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_leb_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;unmap LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">UBI_READONLY</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upd_marker</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ubi_eba_unmap_leb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_leb_unmap</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_leb_map - map logical eraseblock to a physical eraseblock.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function maps an un-mapped logical eraseblock @lnum to a physical</span>
<span class="cm"> * eraseblock. This means, that after a successful invocation of this</span>
<span class="cm"> * function the logical eraseblock @lnum will be empty (contain only %0xFF</span>
<span class="cm"> * bytes) and be mapped to a physical eraseblock, even if an unclean reboot</span>
<span class="cm"> * happens.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success, %-EBADF if the volume is</span>
<span class="cm"> * damaged because of an interrupted update, %-EBADMSG if the logical</span>
<span class="cm"> * eraseblock is already mapped, and other negative error codes in case of</span>
<span class="cm"> * other failures.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_leb_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;unmap LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">UBI_READONLY</span> <span class="o">||</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upd_marker</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ubi_eba_write_leb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_leb_map</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_is_mapped - check if logical eraseblock is mapped.</span>
<span class="cm"> * @desc: volume descriptor</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if logical eraseblock @lnum is mapped to a physical</span>
<span class="cm"> * eraseblock. If a logical eraseblock is un-mapped, this does not necessarily</span>
<span class="cm"> * mean it will still be un-mapped after the UBI device is re-attached. The</span>
<span class="cm"> * logical eraseblock may become mapped to the physical eraseblock it was last</span>
<span class="cm"> * mapped to.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if the LEB is mapped, %0 if not, and a negative</span>
<span class="cm"> * error code in case of failure. If the volume is damaged because of an</span>
<span class="cm"> * interrupted update this function just returns immediately with %-EBADF error</span>
<span class="cm"> * code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_is_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">vol</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;test LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">upd_marker</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_is_mapped</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_sync - synchronize UBI device buffers.</span>
<span class="cm"> * @ubi_num: UBI device to synchronize</span>
<span class="cm"> *</span>
<span class="cm"> * The underlying MTD device may cache data in hardware or in software. This</span>
<span class="cm"> * function ensures the caches are flushed. Returns zero in case of success and</span>
<span class="cm"> * a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_sync</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>

	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_get_device</span><span class="p">(</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mtd_sync</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">ubi_put_device</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_sync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_flush - flush UBI work queue.</span>
<span class="cm"> * @ubi_num: UBI device to flush work queue</span>
<span class="cm"> * @vol_id: volume id to flush for</span>
<span class="cm"> * @lnum: logical eraseblock number to flush for</span>
<span class="cm"> *</span>
<span class="cm"> * This function executes all pending works for a particular volume id / logical</span>
<span class="cm"> * eraseblock number pair. If either value is set to %UBI_ALL, then it acts as</span>
<span class="cm"> * a wildcard for all of the corresponding volume numbers or logical</span>
<span class="cm"> * eraseblock numbers. It returns zero in case of success and a negative error</span>
<span class="cm"> * code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_flush</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_get_device</span><span class="p">(</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_wl_flush</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubi_put_device</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_flush</span><span class="p">);</span>

<span class="n">BLOCKING_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">ubi_notifiers</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_register_volume_notifier - register a volume notifier.</span>
<span class="cm"> * @nb: the notifier description object</span>
<span class="cm"> * @ignore_existing: if non-zero, do not send &quot;added&quot; notification for all</span>
<span class="cm"> *                   already existing volumes</span>
<span class="cm"> *</span>
<span class="cm"> * This function registers a volume notifier, which means that</span>
<span class="cm"> * &#39;nb-&gt;notifier_call()&#39; will be invoked when an UBI  volume is created,</span>
<span class="cm"> * removed, re-sized, re-named, or updated. The first argument of the function</span>
<span class="cm"> * is the notification type. The second argument is pointer to a</span>
<span class="cm"> * &amp;struct ubi_notification object which describes the notification event.</span>
<span class="cm"> * Using UBI API from the volume notifier is prohibited.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code</span>
<span class="cm"> * in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_register_volume_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">ignore_existing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_notifiers</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ignore_existing</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are going to walk all UBI devices and all volumes, and</span>
<span class="cm">	 * notify the user about existing volumes by the %UBI_VOLUME_ADDED</span>
<span class="cm">	 * event. We have to lock the @ubi_devices_mutex to make sure UBI</span>
<span class="cm">	 * devices do not disappear.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>
	<span class="n">ubi_enumerate_volumes</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_register_volume_notifier</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_unregister_volume_notifier - unregister the volume notifier.</span>
<span class="cm"> * @nb: the notifier description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function unregisters volume notifier @nm and returns zero in case of</span>
<span class="cm"> * success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_unregister_volume_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_notifiers</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ubi_unregister_volume_notifier</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
