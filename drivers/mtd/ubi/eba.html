<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › ubi › eba.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>eba.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) International Business Machines Corp., 2006</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The UBI Eraseblock Association (EBA) sub-system.</span>
<span class="cm"> *</span>
<span class="cm"> * This sub-system is responsible for I/O to/from logical eraseblock.</span>
<span class="cm"> *</span>
<span class="cm"> * Although in this implementation the EBA table is fully kept and managed in</span>
<span class="cm"> * RAM, which assumes poor scalability, it might be (partially) maintained on</span>
<span class="cm"> * flash in future implementations.</span>
<span class="cm"> *</span>
<span class="cm"> * The EBA sub-system implements per-logical eraseblock locking. Before</span>
<span class="cm"> * accessing a logical eraseblock it is locked for reading or writing. The</span>
<span class="cm"> * per-logical eraseblock locking is implemented by means of the lock tree. The</span>
<span class="cm"> * lock tree is an RB-tree which refers all the currently locked logical</span>
<span class="cm"> * eraseblocks. The lock tree elements are &amp;struct ubi_ltree_entry objects.</span>
<span class="cm"> * They are indexed by (@vol_id, @lnum) pairs.</span>
<span class="cm"> *</span>
<span class="cm"> * EBA also maintains the global sequence counter which is incremented each</span>
<span class="cm"> * time a logical eraseblock is mapped to a physical eraseblock and it is</span>
<span class="cm"> * stored in the volume identifier header. This means that each VID header has</span>
<span class="cm"> * a unique sequence number. The sequence number is only increased an we assume</span>
<span class="cm"> * 64 bits is enough to never overflow.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &quot;ubi.h&quot;</span>

<span class="cm">/* Number of physical eraseblocks reserved for atomic LEB change operation */</span>
<span class="cp">#define EBA_RESERVED_PEBS 1</span>

<span class="cm">/**</span>
<span class="cm"> * next_sqnum - get next sequence number.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns next sequence number to use, which is just the current</span>
<span class="cm"> * global sequence counter value. It also increases the global sequence</span>
<span class="cm"> * counter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">next_sqnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>
	<span class="n">sqnum</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">global_sqnum</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sqnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_get_compat - get compatibility flags of a volume.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns compatibility flags for an internal volume. User</span>
<span class="cm"> * volumes have no compatibility flags, so %0 is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubi_get_compat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">==</span> <span class="n">UBI_LAYOUT_VOLUME_ID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">UBI_LAYOUT_VOLUME_COMPAT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ltree_lookup - look up the lock tree.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the corresponding &amp;struct ubi_ltree_entry</span>
<span class="cm"> * object if the logical eraseblock is locked and %NULL if it is not.</span>
<span class="cm"> * @ubi-&gt;ltree_lock has to be locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="nf">ltree_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="n">le</span><span class="p">;</span>

		<span class="n">le</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_ltree_entry</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&lt;</span> <span class="n">le</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&gt;</span> <span class="n">le</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">le</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;</span> <span class="n">le</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">le</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ltree_add_entry - add new entry to the lock tree.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds new entry for logical eraseblock (@vol_id, @lnum) to the</span>
<span class="cm"> * lock tree. If such entry is already there, its usage counter is increased.</span>
<span class="cm"> * Returns pointer to the lock tree entry or %-ENOMEM if memory allocation</span>
<span class="cm"> * failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="nf">ltree_add_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="n">le</span><span class="p">,</span> <span class="o">*</span><span class="n">le1</span><span class="p">,</span> <span class="o">*</span><span class="n">le_free</span><span class="p">;</span>

	<span class="n">le</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_ltree_entry</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">le</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">le</span><span class="o">-&gt;</span><span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="n">le</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>
	<span class="n">le1</span> <span class="o">=</span> <span class="n">ltree_lookup</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This logical eraseblock is already locked. The newly</span>
<span class="cm">		 * allocated lock entry is not needed.</span>
<span class="cm">		 */</span>
		<span class="n">le_free</span> <span class="o">=</span> <span class="n">le</span><span class="p">;</span>
		<span class="n">le</span> <span class="o">=</span> <span class="n">le1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * No lock entry, add the newly allocated one to the</span>
<span class="cm">		 * @ubi-&gt;ltree RB-tree.</span>
<span class="cm">		 */</span>
		<span class="n">le_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
			<span class="n">le1</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_ltree_entry</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&lt;</span> <span class="n">le1</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&gt;</span> <span class="n">le1</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">ubi_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">le1</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">le1</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span>
					<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">le_free</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">le</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * leb_read_lock - lock logical eraseblock for reading.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function locks a logical eraseblock for reading. Returns zero in case</span>
<span class="cm"> * of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">leb_read_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="n">le</span><span class="p">;</span>

	<span class="n">le</span> <span class="o">=</span> <span class="n">ltree_add_entry</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">le</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">le</span><span class="p">);</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * leb_read_unlock - unlock logical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">leb_read_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="n">le</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>
	<span class="n">le</span> <span class="o">=</span> <span class="n">ltree_lookup</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">le</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * leb_write_lock - lock logical eraseblock for writing.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function locks a logical eraseblock for writing. Returns zero in case</span>
<span class="cm"> * of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">leb_write_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="n">le</span><span class="p">;</span>

	<span class="n">le</span> <span class="o">=</span> <span class="n">ltree_add_entry</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">le</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">le</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * leb_write_lock - lock logical eraseblock for writing.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function locks a logical eraseblock for writing if there is no</span>
<span class="cm"> * contention and does nothing if there is contention. Returns %0 in case of</span>
<span class="cm"> * success, %1 in case of contention, and and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">leb_write_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="n">le</span><span class="p">;</span>

	<span class="n">le</span> <span class="o">=</span> <span class="n">ltree_add_entry</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">le</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">le</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">down_write_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Contention, cancel */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>
	<span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">le</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * leb_write_unlock - unlock logical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">leb_write_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="o">*</span><span class="n">le</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>
	<span class="n">le</span> <span class="o">=</span> <span class="n">ltree_lookup</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">le</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">le</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_eba_unmap_leb - un-map logical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol: volume description object</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This function un-maps logical eraseblock @lnum and schedules corresponding</span>
<span class="cm"> * physical eraseblock for erasure. Returns zero in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_eba_unmap_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">leb_write_lock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pnum</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* This logical eraseblock is already unmapped */</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;erase LEB %d:%d, PEB %d&quot;</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>

	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">UBI_LEB_UNMAPPED</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_eba_read_leb - read data.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol: volume description object</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @buf: buffer to store the read data</span>
<span class="cm"> * @offset: offset from where to read</span>
<span class="cm"> * @len: how many bytes to read</span>
<span class="cm"> * @check: data CRC check flag</span>
<span class="cm"> *</span>
<span class="cm"> * If the logical eraseblock @lnum is unmapped, @buf is filled with 0xFF</span>
<span class="cm"> * bytes. The @check flag only makes sense for static volumes and forces</span>
<span class="cm"> * eraseblock data CRC checking.</span>
<span class="cm"> *</span>
<span class="cm"> * In case of success this function returns zero. In case of a static volume,</span>
<span class="cm"> * if data CRC mismatches - %-EBADMSG is returned. %-EBADMSG may also be</span>
<span class="cm"> * returned for any volume type if an ECC error was detected by the MTD device</span>
<span class="cm"> * driver. Other negative error cored may be returned in case of other errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_eba_read_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">scrub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">leb_read_lock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pnum</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The logical eraseblock is not mapped, fill the whole buffer</span>
<span class="cm">		 * with 0xFF bytes. The exception is static volumes for which</span>
<span class="cm">		 * it is an error to read unmapped logical eraseblocks.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;read %d bytes from offset %d of LEB %d:%d (unmapped)&quot;</span><span class="p">,</span>
			<span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">leb_read_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">!=</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;read %d bytes from offset %d of LEB %d:%d, PEB %d&quot;</span><span class="p">,</span>
		<span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_DYNAMIC_VOLUME</span><span class="p">)</span>
		<span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vid_hdr</span> <span class="o">=</span> <span class="n">ubi_zalloc_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vid_hdr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The header is either absent or corrupted.</span>
<span class="cm">				 * The former case means there is a bug -</span>
<span class="cm">				 * switch to read-only mode just in case.</span>
<span class="cm">				 * The latter case means a real corruption - we</span>
<span class="cm">				 * may try to recover data. FIXME: but this is</span>
<span class="cm">				 * not implemented.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_BAD_HDR_EBADMSG</span> <span class="o">||</span>
				    <span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_BAD_HDR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;corrupted VID header at PEB &quot;</span>
						 <span class="s">&quot;%d, LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span>
						 <span class="n">lnum</span><span class="p">);</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span>
			<span class="n">scrub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">used_ebs</span><span class="p">));</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">));</span>

		<span class="n">crc</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_crc</span><span class="p">);</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scrub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_DYNAMIC_VOLUME</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="n">scrub</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;force data checking&quot;</span><span class="p">);</span>
				<span class="n">check</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">crc1</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crc1</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;CRC error: calculated %#08x, must be %#08x&quot;</span><span class="p">,</span>
				 <span class="n">crc1</span><span class="p">,</span> <span class="n">crc</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scrub</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_wl_scrub_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>

	<span class="n">leb_read_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">leb_read_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * recover_peb - recover from write failure.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock to recover</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @buf: data which was not written because of the write failure</span>
<span class="cm"> * @offset: offset of the failed write</span>
<span class="cm"> * @len: how many bytes should have been written</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called in case of a write failure and moves all good data</span>
<span class="cm"> * from the potentially bad physical eraseblock to a good physical eraseblock.</span>
<span class="cm"> * This function also writes the data which was not written due to the failure.</span>
<span class="cm"> * Returns new physical eraseblock number in case of success, and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">recover_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">vol_id2idx</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">),</span> <span class="n">new_pnum</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">;</span>

	<span class="n">vid_hdr</span> <span class="o">=</span> <span class="n">ubi_zalloc_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vid_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">new_pnum</span> <span class="o">=</span> <span class="n">ubi_wl_get_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_pnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">new_pnum</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;recover PEB %d, move data to PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">new_pnum</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">next_sqnum</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">new_pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>

	<span class="n">data_size</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Read everything before the area where the write failure happened */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">new_pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>

	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pnum</span><span class="p">;</span>
	<span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;data was successfully recovered&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
<span class="nl">out_put:</span>
	<span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">new_pnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">write_error:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Bad luck? This physical eraseblock is bad too? Crud. Let&#39;s try to</span>
<span class="cm">	 * get another one.</span>
<span class="cm">	 */</span>
	<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;failed to write to PEB %d&quot;</span><span class="p">,</span> <span class="n">new_pnum</span><span class="p">);</span>
	<span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">new_pnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="n">UBI_IO_RETRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;try again&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_eba_write_leb - write data to dynamic volume.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol: volume description object</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @buf: the data to write</span>
<span class="cm"> * @offset: offset within the logical eraseblock where to write</span>
<span class="cm"> * @len: how many bytes to write</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes data to logical eraseblock @lnum of a dynamic volume</span>
<span class="cm"> * @vol. Returns zero in case of success and a negative error code in case</span>
<span class="cm"> * of failure. In case of error, it is possible that something was still</span>
<span class="cm"> * written to the flash media, but may be some garbage.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_eba_write_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">leb_write_lock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pnum</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;write %d bytes at offset %d of LEB %d:%d, PEB %d&quot;</span><span class="p">,</span>
			<span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;failed to write data to PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">&amp;&amp;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">recover_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
						  <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The logical eraseblock is not mapped. We have to get a free physical</span>
<span class="cm">	 * eraseblock and write the volume identifier header there first.</span>
<span class="cm">	 */</span>
	<span class="n">vid_hdr</span> <span class="o">=</span> <span class="n">ubi_zalloc_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vid_hdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">=</span> <span class="n">UBI_VID_DYNAMIC</span><span class="p">;</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">next_sqnum</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_id</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">compat</span> <span class="o">=</span> <span class="n">ubi_get_compat</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_pad</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">data_pad</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">pnum</span> <span class="o">=</span> <span class="n">ubi_wl_get_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pnum</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;write VID hdr and %d bytes at offset %d of LEB %d:%d, PEB %d&quot;</span><span class="p">,</span>
		<span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;failed to write VID header to LEB %d:%d, PEB %d&quot;</span><span class="p">,</span>
			 <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;failed to write %d bytes at offset %d of &quot;</span>
				 <span class="s">&quot;LEB %d:%d, PEB %d&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span>
				 <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnum</span><span class="p">;</span>

	<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">write_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fortunately, this is the first write operation to this physical</span>
<span class="cm">	 * eraseblock, so just put it and request a new one. We assume that if</span>
<span class="cm">	 * this physical eraseblock went bad, the erase code will handle that.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="o">++</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="n">UBI_IO_RETRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">next_sqnum</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;try another PEB&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_eba_write_leb_st - write data to static volume.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol: volume description object</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @buf: data to write</span>
<span class="cm"> * @len: how many bytes to write</span>
<span class="cm"> * @used_ebs: how many logical eraseblocks will this volume contain</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes data to logical eraseblock @lnum of static volume</span>
<span class="cm"> * @vol. The @used_ebs argument should contain total number of logical</span>
<span class="cm"> * eraseblock in this static volume.</span>
<span class="cm"> *</span>
<span class="cm"> * When writing to the last logical eraseblock, the @len argument doesn&#39;t have</span>
<span class="cm"> * to be aligned to the minimal I/O unit size. Instead, it has to be equivalent</span>
<span class="cm"> * to the real data size, although the @buf buffer has to contain the</span>
<span class="cm"> * alignment. In all other cases, @len has to be aligned.</span>
<span class="cm"> *</span>
<span class="cm"> * It is prohibited to write more than once to logical eraseblocks of static</span>
<span class="cm"> * volumes. This function returns zero in case of success and a negative error</span>
<span class="cm"> * code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_eba_write_leb_st</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">used_ebs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">used_ebs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* If this is the last LEB @len may be unaligned */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">data_size</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>

	<span class="n">vid_hdr</span> <span class="o">=</span> <span class="n">ubi_zalloc_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vid_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">leb_write_lock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">next_sqnum</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_id</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">compat</span> <span class="o">=</span> <span class="n">ubi_get_compat</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_pad</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">data_pad</span><span class="p">);</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">=</span> <span class="n">UBI_VID_STATIC</span><span class="p">;</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">data_size</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">used_ebs</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">used_ebs</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_crc</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">pnum</span> <span class="o">=</span> <span class="n">ubi_wl_get_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pnum</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;write VID hdr and %d bytes at LEB %d:%d, PEB %d, used_ebs %d&quot;</span><span class="p">,</span>
		<span class="n">len</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">used_ebs</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;failed to write VID header to LEB %d:%d, PEB %d&quot;</span><span class="p">,</span>
			 <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;failed to write %d bytes of data to PEB %d&quot;</span><span class="p">,</span>
			 <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnum</span><span class="p">;</span>

	<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">write_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This flash device does not admit of bad eraseblocks or</span>
<span class="cm">		 * something nasty and unexpected happened. Switch to read-only</span>
<span class="cm">		 * mode just in case.</span>
<span class="cm">		 */</span>
		<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="o">++</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="n">UBI_IO_RETRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">next_sqnum</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;try another PEB&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ubi_eba_atomic_leb_change - change logical eraseblock atomically.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol: volume description object</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @buf: data to write</span>
<span class="cm"> * @len: how many bytes to write</span>
<span class="cm"> *</span>
<span class="cm"> * This function changes the contents of a logical eraseblock atomically. @buf</span>
<span class="cm"> * has to contain new logical eraseblock data, and @len - the length of the</span>
<span class="cm"> * data, which has to be aligned. This function guarantees that in case of an</span>
<span class="cm"> * unclean reboot the old contents is preserved. Returns zero in case of</span>
<span class="cm"> * success and a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI reserves one LEB for the &quot;atomic LEB change&quot; operation, so only one</span>
<span class="cm"> * LEB change may be done at a time. This is ensured by @ubi-&gt;alc_mutex.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_eba_atomic_leb_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Special case when data length is zero. In this case the LEB</span>
<span class="cm">		 * has to be unmapped and mapped somewhere else.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_eba_unmap_leb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ubi_eba_write_leb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vid_hdr</span> <span class="o">=</span> <span class="n">ubi_zalloc_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vid_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">alc_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">leb_write_lock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_mutex</span><span class="p">;</span>

	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">next_sqnum</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_id</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">compat</span> <span class="o">=</span> <span class="n">ubi_get_compat</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_pad</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">data_pad</span><span class="p">);</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">=</span> <span class="n">UBI_VID_DYNAMIC</span><span class="p">;</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">copy_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_crc</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">pnum</span> <span class="o">=</span> <span class="n">ubi_wl_get_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pnum</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_leb_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;change LEB %d:%d, PEB %d, write VID hdr to PEB %d&quot;</span><span class="p">,</span>
		<span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">],</span> <span class="n">pnum</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;failed to write VID header to LEB %d:%d, PEB %d&quot;</span><span class="p">,</span>
			 <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;failed to write %d bytes of data to PEB %d&quot;</span><span class="p">,</span>
			 <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">write_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_leb_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnum</span><span class="p">;</span>

<span class="nl">out_leb_unlock:</span>
	<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
<span class="nl">out_mutex:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">alc_mutex</span><span class="p">);</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">write_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This flash device does not admit of bad eraseblocks or</span>
<span class="cm">		 * something nasty and unexpected happened. Switch to read-only</span>
<span class="cm">		 * mode just in case.</span>
<span class="cm">		 */</span>
		<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_leb_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="o">++</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="n">UBI_IO_RETRIES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_leb_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">next_sqnum</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;try another PEB&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_error_sane - check whether a read error is sane.</span>
<span class="cm"> * @err: code of the error happened during reading</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;ubi_eba_copy_leb()&#39; which is called when we</span>
<span class="cm"> * cannot read data from the target PEB (an error @err happened). If the error</span>
<span class="cm"> * code is sane, then we treat this error as non-fatal. Otherwise the error is</span>
<span class="cm"> * fatal and UBI will be switched to R/O mode later.</span>
<span class="cm"> *</span>
<span class="cm"> * The idea is that we try not to switch to R/O mode if the read error is</span>
<span class="cm"> * something which suggests there was a real read problem. E.g., %-EIO. Or a</span>
<span class="cm"> * memory allocation failed (-%ENOMEM). Otherwise, it is safer to switch to R/O</span>
<span class="cm"> * mode, simply because we do not know what happened at the MTD level, and we</span>
<span class="cm"> * cannot handle this. E.g., the underlying driver may have become crazy, and</span>
<span class="cm"> * it is safer to switch to R/O mode to preserve the data.</span>
<span class="cm"> *</span>
<span class="cm"> * And bear in mind, this is about reading from the target PEB, i.e. the PEB</span>
<span class="cm"> * which we have just written.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_error_sane</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_BAD_HDR</span> <span class="o">||</span>
	    <span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_BAD_HDR_EBADMSG</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_eba_copy_leb - copy logical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @from: physical eraseblock number from where to copy</span>
<span class="cm"> * @to: physical eraseblock number where to copy</span>
<span class="cm"> * @vid_hdr: VID header of the @from physical eraseblock</span>
<span class="cm"> *</span>
<span class="cm"> * This function copies logical eraseblock from physical eraseblock @from to</span>
<span class="cm"> * physical eraseblock @to. The @vid_hdr buffer may be changed by this</span>
<span class="cm"> * function. Returns:</span>
<span class="cm"> *   o %0 in case of success;</span>
<span class="cm"> *   o %MOVE_CANCEL_RACE, %MOVE_TARGET_WR_ERR, %MOVE_TARGET_BITFLIPS, etc;</span>
<span class="cm"> *   o a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_eba_copy_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">aldata_size</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>

	<span class="n">vol_id</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>

	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;copy LEB %d:%d, PEB %d to PEB %d&quot;</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_VID_STATIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data_size</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
		<span class="n">aldata_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">data_size</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">data_size</span> <span class="o">=</span> <span class="n">aldata_size</span> <span class="o">=</span>
			    <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_pad</span><span class="p">);</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">vol_id2idx</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note, we may race with volume deletion, which means that the volume</span>
<span class="cm">	 * this logical eraseblock belongs to might be being deleted. Since the</span>
<span class="cm">	 * volume deletion un-maps all the volume&#39;s logical eraseblocks, it will</span>
<span class="cm">	 * be locked in &#39;ubi_wl_put_peb()&#39; and wait for the WL worker to finish.</span>
<span class="cm">	 */</span>
	<span class="n">vol</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No need to do further work, cancel */</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;volume %d is being removed, cancel&quot;</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MOVE_CANCEL_RACE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do not want anybody to write to this logical eraseblock while we</span>
<span class="cm">	 * are moving it, so lock it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, we are using non-waiting locking here, because we cannot sleep</span>
<span class="cm">	 * on the LEB, since it may cause deadlocks. Indeed, imagine a task is</span>
<span class="cm">	 * unmapping the LEB which is mapped to the PEB we are going to move</span>
<span class="cm">	 * (@from). This task locks the LEB and goes sleep in the</span>
<span class="cm">	 * &#39;ubi_wl_put_peb()&#39; function on the @ubi-&gt;move_mutex. In turn, we are</span>
<span class="cm">	 * holding @ubi-&gt;move_mutex and go sleep on the LEB lock. So, if the</span>
<span class="cm">	 * LEB is already locked, we just do not move it and return</span>
<span class="cm">	 * %MOVE_RETRY. Note, we do not return %MOVE_CANCEL_RACE here because</span>
<span class="cm">	 * we do not know the reasons of the contention - it may be just a</span>
<span class="cm">	 * normal I/O on this LEB, so we want to re-try.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">leb_write_trylock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;contention on LEB %d:%d, cancel&quot;</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MOVE_RETRY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The LEB might have been put meanwhile, and the task which put it is</span>
<span class="cm">	 * probably waiting on @ubi-&gt;move_mutex. No need to continue the work,</span>
<span class="cm">	 * cancel it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">!=</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;LEB %d:%d is no longer mapped to PEB %d, mapped to &quot;</span>
		       <span class="s">&quot;PEB %d, cancel&quot;</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span>
		       <span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">MOVE_CANCEL_RACE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock_leb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, now the LEB is locked and we can safely start moving it. Since</span>
<span class="cm">	 * this function utilizes the @ubi-&gt;peb_buf buffer which is shared</span>
<span class="cm">	 * with some other functions - we lock the buffer by taking the</span>
<span class="cm">	 * @ubi-&gt;buf_mutex.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;read %d bytes of data&quot;</span><span class="p">,</span> <span class="n">aldata_size</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">aldata_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;error %d while reading data from PEB %d&quot;</span><span class="p">,</span>
			 <span class="n">err</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">MOVE_SOURCE_RD_ERR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we have got to calculate how much data we have to copy. In</span>
<span class="cm">	 * case of a static volume it is fairly easy - the VID header contains</span>
<span class="cm">	 * the data size. In case of a dynamic volume it is more difficult - we</span>
<span class="cm">	 * have to read the contents, cut 0xFF bytes from the end and copy only</span>
<span class="cm">	 * the first part. We must do this to avoid writing 0xFF bytes as it</span>
<span class="cm">	 * may have some side-effects. And not only this. It is important not</span>
<span class="cm">	 * to include those 0xFFs to CRC because later the they may be filled</span>
<span class="cm">	 * by data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_VID_DYNAMIC</span><span class="p">)</span>
		<span class="n">aldata_size</span> <span class="o">=</span> <span class="n">data_size</span> <span class="o">=</span>
			<span class="n">ubi_calc_data_len</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>

	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * It may turn out to be that the whole @from physical eraseblock</span>
<span class="cm">	 * contains only 0xFF bytes. Then we have to only write the VID header</span>
<span class="cm">	 * and do not write any data. This also means we should not set</span>
<span class="cm">	 * @vid_hdr-&gt;copy_flag, @vid_hdr-&gt;data_size, and @vid_hdr-&gt;data_crc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">copy_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">data_size</span><span class="p">);</span>
		<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_crc</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">next_sqnum</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">MOVE_TARGET_WR_ERR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cond_resched</span><span class="p">();</span>

	<span class="cm">/* Read the VID header back and check if it was written correctly */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;error %d while reading VID header back from &quot;</span>
				  <span class="s">&quot;PEB %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_error_sane</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">MOVE_TARGET_RD_ERR</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">MOVE_TARGET_BITFLIPS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">aldata_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">MOVE_TARGET_WR_ERR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock_buf</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve written the data and are going to read it back to make</span>
<span class="cm">		 * sure it was written correctly.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">aldata_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_data</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">aldata_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;error %d while reading data back &quot;</span>
					 <span class="s">&quot;from PEB %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">is_error_sane</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">MOVE_TARGET_RD_ERR</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">MOVE_TARGET_BITFLIPS</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock_buf</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">data_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;read data back from PEB %d and it is &quot;</span>
				 <span class="s">&quot;different&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock_buf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">==</span> <span class="n">from</span><span class="p">);</span>
	<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>

<span class="nl">out_unlock_buf:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
<span class="nl">out_unlock_leb:</span>
	<span class="n">leb_write_unlock</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * print_rsvd_warning - warn about not having enough reserved PEBs.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;ubi_eba_init()&#39; which is called when UBI</span>
<span class="cm"> * cannot reserve enough PEBs for bad block handling. This function makes a</span>
<span class="cm"> * decision whether we have to print a warning or not. The algorithm is as</span>
<span class="cm"> * follows:</span>
<span class="cm"> *   o if this is a new UBI image, then just print the warning</span>
<span class="cm"> *   o if this is an UBI image which has already been used for some time, print</span>
<span class="cm"> *     a warning only if we can reserve less than 10% of the expected amount of</span>
<span class="cm"> *     the reserved PEB.</span>
<span class="cm"> *</span>
<span class="cm"> * The idea is that when UBI is used, PEBs become bad, and the reserved pool</span>
<span class="cm"> * of PEBs becomes smaller, which is normal and we do not want to scare users</span>
<span class="cm"> * with a warning every time they attach the MTD device. This was an issue</span>
<span class="cm"> * reported by real users.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_rsvd_warning</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The 1 &lt;&lt; 18 (256KiB) number is picked randomly, just a reasonably</span>
<span class="cm">	 * large number to distinguish between newly flashed and used images.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">max_sqnum</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_level</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">min</span><span class="p">)</span>
			<span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span> <span class="o">&gt;</span> <span class="n">min</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;cannot reserve enough PEBs for bad PEB handling, reserved %d,&quot;</span>
		 <span class="s">&quot; need %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_level</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">corr_peb_count</span><span class="p">)</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;%d PEBs are corrupted and not used&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">corr_peb_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_eba_init - initialize the EBA sub-system using attaching information.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @ai: attaching information</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_eba_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">num_volumes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_ainf_volume</span> <span class="o">*</span><span class="n">av</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_ainf_peb</span> <span class="o">*</span><span class="n">aeb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>

	<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;initialize EBA sub-system&quot;</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">alc_mutex</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ltree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">global_sqnum</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">max_sqnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_volumes</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span> <span class="o">+</span> <span class="n">UBI_INT_VOL_COUNT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_volumes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vol</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
				       <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">UBI_LEB_UNMAPPED</span><span class="p">;</span>

		<span class="n">av</span> <span class="o">=</span> <span class="n">ubi_find_av</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">idx2vol_id</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">av</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ubi_rb_for_each_entry</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="n">aeb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">aeb</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * This may happen in case of an unclean reboot</span>
<span class="cm">				 * during re-size.</span>
<span class="cm">				 */</span>
				<span class="n">ubi_move_aeb_to_list</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">aeb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">);</span>
			<span class="n">vol</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">[</span><span class="n">aeb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">&lt;</span> <span class="n">EBA_RESERVED_PEBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;no enough physical eraseblocks (%d, need %d)&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span><span class="p">,</span> <span class="n">EBA_RESERVED_PEBS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">corr_peb_count</span><span class="p">)</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;%d PEBs are corrupted and not used&quot;</span><span class="p">,</span>
				<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">corr_peb_count</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">-=</span> <span class="n">EBA_RESERVED_PEBS</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">rsvd_pebs</span> <span class="o">+=</span> <span class="n">EBA_RESERVED_PEBS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_calculate_reserved</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_level</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No enough free physical eraseblocks */</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span><span class="p">;</span>
			<span class="n">print_rsvd_warning</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ai</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_level</span><span class="p">;</span>

		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">-=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span><span class="p">;</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">rsvd_pebs</span>  <span class="o">+=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_eba</span><span class="p">(</span><span class="s">&quot;EBA sub-system is initialized&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_volumes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eba_tbl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
