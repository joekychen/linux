<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › ubi › ubi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ubi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) International Business Machines Corp., 2006</span>
<span class="cm"> * Copyright (c) Nokia Corporation, 2006, 2007</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __UBI_UBI_H__</span>
<span class="cp">#define __UBI_UBI_H__</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/ubi.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>

<span class="cp">#include &quot;ubi-media.h&quot;</span>

<span class="cm">/* Maximum number of supported UBI devices */</span>
<span class="cp">#define UBI_MAX_DEVICES 32</span>

<span class="cm">/* UBI name used for character devices, sysfs, etc */</span>
<span class="cp">#define UBI_NAME_STR &quot;ubi&quot;</span>

<span class="cm">/* Normal UBI messages */</span>
<span class="cp">#define ubi_msg(fmt, ...) printk(KERN_NOTICE &quot;UBI: &quot; fmt &quot;\n&quot;, ##__VA_ARGS__)</span>
<span class="cm">/* UBI warning messages */</span>
<span class="cp">#define ubi_warn(fmt, ...) printk(KERN_WARNING &quot;UBI warning: %s: &quot; fmt &quot;\n&quot;, \</span>
<span class="cp">				  __func__, ##__VA_ARGS__)</span>
<span class="cm">/* UBI error messages */</span>
<span class="cp">#define ubi_err(fmt, ...) printk(KERN_ERR &quot;UBI error: %s: &quot; fmt &quot;\n&quot;, \</span>
<span class="cp">				 __func__, ##__VA_ARGS__)</span>

<span class="cm">/* Lowest number PEBs reserved for bad PEB handling */</span>
<span class="cp">#define MIN_RESEVED_PEBS 2</span>

<span class="cm">/* Background thread name pattern */</span>
<span class="cp">#define UBI_BGT_NAME_PATTERN &quot;ubi_bgt%dd&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * This marker in the EBA table means that the LEB is um-mapped.</span>
<span class="cm"> * NOTE! It has to have the same value as %UBI_ALL.</span>
<span class="cm"> */</span>
<span class="cp">#define UBI_LEB_UNMAPPED -1</span>

<span class="cm">/*</span>
<span class="cm"> * In case of errors, UBI tries to repeat the operation several times before</span>
<span class="cm"> * returning error. The below constant defines how many times UBI re-tries.</span>
<span class="cm"> */</span>
<span class="cp">#define UBI_IO_RETRIES 3</span>

<span class="cm">/*</span>
<span class="cm"> * Length of the protection queue. The length is effectively equivalent to the</span>
<span class="cm"> * number of (global) erase cycles PEBs are protected from the wear-leveling</span>
<span class="cm"> * worker.</span>
<span class="cm"> */</span>
<span class="cp">#define UBI_PROT_QUEUE_LEN 10</span>

<span class="cm">/* The volume ID/LEB number/erase counter is unknown */</span>
<span class="cp">#define UBI_UNKNOWN -1</span>

<span class="cm">/*</span>
<span class="cm"> * Error codes returned by the I/O sub-system.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI_IO_FF: the read region of flash contains only 0xFFs</span>
<span class="cm"> * UBI_IO_FF_BITFLIPS: the same as %UBI_IO_FF, but also also there was a data</span>
<span class="cm"> *                     integrity error reported by the MTD driver</span>
<span class="cm"> *                     (uncorrectable ECC error in case of NAND)</span>
<span class="cm"> * UBI_IO_BAD_HDR: the EC or VID header is corrupted (bad magic or CRC)</span>
<span class="cm"> * UBI_IO_BAD_HDR_EBADMSG: the same as %UBI_IO_BAD_HDR, but also there was a</span>
<span class="cm"> *                         data integrity error reported by the MTD driver</span>
<span class="cm"> *                         (uncorrectable ECC error in case of NAND)</span>
<span class="cm"> * UBI_IO_BITFLIPS: bit-flips were detected and corrected</span>
<span class="cm"> *</span>
<span class="cm"> * Note, it is probably better to have bit-flip and ebadmsg as flags which can</span>
<span class="cm"> * be or&#39;ed with other error code. But this is a big change because there are</span>
<span class="cm"> * may callers, so it does not worth the risk of introducing a bug</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBI_IO_FF</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">UBI_IO_FF_BITFLIPS</span><span class="p">,</span>
	<span class="n">UBI_IO_BAD_HDR</span><span class="p">,</span>
	<span class="n">UBI_IO_BAD_HDR_EBADMSG</span><span class="p">,</span>
	<span class="n">UBI_IO_BITFLIPS</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Return codes of the &#39;ubi_eba_copy_leb()&#39; function.</span>
<span class="cm"> *</span>
<span class="cm"> * MOVE_CANCEL_RACE: canceled because the volume is being deleted, the source</span>
<span class="cm"> *                   PEB was put meanwhile, or there is I/O on the source PEB</span>
<span class="cm"> * MOVE_SOURCE_RD_ERR: canceled because there was a read error from the source</span>
<span class="cm"> *                     PEB</span>
<span class="cm"> * MOVE_TARGET_RD_ERR: canceled because there was a read error from the target</span>
<span class="cm"> *                     PEB</span>
<span class="cm"> * MOVE_TARGET_WR_ERR: canceled because there was a write error to the target</span>
<span class="cm"> *                     PEB</span>
<span class="cm"> * MOVE_TARGET_BITFLIPS: canceled because a bit-flip was detected in the</span>
<span class="cm"> *                       target PEB</span>
<span class="cm"> * MOVE_RETRY: retry scrubbing the PEB</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">MOVE_CANCEL_RACE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">MOVE_SOURCE_RD_ERR</span><span class="p">,</span>
	<span class="n">MOVE_TARGET_RD_ERR</span><span class="p">,</span>
	<span class="n">MOVE_TARGET_WR_ERR</span><span class="p">,</span>
	<span class="n">MOVE_TARGET_BITFLIPS</span><span class="p">,</span>
	<span class="n">MOVE_RETRY</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_wl_entry - wear-leveling entry.</span>
<span class="cm"> * @u.rb: link in the corresponding (free/used) RB-tree</span>
<span class="cm"> * @u.list: link in the protection queue</span>
<span class="cm"> * @ec: erase counter</span>
<span class="cm"> * @pnum: physical eraseblock number</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure is used in the WL sub-system. Each physical eraseblock</span>
<span class="cm"> * has a corresponding &amp;struct wl_entry object which may be kept in different</span>
<span class="cm"> * RB-trees. See WL sub-system for details.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnum</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_ltree_entry - an entry in the lock tree.</span>
<span class="cm"> * @rb: links RB-tree nodes</span>
<span class="cm"> * @vol_id: volume ID of the locked logical eraseblock</span>
<span class="cm"> * @lnum: locked logical eraseblock number</span>
<span class="cm"> * @users: how many tasks are using this logical eraseblock or wait for it</span>
<span class="cm"> * @mutex: read/write mutex to implement read/write access serialization to</span>
<span class="cm"> *         the (@vol_id, @lnum) logical eraseblock</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure is used in the EBA sub-system to implement per-LEB</span>
<span class="cm"> * locking. When a logical eraseblock is being locked - corresponding</span>
<span class="cm"> * &amp;struct ubi_ltree_entry object is inserted to the lock tree (@ubi-&gt;ltree).</span>
<span class="cm"> * See EBA sub-system for details.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_ltree_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">users</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">mutex</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_rename_entry - volume re-name description data structure.</span>
<span class="cm"> * @new_name_len: new volume name length</span>
<span class="cm"> * @new_name: new volume name</span>
<span class="cm"> * @remove: if not zero, this volume should be removed, not re-named</span>
<span class="cm"> * @desc: descriptor of the volume</span>
<span class="cm"> * @list: links re-name entries into a list</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure is utilized in the multiple volume re-name code. Namely,</span>
<span class="cm"> * UBI first creates a list of &amp;struct ubi_rename_entry objects from the</span>
<span class="cm"> * &amp;struct ubi_rnvol_req request object, and then utilizes this list to do all</span>
<span class="cm"> * the job.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_rename_entry</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">new_name_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">new_name</span><span class="p">[</span><span class="n">UBI_VOL_NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">remove</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ubi_volume_desc</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_volume - UBI volume description data structure.</span>
<span class="cm"> * @dev: device object to make use of the the Linux device model</span>
<span class="cm"> * @cdev: character device object to create character device</span>
<span class="cm"> * @ubi: reference to the UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @ref_count: volume reference count</span>
<span class="cm"> * @readers: number of users holding this volume in read-only mode</span>
<span class="cm"> * @writers: number of users holding this volume in read-write mode</span>
<span class="cm"> * @exclusive: whether somebody holds this volume in exclusive mode</span>
<span class="cm"> *</span>
<span class="cm"> * @reserved_pebs: how many physical eraseblocks are reserved for this volume</span>
<span class="cm"> * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)</span>
<span class="cm"> * @usable_leb_size: logical eraseblock size without padding</span>
<span class="cm"> * @used_ebs: how many logical eraseblocks in this volume contain data</span>
<span class="cm"> * @last_eb_bytes: how many bytes are stored in the last logical eraseblock</span>
<span class="cm"> * @used_bytes: how many bytes of data this volume contains</span>
<span class="cm"> * @alignment: volume alignment</span>
<span class="cm"> * @data_pad: how many bytes are not used at the end of physical eraseblocks to</span>
<span class="cm"> *            satisfy the requested alignment</span>
<span class="cm"> * @name_len: volume name length</span>
<span class="cm"> * @name: volume name</span>
<span class="cm"> *</span>
<span class="cm"> * @upd_ebs: how many eraseblocks are expected to be updated</span>
<span class="cm"> * @ch_lnum: LEB number which is being changing by the atomic LEB change</span>
<span class="cm"> *           operation</span>
<span class="cm"> * @upd_bytes: how many bytes are expected to be received for volume update or</span>
<span class="cm"> *             atomic LEB change</span>
<span class="cm"> * @upd_received: how many bytes were already received for volume update or</span>
<span class="cm"> *                atomic LEB change</span>
<span class="cm"> * @upd_buf: update buffer which is used to collect update data or data for</span>
<span class="cm"> *           atomic LEB change</span>
<span class="cm"> *</span>
<span class="cm"> * @eba_tbl: EBA table of this volume (LEB-&gt;PEB mapping)</span>
<span class="cm"> * @checked: %1 if this static volume was checked</span>
<span class="cm"> * @corrupted: %1 if the volume is corrupted (static volumes only)</span>
<span class="cm"> * @upd_marker: %1 if the update marker is set for this volume</span>
<span class="cm"> * @updating: %1 if the volume is being updated</span>
<span class="cm"> * @changing_leb: %1 if the atomic LEB change ioctl command is in progress</span>
<span class="cm"> * @direct_writes: %1 if direct writes are enabled for this volume</span>
<span class="cm"> *</span>
<span class="cm"> * The @corrupted field indicates that the volume&#39;s contents is corrupted.</span>
<span class="cm"> * Since UBI protects only static volumes, this field is not relevant to</span>
<span class="cm"> * dynamic volumes - it is user&#39;s responsibility to assure their data</span>
<span class="cm"> * integrity.</span>
<span class="cm"> *</span>
<span class="cm"> * The @upd_marker flag indicates that this volume is either being updated at</span>
<span class="cm"> * the moment or is damaged because of an unclean reboot.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="n">cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ref_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">readers</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">writers</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exclusive</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">reserved_pebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">usable_leb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used_ebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_eb_bytes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">used_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alignment</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_pad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">UBI_VOL_NAME_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">upd_ebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ch_lnum</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">upd_bytes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">upd_received</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">upd_buf</span><span class="p">;</span>

	<span class="kt">int</span> <span class="o">*</span><span class="n">eba_tbl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">checked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">corrupted</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">upd_marker</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">updating</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">changing_leb</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">direct_writes</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_volume_desc - UBI volume descriptor returned when it is opened.</span>
<span class="cm"> * @vol: reference to the corresponding volume description object</span>
<span class="cm"> * @mode: open mode (%UBI_READONLY, %UBI_READWRITE, or %UBI_EXCLUSIVE)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_device - UBI device description structure</span>
<span class="cm"> * @dev: UBI device object to use the the Linux device model</span>
<span class="cm"> * @cdev: character device object to create character device</span>
<span class="cm"> * @ubi_num: UBI device number</span>
<span class="cm"> * @ubi_name: UBI device name</span>
<span class="cm"> * @vol_count: number of volumes in this UBI device</span>
<span class="cm"> * @volumes: volumes of this UBI device</span>
<span class="cm"> * @volumes_lock: protects @volumes, @rsvd_pebs, @avail_pebs, beb_rsvd_pebs,</span>
<span class="cm"> *                @beb_rsvd_level, @bad_peb_count, @good_peb_count, @vol_count,</span>
<span class="cm"> *                @vol-&gt;readers, @vol-&gt;writers, @vol-&gt;exclusive,</span>
<span class="cm"> *                @vol-&gt;ref_count, @vol-&gt;mapping and @vol-&gt;eba_tbl.</span>
<span class="cm"> * @ref_count: count of references on the UBI device</span>
<span class="cm"> * @image_seq: image sequence number recorded on EC headers</span>
<span class="cm"> *</span>
<span class="cm"> * @rsvd_pebs: count of reserved physical eraseblocks</span>
<span class="cm"> * @avail_pebs: count of available physical eraseblocks</span>
<span class="cm"> * @beb_rsvd_pebs: how many physical eraseblocks are reserved for bad PEB</span>
<span class="cm"> *                 handling</span>
<span class="cm"> * @beb_rsvd_level: normal level of PEBs reserved for bad PEB handling</span>
<span class="cm"> *</span>
<span class="cm"> * @autoresize_vol_id: ID of the volume which has to be auto-resized at the end</span>
<span class="cm"> *                     of UBI initialization</span>
<span class="cm"> * @vtbl_slots: how many slots are available in the volume table</span>
<span class="cm"> * @vtbl_size: size of the volume table in bytes</span>
<span class="cm"> * @vtbl: in-RAM volume table copy</span>
<span class="cm"> * @device_mutex: protects on-flash volume table and serializes volume</span>
<span class="cm"> *                creation, deletion, update, re-size, re-name and set</span>
<span class="cm"> *                property</span>
<span class="cm"> *</span>
<span class="cm"> * @max_ec: current highest erase counter value</span>
<span class="cm"> * @mean_ec: current mean erase counter value</span>
<span class="cm"> *</span>
<span class="cm"> * @global_sqnum: global sequence number</span>
<span class="cm"> * @ltree_lock: protects the lock tree and @global_sqnum</span>
<span class="cm"> * @ltree: the lock tree</span>
<span class="cm"> * @alc_mutex: serializes &quot;atomic LEB change&quot; operations</span>
<span class="cm"> *</span>
<span class="cm"> * @used: RB-tree of used physical eraseblocks</span>
<span class="cm"> * @erroneous: RB-tree of erroneous used physical eraseblocks</span>
<span class="cm"> * @free: RB-tree of free physical eraseblocks</span>
<span class="cm"> * @scrub: RB-tree of physical eraseblocks which need scrubbing</span>
<span class="cm"> * @pq: protection queue (contain physical eraseblocks which are temporarily</span>
<span class="cm"> *      protected from the wear-leveling worker)</span>
<span class="cm"> * @pq_head: protection queue head</span>
<span class="cm"> * @wl_lock: protects the @used, @free, @pq, @pq_head, @lookuptbl, @move_from,</span>
<span class="cm"> *	     @move_to, @move_to_put @erase_pending, @wl_scheduled, @works,</span>
<span class="cm"> *	     @erroneous, and @erroneous_peb_count fields</span>
<span class="cm"> * @move_mutex: serializes eraseblock moves</span>
<span class="cm"> * @work_sem: synchronizes the WL worker with use tasks</span>
<span class="cm"> * @wl_scheduled: non-zero if the wear-leveling was scheduled</span>
<span class="cm"> * @lookuptbl: a table to quickly find a &amp;struct ubi_wl_entry object for any</span>
<span class="cm"> *             physical eraseblock</span>
<span class="cm"> * @move_from: physical eraseblock from where the data is being moved</span>
<span class="cm"> * @move_to: physical eraseblock where the data is being moved to</span>
<span class="cm"> * @move_to_put: if the &quot;to&quot; PEB was put</span>
<span class="cm"> * @works: list of pending works</span>
<span class="cm"> * @works_count: count of pending works</span>
<span class="cm"> * @bgt_thread: background thread description object</span>
<span class="cm"> * @thread_enabled: if the background thread is enabled</span>
<span class="cm"> * @bgt_name: background thread name</span>
<span class="cm"> *</span>
<span class="cm"> * @flash_size: underlying MTD device size (in bytes)</span>
<span class="cm"> * @peb_count: count of physical eraseblocks on the MTD device</span>
<span class="cm"> * @peb_size: physical eraseblock size</span>
<span class="cm"> * @bad_peb_count: count of bad physical eraseblocks</span>
<span class="cm"> * @good_peb_count: count of good physical eraseblocks</span>
<span class="cm"> * @corr_peb_count: count of corrupted physical eraseblocks (preserved and not</span>
<span class="cm"> *                  used by UBI)</span>
<span class="cm"> * @erroneous_peb_count: count of erroneous physical eraseblocks in @erroneous</span>
<span class="cm"> * @max_erroneous: maximum allowed amount of erroneous physical eraseblocks</span>
<span class="cm"> * @min_io_size: minimal input/output unit size of the underlying MTD device</span>
<span class="cm"> * @hdrs_min_io_size: minimal I/O unit size used for VID and EC headers</span>
<span class="cm"> * @ro_mode: if the UBI device is in read-only mode</span>
<span class="cm"> * @leb_size: logical eraseblock size</span>
<span class="cm"> * @leb_start: starting offset of logical eraseblocks within physical</span>
<span class="cm"> *             eraseblocks</span>
<span class="cm"> * @ec_hdr_alsize: size of the EC header aligned to @hdrs_min_io_size</span>
<span class="cm"> * @vid_hdr_alsize: size of the VID header aligned to @hdrs_min_io_size</span>
<span class="cm"> * @vid_hdr_offset: starting offset of the volume identifier header (might be</span>
<span class="cm"> *                  unaligned)</span>
<span class="cm"> * @vid_hdr_aloffset: starting offset of the VID header aligned to</span>
<span class="cm"> * @hdrs_min_io_size</span>
<span class="cm"> * @vid_hdr_shift: contains @vid_hdr_offset - @vid_hdr_aloffset</span>
<span class="cm"> * @bad_allowed: whether the MTD device admits of bad physical eraseblocks or</span>
<span class="cm"> *               not</span>
<span class="cm"> * @nor_flash: non-zero if working on top of NOR flash</span>
<span class="cm"> * @max_write_size: maximum amount of bytes the underlying flash can write at a</span>
<span class="cm"> *                  time (MTD write buffer size)</span>
<span class="cm"> * @mtd: MTD device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * @peb_buf: a buffer of PEB size used for different purposes</span>
<span class="cm"> * @buf_mutex: protects @peb_buf</span>
<span class="cm"> * @ckvol_mutex: serializes static volume checking when opening</span>
<span class="cm"> *</span>
<span class="cm"> * @dbg: debugging information for this UBI device</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="n">cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ubi_num</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ubi_name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">UBI_NAME_STR</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">vol_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">volumes</span><span class="p">[</span><span class="n">UBI_MAX_VOLUMES</span><span class="o">+</span><span class="n">UBI_INT_VOL_COUNT</span><span class="p">];</span>
	<span class="n">spinlock_t</span> <span class="n">volumes_lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ref_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">image_seq</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">rsvd_pebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">avail_pebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">beb_rsvd_pebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">beb_rsvd_level</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">autoresize_vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vtbl_slots</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vtbl_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_vtbl_record</span> <span class="o">*</span><span class="n">vtbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">device_mutex</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">max_ec</span><span class="p">;</span>
	<span class="cm">/* Note, mean_ec is not updated run-time - should be fixed */</span>
	<span class="kt">int</span> <span class="n">mean_ec</span><span class="p">;</span>

	<span class="cm">/* EBA sub-system&#39;s stuff */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">global_sqnum</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ltree_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">ltree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">alc_mutex</span><span class="p">;</span>

	<span class="cm">/* Wear-leveling sub-system&#39;s stuff */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">used</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">erroneous</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">free</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">scrub</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pq</span><span class="p">[</span><span class="n">UBI_PROT_QUEUE_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">pq_head</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">wl_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">move_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">work_sem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wl_scheduled</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">**</span><span class="n">lookuptbl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">move_from</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">move_to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">move_to_put</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">works</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">works_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">bgt_thread</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">thread_enabled</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">bgt_name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">UBI_BGT_NAME_PATTERN</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/* I/O sub-system&#39;s stuff */</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">flash_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">peb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bad_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">good_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">corr_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">erroneous_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_erroneous</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_io_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hdrs_min_io_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ro_mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leb_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ec_hdr_alsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vid_hdr_alsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vid_hdr_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vid_hdr_aloffset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vid_hdr_shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bad_allowed</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nor_flash</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_write_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">peb_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">buf_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ckvol_mutex</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ubi_debug_info</span> <span class="o">*</span><span class="n">dbg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_ainf_peb - attach information about a physical eraseblock.</span>
<span class="cm"> * @ec: erase counter (%UBI_UNKNOWN if it is unknown)</span>
<span class="cm"> * @pnum: physical eraseblock number</span>
<span class="cm"> * @vol_id: ID of the volume this LEB belongs to</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @scrub: if this physical eraseblock needs scrubbing</span>
<span class="cm"> * @copy_flag: this LEB is a copy (@copy_flag is set in VID header of this LEB)</span>
<span class="cm"> * @sqnum: sequence number</span>
<span class="cm"> * @u: unions RB-tree or @list links</span>
<span class="cm"> * @u.rb: link in the per-volume RB-tree of &amp;struct ubi_ainf_peb objects</span>
<span class="cm"> * @u.list: link in one of the eraseblock lists</span>
<span class="cm"> *</span>
<span class="cm"> * One object of this type is allocated for each physical eraseblock when</span>
<span class="cm"> * attaching an MTD device. Note, if this PEB does not belong to any LEB /</span>
<span class="cm"> * volume, the @vol_id and @lnum fields are initialized to %UBI_UNKNOWN.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_ainf_peb</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">ec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scrub</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">copy_flag</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_ainf_volume - attaching information about a volume.</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> * @highest_lnum: highest logical eraseblock number in this volume</span>
<span class="cm"> * @leb_count: number of logical eraseblocks in this volume</span>
<span class="cm"> * @vol_type: volume type</span>
<span class="cm"> * @used_ebs: number of used logical eraseblocks in this volume (only for</span>
<span class="cm"> *            static volumes)</span>
<span class="cm"> * @last_data_size: amount of data in the last logical eraseblock of this</span>
<span class="cm"> *                  volume (always equivalent to the usable logical eraseblock</span>
<span class="cm"> *                  size in case of dynamic volumes)</span>
<span class="cm"> * @data_pad: how many bytes at the end of logical eraseblocks of this volume</span>
<span class="cm"> *            are not used (due to volume alignment)</span>
<span class="cm"> * @compat: compatibility flags of this volume</span>
<span class="cm"> * @rb: link in the volume RB-tree</span>
<span class="cm"> * @root: root of the RB-tree containing all the eraseblock belonging to this</span>
<span class="cm"> *        volume (&amp;struct ubi_ainf_peb objects)</span>
<span class="cm"> *</span>
<span class="cm"> * One object of this type is allocated for each volume when attaching an MTD</span>
<span class="cm"> * device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_ainf_volume</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">highest_lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used_ebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_data_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_pad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">root</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_attach_info - MTD device attaching information.</span>
<span class="cm"> * @volumes: root of the volume RB-tree</span>
<span class="cm"> * @corr: list of corrupted physical eraseblocks</span>
<span class="cm"> * @free: list of free physical eraseblocks</span>
<span class="cm"> * @erase: list of physical eraseblocks which have to be erased</span>
<span class="cm"> * @alien: list of physical eraseblocks which should not be used by UBI (e.g.,</span>
<span class="cm"> *         those belonging to &quot;preserve&quot;-compatible internal volumes)</span>
<span class="cm"> * @corr_peb_count: count of PEBs in the @corr list</span>
<span class="cm"> * @empty_peb_count: count of PEBs which are presumably empty (contain only</span>
<span class="cm"> *                   0xFF bytes)</span>
<span class="cm"> * @alien_peb_count: count of PEBs in the @alien list</span>
<span class="cm"> * @bad_peb_count: count of bad physical eraseblocks</span>
<span class="cm"> * @maybe_bad_peb_count: count of bad physical eraseblocks which are not marked</span>
<span class="cm"> *                       as bad yet, but which look like bad</span>
<span class="cm"> * @vols_found: number of volumes found</span>
<span class="cm"> * @highest_vol_id: highest volume ID</span>
<span class="cm"> * @is_empty: flag indicating whether the MTD device is empty or not</span>
<span class="cm"> * @min_ec: lowest erase counter value</span>
<span class="cm"> * @max_ec: highest erase counter value</span>
<span class="cm"> * @max_sqnum: highest sequence number value</span>
<span class="cm"> * @mean_ec: mean erase counter value</span>
<span class="cm"> * @ec_sum: a temporary variable used when calculating @mean_ec</span>
<span class="cm"> * @ec_count: a temporary variable used when calculating @mean_ec</span>
<span class="cm"> * @aeb_slab_cache: slab cache for &amp;struct ubi_ainf_peb objects</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure contains the result of attaching an MTD device and may</span>
<span class="cm"> * be used by other UBI sub-systems to build final UBI data structures, further</span>
<span class="cm"> * error-recovery and so on.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">volumes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">corr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">erase</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">alien</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">corr_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alien_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bad_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maybe_bad_peb_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vols_found</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">highest_vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_empty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_ec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_ec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">max_sqnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mean_ec</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">ec_sum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ec_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">aeb_slab_cache</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include &quot;debug.h&quot;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ubi_wl_entry_slab</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ubi_ctrl_cdev_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ubi_cdev_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ubi_vol_cdev_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">ubi_class</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">ubi_devices_mutex</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">blocking_notifier_head</span> <span class="n">ubi_notifiers</span><span class="p">;</span>

<span class="cm">/* scan.c */</span>
<span class="kt">int</span> <span class="n">ubi_add_to_av</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">ec</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bitflips</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubi_ainf_volume</span> <span class="o">*</span><span class="n">ubi_find_av</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">vol_id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_remove_av</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_ainf_volume</span> <span class="o">*</span><span class="n">av</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubi_ainf_peb</span> <span class="o">*</span><span class="n">ubi_early_get_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_destroy_ai</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">);</span>

<span class="cm">/* vtbl.c */</span>
<span class="kt">int</span> <span class="n">ubi_change_vtbl_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ubi_vtbl_record</span> <span class="o">*</span><span class="n">vtbl_rec</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_vtbl_rename_volumes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">rename_list</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_read_volume_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">);</span>

<span class="cm">/* vmt.c */</span>
<span class="kt">int</span> <span class="n">ubi_create_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_mkvol_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_remove_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">no_vtbl</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_resize_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved_pebs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_rename_volumes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">rename_list</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_add_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_free_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">);</span>

<span class="cm">/* upd.c */</span>
<span class="kt">int</span> <span class="n">ubi_start_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		     <span class="kt">long</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_more_update_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_start_leb_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_leb_change_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_more_leb_change_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/* misc.c */</span>
<span class="kt">int</span> <span class="n">ubi_calc_data_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_check_volume</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_calculate_reserved</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_check_pattern</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">patt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="cm">/* eba.c */</span>
<span class="kt">int</span> <span class="n">ubi_eba_unmap_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_eba_read_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_eba_write_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_eba_write_leb_st</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">used_ebs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_eba_atomic_leb_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_eba_copy_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_eba_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">);</span>

<span class="cm">/* wl.c */</span>
<span class="kt">int</span> <span class="n">ubi_wl_get_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_wl_put_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">torture</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_wl_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_wl_scrub_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_wl_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_wl_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">u</span><span class="p">);</span>

<span class="cm">/* io.c */</span>
<span class="kt">int</span> <span class="n">ubi_io_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_io_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_io_sync_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">torture</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_io_is_bad</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_io_mark_bad</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_io_read_ec_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_io_write_ec_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_io_read_vid_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_io_write_vid_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">);</span>

<span class="cm">/* build.c */</span>
<span class="kt">int</span> <span class="n">ubi_attach_mtd_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vid_hdr_offset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_detach_mtd_dev</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anyway</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi_get_device</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_put_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi_get_by_major</span><span class="p">(</span><span class="kt">int</span> <span class="n">major</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_major2num</span><span class="p">(</span><span class="kt">int</span> <span class="n">major</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_volume_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">ntype</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_notify_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ntype</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubi_enumerate_volumes</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_free_internal_volumes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">);</span>

<span class="cm">/* kapi.c */</span>
<span class="kt">void</span> <span class="n">ubi_do_get_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_device_info</span> <span class="o">*</span><span class="n">di</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubi_do_get_volume_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ubi_volume_info</span> <span class="o">*</span><span class="n">vi</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ubi_rb_for_each_entry - walk an RB-tree.</span>
<span class="cm"> * @rb: a pointer to type &#39;struct rb_node&#39; to use as a loop counter</span>
<span class="cm"> * @pos: a pointer to RB-tree entry type to use as a loop counter</span>
<span class="cm"> * @root: RB-tree&#39;s root</span>
<span class="cm"> * @member: the name of the &#39;struct rb_node&#39; within the RB-tree entry</span>
<span class="cm"> */</span>
<span class="cp">#define ubi_rb_for_each_entry(rb, pos, root, member)                         \</span>
<span class="cp">	for (rb = rb_first(root),                                            \</span>
<span class="cp">	     pos = (rb ? container_of(rb, typeof(*pos), member) : NULL);     \</span>
<span class="cp">	     rb;                                                             \</span>
<span class="cp">	     rb = rb_next(rb),                                               \</span>
<span class="cp">	     pos = (rb ? container_of(rb, typeof(*pos), member) : NULL))</span>

<span class="cm">/*</span>
<span class="cm"> * ubi_move_aeb_to_list - move a PEB from the volume tree to a list.</span>
<span class="cm"> *</span>
<span class="cm"> * @av: volume attaching information</span>
<span class="cm"> * @aeb: attaching eraseblock information</span>
<span class="cm"> * @list: the list to move to</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ubi_move_aeb_to_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_ainf_volume</span> <span class="o">*</span><span class="n">av</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ubi_ainf_peb</span> <span class="o">*</span><span class="n">aeb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aeb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aeb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_zalloc_vid_hdr - allocate a volume identifier header object.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @gfp_flags: GFP flags to allocate with</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the newly allocated and zero-filled</span>
<span class="cm"> * volume identifier header object in case of success and %NULL in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span>
<span class="nf">ubi_zalloc_vid_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">;</span>

	<span class="n">vid_hdr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_alsize</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vid_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * VID headers may be stored at un-aligned flash offsets, so we shift</span>
<span class="cm">	 * the pointer.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">vid_hdr</span> <span class="o">+</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_free_vid_hdr - free a volume identifier header object.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vid_hdr: the object to free</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ubi_free_vid_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">vid_hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is equivalent to &#39;ubi_io_read()&#39;, but @offset is relative to</span>
<span class="cm"> * the beginning of the logical eraseblock, not to the beginning of the</span>
<span class="cm"> * physical eraseblock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ubi_io_read_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ubi_io_read</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is equivalent to &#39;ubi_io_write()&#39;, but @offset is relative to</span>
<span class="cm"> * the beginning of the logical eraseblock, not to the beginning of the</span>
<span class="cm"> * physical eraseblock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ubi_io_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ubi_io_write</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_ro_mode - switch to read-only mode.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ubi_ro_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;switch to read-only mode&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vol_id2idx - get table index by volume ID.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: volume ID</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">vol_id2idx</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="n">UBI_INTERNAL_VOL_START</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vol_id</span> <span class="o">-</span> <span class="n">UBI_INTERNAL_VOL_START</span> <span class="o">+</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">vol_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * idx2vol_id - get volume ID by table index.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @idx: table index</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">idx2vol_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span> <span class="o">+</span> <span class="n">UBI_INTERNAL_VOL_START</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* !__UBI_UBI_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
