<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › ubi › build.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>build.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) International Business Machines Corp., 2006</span>
<span class="cm"> * Copyright (c) Nokia Corporation, 2007</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Artem Bityutskiy (Битюцкий Артём),</span>
<span class="cm"> *         Frank Haverkamp</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file includes UBI initialization and building of UBI devices.</span>
<span class="cm"> *</span>
<span class="cm"> * When UBI is initialized, it attaches all the MTD devices specified as the</span>
<span class="cm"> * module load parameters or the kernel boot parameters. If MTD devices were</span>
<span class="cm"> * specified, UBI does not attach any MTD device, but it is possible to do</span>
<span class="cm"> * later using the &quot;UBI control device&quot;.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/stringify.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;ubi.h&quot;</span>

<span class="cm">/* Maximum length of the &#39;mtd=&#39; parameter */</span>
<span class="cp">#define MTD_PARAM_LEN_MAX 64</span>

<span class="cp">#ifdef CONFIG_MTD_UBI_MODULE</span>
<span class="cp">#define ubi_is_module() 1</span>
<span class="cp">#else</span>
<span class="cp">#define ubi_is_module() 0</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * struct mtd_dev_param - MTD device parameter description data structure.</span>
<span class="cm"> * @name: MTD character device node path, MTD device name, or MTD device number</span>
<span class="cm"> *        string</span>
<span class="cm"> * @vid_hdr_offs: VID header offset</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mtd_dev_param</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MTD_PARAM_LEN_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">vid_hdr_offs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Numbers of elements set in the @mtd_dev_param array */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__initdata</span> <span class="n">mtd_devs</span><span class="p">;</span>

<span class="cm">/* MTD devices specification parameters */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_dev_param</span> <span class="n">__initdata</span> <span class="n">mtd_dev_param</span><span class="p">[</span><span class="n">UBI_MAX_DEVICES</span><span class="p">];</span>

<span class="cm">/* Root UBI &quot;class&quot; object (corresponds to &#39;/&lt;sysfs&gt;/class/ubi/&#39;) */</span>
<span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">ubi_class</span><span class="p">;</span>

<span class="cm">/* Slab cache for wear-leveling entries */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ubi_wl_entry_slab</span><span class="p">;</span>

<span class="cm">/* UBI control character device */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">ubi_ctrl_cdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ubi_ctrl&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubi_ctrl_cdev_operations</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* All UBI devices in system */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi_devices</span><span class="p">[</span><span class="n">UBI_MAX_DEVICES</span><span class="p">];</span>

<span class="cm">/* Serializes UBI devices creations and removals */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>

<span class="cm">/* Protects @ubi_devices and @ubi-&gt;ref_count */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ubi_devices_lock</span><span class="p">);</span>

<span class="cm">/* &quot;Show&quot; method for files in &#39;/&lt;sysfs&gt;/class/ubi/&#39; */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ubi_version_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">UBI_VERSION</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* UBI version attribute (&#39;/&lt;sysfs&gt;/class/ubi/version&#39;) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">class_attribute</span> <span class="n">ubi_version</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">ubi_version_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">dev_attribute_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/* UBI device attributes (correspond to files in &#39;/&lt;sysfs&gt;/class/ubi/ubiX&#39;) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_eraseblock_size</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">eraseblock_size</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_avail_eraseblocks</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">avail_eraseblocks</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_total_eraseblocks</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">total_eraseblocks</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_volumes_count</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">volumes_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_max_ec</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">max_ec</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_reserved_for_bad</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">reserved_for_bad</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_bad_peb_count</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">bad_peb_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_max_vol_count</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">max_vol_count</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_min_io_size</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">min_io_size</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_bgt_enabled</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">bgt_enabled</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">dev_mtd_num</span> <span class="o">=</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">mtd_num</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">dev_attribute_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_volume_notify - send a volume change notification.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol: volume description object of the changed volume</span>
<span class="cm"> * @ntype: notification type to send (%UBI_VOLUME_ADDED, etc)</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function which notifies all subscribers about a volume</span>
<span class="cm"> * change event (creation, removal, re-sizing, re-naming, updating). Returns</span>
<span class="cm"> * zero in case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_volume_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ntype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_notification</span> <span class="n">nt</span><span class="p">;</span>

	<span class="n">ubi_do_get_device_info</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nt</span><span class="p">.</span><span class="n">di</span><span class="p">);</span>
	<span class="n">ubi_do_get_volume_info</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nt</span><span class="p">.</span><span class="n">vi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_notifiers</span><span class="p">,</span> <span class="n">ntype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_notify_all - send a notification to all volumes.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @ntype: notification type to send (%UBI_VOLUME_ADDED, etc)</span>
<span class="cm"> * @nb: the notifier to call</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks all volumes of UBI device @ubi and sends the @ntype</span>
<span class="cm"> * notification for each volume. If @nb is %NULL, then all registered notifiers</span>
<span class="cm"> * are called, otherwise only the @nb notifier is called. Returns the number of</span>
<span class="cm"> * sent notifications.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_notify_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ntype</span><span class="p">,</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_notification</span> <span class="n">nt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubi_do_get_device_info</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nt</span><span class="p">.</span><span class="n">di</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">device_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since the @ubi-&gt;device is locked, and we are not going to</span>
<span class="cm">		 * change @ubi-&gt;volumes, we do not have to lock</span>
<span class="cm">		 * @ubi-&gt;volumes_lock.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ubi_do_get_volume_info</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">nt</span><span class="p">.</span><span class="n">vi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span>
			<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">ntype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nt</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_notifiers</span><span class="p">,</span> <span class="n">ntype</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">nt</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">device_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_enumerate_volumes - send &quot;add&quot; notification for all existing volumes.</span>
<span class="cm"> * @nb: the notifier to call</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks all UBI devices and volumes and sends the</span>
<span class="cm"> * %UBI_VOLUME_ADDED notification for each volume. If @nb is %NULL, then all</span>
<span class="cm"> * registered notifiers are called, otherwise only the @nb notifier is called.</span>
<span class="cm"> * Returns the number of sent notifications.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_enumerate_volumes</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the @ubi_devices_mutex is locked, and we are not going to</span>
<span class="cm">	 * change @ubi_devices, we do not have to lock @ubi_devices_lock.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">ubi_notify_all</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">UBI_VOLUME_ADDED</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_get_device - get UBI device.</span>
<span class="cm"> * @ubi_num: UBI device number</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns UBI device description object for UBI device number</span>
<span class="cm"> * @ubi_num, or %NULL if the device does not exist. This function increases the</span>
<span class="cm"> * device reference count to prevent removal of the device. In other words, the</span>
<span class="cm"> * device cannot be removed if its reference count is not zero.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="nf">ubi_get_device</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>
	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_devices</span><span class="p">[</span><span class="n">ubi_num</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ubi</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_put_device - drop an UBI device reference.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubi_put_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_get_by_major - get UBI device by character device major number.</span>
<span class="cm"> * @major: major number</span>
<span class="cm"> *</span>
<span class="cm"> * This function is similar to &#39;ubi_get_device()&#39;, but it searches the device</span>
<span class="cm"> * by its major number.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="nf">ubi_get_by_major</span><span class="p">(</span><span class="kt">int</span> <span class="n">major</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span> <span class="o">&amp;&amp;</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">major</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ubi</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_major2num - get UBI device number by character device major number.</span>
<span class="cm"> * @major: major number</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches UBI device number object by its major number. If UBI</span>
<span class="cm"> * device was not found, this function returns -ENODEV, otherwise the UBI device</span>
<span class="cm"> * number is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_major2num</span><span class="p">(</span><span class="kt">int</span> <span class="n">major</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ubi_num</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span> <span class="o">&amp;&amp;</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">major</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_num</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ubi_num</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* &quot;Show&quot; method for files in &#39;/&lt;sysfs&gt;/class/ubi/ubiX/&#39; */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dev_attribute_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The below code looks weird, but it actually makes sense. We get the</span>
<span class="cm">	 * UBI device reference from the contained &#39;struct ubi_device&#39;. But it</span>
<span class="cm">	 * is unclear if the device was removed or not yet. Indeed, if the</span>
<span class="cm">	 * device was removed before we increased its reference count,</span>
<span class="cm">	 * &#39;ubi_get_device()&#39; will return -ENODEV and we fail.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Remember, &#39;struct ubi_device&#39; is freed in the release function, so</span>
<span class="cm">	 * we still can use &#39;ubi-&gt;ubi_num&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">ubi</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_device</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_get_device</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_eraseblock_size</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_avail_eraseblocks</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_total_eraseblocks</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">good_peb_count</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_volumes_count</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vol_count</span> <span class="o">-</span> <span class="n">UBI_INT_VOL_COUNT</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_max_ec</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_ec</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_reserved_for_bad</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_bad_peb_count</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_peb_count</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_max_vol_count</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_min_io_size</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_bgt_enabled</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">thread_enabled</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev_mtd_num</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ubi_put_device</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_device</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_sysfs_init - initialize sysfs for an UBI device.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @ref: set to %1 on exit in case of failure if a reference to @ubi-&gt;dev was</span>
<span class="cm"> *       taken</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubi_sysfs_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">dev_release</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">devt</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">ubi_class</span><span class="p">;</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">UBI_NAME_STR</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_eraseblock_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_avail_eraseblocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_total_eraseblocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_volumes_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_max_ec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_reserved_for_bad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_bad_peb_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_max_vol_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_min_io_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_bgt_enabled</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_mtd_num</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_sysfs_close - close sysfs for an UBI device.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubi_sysfs_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_mtd_num</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_bgt_enabled</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_min_io_size</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_max_vol_count</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_bad_peb_count</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_reserved_for_bad</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_max_ec</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_volumes_count</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_total_eraseblocks</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_avail_eraseblocks</span><span class="p">);</span>
	<span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_eraseblock_size</span><span class="p">);</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kill_volumes - destroy all user volumes.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kill_volumes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">ubi_free_volume</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uif_init - initialize user interfaces for an UBI device.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @ref: set to %1 on exit in case of failure if a reference to @ubi-&gt;dev was</span>
<span class="cm"> *       taken, otherwise set to %0</span>
<span class="cm"> *</span>
<span class="cm"> * This function initializes various user interfaces for an UBI device. If the</span>
<span class="cm"> * initialization fails at an early stage, this function frees all the</span>
<span class="cm"> * resources it allocated, returns an error, and @ref is set to %0. However,</span>
<span class="cm"> * if the initialization fails after the UBI device was registered in the</span>
<span class="cm"> * driver core subsystem, this function takes a reference to @ubi-&gt;dev, because</span>
<span class="cm"> * otherwise the release function (&#39;dev_release()&#39;) would free whole @ubi</span>
<span class="cm"> * object. The @ref argument is set to %1 in this case. The caller has to put</span>
<span class="cm"> * this reference.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uif_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">dev</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_name</span><span class="p">,</span> <span class="n">UBI_NAME_STR</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Major numbers for the UBI character devices are allocated</span>
<span class="cm">	 * dynamically. Major numbers of volume character devices are</span>
<span class="cm">	 * equivalent to ones of the corresponding UBI character device. Minor</span>
<span class="cm">	 * numbers of UBI character devices are 0, while minor numbers of</span>
<span class="cm">	 * volume character devices start from 1. Thus, we allocate one major</span>
<span class="cm">	 * number and ubi-&gt;vtbl_slots + 1 minor numbers.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot register UBI character devices&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi_cdev_operations</span><span class="p">);</span>
	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;%s major is %u&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_name</span><span class="p">,</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot add character device&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unreg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_sysfs_init</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_sysfs</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_add_volume</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot add volume %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_volumes</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_volumes:</span>
	<span class="n">kill_volumes</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
<span class="nl">out_sysfs:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ref</span><span class="p">)</span>
		<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ubi_sysfs_close</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">);</span>
<span class="nl">out_unreg:</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot initialize UBI %s, error %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * uif_close - close user interfaces for an UBI device.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * Note, since this function un-registers UBI volume device objects (@vol-&gt;dev),</span>
<span class="cm"> * the memory allocated voe the volumes is freed as well (in the release</span>
<span class="cm"> * function).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uif_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kill_volumes</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">ubi_sysfs_close</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">);</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_free_internal_volumes - free internal volumes.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubi_free_internal_volumes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span> <span class="o">+</span> <span class="n">UBI_INT_VOL_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">eba_tbl</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * io_init - initialize I/O sub-system for a given UBI device.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * If @ubi-&gt;vid_hdr_offset or @ubi-&gt;leb_start is zero, default offsets are</span>
<span class="cm"> * assumed:</span>
<span class="cm"> *   o EC header is always at offset zero - this cannot be changed;</span>
<span class="cm"> *   o VID header starts just after the EC header at the closest address</span>
<span class="cm"> *     aligned to @io-&gt;hdrs_min_io_size;</span>
<span class="cm"> *   o data starts just after the VID header at the closest address aligned to</span>
<span class="cm"> *     @io-&gt;min_io_size</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">io_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">numeraseregions</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some flashes have several erase regions. Different regions</span>
<span class="cm">		 * may have different eraseblock size and other</span>
<span class="cm">		 * characteristics. It looks like mostly multi-region flashes</span>
<span class="cm">		 * have one &quot;main&quot; region and one or more small regions to</span>
<span class="cm">		 * store boot loader code or boot parameters or whatever. I</span>
<span class="cm">		 * guess we should just pick the largest region. But this is</span>
<span class="cm">		 * not implemented.</span>
<span class="cm">		 */</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;multiple regions, not implemented&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note, in this implementation we support MTD devices with 0x7FFFFFFF</span>
<span class="cm">	 * physical eraseblocks maximum.</span>
<span class="cm">	 */</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span>   <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span>  <span class="o">=</span> <span class="n">mtd_div_by_eb</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">flash_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtd_can_have_bb</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">))</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">MTD_NORFLASH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">nor_flash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">&gt;&gt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">subpage_sft</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure minimal I/O unit is power of 2. Note, there is no</span>
<span class="cm">	 * fundamental reason for this assumption. It is just an optimization</span>
<span class="cm">	 * which allows us to avoid costly division operations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;min. I/O unit (%d) is not power of 2&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span> <span class="o">&lt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">%</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writebufsize</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Maximum write size has to be greater or equivalent to min. I/O</span>
<span class="cm">	 * size, and be multiple of min. I/O size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">||</span>
	    <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">%</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad write buffer size %d for %d min. I/O unit&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate default aligned sizes of EC and VID headers */</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ec_hdr_alsize</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBI_EC_HDR_SIZE</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_alsize</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBI_VID_HDR_SIZE</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span><span class="p">);</span>

	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;min_io_size      %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;max_write_size   %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;hdrs_min_io_size %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;ec_hdr_alsize    %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ec_hdr_alsize</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;vid_hdr_alsize   %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_alsize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Default offset */</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span> <span class="o">=</span>
				      <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ec_hdr_alsize</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">&amp;</span>
						<span class="o">~</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">-</span>
						<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Similar for the data offset */</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">+</span> <span class="n">UBI_VID_HDR_SIZE</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>

	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;vid_hdr_offset   %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;vid_hdr_aloffset %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;vid_hdr_shift    %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;leb_start        %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">);</span>

	<span class="cm">/* The shift must be aligned to 32-bit boundary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;unaligned VID header shift %d&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check sanity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">&lt;</span> <span class="n">UBI_EC_HDR_SIZE</span> <span class="o">||</span>
	    <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">+</span> <span class="n">UBI_VID_HDR_SIZE</span> <span class="o">||</span>
	    <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span> <span class="o">&gt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">-</span> <span class="n">UBI_VID_HDR_SIZE</span> <span class="o">||</span>
	    <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad VID header (%d) or data offsets (%d)&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set maximum amount of physical erroneous eraseblocks to be 10%.</span>
<span class="cm">	 * Erroneous PEB are those which have read errors.</span>
<span class="cm">	 */</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_erroneous</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_erroneous</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_erroneous</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;max_erroneous    %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_erroneous</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It may happen that EC and VID headers are situated in one minimal</span>
<span class="cm">	 * I/O unit. In this case we can only accept this UBI image in</span>
<span class="cm">	 * read-only mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">+</span> <span class="n">UBI_VID_HDR_SIZE</span> <span class="o">&lt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;EC and VID headers are in the same minimal I/O unit, &quot;</span>
			 <span class="s">&quot;switch to read-only mode&quot;</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">-</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MTD_WRITEABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;MTD device %d is write-protected, attach in &quot;</span>
			<span class="s">&quot;read-only mode&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;physical eraseblock size:   %d bytes (%d KiB)&quot;</span><span class="p">,</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;logical eraseblock size:    %d bytes&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;smallest flash I/O unit:    %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span> <span class="o">!=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">)</span>
		<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;sub-page size:              %d&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;VID header offset:          %d (aligned %d)&quot;</span><span class="p">,</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;data offset:                %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note, ideally, we have to initialize @ubi-&gt;bad_peb_count here. But</span>
<span class="cm">	 * unfortunately, MTD does not provide this information. We should loop</span>
<span class="cm">	 * over all physical eraseblocks and invoke mtd-&gt;block_is_bad() for</span>
<span class="cm">	 * each physical eraseblock. So, we leave @ubi-&gt;bad_peb_count</span>
<span class="cm">	 * uninitialized so far.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * autoresize - re-size the volume which has the &quot;auto-resize&quot; flag set.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: ID of the volume to re-size</span>
<span class="cm"> *</span>
<span class="cm"> * This function re-sizes the volume marked by the %UBI_VTBL_AUTORESIZE_FLG in</span>
<span class="cm"> * the volume table to the largest possible size. See comments in ubi-header.h</span>
<span class="cm"> * for more description of the flag. Returns zero in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">autoresize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume</span> <span class="o">*</span><span class="n">vol</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">[</span><span class="n">vol_id</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">old_reserved_pebs</span> <span class="o">=</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the auto-resize flag in the volume in-memory copy of the</span>
<span class="cm">	 * volume table, and &#39;ubi_resize_volume()&#39; will propagate this change</span>
<span class="cm">	 * to the flash.</span>
<span class="cm">	 */</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl</span><span class="p">[</span><span class="n">vol_id</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UBI_VTBL_AUTORESIZE_FLG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_vtbl_record</span> <span class="n">vtbl_rec</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * No available PEBs to re-size the volume, clear the flag on</span>
<span class="cm">		 * flash and exit.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vtbl_rec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl</span><span class="p">[</span><span class="n">vol_id</span><span class="p">],</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_vtbl_record</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_change_vtbl_record</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vtbl_rec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot clean auto-resize flag for volume %d&quot;</span><span class="p">,</span>
				<span class="n">vol_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">desc</span><span class="p">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">vol</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_resize_volume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span>
					<span class="n">old_reserved_pebs</span> <span class="o">+</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot auto-resize volume %d&quot;</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;volume %d (</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">) re-sized from %d to %d LEBs&quot;</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span>
		<span class="n">vol</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">old_reserved_pebs</span><span class="p">,</span> <span class="n">vol</span><span class="o">-&gt;</span><span class="n">reserved_pebs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_attach_mtd_dev - attach an MTD device.</span>
<span class="cm"> * @mtd: MTD device description object</span>
<span class="cm"> * @ubi_num: number to assign to the new UBI device</span>
<span class="cm"> * @vid_hdr_offset: VID header offset</span>
<span class="cm"> *</span>
<span class="cm"> * This function attaches MTD device @mtd_dev to UBI and assign @ubi_num number</span>
<span class="cm"> * to the newly created UBI device, unless @ubi_num is %UBI_DEV_NUM_AUTO, in</span>
<span class="cm"> * which case this function finds a vacant device number and assigns it</span>
<span class="cm"> * automatically. Returns the new UBI device number in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the invocations of this function has to be serialized by the</span>
<span class="cm"> * @ubi_devices_mutex.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_attach_mtd_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vid_hdr_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we already have the same MTD device attached.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, this function assumes that UBI devices creations and deletions</span>
<span class="cm">	 * are serialized, so it does not take the &amp;ubi_devices_lock.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span> <span class="o">&amp;&amp;</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;mtd%d is already attached to ubi%d&quot;</span><span class="p">,</span>
				<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure this MTD device is not emulated on top of an UBI volume</span>
<span class="cm">	 * already. Well, generally this recursion works fine, but there are</span>
<span class="cm">	 * different problems like the UBI module takes a reference to itself</span>
<span class="cm">	 * by attaching (and thus, opening) the emulated MTD device. This</span>
<span class="cm">	 * results in inability to unload the module. And in general it makes</span>
<span class="cm">	 * no sense to attach emulated MTD devices, so we prohibit this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">MTD_UBIVOLUME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;refuse attaching mtd%d - it is already emulated on &quot;</span>
			<span class="s">&quot;top of UBI&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi_num</span> <span class="o">==</span> <span class="n">UBI_DEV_NUM_AUTO</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Search for an empty slot in the @ubi_devices array */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ubi_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ubi_num</span> <span class="o">&lt;</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">;</span> <span class="n">ubi_num</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi_devices</span><span class="p">[</span><span class="n">ubi_num</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi_num</span> <span class="o">==</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;only %d UBI devices may be created&quot;</span><span class="p">,</span>
				<span class="n">UBI_MAX_DEVICES</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi_num</span> <span class="o">&gt;=</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* Make sure ubi_num is not busy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi_devices</span><span class="p">[</span><span class="n">ubi_num</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;ubi%d already exists&quot;</span><span class="p">,</span> <span class="n">ubi_num</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ubi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">mtd</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span> <span class="o">=</span> <span class="n">ubi_num</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">=</span> <span class="n">vid_hdr_offset</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">autoresize_vol_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ckvol_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">device_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;attaching mtd%d to ubi%d&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">ubi_num</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;sizeof(struct ubi_ainf_peb) %zu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_ainf_peb</span><span class="p">));</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;sizeof(struct ubi_wl_entry) %zu&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">io_init</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_debugging_init_dev</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_attach</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;failed to attach mtd%d, error %d&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_debugging</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">autoresize_vol_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">autoresize</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">autoresize_vol_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_detach</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">uif_init</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_detach</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_debugfs_init_dev</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_uif</span><span class="p">;</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_thread</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">ubi_thread</span><span class="p">,</span> <span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_thread</span><span class="p">);</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot spawn </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, error %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span>
			<span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_debugfs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;attached mtd%d to ubi%d&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">ubi_num</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;MTD device name:            </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;MTD device size:            %llu MiB&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">flash_size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;number of good PEBs:        %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">good_peb_count</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;number of bad PEBs:         %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_peb_count</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;number of corrupted PEBs:   %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">corr_peb_count</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;max. allowed volumes:       %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl_slots</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;wear-leveling threshold:    %d&quot;</span><span class="p">,</span> <span class="n">CONFIG_MTD_UBI_WL_THRESHOLD</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;number of internal volumes: %d&quot;</span><span class="p">,</span> <span class="n">UBI_INT_VOL_COUNT</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;number of user volumes:     %d&quot;</span><span class="p">,</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vol_count</span> <span class="o">-</span> <span class="n">UBI_INT_VOL_COUNT</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;available PEBs:             %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;total number of reserved PEBs: %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">rsvd_pebs</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;number of PEBs reserved for bad PEB handling: %d&quot;</span><span class="p">,</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;max/mean erase counter: %d/%d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_ec</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mean_ec</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;image sequence number:  %d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">image_seq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The below lock makes sure we do not race with &#39;ubi_thread()&#39; which</span>
<span class="cm">	 * checks @ubi-&gt;thread_enabled. Otherwise we may fail to wake it up.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">thread_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_thread</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="n">ubi_devices</span><span class="p">[</span><span class="n">ubi_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">ubi</span><span class="p">;</span>
	<span class="n">ubi_notify_all</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">UBI_VOLUME_ADDED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ubi_num</span><span class="p">;</span>

<span class="nl">out_debugfs:</span>
	<span class="n">ubi_debugfs_exit_dev</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
<span class="nl">out_uif:</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">uif_close</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
<span class="nl">out_detach:</span>
	<span class="n">ubi_wl_close</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">ubi_free_internal_volumes</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl</span><span class="p">);</span>
<span class="nl">out_debugging:</span>
	<span class="n">ubi_debugging_exit_dev</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_detach_mtd_dev - detach an MTD device.</span>
<span class="cm"> * @ubi_num: UBI device number to detach from</span>
<span class="cm"> * @anyway: detach MTD even if device reference count is not zero</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys an UBI device number @ubi_num and detaches the</span>
<span class="cm"> * underlying MTD device. Returns zero in case of success and %-EBUSY if the</span>
<span class="cm"> * UBI device is busy and cannot be destroyed, and %-EINVAL if it does not</span>
<span class="cm"> * exist.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the invocations of this function has to be serialized by the</span>
<span class="cm"> * @ubi_devices_mutex.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_detach_mtd_dev</span><span class="p">(</span><span class="kt">int</span> <span class="n">ubi_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anyway</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi_num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ubi_num</span> <span class="o">&gt;=</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_get_device</span><span class="p">(</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ref_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anyway</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* This may only happen if there is a bug */</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;%s reference count %d, destroy anyway&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_name</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ubi_devices</span><span class="p">[</span><span class="n">ubi_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_lock</span><span class="p">);</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi_num</span> <span class="o">==</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="n">ubi_notify_all</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">UBI_VOLUME_REMOVED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;detaching mtd%d from ubi%d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">ubi_num</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before freeing anything, we have to stop the background thread to</span>
<span class="cm">	 * prevent it from doing anything on this device while we are freeing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_thread</span><span class="p">)</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_thread</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get a reference to the device in order to prevent &#39;dev_release()&#39;</span>
<span class="cm">	 * from freeing the @ubi object.</span>
<span class="cm">	 */</span>
	<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ubi_debugfs_exit_dev</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">uif_close</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">ubi_wl_close</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">ubi_free_internal_volumes</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vtbl</span><span class="p">);</span>
	<span class="n">put_mtd_device</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">ubi_debugging_exit_dev</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;mtd%d is detached from ubi%d&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">);</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * open_mtd_by_chdev - open an MTD device by its character device node path.</span>
<span class="cm"> * @mtd_dev: MTD character device node path</span>
<span class="cm"> *</span>
<span class="cm"> * This helper function opens an MTD device by its character node device path.</span>
<span class="cm"> * Returns MTD device description object in case of success and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">open_mtd_by_chdev</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mtd_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="cm">/* Probably this is an MTD character device node path */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kern_path</span><span class="p">(</span><span class="n">mtd_dev</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="cm">/* MTD device number is defined by the major / minor numbers */</span>
	<span class="n">major</span> <span class="o">=</span> <span class="n">imajor</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">major</span> <span class="o">!=</span> <span class="n">MTD_CHAR_MAJOR</span> <span class="o">||</span> <span class="o">!</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">minor</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Just do not think the &quot;/dev/mtdrX&quot; devices support is need,</span>
<span class="cm">		 * so do not support them to avoid doing extra work.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">get_mtd_device</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">minor</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * open_mtd_device - open MTD device by name, character device path, or number.</span>
<span class="cm"> * @mtd_dev: name, character device node path, or MTD device device number</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries to open and MTD device described by @mtd_dev string,</span>
<span class="cm"> * which is first treated as ASCII MTD device number, and if it is not true, it</span>
<span class="cm"> * is treated as MTD device name, and if that is also not true, it is treated</span>
<span class="cm"> * as MTD character device node path. Returns MTD device description object in</span>
<span class="cm"> * case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">open_mtd_device</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mtd_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtd_num</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>

	<span class="n">mtd_num</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">mtd_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="n">mtd_dev</span> <span class="o">==</span> <span class="n">endp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This does not look like an ASCII integer, probably this is</span>
<span class="cm">		 * MTD device name.</span>
<span class="cm">		 */</span>
		<span class="n">mtd</span> <span class="o">=</span> <span class="n">get_mtd_device_nm</span><span class="p">(</span><span class="n">mtd_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mtd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mtd</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
			<span class="cm">/* Probably this is an MTD character device node path */</span>
			<span class="n">mtd</span> <span class="o">=</span> <span class="n">open_mtd_by_chdev</span><span class="p">(</span><span class="n">mtd_dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mtd</span> <span class="o">=</span> <span class="n">get_mtd_device</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mtd_num</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mtd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ubi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

	<span class="cm">/* Ensure that EC and VID headers have correct size */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_ec_hdr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">64</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_vid_hdr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtd_devs</span> <span class="o">&gt;</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;too many MTD devices, maximum is %d&quot;</span><span class="p">,</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create base sysfs directory and sysfs files */</span>
	<span class="n">ubi_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="n">UBI_NAME_STR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ubi_class</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ubi_class</span><span class="p">);</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot create UBI class&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">class_create_file</span><span class="p">(</span><span class="n">ubi_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi_version</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot create sysfs file&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_class</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_ctrl_cdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot register device&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_version</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_wl_entry_slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;ubi_wl_entry_slab&quot;</span><span class="p">,</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">),</span>
					      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi_wl_entry_slab</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dev_unreg</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_debugfs_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_slab</span><span class="p">;</span>


	<span class="cm">/* Attach MTD devices */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mtd_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mtd_dev_param</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mtd_dev_param</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">mtd</span> <span class="o">=</span> <span class="n">open_mtd_device</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mtd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_detach</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_attach_mtd_dev</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">UBI_DEV_NUM_AUTO</span><span class="p">,</span>
					 <span class="n">p</span><span class="o">-&gt;</span><span class="n">vid_hdr_offs</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot attach mtd%d&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
			<span class="n">put_mtd_device</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Originally UBI stopped initializing on any error.</span>
<span class="cm">			 * However, later on it was found out that this</span>
<span class="cm">			 * behavior is not very good when UBI is compiled into</span>
<span class="cm">			 * the kernel and the MTD devices to attach are passed</span>
<span class="cm">			 * through the command line. Indeed, UBI failure</span>
<span class="cm">			 * stopped whole boot sequence.</span>
<span class="cm">			 *</span>
<span class="cm">			 * To fix this, we changed the behavior for the</span>
<span class="cm">			 * non-module case, but preserved the old behavior for</span>
<span class="cm">			 * the module case, just for compatibility. This is a</span>
<span class="cm">			 * little inconsistent, though.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ubi_is_module</span><span class="p">())</span>
				<span class="k">goto</span> <span class="n">out_detach</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_detach:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi_devices</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>
			<span class="n">ubi_detach_mtd_dev</span><span class="p">(</span><span class="n">ubi_devices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">ubi_debugfs_exit</span><span class="p">();</span>
<span class="nl">out_slab:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">);</span>
<span class="nl">out_dev_unreg:</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_ctrl_cdev</span><span class="p">);</span>
<span class="nl">out_version:</span>
	<span class="n">class_remove_file</span><span class="p">(</span><span class="n">ubi_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi_version</span><span class="p">);</span>
<span class="nl">out_class:</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">ubi_class</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;UBI error: cannot initialize UBI, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">ubi_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ubi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>
			<span class="n">ubi_detach_mtd_dev</span><span class="p">(</span><span class="n">ubi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_devices_mutex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">ubi_debugfs_exit</span><span class="p">();</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">);</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi_ctrl_cdev</span><span class="p">);</span>
	<span class="n">class_remove_file</span><span class="p">(</span><span class="n">ubi_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi_version</span><span class="p">);</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">ubi_class</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ubi_exit</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bytes_str_to_int - convert a number of bytes string into an integer.</span>
<span class="cm"> * @str: the string to convert</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns positive resulting integer in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">bytes_str_to_int</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="n">endp</span> <span class="o">||</span> <span class="n">result</span> <span class="o">&gt;=</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;UBI error: incorrect bytes count: </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">str</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">endp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;G&#39;</span>:
		<span class="n">result</span> <span class="o">*=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;M&#39;</span>:
		<span class="n">result</span> <span class="o">*=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;K&#39;</span>:
		<span class="n">result</span> <span class="o">*=</span> <span class="mi">1024</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;i&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">endp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span>
			<span class="n">endp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;\0&#39;</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;UBI error: incorrect bytes count: </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">str</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_mtd_param_parse - parse the &#39;mtd=&#39; UBI parameter.</span>
<span class="cm"> * @val: the parameter value to parse</span>
<span class="cm"> * @kp: not used</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ubi_mtd_param_parse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_param</span> <span class="o">*</span><span class="n">kp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_dev_param</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MTD_PARAM_LEN_MAX</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtd_devs</span> <span class="o">==</span> <span class="n">UBI_MAX_DEVICES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;UBI error: too many parameters, max. is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">UBI_MAX_DEVICES</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">MTD_PARAM_LEN_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">MTD_PARAM_LEN_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;UBI error: parameter </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> is too long, &quot;</span>
		       <span class="s">&quot;max. is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">MTD_PARAM_LEN_MAX</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;UBI warning: empty &#39;mtd=&#39; parameter - &quot;</span>
		       <span class="s">&quot;ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Get rid of the final newline */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuf</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;UBI error: too many arguments at </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mtd_dev_param</span><span class="p">[</span><span class="n">mtd_devs</span><span class="p">];</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">vid_hdr_offs</span> <span class="o">=</span> <span class="n">bytes_str_to_int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">vid_hdr_offs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vid_hdr_offs</span><span class="p">;</span>

	<span class="n">mtd_devs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_param_call</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ubi_mtd_param_parse</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mo">000</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="s">&quot;MTD devices to attach. Parameter format: &quot;</span>
		      <span class="s">&quot;mtd=&lt;name|num|path&gt;[,&lt;vid_hdr_offs&gt;].</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;Multiple </span><span class="se">\&quot;</span><span class="s">mtd</span><span class="se">\&quot;</span><span class="s"> parameters may be specified.</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;MTD devices may be specified by their number, name, or &quot;</span>
		      <span class="s">&quot;path to the MTD character device node.</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;Optional </span><span class="se">\&quot;</span><span class="s">vid_hdr_offs</span><span class="se">\&quot;</span><span class="s"> parameter specifies UBI VID &quot;</span>
		      <span class="s">&quot;header position to be used by UBI.</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;Example 1: mtd=/dev/mtd0 - attach MTD device &quot;</span>
		      <span class="s">&quot;/dev/mtd0.</span><span class="se">\n</span><span class="s">&quot;</span>
		      <span class="s">&quot;Example 2: mtd=content,1984 mtd=4 - attach MTD device &quot;</span>
		      <span class="s">&quot;with name </span><span class="se">\&quot;</span><span class="s">content</span><span class="se">\&quot;</span><span class="s"> using VID header offset 1984, and &quot;</span>
		      <span class="s">&quot;MTD device number 4 with default VID header offset.&quot;</span><span class="p">);</span>

<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">__stringify</span><span class="p">(</span><span class="n">UBI_VERSION</span><span class="p">));</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;UBI - Unsorted Block Images&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Artem Bityutskiy&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
