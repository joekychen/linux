<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › ubi › ubi-media.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ubi-media.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) International Business Machines Corp., 2006</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Thomas Gleixner</span>
<span class="cm"> *          Frank Haverkamp</span>
<span class="cm"> *          Oliver Lohmann</span>
<span class="cm"> *          Andreas Arnez</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file defines the layout of UBI headers and all the other UBI on-flash</span>
<span class="cm"> * data structures.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __UBI_MEDIA_H__</span>
<span class="cp">#define __UBI_MEDIA_H__</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cm">/* The version of UBI images supported by this implementation */</span>
<span class="cp">#define UBI_VERSION 1</span>

<span class="cm">/* The highest erase counter value supported by this implementation */</span>
<span class="cp">#define UBI_MAX_ERASECOUNTER 0x7FFFFFFF</span>

<span class="cm">/* The initial CRC32 value used when calculating CRC checksums */</span>
<span class="cp">#define UBI_CRC32_INIT 0xFFFFFFFFU</span>

<span class="cm">/* Erase counter header magic number (ASCII &quot;UBI#&quot;) */</span>
<span class="cp">#define UBI_EC_HDR_MAGIC  0x55424923</span>
<span class="cm">/* Volume identifier header magic number (ASCII &quot;UBI!&quot;) */</span>
<span class="cp">#define UBI_VID_HDR_MAGIC 0x55424921</span>

<span class="cm">/*</span>
<span class="cm"> * Volume type constants used in the volume identifier header.</span>
<span class="cm"> *</span>
<span class="cm"> * @UBI_VID_DYNAMIC: dynamic volume</span>
<span class="cm"> * @UBI_VID_STATIC: static volume</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBI_VID_DYNAMIC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">UBI_VID_STATIC</span>  <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Volume flags used in the volume table record.</span>
<span class="cm"> *</span>
<span class="cm"> * @UBI_VTBL_AUTORESIZE_FLG: auto-resize this volume</span>
<span class="cm"> *</span>
<span class="cm"> * %UBI_VTBL_AUTORESIZE_FLG flag can be set only for one volume in the volume</span>
<span class="cm"> * table. UBI automatically re-sizes the volume which has this flag and makes</span>
<span class="cm"> * the volume to be of largest possible size. This means that if after the</span>
<span class="cm"> * initialization UBI finds out that there are available physical eraseblocks</span>
<span class="cm"> * present on the device, it automatically appends all of them to the volume</span>
<span class="cm"> * (the physical eraseblocks reserved for bad eraseblocks handling and other</span>
<span class="cm"> * reserved physical eraseblocks are not taken). So, if there is a volume with</span>
<span class="cm"> * the %UBI_VTBL_AUTORESIZE_FLG flag set, the amount of available logical</span>
<span class="cm"> * eraseblocks will be zero after UBI is loaded, because all of them will be</span>
<span class="cm"> * reserved for this volume. Note, the %UBI_VTBL_AUTORESIZE_FLG bit is cleared</span>
<span class="cm"> * after the volume had been initialized.</span>
<span class="cm"> *</span>
<span class="cm"> * The auto-resize feature is useful for device production purposes. For</span>
<span class="cm"> * example, different NAND flash chips may have different amount of initial bad</span>
<span class="cm"> * eraseblocks, depending of particular chip instance. Manufacturers of NAND</span>
<span class="cm"> * chips usually guarantee that the amount of initial bad eraseblocks does not</span>
<span class="cm"> * exceed certain percent, e.g. 2%. When one creates an UBI image which will be</span>
<span class="cm"> * flashed to the end devices in production, he does not know the exact amount</span>
<span class="cm"> * of good physical eraseblocks the NAND chip on the device will have, but this</span>
<span class="cm"> * number is required to calculate the volume sized and put them to the volume</span>
<span class="cm"> * table of the UBI image. In this case, one of the volumes (e.g., the one</span>
<span class="cm"> * which will store the root file system) is marked as &quot;auto-resizable&quot;, and</span>
<span class="cm"> * UBI will adjust its size on the first boot if needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, first UBI reserves some amount of physical eraseblocks for bad</span>
<span class="cm"> * eraseblock handling, and then re-sizes the volume, not vice-versa. This</span>
<span class="cm"> * means that the pool of reserved physical eraseblocks will always be present.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBI_VTBL_AUTORESIZE_FLG</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Compatibility constants used by internal volumes.</span>
<span class="cm"> *</span>
<span class="cm"> * @UBI_COMPAT_DELETE: delete this internal volume before anything is written</span>
<span class="cm"> *                     to the flash</span>
<span class="cm"> * @UBI_COMPAT_RO: attach this device in read-only mode</span>
<span class="cm"> * @UBI_COMPAT_PRESERVE: preserve this internal volume - do not touch its</span>
<span class="cm"> *                       physical eraseblocks, don&#39;t allow the wear-leveling</span>
<span class="cm"> *                       sub-system to move them</span>
<span class="cm"> * @UBI_COMPAT_REJECT: reject this UBI image</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBI_COMPAT_DELETE</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">UBI_COMPAT_RO</span>       <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">UBI_COMPAT_PRESERVE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">UBI_COMPAT_REJECT</span>   <span class="o">=</span> <span class="mi">5</span>
<span class="p">};</span>

<span class="cm">/* Sizes of UBI headers */</span>
<span class="cp">#define UBI_EC_HDR_SIZE  sizeof(struct ubi_ec_hdr)</span>
<span class="cp">#define UBI_VID_HDR_SIZE sizeof(struct ubi_vid_hdr)</span>

<span class="cm">/* Sizes of UBI headers without the ending CRC */</span>
<span class="cp">#define UBI_EC_HDR_SIZE_CRC  (UBI_EC_HDR_SIZE  - sizeof(__be32))</span>
<span class="cp">#define UBI_VID_HDR_SIZE_CRC (UBI_VID_HDR_SIZE - sizeof(__be32))</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_ec_hdr - UBI erase counter header.</span>
<span class="cm"> * @magic: erase counter header magic number (%UBI_EC_HDR_MAGIC)</span>
<span class="cm"> * @version: version of UBI implementation which is supposed to accept this</span>
<span class="cm"> *           UBI image</span>
<span class="cm"> * @padding1: reserved for future, zeroes</span>
<span class="cm"> * @ec: the erase counter</span>
<span class="cm"> * @vid_hdr_offset: where the VID header starts</span>
<span class="cm"> * @data_offset: where the user data start</span>
<span class="cm"> * @image_seq: image sequence number</span>
<span class="cm"> * @padding2: reserved for future, zeroes</span>
<span class="cm"> * @hdr_crc: erase counter header CRC checksum</span>
<span class="cm"> *</span>
<span class="cm"> * The erase counter header takes 64 bytes and has a plenty of unused space for</span>
<span class="cm"> * future usage. The unused fields are zeroed. The @version field is used to</span>
<span class="cm"> * indicate the version of UBI implementation which is supposed to be able to</span>
<span class="cm"> * work with this UBI image. If @version is greater than the current UBI</span>
<span class="cm"> * version, the image is rejected. This may be useful in future if something</span>
<span class="cm"> * is changed radically. This field is duplicated in the volume identifier</span>
<span class="cm"> * header.</span>
<span class="cm"> *</span>
<span class="cm"> * The @vid_hdr_offset and @data_offset fields contain the offset of the the</span>
<span class="cm"> * volume identifier header and user data, relative to the beginning of the</span>
<span class="cm"> * physical eraseblock. These values have to be the same for all physical</span>
<span class="cm"> * eraseblocks.</span>
<span class="cm"> *</span>
<span class="cm"> * The @image_seq field is used to validate a UBI image that has been prepared</span>
<span class="cm"> * for a UBI device. The @image_seq value can be any value, but it must be the</span>
<span class="cm"> * same on all eraseblocks. UBI will ensure that all new erase counter headers</span>
<span class="cm"> * also contain this value, and will check the value when attaching the flash.</span>
<span class="cm"> * One way to make use of @image_seq is to increase its value by one every time</span>
<span class="cm"> * an image is flashed over an existing image, then, if the flashing does not</span>
<span class="cm"> * complete, UBI will detect the error when attaching the media.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="p">{</span>
	<span class="n">__be32</span>  <span class="n">magic</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">version</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">padding1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__be64</span>  <span class="n">ec</span><span class="p">;</span> <span class="cm">/* Warning: the current limit is 31-bit anyway! */</span>
	<span class="n">__be32</span>  <span class="n">vid_hdr_offset</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">data_offset</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">image_seq</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">padding2</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="n">__be32</span>  <span class="n">hdr_crc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_vid_hdr - on-flash UBI volume identifier header.</span>
<span class="cm"> * @magic: volume identifier header magic number (%UBI_VID_HDR_MAGIC)</span>
<span class="cm"> * @version: UBI implementation version which is supposed to accept this UBI</span>
<span class="cm"> *           image (%UBI_VERSION)</span>
<span class="cm"> * @vol_type: volume type (%UBI_VID_DYNAMIC or %UBI_VID_STATIC)</span>
<span class="cm"> * @copy_flag: if this logical eraseblock was copied from another physical</span>
<span class="cm"> *             eraseblock (for wear-leveling reasons)</span>
<span class="cm"> * @compat: compatibility of this volume (%0, %UBI_COMPAT_DELETE,</span>
<span class="cm"> *          %UBI_COMPAT_IGNORE, %UBI_COMPAT_PRESERVE, or %UBI_COMPAT_REJECT)</span>
<span class="cm"> * @vol_id: ID of this volume</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @padding1: reserved for future, zeroes</span>
<span class="cm"> * @data_size: how many bytes of data this logical eraseblock contains</span>
<span class="cm"> * @used_ebs: total number of used logical eraseblocks in this volume</span>
<span class="cm"> * @data_pad: how many bytes at the end of this physical eraseblock are not</span>
<span class="cm"> *            used</span>
<span class="cm"> * @data_crc: CRC checksum of the data stored in this logical eraseblock</span>
<span class="cm"> * @padding2: reserved for future, zeroes</span>
<span class="cm"> * @sqnum: sequence number</span>
<span class="cm"> * @padding3: reserved for future, zeroes</span>
<span class="cm"> * @hdr_crc: volume identifier header CRC checksum</span>
<span class="cm"> *</span>
<span class="cm"> * The @sqnum is the value of the global sequence counter at the time when this</span>
<span class="cm"> * VID header was created. The global sequence counter is incremented each time</span>
<span class="cm"> * UBI writes a new VID header to the flash, i.e. when it maps a logical</span>
<span class="cm"> * eraseblock to a new physical eraseblock. The global sequence counter is an</span>
<span class="cm"> * unsigned 64-bit integer and we assume it never overflows. The @sqnum</span>
<span class="cm"> * (sequence number) is used to distinguish between older and newer versions of</span>
<span class="cm"> * logical eraseblocks.</span>
<span class="cm"> *</span>
<span class="cm"> * There are 2 situations when there may be more than one physical eraseblock</span>
<span class="cm"> * corresponding to the same logical eraseblock, i.e., having the same @vol_id</span>
<span class="cm"> * and @lnum values in the volume identifier header. Suppose we have a logical</span>
<span class="cm"> * eraseblock L and it is mapped to the physical eraseblock P.</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Because UBI may erase physical eraseblocks asynchronously, the following</span>
<span class="cm"> * situation is possible: L is asynchronously erased, so P is scheduled for</span>
<span class="cm"> * erasure, then L is written to,i.e. mapped to another physical eraseblock P1,</span>
<span class="cm"> * so P1 is written to, then an unclean reboot happens. Result - there are 2</span>
<span class="cm"> * physical eraseblocks P and P1 corresponding to the same logical eraseblock</span>
<span class="cm"> * L. But P1 has greater sequence number, so UBI picks P1 when it attaches the</span>
<span class="cm"> * flash.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. From time to time UBI moves logical eraseblocks to other physical</span>
<span class="cm"> * eraseblocks for wear-leveling reasons. If, for example, UBI moves L from P</span>
<span class="cm"> * to P1, and an unclean reboot happens before P is physically erased, there</span>
<span class="cm"> * are two physical eraseblocks P and P1 corresponding to L and UBI has to</span>
<span class="cm"> * select one of them when the flash is attached. The @sqnum field says which</span>
<span class="cm"> * PEB is the original (obviously P will have lower @sqnum) and the copy. But</span>
<span class="cm"> * it is not enough to select the physical eraseblock with the higher sequence</span>
<span class="cm"> * number, because the unclean reboot could have happen in the middle of the</span>
<span class="cm"> * copying process, so the data in P is corrupted. It is also not enough to</span>
<span class="cm"> * just select the physical eraseblock with lower sequence number, because the</span>
<span class="cm"> * data there may be old (consider a case if more data was added to P1 after</span>
<span class="cm"> * the copying). Moreover, the unclean reboot may happen when the erasure of P</span>
<span class="cm"> * was just started, so it result in unstable P, which is &quot;mostly&quot; OK, but</span>
<span class="cm"> * still has unstable bits.</span>
<span class="cm"> *</span>
<span class="cm"> * UBI uses the @copy_flag field to indicate that this logical eraseblock is a</span>
<span class="cm"> * copy. UBI also calculates data CRC when the data is moved and stores it at</span>
<span class="cm"> * the @data_crc field of the copy (P1). So when UBI needs to pick one physical</span>
<span class="cm"> * eraseblock of two (P or P1), the @copy_flag of the newer one (P1) is</span>
<span class="cm"> * examined. If it is cleared, the situation* is simple and the newer one is</span>
<span class="cm"> * picked. If it is set, the data CRC of the copy (P1) is examined. If the CRC</span>
<span class="cm"> * checksum is correct, this physical eraseblock is selected (P1). Otherwise</span>
<span class="cm"> * the older one (P) is selected.</span>
<span class="cm"> *</span>
<span class="cm"> * There are 2 sorts of volumes in UBI: user volumes and internal volumes.</span>
<span class="cm"> * Internal volumes are not seen from outside and are used for various internal</span>
<span class="cm"> * UBI purposes. In this implementation there is only one internal volume - the</span>
<span class="cm"> * layout volume. Internal volumes are the main mechanism of UBI extensions.</span>
<span class="cm"> * For example, in future one may introduce a journal internal volume. Internal</span>
<span class="cm"> * volumes have their own reserved range of IDs.</span>
<span class="cm"> *</span>
<span class="cm"> * The @compat field is only used for internal volumes and contains the &quot;degree</span>
<span class="cm"> * of their compatibility&quot;. It is always zero for user volumes. This field</span>
<span class="cm"> * provides a mechanism to introduce UBI extensions and to be still compatible</span>
<span class="cm"> * with older UBI binaries. For example, if someone introduced a journal in</span>
<span class="cm"> * future, he would probably use %UBI_COMPAT_DELETE compatibility for the</span>
<span class="cm"> * journal volume.  And in this case, older UBI binaries, which know nothing</span>
<span class="cm"> * about the journal volume, would just delete this volume and work perfectly</span>
<span class="cm"> * fine. This is similar to what Ext2fs does when it is fed by an Ext3fs image</span>
<span class="cm"> * - it just ignores the Ext3fs journal.</span>
<span class="cm"> *</span>
<span class="cm"> * The @data_crc field contains the CRC checksum of the contents of the logical</span>
<span class="cm"> * eraseblock if this is a static volume. In case of dynamic volumes, it does</span>
<span class="cm"> * not contain the CRC checksum as a rule. The only exception is when the</span>
<span class="cm"> * data of the physical eraseblock was moved by the wear-leveling sub-system,</span>
<span class="cm"> * then the wear-leveling sub-system calculates the data CRC and stores it in</span>
<span class="cm"> * the @data_crc field. And of course, the @copy_flag is %in this case.</span>
<span class="cm"> *</span>
<span class="cm"> * The @data_size field is used only for static volumes because UBI has to know</span>
<span class="cm"> * how many bytes of data are stored in this eraseblock. For dynamic volumes,</span>
<span class="cm"> * this field usually contains zero. The only exception is when the data of the</span>
<span class="cm"> * physical eraseblock was moved to another physical eraseblock for</span>
<span class="cm"> * wear-leveling reasons. In this case, UBI calculates CRC checksum of the</span>
<span class="cm"> * contents and uses both @data_crc and @data_size fields. In this case, the</span>
<span class="cm"> * @data_size field contains data size.</span>
<span class="cm"> *</span>
<span class="cm"> * The @used_ebs field is used only for static volumes and indicates how many</span>
<span class="cm"> * eraseblocks the data of the volume takes. For dynamic volumes this field is</span>
<span class="cm"> * not used and always contains zero.</span>
<span class="cm"> *</span>
<span class="cm"> * The @data_pad is calculated when volumes are created using the alignment</span>
<span class="cm"> * parameter. So, effectively, the @data_pad field reduces the size of logical</span>
<span class="cm"> * eraseblocks of this volume. This is very handy when one uses block-oriented</span>
<span class="cm"> * software (say, cramfs) on top of the UBI volume.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="p">{</span>
	<span class="n">__be32</span>  <span class="n">magic</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">version</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">vol_type</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">copy_flag</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">compat</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">vol_id</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">lnum</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">padding1</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__be32</span>  <span class="n">data_size</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">used_ebs</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">data_pad</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">data_crc</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">padding2</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__be64</span>  <span class="n">sqnum</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">padding3</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="n">__be32</span>  <span class="n">hdr_crc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/* Internal UBI volumes count */</span>
<span class="cp">#define UBI_INT_VOL_COUNT 1</span>

<span class="cm">/*</span>
<span class="cm"> * Starting ID of internal volumes: 0x7fffefff.</span>
<span class="cm"> * There is reserved room for 4096 internal volumes.</span>
<span class="cm"> */</span>
<span class="cp">#define UBI_INTERNAL_VOL_START (0x7FFFFFFF - 4096)</span>

<span class="cm">/* The layout volume contains the volume table */</span>

<span class="cp">#define UBI_LAYOUT_VOLUME_ID     UBI_INTERNAL_VOL_START</span>
<span class="cp">#define UBI_LAYOUT_VOLUME_TYPE   UBI_VID_DYNAMIC</span>
<span class="cp">#define UBI_LAYOUT_VOLUME_ALIGN  1</span>
<span class="cp">#define UBI_LAYOUT_VOLUME_EBS    2</span>
<span class="cp">#define UBI_LAYOUT_VOLUME_NAME   &quot;layout volume&quot;</span>
<span class="cp">#define UBI_LAYOUT_VOLUME_COMPAT UBI_COMPAT_REJECT</span>

<span class="cm">/* The maximum number of volumes per one UBI device */</span>
<span class="cp">#define UBI_MAX_VOLUMES 128</span>

<span class="cm">/* The maximum volume name length */</span>
<span class="cp">#define UBI_VOL_NAME_MAX 127</span>

<span class="cm">/* Size of the volume table record */</span>
<span class="cp">#define UBI_VTBL_RECORD_SIZE sizeof(struct ubi_vtbl_record)</span>

<span class="cm">/* Size of the volume table record without the ending CRC */</span>
<span class="cp">#define UBI_VTBL_RECORD_SIZE_CRC (UBI_VTBL_RECORD_SIZE - sizeof(__be32))</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_vtbl_record - a record in the volume table.</span>
<span class="cm"> * @reserved_pebs: how many physical eraseblocks are reserved for this volume</span>
<span class="cm"> * @alignment: volume alignment</span>
<span class="cm"> * @data_pad: how many bytes are unused at the end of the each physical</span>
<span class="cm"> * eraseblock to satisfy the requested alignment</span>
<span class="cm"> * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)</span>
<span class="cm"> * @upd_marker: if volume update was started but not finished</span>
<span class="cm"> * @name_len: volume name length</span>
<span class="cm"> * @name: the volume name</span>
<span class="cm"> * @flags: volume flags (%UBI_VTBL_AUTORESIZE_FLG)</span>
<span class="cm"> * @padding: reserved, zeroes</span>
<span class="cm"> * @crc: a CRC32 checksum of the record</span>
<span class="cm"> *</span>
<span class="cm"> * The volume table records are stored in the volume table, which is stored in</span>
<span class="cm"> * the layout volume. The layout volume consists of 2 logical eraseblock, each</span>
<span class="cm"> * of which contains a copy of the volume table (i.e., the volume table is</span>
<span class="cm"> * duplicated). The volume table is an array of &amp;struct ubi_vtbl_record</span>
<span class="cm"> * objects indexed by the volume ID.</span>
<span class="cm"> *</span>
<span class="cm"> * If the size of the logical eraseblock is large enough to fit</span>
<span class="cm"> * %UBI_MAX_VOLUMES records, the volume table contains %UBI_MAX_VOLUMES</span>
<span class="cm"> * records. Otherwise, it contains as many records as it can fit (i.e., size of</span>
<span class="cm"> * logical eraseblock divided by sizeof(struct ubi_vtbl_record)).</span>
<span class="cm"> *</span>
<span class="cm"> * The @upd_marker flag is used to implement volume update. It is set to %1</span>
<span class="cm"> * before update and set to %0 after the update. So if the update operation was</span>
<span class="cm"> * interrupted, UBI knows that the volume is corrupted.</span>
<span class="cm"> *</span>
<span class="cm"> * The @alignment field is specified when the volume is created and cannot be</span>
<span class="cm"> * later changed. It may be useful, for example, when a block-oriented file</span>
<span class="cm"> * system works on top of UBI. The @data_pad field is calculated using the</span>
<span class="cm"> * logical eraseblock size and @alignment. The alignment must be multiple to the</span>
<span class="cm"> * minimal flash I/O unit. If @alignment is 1, all the available space of</span>
<span class="cm"> * the physical eraseblocks is used.</span>
<span class="cm"> *</span>
<span class="cm"> * Empty records contain all zeroes and the CRC checksum of those zeroes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_vtbl_record</span> <span class="p">{</span>
	<span class="n">__be32</span>  <span class="n">reserved_pebs</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">alignment</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">data_pad</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">vol_type</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">upd_marker</span><span class="p">;</span>
	<span class="n">__be16</span>  <span class="n">name_len</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">name</span><span class="p">[</span><span class="n">UBI_VOL_NAME_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">__u8</span>    <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u8</span>    <span class="n">padding</span><span class="p">[</span><span class="mi">23</span><span class="p">];</span>
	<span class="n">__be32</span>  <span class="n">crc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* !__UBI_MEDIA_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
