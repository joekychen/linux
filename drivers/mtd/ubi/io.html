<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › ubi › io.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>io.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) International Business Machines Corp., 2006</span>
<span class="cm"> * Copyright (c) Nokia Corporation, 2006, 2007</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * UBI input/output sub-system.</span>
<span class="cm"> *</span>
<span class="cm"> * This sub-system provides a uniform way to work with all kinds of the</span>
<span class="cm"> * underlying MTD devices. It also implements handy functions for reading and</span>
<span class="cm"> * writing UBI headers.</span>
<span class="cm"> *</span>
<span class="cm"> * We are trying to have a paranoid mindset and not to trust to what we read</span>
<span class="cm"> * from the flash media in order to be more secure and robust. So this</span>
<span class="cm"> * sub-system validates every single header it reads from the flash media.</span>
<span class="cm"> *</span>
<span class="cm"> * Some words about how the eraseblock headers are stored.</span>
<span class="cm"> *</span>
<span class="cm"> * The erase counter header is always stored at offset zero. By default, the</span>
<span class="cm"> * VID header is stored after the EC header at the closest aligned offset</span>
<span class="cm"> * (i.e. aligned to the minimum I/O unit size). Data starts next to the VID</span>
<span class="cm"> * header at the closest aligned offset. But this default layout may be</span>
<span class="cm"> * changed. For example, for different reasons (e.g., optimization) UBI may be</span>
<span class="cm"> * asked to put the VID header at further offset, and even at an unaligned</span>
<span class="cm"> * offset. Of course, if the offset of the VID header is unaligned, UBI adds</span>
<span class="cm"> * proper padding in front of it. Data offset may also be changed but it has to</span>
<span class="cm"> * be aligned.</span>
<span class="cm"> *</span>
<span class="cm"> * About minimal I/O units. In general, UBI assumes flash device model where</span>
<span class="cm"> * there is only one minimal I/O unit size. E.g., in case of NOR flash it is 1,</span>
<span class="cm"> * in case of NAND flash it is a NAND page, etc. This is reported by MTD in the</span>
<span class="cm"> * @ubi-&gt;mtd-&gt;writesize field. But as an exception, UBI admits of using another</span>
<span class="cm"> * (smaller) minimal I/O unit size for EC and VID headers to make it possible</span>
<span class="cm"> * to do different optimizations.</span>
<span class="cm"> *</span>
<span class="cm"> * This is extremely useful in case of NAND flashes which admit of several</span>
<span class="cm"> * write operations to one NAND page. In this case UBI can fit EC and VID</span>
<span class="cm"> * headers at one NAND page. Thus, UBI may use &quot;sub-page&quot; size as the minimal</span>
<span class="cm"> * I/O unit for the headers (the @ubi-&gt;hdrs_min_io_size field). But it still</span>
<span class="cm"> * reports NAND page size (@ubi-&gt;min_io_size) as a minimal I/O unit for the UBI</span>
<span class="cm"> * users.</span>
<span class="cm"> *</span>
<span class="cm"> * Example: some Samsung NANDs with 2KiB pages allow 4x 512-byte writes, so</span>
<span class="cm"> * although the minimal I/O unit is 2K, UBI uses 512 bytes for EC and VID</span>
<span class="cm"> * headers.</span>
<span class="cm"> *</span>
<span class="cm"> * Q: why not just to treat sub-page as a minimal I/O unit of this flash</span>
<span class="cm"> * device, e.g., make @ubi-&gt;min_io_size = 512 in the example above?</span>
<span class="cm"> *</span>
<span class="cm"> * A: because when writing a sub-page, MTD still writes a full 2K page but the</span>
<span class="cm"> * bytes which are not relevant to the sub-page are 0xFF. So, basically,</span>
<span class="cm"> * writing 4x512 sub-pages is 4 times slower than writing one 2KiB NAND page.</span>
<span class="cm"> * Thus, we prefer to use sub-pages only for EC and VID headers.</span>
<span class="cm"> *</span>
<span class="cm"> * As it was noted above, the VID header may start at a non-aligned offset.</span>
<span class="cm"> * For example, in case of a 2KiB page NAND flash with a 512 bytes sub-page,</span>
<span class="cm"> * the VID header may reside at offset 1984 which is the last 64 bytes of the</span>
<span class="cm"> * last sub-page (EC header is always at offset zero). This causes some</span>
<span class="cm"> * difficulties when reading and writing VID headers.</span>
<span class="cm"> *</span>
<span class="cm"> * Suppose we have a 64-byte buffer and we read a VID header at it. We change</span>
<span class="cm"> * the data and want to write this VID header out. As we can only write in</span>
<span class="cm"> * 512-byte chunks, we have to allocate one more buffer and copy our VID header</span>
<span class="cm"> * to offset 448 of this buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * The I/O sub-system does the following trick in order to avoid this extra</span>
<span class="cm"> * copy. It always allocates a @ubi-&gt;vid_hdr_alsize bytes buffer for the VID</span>
<span class="cm"> * header and returns a pointer to offset @ubi-&gt;vid_hdr_shift of this buffer.</span>
<span class="cm"> * When the VID header is being written out, it shifts the VID header pointer</span>
<span class="cm"> * back and writes the whole sub-page.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;ubi.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_not_bad</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_peb_ec_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_ec_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_peb_vid_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_vid_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_read - read data from a physical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @buf: buffer where to store the read data</span>
<span class="cm"> * @pnum: physical eraseblock number to read from</span>
<span class="cm"> * @offset: offset within the physical eraseblock from where to read</span>
<span class="cm"> * @len: how many bytes to read</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads data from offset @offset of physical eraseblock @pnum</span>
<span class="cm"> * and stores the read data in the @buf buffer. The following return codes are</span>
<span class="cm"> * possible:</span>
<span class="cm"> *</span>
<span class="cm"> * o %0 if all the requested data were successfully read;</span>
<span class="cm"> * o %UBI_IO_BITFLIPS if all the requested data were successfully read, but</span>
<span class="cm"> *   correctable bit-flips were detected; this is harmless but may indicate</span>
<span class="cm"> *   that this eraseblock may become bad soon (but do not have to);</span>
<span class="cm"> * o %-EBADMSG if the MTD subsystem reported about data integrity problems, for</span>
<span class="cm"> *   example it can be an ECC error in case of NAND; this most probably means</span>
<span class="cm"> *   that the data is corrupted;</span>
<span class="cm"> * o %-EIO if some I/O error occurred;</span>
<span class="cm"> * o other negative error codes in case of other errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">read</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;read %d bytes from PEB %d:%d&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_not_bad</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Deliberately corrupt the buffer to improve robustness. Indeed, if we</span>
<span class="cm">	 * do not do this, the following may happen:</span>
<span class="cm">	 * 1. The buffer contains data from previous operation, e.g., read from</span>
<span class="cm">	 *    another PEB previously. The data looks like expected, e.g., if we</span>
<span class="cm">	 *    just do not read anything and return - the caller would not</span>
<span class="cm">	 *    notice this. E.g., if we are reading a VID header, the buffer may</span>
<span class="cm">	 *    contain a valid VID header from another PEB.</span>
<span class="cm">	 * 2. The driver is buggy and returns us success or -EBADMSG or</span>
<span class="cm">	 *    -EUCLEAN, but it does not actually put any data to the buffer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This may confuse UBI or upper layers - they may think the buffer</span>
<span class="cm">	 * contains valid data while in fact it is just old data. This is</span>
<span class="cm">	 * especially possible because UBI (and UBIFS) relies on CRC, and</span>
<span class="cm">	 * treats data as correct even in case of ECC errors if the CRC is</span>
<span class="cm">	 * correct.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Try to prevent this situation by changing the first byte of the</span>
<span class="cm">	 * buffer.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)</span> <span class="o">^=</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pnum</span> <span class="o">*</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errstr</span> <span class="o">=</span> <span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; (ECC error)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mtd_is_bitflip</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * -EUCLEAN is reported if there was a bit-flip which</span>
<span class="cm">			 * was corrected, so this is harmless.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We do not report about it here unless debugging is</span>
<span class="cm">			 * enabled. A corresponding message will be printed</span>
<span class="cm">			 * later, when it is has been scrubbed.</span>
<span class="cm">			 */</span>
			<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;fixable bit-flip detected at PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="n">ubi_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">read</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">UBI_IO_RETRIES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;error %d%s while reading %d bytes from PEB &quot;</span>
				 <span class="s">&quot;%d:%d, read only %zd bytes, retry&quot;</span><span class="p">,</span>
				 <span class="n">err</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">read</span><span class="p">);</span>
			<span class="n">yield</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;error %d%s while reading %d bytes from PEB %d:%d, &quot;</span>
			<span class="s">&quot;read %zd bytes&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">read</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * The driver should never return -EBADMSG if it failed to read</span>
<span class="cm">		 * all the requested data. But some buggy drivers might do</span>
<span class="cm">		 * this, so we change it to -EIO.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">!=</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ubi_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">read</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ubi_dbg_is_bitflip</span><span class="p">(</span><span class="n">ubi</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;bit-flip (emulated)&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_write - write data to a physical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @buf: buffer with the data to write</span>
<span class="cm"> * @pnum: physical eraseblock number to write to</span>
<span class="cm"> * @offset: offset within the physical eraseblock where to write</span>
<span class="cm"> * @len: how many bytes to write</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes @len bytes of data from buffer @buf to offset @offset</span>
<span class="cm"> * of physical eraseblock @pnum. If all the data were successfully written,</span>
<span class="cm"> * zero is returned. If an error occurred, this function returns a negative</span>
<span class="cm"> * error code. If %-EIO is returned, the physical eraseblock most probably went</span>
<span class="cm"> * bad.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, in case of an error, it is possible that something was still written</span>
<span class="cm"> * to the flash media, but may be some garbage.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;write %d bytes to PEB %d:%d&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">%</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">%</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">hdrs_min_io_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;read-only mode&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_not_bad</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* The area we are writing to has to contain all 0xFF bytes */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_self_check_all_ff</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We write to the data area of the physical eraseblock. Make</span>
<span class="cm">		 * sure it has valid EC and VID headers.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_peb_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_peb_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi_dbg_is_write_failure</span><span class="p">(</span><span class="n">ubi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot write %d bytes to PEB %d:%d &quot;</span>
			<span class="s">&quot;(emulated)&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pnum</span> <span class="o">*</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_write</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">written</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;error %d while writing %d bytes to PEB %d:%d, written &quot;</span>
			<span class="s">&quot;%zd bytes&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">written</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">ubi_dump_flash</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">written</span> <span class="o">==</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_write</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since we always write sequentially, the rest of the PEB has</span>
<span class="cm">		 * to contain only 0xFF bytes.</span>
<span class="cm">		 */</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_self_check_all_ff</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * erase_callback - MTD erasure call-back.</span>
<span class="cm"> * @ei: MTD erase information object.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, even though MTD erase interface is asynchronous, all the current</span>
<span class="cm"> * implementations are synchronous anyway.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">erase_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_up_interruptible</span><span class="p">((</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_sync_erase - synchronously erase a physical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to erase</span>
<span class="cm"> *</span>
<span class="cm"> * This function synchronously erases physical eraseblock @pnum and returns</span>
<span class="cm"> * zero in case of success and a negative error code in case of failure. If</span>
<span class="cm"> * %-EIO is returned, the physical eraseblock most probably went bad.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_sync_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">erase_info</span> <span class="n">ei</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;erase PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;read-only mode&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">retry:</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">erase_info</span><span class="p">));</span>

	<span class="n">ei</span><span class="p">.</span><span class="n">mtd</span>      <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>
	<span class="n">ei</span><span class="p">.</span><span class="n">addr</span>     <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pnum</span> <span class="o">*</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">;</span>
	<span class="n">ei</span><span class="p">.</span><span class="n">len</span>      <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">;</span>
	<span class="n">ei</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">erase_callback</span><span class="p">;</span>
	<span class="n">ei</span><span class="p">.</span><span class="n">priv</span>     <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_erase</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ei</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">UBI_IO_RETRIES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;error %d while erasing PEB %d, retry&quot;</span><span class="p">,</span>
				 <span class="n">err</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="n">yield</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot erase PEB %d, error %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">ei</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">MTD_ERASE_DONE</span> <span class="o">||</span>
					   <span class="n">ei</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">MTD_ERASE_FAILED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;interrupted PEB %d erasure&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">MTD_ERASE_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">UBI_IO_RETRIES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;error while erasing PEB %d, retry&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="n">yield</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot erase PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_self_check_all_ff</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi_dbg_is_erase_failure</span><span class="p">(</span><span class="n">ubi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot erase PEB %d (emulated)&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Patterns to write to a physical eraseblock when torturing it */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">patterns</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0xa5</span><span class="p">,</span> <span class="mh">0x5a</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * torture_peb - test a supposedly bad physical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to test</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %-EIO if the physical eraseblock did not pass the</span>
<span class="cm"> * test, a positive number of erase operations done if the test was</span>
<span class="cm"> * successfully passed, and other negative error codes in case of other errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">torture_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">patt_count</span><span class="p">;</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;run torture test for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">patt_count</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">patterns</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">patt_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">patt_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">do_sync_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Make sure the PEB contains only 0xFF bytes */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_check_pattern</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;erased PEB %d, but a non-0xFF byte found&quot;</span><span class="p">,</span>
				<span class="n">pnum</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Write a pattern and check it */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">patterns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="o">~</span><span class="n">patterns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_check_pattern</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_buf</span><span class="p">,</span> <span class="n">patterns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;pattern %x checking failed for PEB %d&quot;</span><span class="p">,</span>
				<span class="n">patterns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">patt_count</span><span class="p">;</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;PEB %d passed torture test, do not mark it as bad&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">buf_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_BITFLIPS</span> <span class="o">||</span> <span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If a bit-flip or data integrity error was detected, the test</span>
<span class="cm">		 * has not passed because it happened on a freshly erased</span>
<span class="cm">		 * physical eraseblock which means something is wrong with it.</span>
<span class="cm">		 */</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;read problems on freshly erased PEB %d, must be bad&quot;</span><span class="p">,</span>
			<span class="n">pnum</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nor_erase_prepare - prepare a NOR flash PEB for erasure.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: physical eraseblock number to prepare</span>
<span class="cm"> *</span>
<span class="cm"> * NOR flash, or at least some of them, have peculiar embedded PEB erasure</span>
<span class="cm"> * algorithm: the PEB is first filled with zeroes, then it is erased. And</span>
<span class="cm"> * filling with zeroes starts from the end of the PEB. This was observed with</span>
<span class="cm"> * Spansion S29GL512N NOR flash.</span>
<span class="cm"> *</span>
<span class="cm"> * This means that in case of a power cut we may end up with intact data at the</span>
<span class="cm"> * beginning of the PEB, and all zeroes at the end of PEB. In other words, the</span>
<span class="cm"> * EC and VID headers are OK, but a large chunk of data at the end of PEB is</span>
<span class="cm"> * zeroed. This makes UBI mistakenly treat this PEB as used and associate it</span>
<span class="cm"> * with an LEB, which leads to subsequent failures (e.g., UBIFS fails).</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called before erasing NOR PEBs and it zeroes out EC and VID</span>
<span class="cm"> * magic numbers in order to invalidate them and prevent the failures. Returns</span>
<span class="cm"> * zero in case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nor_erase_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">err1</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note, we cannot generally define VID header buffers on stack,</span>
<span class="cm">	 * because of the way we deal with these buffers (see the header</span>
<span class="cm">	 * comment in this file). But we know this is a NOR-specific piece of</span>
<span class="cm">	 * code, so we can do this. But yes, this is error-prone and we should</span>
<span class="cm">	 * (pre-)allocate VID header buffer instead.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="n">vid_hdr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is important to first invalidate the EC header, and then the VID</span>
<span class="cm">	 * header. Otherwise a power cut may lead to valid EC header and</span>
<span class="cm">	 * invalid VID header, in which case UBI will treat this PEB as</span>
<span class="cm">	 * corrupted and will try to preserve it, and print scary warnings.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pnum</span> <span class="o">*</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_write</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">written</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_write</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">written</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We failed to write to the media. This was observed with Spansion</span>
<span class="cm">	 * S29GL512N NOR flash. Most probably the previously eraseblock erasure</span>
<span class="cm">	 * was interrupted at a very inappropriate moment, so it became</span>
<span class="cm">	 * unwritable. In this case we probably anyway have garbage in this</span>
<span class="cm">	 * PEB.</span>
<span class="cm">	 */</span>
	<span class="n">err1</span> <span class="o">=</span> <span class="n">ubi_io_read_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vid_hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err1</span> <span class="o">==</span> <span class="n">UBI_IO_BAD_HDR_EBADMSG</span> <span class="o">||</span> <span class="n">err1</span> <span class="o">==</span> <span class="n">UBI_IO_BAD_HDR</span> <span class="o">||</span>
	    <span class="n">err1</span> <span class="o">==</span> <span class="n">UBI_IO_FF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="n">ec_hdr</span><span class="p">;</span>

		<span class="n">err1</span> <span class="o">=</span> <span class="n">ubi_io_read_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ec_hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err1</span> <span class="o">==</span> <span class="n">UBI_IO_BAD_HDR_EBADMSG</span> <span class="o">||</span> <span class="n">err1</span> <span class="o">==</span> <span class="n">UBI_IO_BAD_HDR</span> <span class="o">||</span>
		    <span class="n">err1</span> <span class="o">==</span> <span class="n">UBI_IO_FF</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * Both VID and EC headers are corrupted, so we can</span>
<span class="cm">			 * safely erase this PEB and not afraid that it will be</span>
<span class="cm">			 * treated as a valid PEB in case of an unclean reboot.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The PEB contains a valid VID header, but we cannot invalidate it.</span>
<span class="cm">	 * Supposedly the flash media or the driver is screwed up, so return an</span>
<span class="cm">	 * error.</span>
<span class="cm">	 */</span>
	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot invalidate PEB %d, write returned %d read returned %d&quot;</span><span class="p">,</span>
		<span class="n">pnum</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">err1</span><span class="p">);</span>
	<span class="n">ubi_dump_flash</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_sync_erase - synchronously erase a physical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: physical eraseblock number to erase</span>
<span class="cm"> * @torture: if this physical eraseblock has to be tortured</span>
<span class="cm"> *</span>
<span class="cm"> * This function synchronously erases physical eraseblock @pnum. If @torture</span>
<span class="cm"> * flag is not zero, the physical eraseblock is checked by means of writing</span>
<span class="cm"> * different patterns to it and reading them back. If the torturing is enabled,</span>
<span class="cm"> * the physical eraseblock is erased more than once.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of erasures made in case of success, %-EIO</span>
<span class="cm"> * if the erasure failed or the torturing test failed, and other negative error</span>
<span class="cm"> * codes in case of other errors. Note, %-EIO means that the physical</span>
<span class="cm"> * eraseblock is bad.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_sync_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">torture</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_not_bad</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;read-only mode&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">nor_flash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nor_erase_prepare</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">torture</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">torture_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_sync_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_is_bad - check if a physical eraseblock is bad.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a positive number if the physical eraseblock is bad,</span>
<span class="cm"> * zero if not, and a negative error code if an error occurred.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_is_bad</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_block_isbad</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pnum</span> <span class="o">*</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;error %d while checking if PEB %d is bad&quot;</span><span class="p">,</span>
				<span class="n">ret</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;PEB %d is bad&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_mark_bad - mark a physical eraseblock as bad.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to mark</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_mark_bad</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>

	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;read-only mode&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_block_markbad</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pnum</span> <span class="o">*</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot mark PEB %d bad, error %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * validate_ec_hdr - validate an erase counter header.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @ec_hdr: the erase counter header to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the erase counter header is OK, and %1 if</span>
<span class="cm"> * not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_ec_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">ec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vid_hdr_offset</span><span class="p">,</span> <span class="n">leb_start</span><span class="p">;</span>

	<span class="n">ec</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
	<span class="n">vid_hdr_offset</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span><span class="p">);</span>
	<span class="n">leb_start</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">data_offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="n">UBI_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;node with incompatible UBI version found: &quot;</span>
			<span class="s">&quot;this UBI version is %d, image version is %d&quot;</span><span class="p">,</span>
			<span class="n">UBI_VERSION</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vid_hdr_offset</span> <span class="o">!=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad VID header offset %d, expected %d&quot;</span><span class="p">,</span>
			<span class="n">vid_hdr_offset</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">leb_start</span> <span class="o">!=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad data offset %d, expected %d&quot;</span><span class="p">,</span>
			<span class="n">leb_start</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ec</span> <span class="o">&gt;</span> <span class="n">UBI_MAX_ERASECOUNTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad erase counter %lld&quot;</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad EC header&quot;</span><span class="p">);</span>
	<span class="n">ubi_dump_ec_hdr</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_read_ec_hdr - read and check an erase counter header.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: physical eraseblock to read from</span>
<span class="cm"> * @ec_hdr: a &amp;struct ubi_ec_hdr object where to store the read erase counter</span>
<span class="cm"> * header</span>
<span class="cm"> * @verbose: be verbose if the header is corrupted or was not found</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads erase counter header from physical eraseblock @pnum and</span>
<span class="cm"> * stores it in @ec_hdr. This function also checks CRC checksum of the read</span>
<span class="cm"> * erase counter header. The following codes may be returned:</span>
<span class="cm"> *</span>
<span class="cm"> * o %0 if the CRC checksum is correct and the header was successfully read;</span>
<span class="cm"> * o %UBI_IO_BITFLIPS if the CRC is correct, but bit-flips were detected</span>
<span class="cm"> *   and corrected by the flash driver; this is harmless but may indicate that</span>
<span class="cm"> *   this eraseblock may become bad soon (but may be not);</span>
<span class="cm"> * o %UBI_IO_BAD_HDR if the erase counter header is corrupted (a CRC error);</span>
<span class="cm"> * o %UBI_IO_BAD_HDR_EBADMSG is the same as %UBI_IO_BAD_HDR, but there also was</span>
<span class="cm"> *   a data integrity error (uncorrectable ECC error in case of NAND);</span>
<span class="cm"> * o %UBI_IO_FF if only 0xFF bytes were read (the PEB is supposedly empty)</span>
<span class="cm"> * o a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_read_ec_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">read_err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;read EC header from PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

	<span class="n">read_err</span> <span class="o">=</span> <span class="n">ubi_io_read</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UBI_EC_HDR_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">read_err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">read_err</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We read all the data, but either a correctable bit-flip</span>
<span class="cm">		 * occurred, or MTD reported a data integrity error</span>
<span class="cm">		 * (uncorrectable ECC error in case of NAND). The former is</span>
<span class="cm">		 * harmless, the later may mean that the read data is</span>
<span class="cm">		 * corrupted. But we have a CRC check-sum and we will detect</span>
<span class="cm">		 * this. If the EC header is still OK, we just report this as</span>
<span class="cm">		 * there was a bit-flip, to force scrubbing.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">magic</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">UBI_EC_HDR_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">read_err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">UBI_IO_BAD_HDR_EBADMSG</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The magic field is wrong. Let&#39;s check if we have read all</span>
<span class="cm">		 * 0xFF. If yes, this physical eraseblock is assumed to be</span>
<span class="cm">		 * empty.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi_check_pattern</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">UBI_EC_HDR_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* The physical eraseblock is supposedly empty */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
				<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;no EC header found at PEB %d, &quot;</span>
					 <span class="s">&quot;only 0xFF bytes&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="n">dbg_bld</span><span class="p">(</span><span class="s">&quot;no EC header found at PEB %d, &quot;</span>
				<span class="s">&quot;only 0xFF bytes&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">UBI_IO_FF</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">UBI_IO_FF_BITFLIPS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * This is not a valid erase counter header, and these are not</span>
<span class="cm">		 * 0xFF bytes. Report that the header is corrupted.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;bad magic number at PEB %d: %08x instead of &quot;</span>
				 <span class="s">&quot;%08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">UBI_EC_HDR_MAGIC</span><span class="p">);</span>
			<span class="n">ubi_dump_ec_hdr</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dbg_bld</span><span class="p">(</span><span class="s">&quot;bad magic number at PEB %d: %08x instead of &quot;</span>
			<span class="s">&quot;%08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">UBI_EC_HDR_MAGIC</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">UBI_IO_BAD_HDR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">,</span> <span class="n">UBI_EC_HDR_SIZE_CRC</span><span class="p">);</span>
	<span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">hdr_crc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr_crc</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;bad EC header CRC at PEB %d, calculated &quot;</span>
				 <span class="s">&quot;%#08x, read %#08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">);</span>
			<span class="n">ubi_dump_ec_hdr</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dbg_bld</span><span class="p">(</span><span class="s">&quot;bad EC header CRC at PEB %d, calculated &quot;</span>
			<span class="s">&quot;%#08x, read %#08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">UBI_IO_BAD_HDR</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">UBI_IO_BAD_HDR_EBADMSG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* And of course validate what has just been read from the media */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">validate_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;validation failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there was %-EBADMSG, but the header CRC is still OK, report about</span>
<span class="cm">	 * a bit-flip to force scrubbing on this PEB.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">read_err</span> <span class="o">?</span> <span class="n">UBI_IO_BITFLIPS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_write_ec_hdr - write an erase counter header.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: physical eraseblock to write to</span>
<span class="cm"> * @ec_hdr: the erase counter header to write</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes erase counter header described by @ec_hdr to physical</span>
<span class="cm"> * eraseblock @pnum. It also fills most fields of @ec_hdr before writing, so</span>
<span class="cm"> * the caller do not have to fill them. Callers must only fill the @ec_hdr-&gt;ec</span>
<span class="cm"> * field.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure. If %-EIO is returned, the physical eraseblock most probably</span>
<span class="cm"> * went bad.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_write_ec_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;write EC header to PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>  <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

	<span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">UBI_EC_HDR_MAGIC</span><span class="p">);</span>
	<span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">UBI_VERSION</span><span class="p">;</span>
	<span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_offset</span><span class="p">);</span>
	<span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">data_offset</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_start</span><span class="p">);</span>
	<span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">image_seq</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">image_seq</span><span class="p">);</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">,</span> <span class="n">UBI_EC_HDR_SIZE_CRC</span><span class="p">);</span>
	<span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ec_hdr_alsize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * validate_vid_hdr - validate a volume identifier header.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vid_hdr: the volume identifier header to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks that data stored in the volume identifier header</span>
<span class="cm"> * @vid_hdr. Returns zero if the VID header is OK and %1 if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_vid_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">vol_type</span> <span class="o">=</span> <span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copy_flag</span> <span class="o">=</span> <span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">copy_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">compat</span> <span class="o">=</span> <span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">compat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_size</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">used_ebs</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">used_ebs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">data_pad</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_pad</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">data_crc</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">data_crc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">usable_leb_size</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">data_pad</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_flag</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">copy_flag</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad copy_flag&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">data_size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">used_ebs</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">data_pad</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;negative values&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="n">UBI_MAX_VOLUMES</span> <span class="o">&amp;&amp;</span> <span class="n">vol_id</span> <span class="o">&lt;</span> <span class="n">UBI_INTERNAL_VOL_START</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad vol_id&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&lt;</span> <span class="n">UBI_INTERNAL_VOL_START</span> <span class="o">&amp;&amp;</span> <span class="n">compat</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad compat&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">&gt;=</span> <span class="n">UBI_INTERNAL_VOL_START</span> <span class="o">&amp;&amp;</span> <span class="n">compat</span> <span class="o">!=</span> <span class="n">UBI_COMPAT_DELETE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">compat</span> <span class="o">!=</span> <span class="n">UBI_COMPAT_RO</span> <span class="o">&amp;&amp;</span> <span class="n">compat</span> <span class="o">!=</span> <span class="n">UBI_COMPAT_PRESERVE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">compat</span> <span class="o">!=</span> <span class="n">UBI_COMPAT_REJECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad compat&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_type</span> <span class="o">!=</span> <span class="n">UBI_VID_DYNAMIC</span> <span class="o">&amp;&amp;</span> <span class="n">vol_type</span> <span class="o">!=</span> <span class="n">UBI_VID_STATIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad vol_type&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_pad</span> <span class="o">&gt;=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad data_pad&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_VID_STATIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Although from high-level point of view static volumes may</span>
<span class="cm">		 * contain zero bytes of data, but no VID headers can contain</span>
<span class="cm">		 * zero at these fields, because they empty volumes do not have</span>
<span class="cm">		 * mapped logical eraseblocks.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">used_ebs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;zero used_ebs&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;zero data_size&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">used_ebs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">!=</span> <span class="n">usable_leb_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad data_size&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">used_ebs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad data_size at last LEB&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;too high lnum&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_crc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;non-zero data CRC&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;non-zero data_size&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;zero data_size of copy&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">used_ebs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad used_ebs&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad VID header&quot;</span><span class="p">);</span>
	<span class="n">ubi_dump_vid_hdr</span><span class="p">(</span><span class="n">vid_hdr</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_read_vid_hdr - read and check a volume identifier header.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: physical eraseblock number to read from</span>
<span class="cm"> * @vid_hdr: &amp;struct ubi_vid_hdr object where to store the read volume</span>
<span class="cm"> * identifier header</span>
<span class="cm"> * @verbose: be verbose if the header is corrupted or wasn&#39;t found</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads the volume identifier header from physical eraseblock</span>
<span class="cm"> * @pnum and stores it in @vid_hdr. It also checks CRC checksum of the read</span>
<span class="cm"> * volume identifier header. The error codes are the same as in</span>
<span class="cm"> * &#39;ubi_io_read_ec_hdr()&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the implementation of this function is also very similar to</span>
<span class="cm"> * &#39;ubi_io_read_ec_hdr()&#39;, so refer commentaries in &#39;ubi_io_read_ec_hdr()&#39;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_read_vid_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">read_err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;read VID header from PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>  <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">vid_hdr</span> <span class="o">-</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span><span class="p">;</span>
	<span class="n">read_err</span> <span class="o">=</span> <span class="n">ubi_io_read</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">,</span>
			  <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_alsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_err</span> <span class="o">&amp;&amp;</span> <span class="n">read_err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">read_err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">read_err</span><span class="p">;</span>

	<span class="n">magic</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">UBI_VID_HDR_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">read_err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">UBI_IO_BAD_HDR_EBADMSG</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ubi_check_pattern</span><span class="p">(</span><span class="n">vid_hdr</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">UBI_VID_HDR_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
				<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;no VID header found at PEB %d, &quot;</span>
					 <span class="s">&quot;only 0xFF bytes&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="n">dbg_bld</span><span class="p">(</span><span class="s">&quot;no VID header found at PEB %d, &quot;</span>
				<span class="s">&quot;only 0xFF bytes&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">UBI_IO_FF</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">UBI_IO_FF_BITFLIPS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;bad magic number at PEB %d: %08x instead of &quot;</span>
				 <span class="s">&quot;%08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">UBI_VID_HDR_MAGIC</span><span class="p">);</span>
			<span class="n">ubi_dump_vid_hdr</span><span class="p">(</span><span class="n">vid_hdr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dbg_bld</span><span class="p">(</span><span class="s">&quot;bad magic number at PEB %d: %08x instead of &quot;</span>
			<span class="s">&quot;%08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">magic</span><span class="p">,</span> <span class="n">UBI_VID_HDR_MAGIC</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">UBI_IO_BAD_HDR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">,</span> <span class="n">UBI_VID_HDR_SIZE_CRC</span><span class="p">);</span>
	<span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">hdr_crc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr_crc</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;bad CRC at PEB %d, calculated %#08x, &quot;</span>
				 <span class="s">&quot;read %#08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">);</span>
			<span class="n">ubi_dump_vid_hdr</span><span class="p">(</span><span class="n">vid_hdr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dbg_bld</span><span class="p">(</span><span class="s">&quot;bad CRC at PEB %d, calculated %#08x, &quot;</span>
			<span class="s">&quot;read %#08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">UBI_IO_BAD_HDR</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">UBI_IO_BAD_HDR_EBADMSG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">validate_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;validation failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">read_err</span> <span class="o">?</span> <span class="n">UBI_IO_BITFLIPS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_io_write_vid_hdr - write a volume identifier header.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to write to</span>
<span class="cm"> * @vid_hdr: the volume identifier header to write</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes the volume identifier header described by @vid_hdr to</span>
<span class="cm"> * physical eraseblock @pnum. This function automatically fills the</span>
<span class="cm"> * @vid_hdr-&gt;magic and the @vid_hdr-&gt;version fields, as well as calculates</span>
<span class="cm"> * header CRC checksum and stores it at vid_hdr-&gt;hdr_crc.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure. If %-EIO is returned, the physical eraseblock probably went</span>
<span class="cm"> * bad.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_io_write_vid_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;write VID header to PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>  <span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_peb_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">UBI_VID_HDR_MAGIC</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">UBI_VERSION</span><span class="p">;</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">,</span> <span class="n">UBI_VID_HDR_SIZE_CRC</span><span class="p">);</span>
	<span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">vid_hdr</span> <span class="o">-</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">,</span>
			   <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_alsize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_not_bad - ensure that a physical eraseblock is not bad.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: physical eraseblock number to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the physical eraseblock is good, %-EINVAL if</span>
<span class="cm"> * it is bad and a negative error code if an error occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_not_bad</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_is_bad</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_ec_hdr - check if an erase counter header is all right.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: physical eraseblock number the erase counter header belongs to</span>
<span class="cm"> * @ec_hdr: the erase counter header to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the erase counter header contains valid</span>
<span class="cm"> * values, and %-EINVAL if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_ec_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">magic</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">magic</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">UBI_EC_HDR_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad magic %#08x, must be %#08x&quot;</span><span class="p">,</span>
			<span class="n">magic</span><span class="p">,</span> <span class="n">UBI_EC_HDR_MAGIC</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">validate_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">ubi_dump_ec_hdr</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_peb_ec_hdr - check erase counter header.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the erase counter header is all right and and</span>
<span class="cm"> * a negative error code if not or if an error occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_peb_ec_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ec_hdr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ec_hdr_alsize</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UBI_EC_HDR_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">,</span> <span class="n">UBI_EC_HDR_SIZE_CRC</span><span class="p">);</span>
	<span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">hdr_crc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr_crc</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad CRC, calculated %#08x, read %#08x&quot;</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">);</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="n">ubi_dump_ec_hdr</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_vid_hdr - check that a volume identifier header is all right.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: physical eraseblock number the volume identifier header belongs to</span>
<span class="cm"> * @vid_hdr: the volume identifier header to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the volume identifier header is all right, and</span>
<span class="cm"> * %-EINVAL if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_vid_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">magic</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">magic</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">UBI_VID_HDR_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad VID header magic %#08x at PEB %d, must be %#08x&quot;</span><span class="p">,</span>
			<span class="n">magic</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">UBI_VID_HDR_MAGIC</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">validate_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_dump_vid_hdr</span><span class="p">(</span><span class="n">vid_hdr</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_peb_vid_hdr - check volume identifier header.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the volume identifier header is all right,</span>
<span class="cm"> * and a negative error code if not or if an error occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_peb_vid_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vid_hdr</span> <span class="o">=</span> <span class="n">ubi_zalloc_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vid_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">vid_hdr</span> <span class="o">-</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_shift</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">,</span>
			  <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_alsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBI_CRC32_INIT</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">,</span> <span class="n">UBI_EC_HDR_SIZE_CRC</span><span class="p">);</span>
	<span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">hdr_crc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr_crc</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad VID header CRC at PEB %d, calculated %#08x, &quot;</span>
			<span class="s">&quot;read %#08x&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">hdr_crc</span><span class="p">);</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="n">ubi_dump_vid_hdr</span><span class="p">(</span><span class="n">vid_hdr</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_write - make sure write succeeded.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @buf: buffer with data which were written</span>
<span class="cm"> * @pnum: physical eraseblock number the data were written to</span>
<span class="cm"> * @offset: offset within the physical eraseblock the data were written to</span>
<span class="cm"> * @len: how many bytes were written</span>
<span class="cm"> *</span>
<span class="cm"> * This functions reads data which were recently written and compares it with</span>
<span class="cm"> * the original data buffer - the data have to match. Returns zero if the data</span>
<span class="cm"> * match and a negative error code if not or in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">read</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf1</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pnum</span> <span class="o">*</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buf1</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot allocate memory to check writes&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read</span><span class="p">,</span> <span class="n">buf1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mtd_is_bitflip</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint8_t</span> <span class="n">c</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">uint8_t</span> <span class="n">c1</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf1</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">dump_len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">c1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d:%d, len %d&quot;</span><span class="p">,</span>
			<span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;data differ at position %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">dump_len</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;hex dump of the original buffer from %d to %d&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dump_len</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="n">buf</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">dump_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;hex dump of the read buffer from %d to %d&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dump_len</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="n">buf1</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">dump_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_self_check_all_ff - check that a region of flash is empty.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to check</span>
<span class="cm"> * @offset: the starting offset within the physical eraseblock to check</span>
<span class="cm"> * @len: the length of the region to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if only 0xFF bytes are present at offset</span>
<span class="cm"> * @offset of the physical eraseblock @pnum, and a negative error code if not</span>
<span class="cm"> * or if an error occurred.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_self_check_all_ff</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">read</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">pnum</span> <span class="o">*</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;cannot allocate memory to check for 0xFFs&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mtd_is_bitflip</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;error %d while reading %d bytes from PEB %d:%d, &quot;</span>
			<span class="s">&quot;read %zd bytes&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">read</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_check_pattern</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;flash region at PEB %d:%d, length %d does not &quot;</span>
			<span class="s">&quot;contain all 0xFF bytes&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;hex dump of the %d-%d region&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
