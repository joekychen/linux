<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › ubi › wl.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>wl.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * Copyright (c) International Business Machines Corp., 2006</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See</span>
<span class="cm"> * the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём), Thomas Gleixner</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * UBI wear-leveling sub-system.</span>
<span class="cm"> *</span>
<span class="cm"> * This sub-system is responsible for wear-leveling. It works in terms of</span>
<span class="cm"> * physical eraseblocks and erase counters and knows nothing about logical</span>
<span class="cm"> * eraseblocks, volumes, etc. From this sub-system&#39;s perspective all physical</span>
<span class="cm"> * eraseblocks are of two types - used and free. Used physical eraseblocks are</span>
<span class="cm"> * those that were &quot;get&quot; by the &#39;ubi_wl_get_peb()&#39; function, and free physical</span>
<span class="cm"> * eraseblocks are those that were put by the &#39;ubi_wl_put_peb()&#39; function.</span>
<span class="cm"> *</span>
<span class="cm"> * Physical eraseblocks returned by &#39;ubi_wl_get_peb()&#39; have only erase counter</span>
<span class="cm"> * header. The rest of the physical eraseblock contains only %0xFF bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * When physical eraseblocks are returned to the WL sub-system by means of the</span>
<span class="cm"> * &#39;ubi_wl_put_peb()&#39; function, they are scheduled for erasure. The erasure is</span>
<span class="cm"> * done asynchronously in context of the per-UBI device background thread,</span>
<span class="cm"> * which is also managed by the WL sub-system.</span>
<span class="cm"> *</span>
<span class="cm"> * The wear-leveling is ensured by means of moving the contents of used</span>
<span class="cm"> * physical eraseblocks with low erase counter to free physical eraseblocks</span>
<span class="cm"> * with high erase counter.</span>
<span class="cm"> *</span>
<span class="cm"> * If the WL sub-system fails to erase a physical eraseblock, it marks it as</span>
<span class="cm"> * bad.</span>
<span class="cm"> *</span>
<span class="cm"> * This sub-system is also responsible for scrubbing. If a bit-flip is detected</span>
<span class="cm"> * in a physical eraseblock, it has to be moved. Technically this is the same</span>
<span class="cm"> * as moving it for wear-leveling reasons.</span>
<span class="cm"> *</span>
<span class="cm"> * As it was said, for the UBI sub-system all physical eraseblocks are either</span>
<span class="cm"> * &quot;free&quot; or &quot;used&quot;. Free eraseblock are kept in the @wl-&gt;free RB-tree, while</span>
<span class="cm"> * used eraseblocks are kept in @wl-&gt;used, @wl-&gt;erroneous, or @wl-&gt;scrub</span>
<span class="cm"> * RB-trees, as well as (temporarily) in the @wl-&gt;pq queue.</span>
<span class="cm"> *</span>
<span class="cm"> * When the WL sub-system returns a physical eraseblock, the physical</span>
<span class="cm"> * eraseblock is protected from being moved for some &quot;time&quot;. For this reason,</span>
<span class="cm"> * the physical eraseblock is not directly moved from the @wl-&gt;free tree to the</span>
<span class="cm"> * @wl-&gt;used tree. There is a protection queue in between where this</span>
<span class="cm"> * physical eraseblock is temporarily stored (@wl-&gt;pq).</span>
<span class="cm"> *</span>
<span class="cm"> * All this protection stuff is needed because:</span>
<span class="cm"> *  o we don&#39;t want to move physical eraseblocks just after we have given them</span>
<span class="cm"> *    to the user; instead, we first want to let users fill them up with data;</span>
<span class="cm"> *</span>
<span class="cm"> *  o there is a chance that the user will put the physical eraseblock very</span>
<span class="cm"> *    soon, so it makes sense not to move it for some time, but wait.</span>
<span class="cm"> *</span>
<span class="cm"> * Physical eraseblocks stay protected only for limited time. But the &quot;time&quot; is</span>
<span class="cm"> * measured in erase cycles in this case. This is implemented with help of the</span>
<span class="cm"> * protection queue. Eraseblocks are put to the tail of this queue when they</span>
<span class="cm"> * are returned by the &#39;ubi_wl_get_peb()&#39;, and eraseblocks are removed from the</span>
<span class="cm"> * head of the queue on each erase operation (for any eraseblock). So the</span>
<span class="cm"> * length of the queue defines how may (global) erase cycles PEBs are protected.</span>
<span class="cm"> *</span>
<span class="cm"> * To put it differently, each physical eraseblock has 2 main states: free and</span>
<span class="cm"> * used. The former state corresponds to the @wl-&gt;free tree. The latter state</span>
<span class="cm"> * is split up on several sub-states:</span>
<span class="cm"> * o the WL movement is allowed (@wl-&gt;used tree);</span>
<span class="cm"> * o the WL movement is disallowed (@wl-&gt;erroneous) because the PEB is</span>
<span class="cm"> *   erroneous - e.g., there was a read error;</span>
<span class="cm"> * o the WL movement is temporarily prohibited (@wl-&gt;pq queue);</span>
<span class="cm"> * o scrubbing is needed (@wl-&gt;scrub tree).</span>
<span class="cm"> *</span>
<span class="cm"> * Depending on the sub-state, wear-leveling entries of the used physical</span>
<span class="cm"> * eraseblocks may be kept in one of those structures.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, in this implementation, we keep a small in-RAM object for each physical</span>
<span class="cm"> * eraseblock. This is surely not a scalable solution. But it appears to be good</span>
<span class="cm"> * enough for moderately large flashes and it is simple. In future, one may</span>
<span class="cm"> * re-work this sub-system and make it more scalable.</span>
<span class="cm"> *</span>
<span class="cm"> * At the moment this sub-system does not utilize the sequence number, which</span>
<span class="cm"> * was introduced relatively recently. But it would be wise to do this because</span>
<span class="cm"> * the sequence number of a logical eraseblock characterizes how old is it. For</span>
<span class="cm"> * example, when we move a PEB with low erase counter, and we need to pick the</span>
<span class="cm"> * target PEB, we pick a PEB with the highest EC if our PEB is &quot;old&quot; and we</span>
<span class="cm"> * pick target PEB with an average EC if our PEB is not very &quot;old&quot;. This is a</span>
<span class="cm"> * room for future re-works of the WL sub-system.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &quot;ubi.h&quot;</span>

<span class="cm">/* Number of physical eraseblocks reserved for wear-leveling purposes */</span>
<span class="cp">#define WL_RESERVED_PEBS 1</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum difference between two erase counters. If this threshold is</span>
<span class="cm"> * exceeded, the WL sub-system starts moving data from used physical</span>
<span class="cm"> * eraseblocks with low erase counter to free physical eraseblocks with high</span>
<span class="cm"> * erase counter.</span>
<span class="cm"> */</span>
<span class="cp">#define UBI_WL_THRESHOLD CONFIG_MTD_UBI_WL_THRESHOLD</span>

<span class="cm">/*</span>
<span class="cm"> * When a physical eraseblock is moved, the WL sub-system has to pick the target</span>
<span class="cm"> * physical eraseblock to move to. The simplest way would be just to pick the</span>
<span class="cm"> * one with the highest erase counter. But in certain workloads this could lead</span>
<span class="cm"> * to an unlimited wear of one or few physical eraseblock. Indeed, imagine a</span>
<span class="cm"> * situation when the picked physical eraseblock is constantly erased after the</span>
<span class="cm"> * data is written to it. So, we have a constant which limits the highest erase</span>
<span class="cm"> * counter of the free physical eraseblock to pick. Namely, the WL sub-system</span>
<span class="cm"> * does not pick eraseblocks with erase counter greater than the lowest erase</span>
<span class="cm"> * counter plus %WL_FREE_MAX_DIFF.</span>
<span class="cm"> */</span>
<span class="cp">#define WL_FREE_MAX_DIFF (2*UBI_WL_THRESHOLD)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of consecutive background thread failures which is enough to</span>
<span class="cm"> * switch to read-only mode.</span>
<span class="cm"> */</span>
<span class="cp">#define WL_MAX_FAILURES 32</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubi_work - UBI work description data structure.</span>
<span class="cm"> * @list: a link in the list of pending works</span>
<span class="cm"> * @func: worker function</span>
<span class="cm"> * @e: physical eraseblock to erase</span>
<span class="cm"> * @vol_id: the volume ID on which this erasure is being performed</span>
<span class="cm"> * @lnum: the logical eraseblock number</span>
<span class="cm"> * @torture: if the physical eraseblock has to be tortured</span>
<span class="cm"> *</span>
<span class="cm"> * The @func pointer points to the worker function. If the @cancel argument is</span>
<span class="cm"> * not zero, the worker has to free the resources and exit immediately. The</span>
<span class="cm"> * worker has to return zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubi_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cancel</span><span class="p">);</span>
	<span class="cm">/* The below fields are only relevant to erasure works */</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">torture</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_ec</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">self_check_in_pq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wl_tree_add - add a wear-leveling entry to a WL RB-tree.</span>
<span class="cm"> * @e: the wear-leveling entry to add</span>
<span class="cm"> * @root: the root of the tree</span>
<span class="cm"> *</span>
<span class="cm"> * Note, we use (erase counter, physical eraseblock number) pairs as keys in</span>
<span class="cm"> * the @ubi-&gt;used and @ubi-&gt;free RB-trees.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wl_tree_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e1</span><span class="p">;</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">e1</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&lt;</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&gt;</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ubi_assert</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span> <span class="o">!=</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_work - do one pending work.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">;</span>

	<span class="n">cond_resched</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * @ubi-&gt;work_sem is used to synchronize with the workers. Workers take</span>
<span class="cm">	 * it in read mode, so many of them may be doing works at a time. But</span>
<span class="cm">	 * the queue flush code has to be sure the whole queue of works is</span>
<span class="cm">	 * done, and it takes the mutex in write mode.</span>
<span class="cm">	 */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wrk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_work</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call the worker function. Do not touch the work structure</span>
<span class="cm">	 * after this call as it will have been freed or reused by that</span>
<span class="cm">	 * time by the worker function.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">wrk</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">wrk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;work failed with error code %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * produce_free_peb - produce a free physical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries to make a free PEB by means of synchronous execution of</span>
<span class="cm"> * pending works. This may be needed if, for example the background thread is</span>
<span class="cm"> * disabled. Returns zero in case of success and a negative error code in case</span>
<span class="cm"> * of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">produce_free_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">.</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;do one work synchronously&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">do_work</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * in_wl_tree - check if wear-leveling entry is present in a WL RB-tree.</span>
<span class="cm"> * @e: the wear-leveling entry to check</span>
<span class="cm"> * @root: the root of the tree</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns non-zero if @e is in the @root RB-tree and zero if it</span>
<span class="cm"> * is not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">in_wl_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e1</span><span class="p">;</span>

		<span class="n">e1</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span> <span class="o">==</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_assert</span><span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">e1</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&lt;</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&gt;</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ubi_assert</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span> <span class="o">!=</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * prot_queue_add - add physical eraseblock to the protection queue.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @e: the physical eraseblock to add</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds @e to the tail of the protection queue @ubi-&gt;pq, where</span>
<span class="cm"> * @e will stay for %UBI_PROT_QUEUE_LEN erase operations and will be</span>
<span class="cm"> * temporarily protected from the wear-leveling worker. Note, @wl-&gt;lock has to</span>
<span class="cm"> * be locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">prot_queue_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pq_tail</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq_head</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pq_tail</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pq_tail</span> <span class="o">=</span> <span class="n">UBI_PROT_QUEUE_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pq_tail</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pq_tail</span> <span class="o">&lt;</span> <span class="n">UBI_PROT_QUEUE_LEN</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq</span><span class="p">[</span><span class="n">pq_tail</span><span class="p">]);</span>
	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;added PEB %d EC %d to the protection queue&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_wl_entry - find wear-leveling entry closest to certain erase counter.</span>
<span class="cm"> * @root: the RB-tree where to look for</span>
<span class="cm"> * @diff: maximum possible difference from the smallest erase counter</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks for a wear leveling entry with erase counter closest to</span>
<span class="cm"> * min + @diff, where min is the smallest erase counter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="nf">find_wl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_first</span><span class="p">(</span><span class="n">root</span><span class="p">),</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e1</span><span class="p">;</span>

		<span class="n">e1</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">e1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_wl_get_peb - get a physical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a physical eraseblock in case of success and a</span>
<span class="cm"> * negative error code in case of failure. Might sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_wl_get_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">.</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_assert</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">));</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;no free eraseblocks&quot;</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">produce_free_peb</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">first</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">),</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">),</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">-</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&lt;</span> <span class="n">WL_FREE_MAX_DIFF</span><span class="p">)</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">.</span><span class="n">rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">find_wl_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">WL_FREE_MAX_DIFF</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move the physical eraseblock to the protection queue where it will</span>
<span class="cm">	 * be protected from being moved for some time.</span>
<span class="cm">	 */</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;PEB %d EC %d&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
	<span class="n">prot_queue_add</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_self_check_all_ff</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">,</span>
				    <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_size</span> <span class="o">-</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">vid_hdr_aloffset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;new PEB %d does not contain all 0xFF bytes&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * prot_queue_del - remove a physical eraseblock from the protection queue.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock to remove</span>
<span class="cm"> *</span>
<span class="cm"> * This function deletes PEB @pnum from the protection queue and returns zero</span>
<span class="cm"> * in case of success and %-ENODEV if the PEB was not found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">prot_queue_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">[</span><span class="n">pnum</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self_check_in_pq</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;deleted PEB %d from the protection queue&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sync_erase - synchronously erase a physical eraseblock.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @e: the the physical eraseblock to erase</span>
<span class="cm"> * @torture: if the physical eraseblock has to be tortured</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sync_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">torture</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ec</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">;</span>

	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;erase PEB %d, old EC %llu&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">self_check_ec</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ec_hdr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ec_hdr_alsize</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_sync_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">torture</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">ec</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">&gt;</span> <span class="n">UBI_MAX_ERASECOUNTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Erase counter overflow. Upgrade UBI and use 64-bit</span>
<span class="cm">		 * erase counters internally.</span>
<span class="cm">		 */</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;erase counter overflow at PEB %d, EC %llu&quot;</span><span class="p">,</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;erased PEB %d, new EC %llu&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>

	<span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">ec</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_write_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">=</span> <span class="n">ec</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&gt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_ec</span><span class="p">)</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_ec</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * serve_prot_queue - check if it is time to stop protecting PEBs.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after each erase operation and removes PEBs from the</span>
<span class="cm"> * tail of the protection queue. These PEBs have been protected for long enough</span>
<span class="cm"> * and should be moved to the used tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">serve_prot_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There may be several protected physical eraseblock to remove,</span>
<span class="cm">	 * process them all.</span>
<span class="cm">	 */</span>
<span class="nl">repeat:</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq</span><span class="p">[</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq_head</span><span class="p">],</span> <span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;PEB %d EC %d protection over, move to used tree&quot;</span><span class="p">,</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Let&#39;s be nice and avoid holding the spinlock for</span>
<span class="cm">			 * too long.</span>
<span class="cm">			 */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq_head</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq_head</span> <span class="o">==</span> <span class="n">UBI_PROT_QUEUE_LEN</span><span class="p">)</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq_head</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq_head</span> <span class="o">&lt;</span> <span class="n">UBI_PROT_QUEUE_LEN</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_ubi_work - schedule a work.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @wrk: the work to schedule</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds a work defined by @wrk to the tail of the pending works</span>
<span class="cm"> * list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">schedule_ubi_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">thread_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ubi_dbg_is_bgt_disabled</span><span class="p">(</span><span class="n">ubi</span><span class="p">))</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_thread</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">erase_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wl_wrk</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cancel</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * schedule_erase - schedule an erase work.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @e: the WL entry of the physical eraseblock to erase</span>
<span class="cm"> * @vol_id: the volume ID that last used this PEB</span>
<span class="cm"> * @lnum: the last used logical eraseblock number for the PEB</span>
<span class="cm"> * @torture: if the physical eraseblock has to be tortured</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a %-ENOMEM in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">schedule_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">torture</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wl_wrk</span><span class="p">;</span>

	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;schedule erasure of PEB %d, EC %d, torture %d&quot;</span><span class="p">,</span>
	       <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">,</span> <span class="n">torture</span><span class="p">);</span>

	<span class="n">wl_wrk</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_work</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wl_wrk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">erase_worker</span><span class="p">;</span>
	<span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">vol_id</span> <span class="o">=</span> <span class="n">vol_id</span><span class="p">;</span>
	<span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">torture</span> <span class="o">=</span> <span class="n">torture</span><span class="p">;</span>

	<span class="n">schedule_ubi_work</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">wl_wrk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wear_leveling_worker - wear-leveling worker function.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @wrk: the work object</span>
<span class="cm"> * @cancel: non-zero if the worker has to free memory and exit</span>
<span class="cm"> *</span>
<span class="cm"> * This function copies a more worn out physical eraseblock to a less worn out</span>
<span class="cm"> * one. Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wear_leveling_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">cancel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">scrubbing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">torture</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">protect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">erroneous</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e1</span><span class="p">,</span> <span class="o">*</span><span class="n">e2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_vid_hdr</span> <span class="o">*</span><span class="n">vid_hdr</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">wrk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cancel</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vid_hdr</span> <span class="o">=</span> <span class="n">ubi_zalloc_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vid_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_mutex</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_from</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to_put</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">.</span><span class="n">rb_node</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">.</span><span class="n">rb_node</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">.</span><span class="n">rb_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No free physical eraseblocks? Well, they must be waiting in</span>
<span class="cm">		 * the queue to be erased. Cancel movement - it will be</span>
<span class="cm">		 * triggered again when a free physical eraseblock appears.</span>
<span class="cm">		 *</span>
<span class="cm">		 * No used physical eraseblocks? They must be temporarily</span>
<span class="cm">		 * protected from being moved. They will be moved to the</span>
<span class="cm">		 * @ubi-&gt;used tree later and the wear-leveling will be</span>
<span class="cm">		 * triggered again.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;cancel WL, a list is empty: free %d, used %d&quot;</span><span class="p">,</span>
		       <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">.</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">.</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now pick the least worn-out used physical eraseblock and a</span>
<span class="cm">		 * highly worn-out free physical eraseblock. If the erase</span>
<span class="cm">		 * counters differ much enough, start wear-leveling.</span>
<span class="cm">		 */</span>
		<span class="n">e1</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">),</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>
		<span class="n">e2</span> <span class="o">=</span> <span class="n">find_wl_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">WL_FREE_MAX_DIFF</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">e2</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">-</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&gt;=</span> <span class="n">UBI_WL_THRESHOLD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;no WL needed: min used EC %d, max free EC %d&quot;</span><span class="p">,</span>
			       <span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;move PEB %d EC %d to PEB %d EC %d&quot;</span><span class="p">,</span>
		       <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Perform scrubbing */</span>
		<span class="n">scrubbing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">e1</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">),</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>
		<span class="n">e2</span> <span class="o">=</span> <span class="n">find_wl_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">WL_FREE_MAX_DIFF</span><span class="p">);</span>
		<span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;scrub PEB %d to PEB %d&quot;</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e2</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_from</span> <span class="o">=</span> <span class="n">e1</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to</span> <span class="o">=</span> <span class="n">e2</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we are going to copy physical eraseblock @e1-&gt;pnum to @e2-&gt;pnum.</span>
<span class="cm">	 * We so far do not know which logical eraseblock our physical</span>
<span class="cm">	 * eraseblock (@e1) belongs to. We have to read the volume identifier</span>
<span class="cm">	 * header first.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, we are protected from this PEB being unmapped and erased. The</span>
<span class="cm">	 * &#39;ubi_wl_put_peb()&#39; would wait for moving to be finished if the PEB</span>
<span class="cm">	 * which is being moved was unmapped.</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_FF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We are trying to move PEB without a VID header. UBI</span>
<span class="cm">			 * always write VID headers shortly after the PEB was</span>
<span class="cm">			 * given, so we have a situation when it has not yet</span>
<span class="cm">			 * had a chance to write it, because it was preempted.</span>
<span class="cm">			 * So add this PEB to the protection queue so far,</span>
<span class="cm">			 * because presumably more data will be written there</span>
<span class="cm">			 * (including the missing VID header), and then we&#39;ll</span>
<span class="cm">			 * move it.</span>
<span class="cm">			 */</span>
			<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;PEB %d has no VID header&quot;</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
			<span class="n">protect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_not_moved</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">UBI_IO_FF_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The same situation as %UBI_IO_FF, but bit-flips were</span>
<span class="cm">			 * detected. It is better to schedule this PEB for</span>
<span class="cm">			 * scrubbing.</span>
<span class="cm">			 */</span>
			<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;PEB %d has no VID header but has bit-flips&quot;</span><span class="p">,</span>
			       <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
			<span class="n">scrubbing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_not_moved</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;error %d while reading VID header from PEB %d&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vol_id</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vid_hdr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_eba_copy_leb</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">MOVE_CANCEL_RACE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The LEB has not been moved because the volume is</span>
<span class="cm">			 * being deleted or the PEB has been put meanwhile. We</span>
<span class="cm">			 * should prevent this PEB from being selected for</span>
<span class="cm">			 * wear-leveling movement again, so put it to the</span>
<span class="cm">			 * protection queue.</span>
<span class="cm">			 */</span>
			<span class="n">protect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_not_moved</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">MOVE_RETRY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scrubbing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_not_moved</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">MOVE_TARGET_BITFLIPS</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="n">MOVE_TARGET_WR_ERR</span> <span class="o">||</span>
		    <span class="n">err</span> <span class="o">==</span> <span class="n">MOVE_TARGET_RD_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Target PEB had bit-flips or write error - torture it.</span>
<span class="cm">			 */</span>
			<span class="n">torture</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_not_moved</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">MOVE_SOURCE_RD_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * An error happened while reading the source PEB. Do</span>
<span class="cm">			 * not switch to R/O mode in this case, and give the</span>
<span class="cm">			 * upper layers a possibility to recover from this,</span>
<span class="cm">			 * e.g. by unmapping corresponding LEB. Instead, just</span>
<span class="cm">			 * put this PEB to the @ubi-&gt;erroneous list to prevent</span>
<span class="cm">			 * UBI from trying to move it over and over again.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous_peb_count</span> <span class="o">&gt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_erroneous</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;too many erroneous eraseblocks (%d)&quot;</span><span class="p">,</span>
					<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous_peb_count</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">erroneous</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_not_moved</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>

		<span class="n">ubi_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The PEB has been successfully moved */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scrubbing</span><span class="p">)</span>
		<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;scrubbed PEB %d (LEB %d:%d), data moved to PEB %d&quot;</span><span class="p">,</span>
			<span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to_put</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
		<span class="n">e2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_from</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to_put</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_scheduled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">schedule_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e2</span><span class="p">)</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Well, the target PEB was put meanwhile, schedule it for</span>
<span class="cm">		 * erasure.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;PEB %d (LEB %d:%d) was put meanwhile, erase&quot;</span><span class="p">,</span>
		       <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">schedule_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For some reasons the LEB was not moved, might be an error, might be</span>
<span class="cm">	 * something else. @e1 was not changed, so return it back. @e2 might</span>
<span class="cm">	 * have been changed, schedule it for erasure.</span>
<span class="cm">	 */</span>
<span class="nl">out_not_moved:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;cancel moving PEB %d (LEB %d:%d) to PEB %d (%d)&quot;</span><span class="p">,</span>
		       <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;cancel moving PEB %d to PEB %d (%d)&quot;</span><span class="p">,</span>
		       <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protect</span><span class="p">)</span>
		<span class="n">prot_queue_add</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">erroneous</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous_peb_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scrubbing</span><span class="p">)</span>
		<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to_put</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_from</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_scheduled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">schedule_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">torture</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;error %d while moving PEB %d to PEB %d&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;error %d while moving PEB %d (LEB %d:%d) to PEB %d&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">,</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">e2</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_from</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to_put</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_scheduled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e1</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span>

<span class="nl">out_ro:</span>
	<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_mutex</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_scheduled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_mutex</span><span class="p">);</span>
	<span class="n">ubi_free_vid_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">vid_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ensure_wear_leveling - schedule wear-leveling if it is needed.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if it is time to start wear-leveling and schedules it</span>
<span class="cm"> * if yes. This function returns zero in case of success and a negative error</span>
<span class="cm"> * code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ensure_wear_leveling</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_scheduled</span><span class="p">)</span>
		<span class="cm">/* Wear-leveling is already in the work queue */</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the ubi-&gt;scrub tree is not empty, scrubbing is needed, and the</span>
<span class="cm">	 * the WL worker has to be scheduled anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">.</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">.</span><span class="n">rb_node</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">.</span><span class="n">rb_node</span><span class="p">)</span>
			<span class="cm">/* No physical eraseblocks - no deal */</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We schedule wear-leveling only if the difference between the</span>
<span class="cm">		 * lowest erase counter of used physical eraseblocks and a high</span>
<span class="cm">		 * erase counter of free physical eraseblocks is greater than</span>
<span class="cm">		 * %UBI_WL_THRESHOLD.</span>
<span class="cm">		 */</span>
		<span class="n">e1</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">),</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>
		<span class="n">e2</span> <span class="o">=</span> <span class="n">find_wl_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">WL_FREE_MAX_DIFF</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">e2</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">-</span> <span class="n">e1</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&gt;=</span> <span class="n">UBI_WL_THRESHOLD</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;schedule wear-leveling&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;schedule scrubbing&quot;</span><span class="p">);</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_scheduled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="n">wrk</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_work</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wrk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wrk</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wear_leveling_worker</span><span class="p">;</span>
	<span class="n">schedule_ubi_work</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">wrk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_scheduled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * erase_worker - physical eraseblock erase worker function.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @wl_wrk: the work object</span>
<span class="cm"> * @cancel: non-zero if the worker has to free memory and exit</span>
<span class="cm"> *</span>
<span class="cm"> * This function erases a physical eraseblock and perform torture testing if</span>
<span class="cm"> * needed. It also takes care about marking the physical eraseblock bad if</span>
<span class="cm"> * needed. Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">erase_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wl_wrk</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cancel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnum</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">need</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vol_id</span> <span class="o">=</span> <span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cancel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;cancel erasure of PEB %d EC %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wl_wrk</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;erase PEB %d EC %d LEB %d:%d&quot;</span><span class="p">,</span>
	       <span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">,</span> <span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sync_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">wl_wrk</span><span class="o">-&gt;</span><span class="n">torture</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Fine, we&#39;ve erased it successfully */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wl_wrk</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * One more erase operation has happened, take care about</span>
<span class="cm">		 * protected physical eraseblocks.</span>
<span class="cm">		 */</span>
		<span class="n">serve_prot_queue</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>

		<span class="cm">/* And take care about wear-leveling */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ensure_wear_leveling</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;failed to erase PEB %d, error %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wl_wrk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span>
	    <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err1</span><span class="p">;</span>

		<span class="cm">/* Re-schedule the LEB for erasure */</span>
		<span class="n">err1</span> <span class="o">=</span> <span class="n">schedule_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">err1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this is not %-EIO, we have no idea what to do. Scheduling</span>
<span class="cm">		 * this physical eraseblock for erasure again would cause</span>
<span class="cm">		 * errors again and again. Well, lets switch to R/O mode.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="cm">/* It is %-EIO, the PEB went bad */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;bad physical eraseblock %d detected&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
	<span class="n">need</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_level</span> <span class="o">-</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">need</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">&gt;=</span> <span class="n">need</span> <span class="o">?</span> <span class="n">need</span> <span class="o">:</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span><span class="p">;</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">-=</span> <span class="n">need</span><span class="p">;</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">rsvd_pebs</span> <span class="o">+=</span> <span class="n">need</span><span class="p">;</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span> <span class="o">+=</span> <span class="n">need</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;reserve more %d PEBs&quot;</span><span class="p">,</span> <span class="n">need</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;no reserved physical eraseblocks&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;mark PEB %d as bad&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_mark_bad</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bad_peb_count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">good_peb_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubi_calculate_reserved</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span><span class="p">)</span>
		<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;%d PEBs left in the reserve&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">beb_rsvd_pebs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ubi_warn</span><span class="p">(</span><span class="s">&quot;last PEB from the reserved pool was used&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">volumes_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_ro:</span>
	<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_wl_put_peb - return a PEB to the wear-leveling sub-system.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: the volume ID that last used this PEB</span>
<span class="cm"> * @lnum: the last used logical eraseblock number for the PEB</span>
<span class="cm"> * @pnum: physical eraseblock to return</span>
<span class="cm"> * @torture: if this physical eraseblock has to be tortured</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called to return physical eraseblock @pnum to the pool of</span>
<span class="cm"> * free physical eraseblocks. The @torture flag has to be set if an I/O error</span>
<span class="cm"> * occurred to this @pnum and it has to be tested. This function returns zero</span>
<span class="cm"> * in case of success, and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_wl_put_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">torture</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubi_assert</span><span class="p">(</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">[</span><span class="n">pnum</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_from</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * User is putting the physical eraseblock which was selected to</span>
<span class="cm">		 * be moved. It will be scheduled for erasure in the</span>
<span class="cm">		 * wear-leveling worker.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;PEB %d is being moved, wait&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

		<span class="cm">/* Wait for the WL worker by taking the @ubi-&gt;move_mutex */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_mutex</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * User is putting the physical eraseblock which was selected</span>
<span class="cm">		 * as the target the data is moved to. It may happen if the EBA</span>
<span class="cm">		 * sub-system already re-mapped the LEB in &#39;ubi_eba_copy_leb()&#39;</span>
<span class="cm">		 * but the WL sub-system has not put the PEB to the &quot;used&quot; tree</span>
<span class="cm">		 * yet, but it is about to do this. So we just set a flag which</span>
<span class="cm">		 * will tell the WL worker that the PEB is not needed anymore</span>
<span class="cm">		 * and should be scheduled for erasure.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;PEB %d is the target of data moving&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to_put</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to_put</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_wl_tree</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_wl_tree</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_wl_tree</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous</span><span class="p">);</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous</span><span class="p">);</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous_peb_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous_peb_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* Erroneous PEBs should be tortured */</span>
			<span class="n">torture</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">prot_queue_del</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;PEB %d not found&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
				<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">schedule_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">torture</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_wl_scrub_peb - schedule a physical eraseblock for scrubbing.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock to schedule</span>
<span class="cm"> *</span>
<span class="cm"> * If a bit-flip in a physical eraseblock is detected, this physical eraseblock</span>
<span class="cm"> * needs scrubbing. This function schedules a physical eraseblock for</span>
<span class="cm"> * scrubbing which is done in background. This function returns zero in case of</span>
<span class="cm"> * success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_wl_scrub_peb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;schedule PEB %d for scrubbing&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">e</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">[</span><span class="n">pnum</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_from</span> <span class="o">||</span> <span class="n">in_wl_tree</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">)</span> <span class="o">||</span>
				   <span class="n">in_wl_tree</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_to</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This physical eraseblock was used to move data to. The data</span>
<span class="cm">		 * was moved but the PEB was not yet inserted to the proper</span>
<span class="cm">		 * tree. We should just wait a little and let the WL worker</span>
<span class="cm">		 * proceed.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;the PEB %d is not in proper tree, retry&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="n">yield</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_wl_tree</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">self_check_in_wl_tree</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">prot_queue_del</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;PEB %d not found&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
			<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Technically scrubbing is the same as wear-leveling, so it is done</span>
<span class="cm">	 * by the WL worker.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ensure_wear_leveling</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_wl_flush - flush all pending works.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @vol_id: the volume id to flush for</span>
<span class="cm"> * @lnum: the logical eraseblock number to flush for</span>
<span class="cm"> *</span>
<span class="cm"> * This function executes all pending works for a particular volume id /</span>
<span class="cm"> * logical eraseblock number pair. If either value is set to %UBI_ALL, then it</span>
<span class="cm"> * acts as a wildcard for all of the corresponding volume numbers or logical</span>
<span class="cm"> * eraseblock numbers. It returns zero in case of success and a negative error</span>
<span class="cm"> * code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_wl_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vol_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Erase while the pending works queue is not empty, but not more than</span>
<span class="cm">	 * the number of currently pending works.</span>
<span class="cm">	 */</span>
	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;flush pending work for LEB %d:%d (%d pending works)&quot;</span><span class="p">,</span>
	       <span class="n">vol_id</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">;</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">wrk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">vol_id</span> <span class="o">==</span> <span class="n">UBI_ALL</span> <span class="o">||</span> <span class="n">wrk</span><span class="o">-&gt;</span><span class="n">vol_id</span> <span class="o">==</span> <span class="n">vol_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">UBI_ALL</span> <span class="o">||</span> <span class="n">wrk</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">lnum</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

				<span class="n">err</span> <span class="o">=</span> <span class="n">wrk</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">wrk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure all the works which have been done in parallel are</span>
<span class="cm">	 * finished.</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tree_destroy - destroy an RB-tree.</span>
<span class="cm"> * @root: the root of the tree to destroy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tree_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">rb</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span>
			<span class="n">rb</span> <span class="o">=</span> <span class="n">rb</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span>
			<span class="n">rb</span> <span class="o">=</span> <span class="n">rb</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_wl_entry</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">);</span>

			<span class="n">rb</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">rb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">)</span>
					<span class="n">rb</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">rb</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_thread - UBI background thread.</span>
<span class="cm"> * @u: the UBI device description object pointer</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">u</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">failures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>

	<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;background thread </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> started, PID %d&quot;</span><span class="p">,</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>

	<span class="n">set_freezable</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">try_to_freeze</span><span class="p">())</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">)</span> <span class="o">||</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ro_mode</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">thread_enabled</span> <span class="o">||</span> <span class="n">ubi_dbg_is_bgt_disabled</span><span class="p">(</span><span class="n">ubi</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">do_work</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;%s: work failed with error code %d&quot;</span><span class="p">,</span>
				<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">failures</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">WL_MAX_FAILURES</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Too many failures, disable the thread and</span>
<span class="cm">				 * switch to read-only mode.</span>
<span class="cm">				 */</span>
				<span class="n">ubi_msg</span><span class="p">(</span><span class="s">&quot;%s: %d consecutive failures&quot;</span><span class="p">,</span>
					<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span> <span class="n">WL_MAX_FAILURES</span><span class="p">);</span>
				<span class="n">ubi_ro_mode</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
				<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">thread_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">failures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;background thread </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> is killed&quot;</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cancel_pending - cancel all pending works.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cancel_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubi_work</span> <span class="o">*</span><span class="n">wrk</span><span class="p">;</span>

		<span class="n">wrk</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_work</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">wrk</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">wrk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_wl_init - initialize the WL sub-system using attaching information.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @ai: attaching information</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success, and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubi_wl_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubi_attach_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb1</span><span class="p">,</span> <span class="o">*</span><span class="n">rb2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_ainf_volume</span> <span class="o">*</span><span class="n">av</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_ainf_peb</span> <span class="o">*</span><span class="n">aeb</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">wl_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">move_mutex</span><span class="p">);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">work_sem</span><span class="p">);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">max_ec</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">max_ec</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">works</span><span class="p">);</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span> <span class="n">UBI_BGT_NAME_PATTERN</span><span class="p">,</span> <span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ubi_num</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">peb_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBI_PROT_QUEUE_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">aeb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">e</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span> <span class="o">=</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">=</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">;</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">schedule_erase</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">aeb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">e</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span> <span class="o">=</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">=</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">;</span>
		<span class="n">ubi_assert</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
		<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubi_rb_for_each_entry</span><span class="p">(</span><span class="n">rb1</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">volumes</span><span class="p">,</span> <span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_rb_for_each_entry</span><span class="p">(</span><span class="n">rb2</span><span class="p">,</span> <span class="n">aeb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">u</span><span class="p">.</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cond_resched</span><span class="p">();</span>

			<span class="n">e</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

			<span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span> <span class="o">=</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">;</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span> <span class="o">=</span> <span class="n">aeb</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">;</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aeb</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;add PEB %d EC %d to the used tree&quot;</span><span class="p">,</span>
				       <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
				<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;add PEB %d EC %d to the scrub tree&quot;</span><span class="p">,</span>
				       <span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
				<span class="n">wl_tree_add</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">&lt;</span> <span class="n">WL_RESERVED_PEBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;no enough physical eraseblocks (%d, need %d)&quot;</span><span class="p">,</span>
			<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span><span class="p">,</span> <span class="n">WL_RESERVED_PEBS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">corr_peb_count</span><span class="p">)</span>
			<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;%d PEBs are corrupted and not used&quot;</span><span class="p">,</span>
				<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">corr_peb_count</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">avail_pebs</span> <span class="o">-=</span> <span class="n">WL_RESERVED_PEBS</span><span class="p">;</span>
	<span class="n">ubi</span><span class="o">-&gt;</span><span class="n">rsvd_pebs</span> <span class="o">+=</span> <span class="n">WL_RESERVED_PEBS</span><span class="p">;</span>

	<span class="cm">/* Schedule wear-leveling if needed */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ensure_wear_leveling</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">cancel_pending</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">tree_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
	<span class="n">tree_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="n">tree_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * protection_queue_destroy - destroy the protection queue.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">protection_queue_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBI_PROT_QUEUE_LEN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubi_wl_entry_slab</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubi_wl_close - close the wear-leveling sub-system.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubi_wl_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dbg_wl</span><span class="p">(</span><span class="s">&quot;close the WL sub-system&quot;</span><span class="p">);</span>
	<span class="n">cancel_pending</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">protection_queue_destroy</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">tree_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
	<span class="n">tree_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">erroneous</span><span class="p">);</span>
	<span class="n">tree_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="n">tree_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">scrub</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">lookuptbl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_ec - make sure that the erase counter of a PEB is correct.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @pnum: the physical eraseblock number to check</span>
<span class="cm"> * @ec: the erase counter to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the erase counter of physical eraseblock @pnum</span>
<span class="cm"> * is equivalent to @ec, and a negative error code if not or if an error</span>
<span class="cm"> * occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_ec</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">read_ec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_ec_hdr</span> <span class="o">*</span><span class="n">ec_hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_gen</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ec_hdr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">ec_hdr_alsize</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec_hdr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_io_read_ec_hdr</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">ec_hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">UBI_IO_BITFLIPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The header does not have to exist */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_ec</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ec_hdr</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">!=</span> <span class="n">read_ec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d&quot;</span><span class="p">,</span> <span class="n">pnum</span><span class="p">);</span>
		<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;read EC is %lld, should be %d&quot;</span><span class="p">,</span> <span class="n">read_ec</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ec_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_in_wl_tree - check that wear-leveling entry is in WL RB-tree.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @e: the wear-leveling entry to check</span>
<span class="cm"> * @root: the root of the tree</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if @e is in the @root RB-tree and %-EINVAL if it</span>
<span class="cm"> * is not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_in_wl_tree</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_gen</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_wl_tree</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d, EC %d, RB-tree %p &quot;</span><span class="p">,</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * self_check_in_pq - check if wear-leveling entry is in the protection</span>
<span class="cm"> *                        queue.</span>
<span class="cm"> * @ubi: UBI device description object</span>
<span class="cm"> * @e: the wear-leveling entry to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if @e is in @ubi-&gt;pq and %-EINVAL if it is not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">self_check_in_pq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubi_device</span> <span class="o">*</span><span class="n">ubi</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_wl_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">chk_gen</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBI_PROT_QUEUE_LEN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubi</span><span class="o">-&gt;</span><span class="n">pq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">.</span><span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubi_err</span><span class="p">(</span><span class="s">&quot;self-check failed for PEB %d, EC %d, Protect queue&quot;</span><span class="p">,</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
