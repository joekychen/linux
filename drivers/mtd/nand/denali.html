<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › nand › denali.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>denali.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NAND Flash Controller Device Driver</span>
<span class="cm"> * Copyright © 2009-2010, Intel Corporation and its suppliers.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms and conditions of the GNU General Public License,</span>
<span class="cm"> * version 2, as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;denali.h&quot;</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* We define a module parameter that allows the user to override</span>
<span class="cm"> * the hardware and decide what timing mode should be used.</span>
<span class="cm"> */</span>
<span class="cp">#define NAND_DEFAULT_TIMINGS	-1</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">onfi_timing_mode</span> <span class="o">=</span> <span class="n">NAND_DEFAULT_TIMINGS</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">onfi_timing_mode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">onfi_timing_mode</span><span class="p">,</span> <span class="s">&quot;Overrides default ONFI setting.&quot;</span>
			<span class="s">&quot; -1 indicates use default timings&quot;</span><span class="p">);</span>

<span class="cp">#define DENALI_NAND_NAME    &quot;denali-nand&quot;</span>

<span class="cm">/* We define a macro here that combines all interrupts this driver uses into</span>
<span class="cm"> * a single constant value, for convenience. */</span>
<span class="cp">#define DENALI_IRQ_ALL	(INTR_STATUS__DMA_CMD_COMP | \</span>
<span class="cp">			INTR_STATUS__ECC_TRANSACTION_DONE | \</span>
<span class="cp">			INTR_STATUS__ECC_ERR | \</span>
<span class="cp">			INTR_STATUS__PROGRAM_FAIL | \</span>
<span class="cp">			INTR_STATUS__LOAD_COMP | \</span>
<span class="cp">			INTR_STATUS__PROGRAM_COMP | \</span>
<span class="cp">			INTR_STATUS__TIME_OUT | \</span>
<span class="cp">			INTR_STATUS__ERASE_FAIL | \</span>
<span class="cp">			INTR_STATUS__RST_COMP | \</span>
<span class="cp">			INTR_STATUS__ERASE_COMP)</span>

<span class="cm">/* indicates whether or not the internal value for the flash bank is</span>
<span class="cm"> * valid or not */</span>
<span class="cp">#define CHIP_SELECT_INVALID	-1</span>

<span class="cp">#define SUPPORT_8BITECC		1</span>

<span class="cm">/* This macro divides two integers and rounds fractional values up</span>
<span class="cm"> * to the nearest integer value. */</span>
<span class="cp">#define CEIL_DIV(X, Y) (((X)%(Y)) ? ((X)/(Y)+1) : ((X)/(Y)))</span>

<span class="cm">/* this macro allows us to convert from an MTD structure to our own</span>
<span class="cm"> * device context (denali) structure.</span>
<span class="cm"> */</span>
<span class="cp">#define mtd_to_denali(m) container_of(m, struct denali_nand_info, mtd)</span>

<span class="cm">/* These constants are defined by the driver to enable common driver</span>
<span class="cm"> * configuration options. */</span>
<span class="cp">#define SPARE_ACCESS		0x41</span>
<span class="cp">#define MAIN_ACCESS		0x42</span>
<span class="cp">#define MAIN_SPARE_ACCESS	0x43</span>

<span class="cp">#define DENALI_READ	0</span>
<span class="cp">#define DENALI_WRITE	0x100</span>

<span class="cm">/* types of device accesses. We can issue commands and get status */</span>
<span class="cp">#define COMMAND_CYCLE	0</span>
<span class="cp">#define ADDR_CYCLE	1</span>
<span class="cp">#define STATUS_CYCLE	2</span>

<span class="cm">/* this is a helper macro that allows us to</span>
<span class="cm"> * format the bank into the proper bits for the controller */</span>
<span class="cp">#define BANK(x) ((x) &lt;&lt; 24)</span>

<span class="cm">/* List of platforms this NAND controller has be integrated into */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">denali_pci_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="mh">0x0701</span><span class="p">),</span> <span class="n">INTEL_CE4100</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="mh">0x0809</span><span class="p">),</span> <span class="n">INTEL_MRST</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* end: all zeroes */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* forward declarations */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">clear_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
							<span class="kt">uint32_t</span> <span class="n">irq_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">denali_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
							<span class="kt">uint32_t</span> <span class="n">int_mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">read_interrupt_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">);</span>

<span class="cm">/* Certain operations for the denali NAND controller use</span>
<span class="cm"> * an indexed mode to read/write data. The operation is</span>
<span class="cm"> * performed by writing the address value of the command</span>
<span class="cm"> * to the device memory followed by the data. This function</span>
<span class="cm"> * abstracts this common operation.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">index_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
				<span class="kt">uint32_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Perform an indexed read of the device */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">index_addr_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
				 <span class="kt">uint32_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* We need to buffer some data for some of the NAND core routines.</span>
<span class="cm"> * The operations manage buffering that data. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_byte_to_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">tail</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span><span class="p">));</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">tail</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* reads the status of the device */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="cm">/* initialize the data buffer to store status */</span>
	<span class="n">reset_buf</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">WRITE_PROTECT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
		<span class="n">write_byte_to_buf</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">NAND_STATUS_WP</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">write_byte_to_buf</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* resets a specific device connected to the core */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_bank</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="n">INTR_STATUS__RST_COMP</span> <span class="o">|</span>
			    <span class="n">INTR_STATUS__TIME_OUT</span><span class="p">;</span>

	<span class="n">clear_interrupts</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_RESET</span><span class="p">);</span>

	<span class="n">irq_status</span> <span class="o">=</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">INTR_STATUS__TIME_OUT</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reset bank failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Reset the flash controller */</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">denali_nand_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, Line %d, Function: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">INTR_STATUS__RST_COMP</span> <span class="o">|</span> <span class="n">INTR_STATUS__TIME_OUT</span><span class="p">,</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">INTR_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_RESET</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span>
				<span class="n">INTR_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span>
			<span class="p">(</span><span class="n">INTR_STATUS__RST_COMP</span> <span class="o">|</span> <span class="n">INTR_STATUS__TIME_OUT</span><span class="p">)))</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">INTR_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span>
			<span class="n">INTR_STATUS__TIME_OUT</span><span class="p">)</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;NAND Reset operation timed out on bank %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">INTR_STATUS__RST_COMP</span> <span class="o">|</span> <span class="n">INTR_STATUS__TIME_OUT</span><span class="p">,</span>
			<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">INTR_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">PASS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this routine calculates the ONFI timing values for a given mode and</span>
<span class="cm"> * programs the clocking register accordingly. The mode is determined by</span>
<span class="cm"> * the get_onfi_nand_para routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_onfi_timing_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
								<span class="kt">uint16_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">Trea</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">40</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">16</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Trp</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Treh</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Trc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Trhoh</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Trloh</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Tcea</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Tadl</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Trhw</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Trhz</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Twhr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">120</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">};</span>
	<span class="kt">uint16_t</span> <span class="n">Tcs</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">70</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>

	<span class="kt">uint16_t</span> <span class="n">TclsRising</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">data_invalid_rhoh</span><span class="p">,</span> <span class="n">data_invalid_rloh</span><span class="p">,</span> <span class="n">data_invalid</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">dv_window</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">en_lo</span><span class="p">,</span> <span class="n">en_hi</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">acc_clks</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">addr_2_data</span><span class="p">,</span> <span class="n">re_2_we</span><span class="p">,</span> <span class="n">re_2_re</span><span class="p">,</span> <span class="n">we_2_re</span><span class="p">,</span> <span class="n">cs_cnt</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, Line %d, Function: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">en_lo</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">(</span><span class="n">Trp</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">CLK_X</span><span class="p">);</span>
	<span class="n">en_hi</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">(</span><span class="n">Treh</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">CLK_X</span><span class="p">);</span>
<span class="cp">#if ONFI_BLOOM_TIME</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">en_hi</span> <span class="o">*</span> <span class="n">CLK_X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">Treh</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">en_hi</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">en_lo</span> <span class="o">+</span> <span class="n">en_hi</span><span class="p">)</span> <span class="o">*</span> <span class="n">CLK_X</span> <span class="o">&lt;</span> <span class="n">Trc</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
		<span class="n">en_lo</span> <span class="o">+=</span> <span class="n">CEIL_DIV</span><span class="p">((</span><span class="n">Trc</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">en_lo</span> <span class="o">+</span> <span class="n">en_hi</span><span class="p">)</span> <span class="o">*</span> <span class="n">CLK_X</span><span class="p">),</span> <span class="n">CLK_X</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">en_lo</span> <span class="o">+</span> <span class="n">en_hi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">CLK_MULTI</span><span class="p">)</span>
		<span class="n">en_lo</span> <span class="o">+=</span> <span class="n">CLK_MULTI</span> <span class="o">-</span> <span class="n">en_lo</span> <span class="o">-</span> <span class="n">en_hi</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">dv_window</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data_invalid_rhoh</span> <span class="o">=</span> <span class="n">en_lo</span> <span class="o">*</span> <span class="n">CLK_X</span> <span class="o">+</span> <span class="n">Trhoh</span><span class="p">[</span><span class="n">mode</span><span class="p">];</span>

		<span class="n">data_invalid_rloh</span> <span class="o">=</span> <span class="p">(</span><span class="n">en_lo</span> <span class="o">+</span> <span class="n">en_hi</span><span class="p">)</span> <span class="o">*</span> <span class="n">CLK_X</span> <span class="o">+</span> <span class="n">Trloh</span><span class="p">[</span><span class="n">mode</span><span class="p">];</span>

		<span class="n">data_invalid</span> <span class="o">=</span>
		    <span class="n">data_invalid_rhoh</span> <span class="o">&lt;</span>
		    <span class="n">data_invalid_rloh</span> <span class="o">?</span> <span class="n">data_invalid_rhoh</span> <span class="o">:</span> <span class="n">data_invalid_rloh</span><span class="p">;</span>

		<span class="n">dv_window</span> <span class="o">=</span> <span class="n">data_invalid</span> <span class="o">-</span> <span class="n">Trea</span><span class="p">[</span><span class="n">mode</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dv_window</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">en_lo</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">acc_clks</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">(</span><span class="n">Trea</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">CLK_X</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(((</span><span class="n">acc_clks</span> <span class="o">*</span> <span class="n">CLK_X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Trea</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">acc_clks</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data_invalid</span> <span class="o">-</span> <span class="n">acc_clks</span> <span class="o">*</span> <span class="n">CLK_X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, Line %d: Warning!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>

	<span class="n">addr_2_data</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">(</span><span class="n">Tadl</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">CLK_X</span><span class="p">);</span>
	<span class="n">re_2_we</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">(</span><span class="n">Trhw</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">CLK_X</span><span class="p">);</span>
	<span class="n">re_2_re</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">(</span><span class="n">Trhz</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">CLK_X</span><span class="p">);</span>
	<span class="n">we_2_re</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">(</span><span class="n">Twhr</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">CLK_X</span><span class="p">);</span>
	<span class="n">cs_cnt</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">((</span><span class="n">Tcs</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">-</span> <span class="n">Trp</span><span class="p">[</span><span class="n">mode</span><span class="p">]),</span> <span class="n">CLK_X</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TclsRising</span><span class="p">)</span>
		<span class="n">cs_cnt</span> <span class="o">=</span> <span class="n">CEIL_DIV</span><span class="p">(</span><span class="n">Tcs</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">CLK_X</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cs_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">Tcea</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(((</span><span class="n">cs_cnt</span> <span class="o">*</span> <span class="n">CLK_X</span><span class="p">)</span> <span class="o">+</span> <span class="n">Trea</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">Tcea</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
			<span class="n">cs_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if MODE5_WORKAROUND</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">acc_clks</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Sighting 3462430: Temporary hack for MT29F128G08CJABAWP:B */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">MANUFACTURER_ID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_ID</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x88</span><span class="p">))</span>
		<span class="n">acc_clks</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">acc_clks</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ACC_CLKS</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">re_2_we</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RE_2_WE</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">re_2_re</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RE_2_RE</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">we_2_re</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">WE_2_RE</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">addr_2_data</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ADDR_2_DATA</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">en_lo</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RDWR_EN_LO_CNT</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">en_hi</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RDWR_EN_HI_CNT</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">cs_cnt</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">CS_SETUP_CNT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* queries the NAND device to see what ONFI modes it supports. */</span>
<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">get_onfi_nand_para</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* we needn&#39;t to do a reset here because driver has already</span>
<span class="cm">	 * reset all the banks before</span>
<span class="cm">	 * */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ONFI_TIMING_MODE</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">ONFI_TIMING_MODE__VALUE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FAIL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ONFI_TIMING_MODE</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nand_onfi_timing_set</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* By now, all the ONFI devices we know support the page cache */</span>
	<span class="cm">/* rw feature. So here we enable the pipeline_rw_ahead feature */</span>
	<span class="cm">/* iowrite32(1, denali-&gt;flash_reg + CACHE_WRITE_ENABLE); */</span>
	<span class="cm">/* iowrite32(1, denali-&gt;flash_reg + CACHE_READ_ENABLE);  */</span>

	<span class="k">return</span> <span class="n">PASS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_samsung_nand_para</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
							<span class="kt">uint8_t</span> <span class="n">device_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_id</span> <span class="o">==</span> <span class="mh">0xd3</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Samsung K9WAG08U1A */</span>
		<span class="cm">/* Set timing register values according to datasheet */</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ACC_CLKS</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RE_2_WE</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">WE_2_RE</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ADDR_2_DATA</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RDWR_EN_LO_CNT</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RDWR_EN_HI_CNT</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">CS_SETUP_CNT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_toshiba_nand_para</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Workaround to fix a controller bug which reports a wrong */</span>
	<span class="cm">/* spare area size for some kind of Toshiba NAND device */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_MAIN_AREA_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_SPARE_AREA_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">216</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_SPARE_AREA_SIZE</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICES_CONNECTED</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_SPARE_AREA_SIZE</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span>
				<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">LOGICAL_PAGE_SPARE_SIZE</span><span class="p">);</span>
<span class="cp">#if SUPPORT_15BITECC</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ECC_CORRECTION</span><span class="p">);</span>
<span class="cp">#elif SUPPORT_8BITECC</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ECC_CORRECTION</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_hynix_nand_para</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
							<span class="kt">uint8_t</span> <span class="n">device_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">main_size</span><span class="p">,</span> <span class="n">spare_size</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">device_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0xD5</span>: <span class="cm">/* Hynix H27UAG8T2A, H27UBG8U5A or H27UCG8VFA */</span>
	<span class="k">case</span> <span class="mh">0xD7</span>: <span class="cm">/* Hynix H27UDG8VEM, H27UCG8UDM or H27UCG8V5A */</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">PAGES_PER_BLOCK</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">4096</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_MAIN_AREA_SIZE</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_SPARE_AREA_SIZE</span><span class="p">);</span>
		<span class="n">main_size</span> <span class="o">=</span> <span class="mi">4096</span> <span class="o">*</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICES_CONNECTED</span><span class="p">);</span>
		<span class="n">spare_size</span> <span class="o">=</span> <span class="mi">224</span> <span class="o">*</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICES_CONNECTED</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">main_size</span><span class="p">,</span>
				<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">LOGICAL_PAGE_DATA_SIZE</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">spare_size</span><span class="p">,</span>
				<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">LOGICAL_PAGE_SPARE_SIZE</span><span class="p">);</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICE_WIDTH</span><span class="p">);</span>
<span class="cp">#if SUPPORT_15BITECC</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ECC_CORRECTION</span><span class="p">);</span>
<span class="cp">#elif SUPPORT_8BITECC</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ECC_CORRECTION</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Spectra: Unknown Hynix NAND (Device ID: 0x%x).&quot;</span>
			<span class="s">&quot;Will use default parameter values instead.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">device_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* determines how many NAND chips are connected to the controller. Note for</span>
<span class="cm"> * Intel CE4100 devices we don&#39;t support more than one device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">find_valid_banks</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">id</span><span class="p">[</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">total_used_banks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">MODE_11</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="mi">0</span><span class="p">),</span> <span class="mh">0x90</span><span class="p">);</span>
		<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">MODE_11</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">index_addr_read_data</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">MODE_11</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="mi">2</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Return 1st ID for bank[%d]: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">id</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* WTF? */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">))</span>
				<span class="n">denali</span><span class="o">-&gt;</span><span class="n">total_used_banks</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">platform</span> <span class="o">==</span> <span class="n">INTEL_CE4100</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Platform limitations of the CE4100 device limit</span>
<span class="cm">		 * users to a single chip solution for NAND.</span>
<span class="cm">		 * Multichip support is not enabled.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">total_used_banks</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Sorry, Intel CE4100 only supports &quot;</span>
					<span class="s">&quot;a single NAND device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;denali-&gt;total_used_banks: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">total_used_banks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use the configuration feature register to determine the maximum number of</span>
<span class="cm"> * banks that the hardware supports.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">detect_max_banks</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">features</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">FEATURES</span><span class="p">);</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FEATURES__N_BANKS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">detect_partition_feature</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* For MRST platform, denali-&gt;fwblks represent the</span>
<span class="cm">	 * number of blocks firmware is taken,</span>
<span class="cm">	 * FW is in protect partition and MTD driver has no</span>
<span class="cm">	 * permission to access it. So let driver know how many</span>
<span class="cm">	 * blocks it can&#39;t touch.</span>
<span class="cm">	 * */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">FEATURES</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FEATURES__PARTITION</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">PERM_SRC_ID</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
			<span class="n">PERM_SRC_ID__SRCID</span><span class="p">)</span> <span class="o">==</span> <span class="n">SPECTRA_PARTITION_ID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">denali</span><span class="o">-&gt;</span><span class="n">fwblks</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">MIN_MAX_BANK</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
			      <span class="n">MIN_MAX_BANK__MIN_VALUE</span><span class="p">)</span> <span class="o">*</span>
			     <span class="n">denali</span><span class="o">-&gt;</span><span class="n">blksperchip</span><span class="p">)</span>
			    <span class="o">+</span>
			    <span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">MIN_BLK_ADDR</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span>
			    <span class="n">MIN_BLK_ADDR__VALUE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">denali</span><span class="o">-&gt;</span><span class="n">fwblks</span> <span class="o">=</span> <span class="n">SPECTRA_START_BLOCK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">fwblks</span> <span class="o">=</span> <span class="n">SPECTRA_START_BLOCK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="nf">denali_nand_timing_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">PASS</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">id_bytes</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">maf_id</span><span class="p">,</span> <span class="n">device_id</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;%s, Line %d, Function: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Use read id method to get device ID and other</span>
<span class="cm">	 * params. For some NAND chips, controller can&#39;t</span>
<span class="cm">	 * report the correct device ID by reading from</span>
<span class="cm">	 * DEVICE_ID register</span>
<span class="cm">	 * */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">MODE_11</span> <span class="o">|</span> <span class="n">BANK</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">);</span>
	<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">addr</span> <span class="o">|</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">);</span>
	<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">addr</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">index_addr_read_data</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">addr</span> <span class="o">|</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id_bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">maf_id</span> <span class="o">=</span> <span class="n">id_bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">device_id</span> <span class="o">=</span> <span class="n">id_bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ONFI_DEVICE_NO_OF_LUNS</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">ONFI_DEVICE_NO_OF_LUNS__ONFI_DEVICE</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ONFI 1.0 NAND */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">FAIL</span> <span class="o">==</span> <span class="n">get_onfi_nand_para</span><span class="p">(</span><span class="n">denali</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">FAIL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maf_id</span> <span class="o">==</span> <span class="mh">0xEC</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Samsung NAND */</span>
		<span class="n">get_samsung_nand_para</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">device_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maf_id</span> <span class="o">==</span> <span class="mh">0x98</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Toshiba NAND */</span>
		<span class="n">get_toshiba_nand_para</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maf_id</span> <span class="o">==</span> <span class="mh">0xAD</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Hynix NAND */</span>
		<span class="n">get_hynix_nand_para</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">device_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Dump timing register values:&quot;</span>
			<span class="s">&quot;acc_clks: %d, re_2_we: %d, re_2_re: %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;we_2_re: %d, addr_2_data: %d, rdwr_en_lo_cnt: %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;rdwr_en_hi_cnt: %d, cs_setup_cnt: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ACC_CLKS</span><span class="p">),</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RE_2_WE</span><span class="p">),</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RE_2_RE</span><span class="p">),</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">WE_2_RE</span><span class="p">),</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ADDR_2_DATA</span><span class="p">),</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RDWR_EN_LO_CNT</span><span class="p">),</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RDWR_EN_HI_CNT</span><span class="p">),</span>
			<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">CS_SETUP_CNT</span><span class="p">));</span>

	<span class="n">find_valid_banks</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>

	<span class="n">detect_partition_feature</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>

	<span class="cm">/* If the user specified to override the default timings</span>
<span class="cm">	 * with a specific ONFI mode, we apply those changes here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">onfi_timing_mode</span> <span class="o">!=</span> <span class="n">NAND_DEFAULT_TIMINGS</span><span class="p">)</span>
		<span class="n">nand_onfi_timing_set</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">onfi_timing_mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_set_intr_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
					<span class="kt">uint16_t</span> <span class="n">INT_ENABLE</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s, Line %d, Function: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">INT_ENABLE</span><span class="p">)</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">GLOBAL_INT_ENABLE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">GLOBAL_INT_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* validation function to verify that the controlling software is making</span>
<span class="cm"> * a valid request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_flash_bank_valid</span><span class="p">(</span><span class="kt">int</span> <span class="n">flash_bank</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">flash_bank</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flash_bank</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_irq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">int_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Disable global interrupts */</span>
	<span class="n">denali_set_intr_modes</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">int_mask</span> <span class="o">=</span> <span class="n">DENALI_IRQ_ALL</span><span class="p">;</span>

	<span class="cm">/* Clear all status bits */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0xFFFF</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">INTR_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="n">denali_irq_enable</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">int_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_irq_cleanup</span><span class="p">(</span><span class="kt">int</span> <span class="n">irqnum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">denali_set_intr_modes</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">irqnum</span><span class="p">,</span> <span class="n">denali</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
							<span class="kt">uint32_t</span> <span class="n">int_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">int_mask</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">INTR_EN</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* This function only returns when an interrupt that this driver cares about</span>
<span class="cm"> * occurs. This is to reduce the overhead of servicing interrupts</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">denali_irq_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_interrupt_status</span><span class="p">(</span><span class="n">denali</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DENALI_IRQ_ALL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Interrupts are cleared by writing a 1 to the appropriate status bit */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
							<span class="kt">uint32_t</span> <span class="n">irq_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">intr_status_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">intr_status_reg</span> <span class="o">=</span> <span class="n">INTR_STATUS</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">);</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">irq_mask</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">intr_status_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">read_interrupt_status</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="n">clear_interrupt</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">read_interrupt_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">intr_status_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">intr_status_reg</span> <span class="o">=</span> <span class="n">INTR_STATUS</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">intr_status_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is the interrupt service routine. It handles all interrupts</span>
<span class="cm"> * sent to this device. Note that on CE4100, this is a shared</span>
<span class="cm"> * interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">denali_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>

	<span class="cm">/* check to see if a valid NAND chip has</span>
<span class="cm">	 * been selected.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_flash_bank_valid</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* check to see if controller generated</span>
<span class="cm">		 * the interrupt, since this is a shared interrupt */</span>
		<span class="n">irq_status</span> <span class="o">=</span> <span class="n">denali_irq_detected</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* handle interrupt */</span>
			<span class="cm">/* first acknowledge it */</span>
			<span class="n">clear_interrupt</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">irq_status</span><span class="p">);</span>
			<span class="cm">/* store the status in the device context for someone</span>
<span class="cm">			   to read */</span>
			<span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_status</span> <span class="o">|=</span> <span class="n">irq_status</span><span class="p">;</span>
			<span class="cm">/* notify anyone who cares that it happened */</span>
			<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>
			<span class="cm">/* tell the OS that we&#39;ve handled this */</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define BANK(x) ((x) &lt;&lt; 24)</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="nf">wait_for_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">irq_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">comp_res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">retry</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">comp_res</span> <span class="o">=</span>
			<span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
		<span class="n">intr_status</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">irq_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">irq_mask</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
			<span class="cm">/* our interrupt was detected */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* these are not the interrupts you are looking for -</span>
<span class="cm">			 * need to wait again */</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
			<span class="n">retry</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">comp_res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">comp_res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* timeout */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;timeout occurred, status = 0x%x, mask = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">intr_status</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

		<span class="n">intr_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">intr_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This helper function setups the registers for ECC and whether or not</span>
<span class="cm"> * the spare area will be transferred. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_ecc_for_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ecc_en</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">transfer_spare</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ecc_en_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">transfer_spare_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set ECC, transfer spare bits if needed */</span>
	<span class="n">ecc_en_flag</span> <span class="o">=</span> <span class="n">ecc_en</span> <span class="o">?</span> <span class="n">ECC_ENABLE__FLAG</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">transfer_spare_flag</span> <span class="o">=</span> <span class="n">transfer_spare</span> <span class="o">?</span> <span class="n">TRANSFER_SPARE_REG__FLAG</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Enable spare area/ECC per user&#39;s request. */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">ecc_en_flag</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ECC_ENABLE</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">transfer_spare_flag</span><span class="p">,</span>
			<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">TRANSFER_SPARE_REG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* sends a pipeline command operation to the controller. See the Denali NAND</span>
<span class="cm"> * controller&#39;s user guide for more information (section 4.2.3.6).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_send_pipeline_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
							<span class="n">bool</span> <span class="n">ecc_en</span><span class="p">,</span>
							<span class="n">bool</span> <span class="n">transfer_spare</span><span class="p">,</span>
							<span class="kt">int</span> <span class="n">access_type</span><span class="p">,</span>
							<span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">PASS</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">page_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		 <span class="n">irq_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">DENALI_READ</span><span class="p">)</span>
		<span class="n">irq_mask</span> <span class="o">=</span> <span class="n">INTR_STATUS__LOAD_COMP</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">DENALI_WRITE</span><span class="p">)</span>
		<span class="n">irq_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">setup_ecc_for_xfer</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">ecc_en</span><span class="p">,</span> <span class="n">transfer_spare</span><span class="p">);</span>

	<span class="cm">/* clear interrupts */</span>
	<span class="n">clear_interrupts</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">BANK</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">)</span> <span class="o">|</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">DENALI_WRITE</span> <span class="o">&amp;&amp;</span> <span class="n">access_type</span> <span class="o">!=</span> <span class="n">SPARE_ACCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">MODE_01</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">DENALI_WRITE</span> <span class="o">&amp;&amp;</span> <span class="n">access_type</span> <span class="o">==</span> <span class="n">SPARE_ACCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* read spare area */</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">MODE_10</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">cmd</span><span class="p">,</span> <span class="n">access_type</span><span class="p">);</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">MODE_01</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">DENALI_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* setup page read request for access type */</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">MODE_10</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">cmd</span><span class="p">,</span> <span class="n">access_type</span><span class="p">);</span>

		<span class="cm">/* page 33 of the NAND controller spec indicates we should not</span>
<span class="cm">		   use the pipeline commands in Spare area only mode. So we</span>
<span class="cm">		   don&#39;t.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">access_type</span> <span class="o">==</span> <span class="n">SPARE_ACCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span> <span class="o">=</span> <span class="n">MODE_01</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
			<span class="n">iowrite32</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">cmd</span><span class="p">,</span>
					<span class="mh">0x2000</span> <span class="o">|</span> <span class="n">op</span> <span class="o">|</span> <span class="n">page_count</span><span class="p">);</span>

			<span class="cm">/* wait for command to be accepted</span>
<span class="cm">			 * can always use status0 bit as the</span>
<span class="cm">			 * mask is identical for each</span>
<span class="cm">			 * bank. */</span>
			<span class="n">irq_status</span> <span class="o">=</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;cmd, page, addr on timeout &quot;</span>
						<span class="s">&quot;(0x%x, 0x%x, 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">cmd</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">FAIL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cmd</span> <span class="o">=</span> <span class="n">MODE_01</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
				<span class="n">iowrite32</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* helper function that simply writes a buffer to the flash */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_data_to_flash_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
							<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
							<span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">buf32</span><span class="p">;</span>

	<span class="cm">/* verify that the len is a multiple of 4. see comment in</span>
<span class="cm">	 * read_data_from_flash_mem() */</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">len</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* write the data to the flash memory */</span>
	<span class="n">buf32</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="o">*</span><span class="n">buf32</span><span class="o">++</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span> <span class="cm">/* intent is to return the number of bytes read */</span>
<span class="p">}</span>

<span class="cm">/* helper function that simply reads a buffer from the flash */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_data_from_flash_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span>
								<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
								<span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">buf32</span><span class="p">;</span>

	<span class="cm">/* we assume that len will be a multiple of 4, if not</span>
<span class="cm">	 * it would be nice to know about it ASAP rather than</span>
<span class="cm">	 * have random failures...</span>
<span class="cm">	 * This assumption is based on the fact that this</span>
<span class="cm">	 * function is designed to be used to read flash pages,</span>
<span class="cm">	 * which are typically multiples of 4...</span>
<span class="cm">	 */</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">len</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* transfer the data from the flash */</span>
	<span class="n">buf32</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">buf32</span><span class="o">++</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span> <span class="cm">/* intent is to return the number of bytes read */</span>
<span class="p">}</span>

<span class="cm">/* writes OOB data to the device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_oob_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="n">INTR_STATUS__PROGRAM_COMP</span> <span class="o">|</span>
						<span class="n">INTR_STATUS__PROGRAM_FAIL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">denali_send_pipeline_cmd</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">SPARE_ACCESS</span><span class="p">,</span>
							<span class="n">DENALI_WRITE</span><span class="p">)</span> <span class="o">==</span> <span class="n">PASS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_data_to_flash_mem</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">);</span>

		<span class="cm">/* wait for operation to complete */</span>
		<span class="n">irq_status</span> <span class="o">=</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;OOB write failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to send pipeline command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* reads OOB data from the device */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_oob_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="n">INTR_STATUS__LOAD_COMP</span><span class="p">,</span>
			 <span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">denali_send_pipeline_cmd</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">SPARE_ACCESS</span><span class="p">,</span>
							<span class="n">DENALI_READ</span><span class="p">)</span> <span class="o">==</span> <span class="n">PASS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_data_from_flash_mem</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">);</span>

		<span class="cm">/* wait for command to be accepted</span>
<span class="cm">		 * can always use status0 bit as the mask is identical for each</span>
<span class="cm">		 * bank. */</span>
		<span class="n">irq_status</span> <span class="o">=</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;page on OOB timeout %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/* We set the device back to MAIN_ACCESS here as I observed</span>
<span class="cm">		 * instability with the controller if you do a block erase</span>
<span class="cm">		 * and the last transaction was a SPARE_ACCESS. Block erase</span>
<span class="cm">		 * is reliable (according to the MTD test infrastructure)</span>
<span class="cm">		 * if you are in MAIN_ACCESS.</span>
<span class="cm">		 */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">BANK</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">)</span> <span class="o">|</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">MODE_10</span> <span class="o">|</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">cmd</span><span class="p">,</span> <span class="n">MAIN_ACCESS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* this function examines buffers to see if they contain data that</span>
<span class="cm"> * indicate that the buffer is part of an erased region of flash.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">is_erased</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define ECC_SECTOR_SIZE 512</span>

<span class="cp">#define ECC_SECTOR(x)	(((x) &amp; ECC_ERROR_ADDRESS__SECTOR_NR) &gt;&gt; 12)</span>
<span class="cp">#define ECC_BYTE(x)	(((x) &amp; ECC_ERROR_ADDRESS__OFFSET))</span>
<span class="cp">#define ECC_CORRECTION_VALUE(x) ((x) &amp; ERR_CORRECTION_INFO__BYTEMASK)</span>
<span class="cp">#define ECC_ERROR_CORRECTABLE(x) (!((x) &amp; ERR_CORRECTION_INFO__ERROR_TYPE))</span>
<span class="cp">#define ECC_ERR_DEVICE(x)	(((x) &amp; ERR_CORRECTION_INFO__DEVICE_NR) &gt;&gt; 8)</span>
<span class="cp">#define ECC_LAST_ERR(x)		((x) &amp; ERR_CORRECTION_INFO__LAST_ERR_INFO)</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">handle_ecc</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		       <span class="kt">uint32_t</span> <span class="n">irq_status</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">max_bitflips</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">check_erased_page</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitflips</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">INTR_STATUS__ECC_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* read the ECC errors. we&#39;ll ignore them for now */</span>
		<span class="kt">uint32_t</span> <span class="n">err_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err_correction_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">err_byte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err_sector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err_device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">err_correction_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">denali_set_intr_modes</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">err_address</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span>
						<span class="n">ECC_ERROR_ADDRESS</span><span class="p">);</span>
			<span class="n">err_sector</span> <span class="o">=</span> <span class="n">ECC_SECTOR</span><span class="p">(</span><span class="n">err_address</span><span class="p">);</span>
			<span class="n">err_byte</span> <span class="o">=</span> <span class="n">ECC_BYTE</span><span class="p">(</span><span class="n">err_address</span><span class="p">);</span>

			<span class="n">err_correction_info</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span>
						<span class="n">ERR_CORRECTION_INFO</span><span class="p">);</span>
			<span class="n">err_correction_value</span> <span class="o">=</span>
				<span class="n">ECC_CORRECTION_VALUE</span><span class="p">(</span><span class="n">err_correction_info</span><span class="p">);</span>
			<span class="n">err_device</span> <span class="o">=</span> <span class="n">ECC_ERR_DEVICE</span><span class="p">(</span><span class="n">err_correction_info</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ECC_ERROR_CORRECTABLE</span><span class="p">(</span><span class="n">err_correction_info</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* If err_byte is larger than ECC_SECTOR_SIZE,</span>
<span class="cm">				 * means error happened in OOB, so we ignore</span>
<span class="cm">				 * it. It&#39;s no need for us to correct it</span>
<span class="cm">				 * err_device is represented the NAND error</span>
<span class="cm">				 * bits are happened in if there are more</span>
<span class="cm">				 * than one NAND connected.</span>
<span class="cm">				 * */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err_byte</span> <span class="o">&lt;</span> <span class="n">ECC_SECTOR_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
					<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">err_sector</span> <span class="o">*</span>
							<span class="n">ECC_SECTOR_SIZE</span> <span class="o">+</span>
							<span class="n">err_byte</span><span class="p">)</span> <span class="o">*</span>
							<span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">+</span>
							<span class="n">err_device</span><span class="p">;</span>
					<span class="cm">/* correct the ECC error */</span>
					<span class="n">buf</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">^=</span> <span class="n">err_correction_value</span><span class="p">;</span>
					<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">ecc_stats</span><span class="p">.</span><span class="n">corrected</span><span class="o">++</span><span class="p">;</span>
					<span class="n">bitflips</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* if the error is not correctable, need to</span>
<span class="cm">				 * look at the page to see if it is an erased</span>
<span class="cm">				 * page. if so, then it&#39;s not a real ECC error</span>
<span class="cm">				 * */</span>
				<span class="n">check_erased_page</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ECC_LAST_ERR</span><span class="p">(</span><span class="n">err_correction_info</span><span class="p">));</span>
		<span class="cm">/* Once handle all ecc errors, controller will triger</span>
<span class="cm">		 * a ECC_TRANSACTION_DONE interrupt, so here just wait</span>
<span class="cm">		 * for a while for this interrupt</span>
<span class="cm">		 * */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">read_interrupt_status</span><span class="p">(</span><span class="n">denali</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">INTR_STATUS__ECC_TRANSACTION_DONE</span><span class="p">))</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">clear_interrupts</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
		<span class="n">denali_set_intr_modes</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">max_bitflips</span> <span class="o">=</span> <span class="n">bitflips</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">check_erased_page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* programs the controller to either enable/disable DMA transfers */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_enable_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span> <span class="n">bool</span> <span class="n">en</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">reg_val</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">en</span><span class="p">)</span>
		<span class="n">reg_val</span> <span class="o">=</span> <span class="n">DMA_ENABLE__FLAG</span><span class="p">;</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="n">reg_val</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DMA_ENABLE</span><span class="p">);</span>
	<span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DMA_ENABLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* setups the HW to perform the data DMA */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_setup_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">page_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_buf</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">MODE_10</span> <span class="o">|</span> <span class="n">BANK</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">);</span>

	<span class="cm">/* DMA is a four step process */</span>

	<span class="cm">/* 1. setup transfer type and # of pages */</span>
	<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mh">0x2000</span> <span class="o">|</span> <span class="n">op</span> <span class="o">|</span> <span class="n">page_count</span><span class="p">);</span>

	<span class="cm">/* 2. set memory high address bits 23:8 */</span>
	<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="p">((</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="mh">0x2200</span><span class="p">);</span>

	<span class="cm">/* 3. set memory low address bits 23:8 */</span>
	<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="p">((</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="mh">0x2300</span><span class="p">);</span>

	<span class="cm">/* 4.  interrupt when complete, burst len = 64 bytes*/</span>
	<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="mh">0x14000</span><span class="p">,</span> <span class="mh">0x2400</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* writes a page. user specifies type, and this function handles the</span>
<span class="cm"> * configuration details. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">bool</span> <span class="n">raw_xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">+</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="n">INTR_STATUS__DMA_CMD_COMP</span> <span class="o">|</span>
						<span class="n">INTR_STATUS__PROGRAM_FAIL</span><span class="p">;</span>

	<span class="cm">/* if it is a raw xfer, we want to disable ecc, and send</span>
<span class="cm">	 * the spare area.</span>
<span class="cm">	 * !raw_xfer - enable ecc</span>
<span class="cm">	 * raw_xfer - transfer spare</span>
<span class="cm">	 */</span>
	<span class="n">setup_ecc_for_xfer</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="o">!</span><span class="n">raw_xfer</span><span class="p">,</span> <span class="n">raw_xfer</span><span class="p">);</span>

	<span class="cm">/* copy buffer into DMA buffer */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">raw_xfer</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* transfer the data to the spare area */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span>
			<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="n">clear_interrupts</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="n">denali_enable_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">denali_setup_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">DENALI_WRITE</span><span class="p">);</span>

	<span class="cm">/* wait for operation to complete */</span>
	<span class="n">irq_status</span> <span class="o">=</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;timeout on write_page (type = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">raw_xfer</span><span class="p">);</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">INTR_STATUS__PROGRAM_FAIL</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">NAND_STATUS_FAIL</span> <span class="o">:</span> <span class="n">PASS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">denali_enable_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* NAND core entry points */</span>

<span class="cm">/* this is the callback that the NAND core calls to write a page. Since</span>
<span class="cm"> * writing a page with ECC or without is similar, all the work is done</span>
<span class="cm"> * by write_page above.</span>
<span class="cm"> * */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_write_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* for regular page writes, we let HW handle all the ECC</span>
<span class="cm">	 * data written to the device. */</span>
	<span class="n">write_page</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is the callback that the NAND core calls to write a page without ECC.</span>
<span class="cm"> * raw access is similar to ECC page writes, so all the work is done in the</span>
<span class="cm"> * write_page() function above.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_write_page_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* for raw page writes, we want to disable ECC and simply write</span>
<span class="cm">	   whatever data is in the buffer. */</span>
	<span class="n">write_page</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_write_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">write_oob_data</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_read_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">read_oob_data</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_read_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
			    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_bitflips</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">+</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="n">INTR_STATUS__ECC_TRANSACTION_DONE</span> <span class="o">|</span>
			    <span class="n">INTR_STATUS__ECC_ERR</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">check_erased_page</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IN %s: page %d is not&quot;</span>
				<span class="s">&quot; equal to denali-&gt;page %d, investigate!!&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">setup_ecc_for_xfer</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">denali_enable_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="n">clear_interrupts</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="n">denali_setup_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">DENALI_READ</span><span class="p">);</span>

	<span class="cm">/* wait for operation to complete */</span>
	<span class="n">irq_status</span> <span class="o">=</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

	<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">);</span>

	<span class="n">check_erased_page</span> <span class="o">=</span> <span class="n">handle_ecc</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">irq_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_bitflips</span><span class="p">);</span>
	<span class="n">denali_enable_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_erased_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_oob_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/* check ECC failures that may have occurred on erased pages */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_erased_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_erased</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span><span class="p">))</span>
				<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">ecc_stats</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_erased</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span><span class="p">))</span>
				<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">ecc_stats</span><span class="p">.</span><span class="n">failed</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">max_bitflips</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_read_page_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">+</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="n">INTR_STATUS__DMA_CMD_COMP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IN %s: page %d is not&quot;</span>
				<span class="s">&quot; equal to denali-&gt;page %d, investigate!!&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">setup_ecc_for_xfer</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">denali_enable_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="n">clear_interrupts</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="n">denali_setup_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">DENALI_READ</span><span class="p">);</span>

	<span class="cm">/* wait for operation to complete */</span>
	<span class="n">irq_status</span> <span class="o">=</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">irq_mask</span><span class="p">);</span>

	<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

	<span class="n">denali_enable_dma</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">denali_read_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">head</span> <span class="o">&lt;</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">head</span><span class="o">++</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_select_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_waitfunc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="kt">uint32_t</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* clear interrupts */</span>
	<span class="n">clear_interrupts</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>

	<span class="cm">/* setup page read request for access type */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">MODE_10</span> <span class="o">|</span> <span class="n">BANK</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">)</span> <span class="o">|</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">cmd</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>

	<span class="cm">/* wait for erase to complete or failure to occur */</span>
	<span class="n">irq_status</span> <span class="o">=</span> <span class="n">wait_for_irq</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">INTR_STATUS__ERASE_COMP</span> <span class="o">|</span>
					<span class="n">INTR_STATUS__ERASE_FAIL</span><span class="p">);</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">irq_status</span> <span class="o">&amp;</span> <span class="n">INTR_STATUS__ERASE_FAIL</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">NAND_STATUS_FAIL</span> <span class="o">:</span> <span class="n">PASS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_cmdfunc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NAND_CMD_PAGEPROG</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_CMD_STATUS</span>:
		<span class="n">read_status</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_CMD_READID</span>:
	<span class="k">case</span> <span class="n">NAND_CMD_PARAM</span>:
		<span class="n">reset_buf</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
		<span class="cm">/*sometimes ManufactureId read from register is not right</span>
<span class="cm">		 * e.g. some of Micron MT29F32G08QAA MLC NAND chips</span>
<span class="cm">		 * So here we send READID cmd to NAND insteand</span>
<span class="cm">		 * */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">MODE_11</span> <span class="o">|</span> <span class="n">BANK</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span><span class="p">);</span>
		<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">addr</span> <span class="o">|</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">);</span>
		<span class="n">index_addr</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">addr</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">index_addr_read_data</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">addr</span> <span class="o">|</span> <span class="mi">2</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
			<span class="n">write_byte_to_buf</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_CMD_READ0</span>:
	<span class="k">case</span> <span class="n">NAND_CMD_SEQIN</span>:
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_CMD_RESET</span>:
		<span class="n">reset_bank</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_CMD_READOOB</span>:
		<span class="cm">/* TODO: Read OOB data */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;: unsupported command&quot;</span>
				<span class="s">&quot; received 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* stubs for ECC functions not used by the NAND core */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_ecc_calculate</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ecc_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;denali_ecc_calculate called unexpectedly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_ecc_correct</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">read_ecc</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">calc_ecc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;denali_ecc_correct called unexpectedly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_ecc_hwctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">mtd_to_denali</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;denali_ecc_hwctl called unexpectedly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/* end NAND core entry points */</span>

<span class="cm">/* Initialization code to bring the device up to a known good state */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_hw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* tell driver how many bit controller will skip before</span>
<span class="cm">	 * writing ECC code in OOB, this register may be already</span>
<span class="cm">	 * set by firmware. So we read this value out.</span>
<span class="cm">	 * if this value is 0, just let it be.</span>
<span class="cm">	 * */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">bbtskipbytes</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span>
						<span class="n">SPARE_AREA_SKIP_BYTES</span><span class="p">);</span>
	<span class="n">detect_max_banks</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="n">denali_nand_reset</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x0F</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">RB_PIN_ENABLED</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">CHIP_EN_DONT_CARE__FLAG</span><span class="p">,</span>
			<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">CHIP_ENABLE_DONT_CARE</span><span class="p">);</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">SPARE_AREA_MARKER</span><span class="p">);</span>

	<span class="cm">/* Should set value for these registers when init */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">TWO_ROW_ADDR_CYCLES</span><span class="p">);</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ECC_ENABLE</span><span class="p">);</span>
	<span class="n">denali_nand_timing_set</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="n">denali_irq_init</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Althogh controller spec said SLC ECC is forceb to be 4bit,</span>
<span class="cm"> * but denali controller in MRST only support 15bit and 8bit ECC</span>
<span class="cm"> * correction</span>
<span class="cm"> * */</span>
<span class="cp">#define ECC_8BITS	14</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="n">nand_8bit_oob</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">eccbytes</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define ECC_15BITS	26</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="n">nand_15bit_oob</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">eccbytes</span> <span class="o">=</span> <span class="mi">26</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">bbt_pattern</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">mirror_pattern</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span> <span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="n">bbt_main_descr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">NAND_BBT_LASTBLOCK</span> <span class="o">|</span> <span class="n">NAND_BBT_CREATE</span> <span class="o">|</span> <span class="n">NAND_BBT_WRITE</span>
		<span class="o">|</span> <span class="n">NAND_BBT_2BIT</span> <span class="o">|</span> <span class="n">NAND_BBT_VERSION</span> <span class="o">|</span> <span class="n">NAND_BBT_PERCHIP</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offs</span> <span class="o">=</span>	<span class="mi">8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">veroffs</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="p">.</span><span class="n">maxblocks</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">bbt_pattern</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="n">bbt_mirror_descr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">NAND_BBT_LASTBLOCK</span> <span class="o">|</span> <span class="n">NAND_BBT_CREATE</span> <span class="o">|</span> <span class="n">NAND_BBT_WRITE</span>
		<span class="o">|</span> <span class="n">NAND_BBT_2BIT</span> <span class="o">|</span> <span class="n">NAND_BBT_VERSION</span> <span class="o">|</span> <span class="n">NAND_BBT_PERCHIP</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offs</span> <span class="o">=</span>	<span class="mi">8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">veroffs</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="p">.</span><span class="n">maxblocks</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">mirror_pattern</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* initialize driver data structures */</span>
<span class="kt">void</span> <span class="nf">denali_drv_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* setup interrupt handler */</span>
	<span class="cm">/* the completion object will be used to notify</span>
<span class="cm">	 * the callee that the interrupt is done */</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">);</span>

	<span class="cm">/* the spinlock will be used to synchronize the ISR</span>
<span class="cm">	 * with any element that might be access shared</span>
<span class="cm">	 * data (interrupt status) */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_lock</span><span class="p">);</span>

	<span class="cm">/* indicate that MTD has not selected a valid bank yet */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_bank</span> <span class="o">=</span> <span class="n">CHIP_SELECT_INVALID</span><span class="p">;</span>

	<span class="cm">/* initialize our irq_status variable to indicate no interrupts */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">irq_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* driver entry point */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">denali_pci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">csr_base</span><span class="p">,</span> <span class="n">mem_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">csr_len</span><span class="p">,</span> <span class="n">mem_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span><span class="p">;</span>

	<span class="n">denali</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">denali</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">denali</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Spectra: pci_enable_device failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_alloc_memery</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">==</span> <span class="n">INTEL_CE4100</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Due to a silicon limitation, we can only support</span>
<span class="cm">		 * ONFI timing mode 1 and below.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">onfi_timing_mode</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">onfi_timing_mode</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Intel CE4100 only supports&quot;</span>
					<span class="s">&quot; ONFI timing mode 1 or below</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failed_enable_dev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">platform</span> <span class="o">=</span> <span class="n">INTEL_CE4100</span><span class="p">;</span>
		<span class="n">mem_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mem_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">csr_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">csr_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">platform</span> <span class="o">=</span> <span class="n">INTEL_MRST</span><span class="p">;</span>
		<span class="n">csr_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">csr_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mem_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mem_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mem_base</span> <span class="o">=</span> <span class="n">csr_base</span> <span class="o">+</span> <span class="n">csr_len</span><span class="p">;</span>
			<span class="n">mem_len</span> <span class="o">=</span> <span class="n">csr_len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Is 32-bit DMA supported? */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Spectra: no usable DMA configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_enable_dev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_buf</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span>
					     <span class="n">DENALI_BUF_SIZE</span><span class="p">,</span>
					     <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Spectra: failed to map DMA buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_enable_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">DENALI_NAND_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Spectra: Unable to request memory regions</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_dma_map</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">csr_base</span><span class="p">,</span> <span class="n">csr_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Spectra: Unable to remap memory region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed_req_regions</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">mem_base</span><span class="p">,</span> <span class="n">mem_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Spectra: ioremap_nocache failed!&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed_remap_reg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">denali_hw_init</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="n">denali_drv_init</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>

	<span class="cm">/* denali_isr register is done after all the hardware</span>
<span class="cm">	 * initilization is finished*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">denali_isr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="n">DENALI_NAND_NAME</span><span class="p">,</span> <span class="n">denali</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Spectra: Unable to allocate IRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed_remap_mem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* now that our ISR is registered, we can enable interrupts */</span>
	<span class="n">denali_set_intr_modes</span><span class="p">(</span><span class="n">denali</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">denali</span><span class="p">);</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;denali-nand&quot;</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">priv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">;</span>

	<span class="cm">/* register the driver with the NAND core subsystem */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">select_chip</span> <span class="o">=</span> <span class="n">denali_select_chip</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">cmdfunc</span> <span class="o">=</span> <span class="n">denali_cmdfunc</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">read_byte</span> <span class="o">=</span> <span class="n">denali_read_byte</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">waitfunc</span> <span class="o">=</span> <span class="n">denali_waitfunc</span><span class="p">;</span>

	<span class="cm">/* scan for NAND devices attached to the controller</span>
<span class="cm">	 * this is the first stage in a two step process to register</span>
<span class="cm">	 * with the nand subsystem */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nand_scan_ident</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">max_banks</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed_req_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* MTD supported page sizes vary by kernel. We validate our</span>
<span class="cm">	 * kernel supports the device here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">&gt;</span> <span class="n">NAND_MAX_PAGESIZE</span> <span class="o">+</span> <span class="n">NAND_MAX_OOBSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Spectra: device size not supported by this &quot;</span>
			<span class="s">&quot;version of MTD.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_req_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* support for multi nand</span>
<span class="cm">	 * MTD known nothing about multi nand,</span>
<span class="cm">	 * so we should tell it the real pagesize</span>
<span class="cm">	 * and anything necessery</span>
<span class="cm">	 */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">DEVICES_CONNECTED</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">chipsize</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">page_shift</span> <span class="o">+=</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">pagemask</span> <span class="o">=</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">chipsize</span> <span class="o">&gt;&gt;</span>
						<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">page_shift</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">bbt_erase_shift</span> <span class="o">+=</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">phys_erase_shift</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">bbt_erase_shift</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">chip_shift</span> <span class="o">+=</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">erasesize</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">numchips</span> <span class="o">*</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">chipsize</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">bbtskipbytes</span> <span class="o">*=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>

	<span class="cm">/* second stage of the NAND scan</span>
<span class="cm">	 * this stage requires information regarding ECC and</span>
<span class="cm">	 * bad block management. */</span>

	<span class="cm">/* Bad block management */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">bbt_td</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bbt_main_descr</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">bbt_md</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bbt_mirror_descr</span><span class="p">;</span>

	<span class="cm">/* skip the scan for now until we have OOB read and write support */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">bbt_options</span> <span class="o">|=</span> <span class="n">NAND_BBT_USE_FLASH</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">NAND_SKIP_BBTSCAN</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">NAND_ECC_HW_SYNDROME</span><span class="p">;</span>

	<span class="cm">/* Denali Controller only support 15bit and 8bit ECC in MRST,</span>
<span class="cm">	 * so just let controller do 15bit ECC for MLC and 8bit ECC for</span>
<span class="cm">	 * SLC if possible.</span>
<span class="cm">	 * */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">cellinfo</span> <span class="o">&amp;</span> <span class="mh">0xc</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">bbtskipbytes</span> <span class="o">+</span>
			<span class="n">ECC_15BITS</span> <span class="o">*</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">/</span>
			<span class="n">ECC_SECTOR_SIZE</span><span class="p">))))</span> <span class="p">{</span>
		<span class="cm">/* if MLC OOB size is large enough, use 15bit ECC*/</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nand_15bit_oob</span><span class="p">;</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">ECC_15BITS</span><span class="p">;</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ECC_CORRECTION</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">bbtskipbytes</span> <span class="o">+</span>
			<span class="n">ECC_8BITS</span> <span class="o">*</span> <span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">/</span>
			<span class="n">ECC_SECTOR_SIZE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Your NAND chip OOB is not large enough to&quot;</span>
				<span class="s">&quot; contain 8bit ECC correction codes&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_req_irq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nand_8bit_oob</span><span class="p">;</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">ECC_8BITS</span><span class="p">;</span>
		<span class="n">iowrite32</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span> <span class="o">+</span> <span class="n">ECC_CORRECTION</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">bytes</span> <span class="o">*=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">strength</span> <span class="o">*=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">eccbytes</span> <span class="o">*=</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">/</span> <span class="n">ECC_SECTOR_SIZE</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">oobfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">bbtskipbytes</span> <span class="o">+</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">eccbytes</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">oobfree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span> <span class="o">-</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">eccbytes</span> <span class="o">-</span>
		<span class="n">denali</span><span class="o">-&gt;</span><span class="n">bbtskipbytes</span><span class="p">;</span>

	<span class="cm">/* Let driver know the total blocks number and</span>
<span class="cm">	 * how many blocks contained by each nand chip.</span>
<span class="cm">	 * blksperchip will help driver to know how many</span>
<span class="cm">	 * blocks is taken by FW.</span>
<span class="cm">	 * */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">totalblks</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;&gt;</span>
				<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">phys_erase_shift</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">blksperchip</span> <span class="o">=</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">totalblks</span> <span class="o">/</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">numchips</span><span class="p">;</span>

	<span class="cm">/* These functions are required by the NAND core framework, otherwise,</span>
<span class="cm">	 * the NAND core will assert. However, we don&#39;t need them, so we&#39;ll stub</span>
<span class="cm">	 * them out. */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">calculate</span> <span class="o">=</span> <span class="n">denali_ecc_calculate</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">correct</span> <span class="o">=</span> <span class="n">denali_ecc_correct</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">hwctl</span> <span class="o">=</span> <span class="n">denali_ecc_hwctl</span><span class="p">;</span>

	<span class="cm">/* override the default read operations */</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">ECC_SECTOR_SIZE</span> <span class="o">*</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">read_page</span> <span class="o">=</span> <span class="n">denali_read_page</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">read_page_raw</span> <span class="o">=</span> <span class="n">denali_read_page_raw</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">write_page</span> <span class="o">=</span> <span class="n">denali_write_page</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">write_page_raw</span> <span class="o">=</span> <span class="n">denali_write_page_raw</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">read_oob</span> <span class="o">=</span> <span class="n">denali_read_oob</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">write_oob</span> <span class="o">=</span> <span class="n">denali_write_oob</span><span class="p">;</span>
	<span class="n">denali</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">erase_cmd</span> <span class="o">=</span> <span class="n">denali_erase</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nand_scan_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed_req_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Spectra: Failed to register MTD: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_req_irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">failed_req_irq:</span>
	<span class="n">denali_irq_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">denali</span><span class="p">);</span>
<span class="nl">failed_remap_mem:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">);</span>
<span class="nl">failed_remap_reg:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span><span class="p">);</span>
<span class="nl">failed_req_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">failed_dma_map:</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_buf</span><span class="p">,</span> <span class="n">DENALI_BUF_SIZE</span><span class="p">,</span>
			 <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
<span class="nl">failed_enable_dev:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">failed_alloc_memery:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* driver exit point */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">denali_pci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">denali_nand_info</span> <span class="o">*</span><span class="n">denali</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">nand_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">denali_irq_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">denali</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_reg</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">denali</span><span class="o">-&gt;</span><span class="n">flash_mem</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">denali</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">dma_buf</span><span class="p">,</span> <span class="n">DENALI_BUF_SIZE</span><span class="p">,</span>
			 <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">denali</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">denali_pci_ids</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">denali_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DENALI_NAND_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">denali_pci_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">denali_pci_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">denali_pci_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_pci_driver</span><span class="p">(</span><span class="n">denali_pci_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
