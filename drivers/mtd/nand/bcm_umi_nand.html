<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › nand › bcm_umi_nand.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bcm_umi_nand.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*****************************************************************************</span>
<span class="cm">* Copyright 2004 - 2009 Broadcom Corporation.  All rights reserved.</span>
<span class="cm">*</span>
<span class="cm">* Unless you and Broadcom execute a separate written software license</span>
<span class="cm">* agreement governing use of this software, this software is licensed to you</span>
<span class="cm">* under the terms of the GNU General Public License version 2, available at</span>
<span class="cm">* http://www.broadcom.com/licenses/GPLv2.php (the &quot;GPL&quot;).</span>
<span class="cm">*</span>
<span class="cm">* Notwithstanding the above, under no circumstances may you combine this</span>
<span class="cm">* software in any way with any other Broadcom software provided under a</span>
<span class="cm">* license other than the GPL, without Broadcom&#39;s express prior written</span>
<span class="cm">* consent.</span>
<span class="cm">*****************************************************************************/</span>

<span class="cm">/* ---- Include Files ---------------------------------------------------- */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nand.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nand_ecc.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/partitions.h&gt;</span>

<span class="cp">#include &lt;asm/mach-types.h&gt;</span>

<span class="cp">#include &lt;mach/reg_nand.h&gt;</span>
<span class="cp">#include &lt;mach/reg_umi.h&gt;</span>

<span class="cp">#include &quot;nand_bcm_umi.h&quot;</span>

<span class="cp">#include &lt;mach/memory_settings.h&gt;</span>

<span class="cp">#define USE_DMA 1</span>
<span class="cp">#include &lt;mach/dma.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>

<span class="cm">/* ---- External Variable Declarations ----------------------------------- */</span>
<span class="cm">/* ---- External Function Prototypes ------------------------------------- */</span>
<span class="cm">/* ---- Public Variables ------------------------------------------------- */</span>
<span class="cm">/* ---- Private Constants and Types -------------------------------------- */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">__devinitconst</span> <span class="kt">char</span> <span class="n">gBanner</span><span class="p">[]</span> <span class="o">=</span> <span class="n">KERN_INFO</span> \
	<span class="s">&quot;BCM UMI MTD NAND Driver: 1.00</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#if NAND_ECC_BCH</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">scan_ff_pattern</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xff</span> <span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="n">largepage_bbt</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">scan_ff_pattern</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm">** Preallocate a buffer to avoid having to do this every dma operation.</span>
<span class="cm">** This is the size of the preallocated coherent DMA buffer.</span>
<span class="cm">*/</span>
<span class="cp">#if USE_DMA</span>
<span class="cp">#define DMA_MIN_BUFLEN	512</span>
<span class="cp">#define DMA_MAX_BUFLEN	PAGE_SIZE</span>
<span class="cp">#define USE_DIRECT_IO(len)	(((len) &lt; DMA_MIN_BUFLEN) || \</span>
<span class="cp">	((len) &gt; DMA_MAX_BUFLEN))</span>

<span class="cm">/*</span>
<span class="cm"> * The current NAND data space goes from 0x80001900 to 0x80001FFF,</span>
<span class="cm"> * which is only 0x700 = 1792 bytes long. This is too small for 2K, 4K page</span>
<span class="cm"> * size NAND flash. Need to break the DMA down to multiple 1Ks.</span>
<span class="cm"> *</span>
<span class="cm"> * Need to make sure REG_NAND_DATA_PADDR + DMA_MAX_LEN &lt; 0x80002000</span>
<span class="cm"> */</span>
<span class="cp">#define DMA_MAX_LEN             1024</span>

<span class="cp">#else </span><span class="cm">/* !USE_DMA */</span><span class="cp"></span>
<span class="cp">#define DMA_MIN_BUFLEN          0</span>
<span class="cp">#define DMA_MAX_BUFLEN          0</span>
<span class="cp">#define USE_DIRECT_IO(len)      1</span>
<span class="cp">#endif</span>
<span class="cm">/* ---- Private Function Prototypes -------------------------------------- */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">bcm_umi_nand_read_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">bcm_umi_nand_write_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* ---- Private Variables ------------------------------------------------ */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">board_mtd</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bcm_umi_io_base</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">virtPtr</span><span class="p">;</span>
<span class="k">static</span> <span class="n">dma_addr_t</span> <span class="n">physPtr</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">completion</span> <span class="n">nand_comp</span><span class="p">;</span>

<span class="cm">/* ---- Private Functions ------------------------------------------------ */</span>
<span class="cp">#if NAND_ECC_BCH</span>
<span class="cp">#include &quot;bcm_umi_bch.c&quot;</span>
<span class="cp">#else</span>
<span class="cp">#include &quot;bcm_umi_hamming.c&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#if USE_DMA</span>

<span class="cm">/* Handler called when the DMA finishes. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_dma_handler</span><span class="p">(</span><span class="n">DMA_Device_t</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">userData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nand_comp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_dma_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">dma_set_device_handler</span><span class="p">(</span><span class="n">DMA_DEVICE_NAND_MEM_TO_MEM</span><span class="p">,</span>
		<span class="n">nand_dma_handler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;dma_set_device_handler failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">virtPtr</span> <span class="o">=</span>
	    <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_MAX_BUFLEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">physPtr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">virtPtr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NAND - Failed to allocate memory for DMA buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_dma_term</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">virtPtr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">DMA_MAX_BUFLEN</span><span class="p">,</span> <span class="n">virtPtr</span><span class="p">,</span> <span class="n">physPtr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_dma_read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len_left</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">DMA_Handle_t</span> <span class="n">hndl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virtPtr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;nand_dma_read: virtPtr == NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">physPtr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;nand_dma_read: physPtr == NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">hndl</span> <span class="o">=</span> <span class="n">dma_request_channel</span><span class="p">(</span><span class="n">DMA_DEVICE_NAND_MEM_TO_MEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hndl</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;nand_dma_read: unable to allocate dma channel: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">hndl</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len_left</span> <span class="o">&gt;</span> <span class="n">DMA_MAX_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp_len</span> <span class="o">=</span> <span class="n">DMA_MAX_LEN</span><span class="p">;</span>
			<span class="n">len_left</span> <span class="o">-=</span> <span class="n">DMA_MAX_LEN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tmp_len</span> <span class="o">=</span> <span class="n">len_left</span><span class="p">;</span>
			<span class="n">len_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nand_comp</span><span class="p">);</span>
		<span class="n">dma_transfer_mem_to_mem</span><span class="p">(</span><span class="n">hndl</span><span class="p">,</span> <span class="n">REG_NAND_DATA_PADDR</span><span class="p">,</span>
					<span class="n">physPtr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">tmp_len</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nand_comp</span><span class="p">);</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">tmp_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dma_free_channel</span><span class="p">(</span><span class="n">hndl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">virtPtr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_dma_write</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len_left</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">DMA_Handle_t</span> <span class="n">hndl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;nand_dma_write: buf == NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virtPtr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;nand_dma_write: virtPtr == NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">physPtr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;nand_dma_write: physPtr == NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">virtPtr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>


	<span class="n">hndl</span> <span class="o">=</span> <span class="n">dma_request_channel</span><span class="p">(</span><span class="n">DMA_DEVICE_NAND_MEM_TO_MEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hndl</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;nand_dma_write: unable to allocate dma channel: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">hndl</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len_left</span> <span class="o">&gt;</span> <span class="n">DMA_MAX_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp_len</span> <span class="o">=</span> <span class="n">DMA_MAX_LEN</span><span class="p">;</span>
			<span class="n">len_left</span> <span class="o">-=</span> <span class="n">DMA_MAX_LEN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tmp_len</span> <span class="o">=</span> <span class="n">len_left</span><span class="p">;</span>
			<span class="n">len_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nand_comp</span><span class="p">);</span>
		<span class="n">dma_transfer_mem_to_mem</span><span class="p">(</span><span class="n">hndl</span><span class="p">,</span> <span class="n">physPtr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
					<span class="n">REG_NAND_DATA_PADDR</span><span class="p">,</span> <span class="n">tmp_len</span><span class="p">);</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nand_comp</span><span class="p">);</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">tmp_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dma_free_channel</span><span class="p">(</span><span class="n">hndl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_dev_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nand_bcm_umi_dev_ready</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">*  bcm_umi_nand_inithw</span>
<span class="cm">*</span>
<span class="cm">*   This routine does the necessary hardware (board-specific)</span>
<span class="cm">*   initializations.  This includes setting up the timings, etc.</span>
<span class="cm">*</span>
<span class="cm">***************************************************************************/</span>
<span class="kt">int</span> <span class="nf">bcm_umi_nand_inithw</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Configure nand timing parameters */</span>
	<span class="n">REG_UMI_NAND_TCR</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x7ffff</span><span class="p">;</span>
	<span class="n">REG_UMI_NAND_TCR</span> <span class="o">|=</span> <span class="n">HW_CFG_NAND_TCR</span><span class="p">;</span>

<span class="cp">#if !defined(CONFIG_MTD_NAND_BCM_UMI_HWCS)</span>
	<span class="cm">/* enable software control of CS */</span>
	<span class="n">REG_UMI_NAND_TCR</span> <span class="o">|=</span> <span class="n">REG_UMI_NAND_TCR_CS_SWCTRL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* keep NAND chip select asserted */</span>
	<span class="n">REG_UMI_NAND_RCSR</span> <span class="o">|=</span> <span class="n">REG_UMI_NAND_RCSR_CS_ASSERTED</span><span class="p">;</span>

	<span class="n">REG_UMI_NAND_TCR</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REG_UMI_NAND_TCR_WORD16</span><span class="p">;</span>
	<span class="cm">/* enable writes to flash */</span>
	<span class="n">REG_UMI_MMD_ICR</span> <span class="o">|=</span> <span class="n">REG_UMI_MMD_ICR_FLASH_WP</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">NAND_CMD_RESET</span><span class="p">,</span> <span class="n">bcm_umi_io_base</span> <span class="o">+</span> <span class="n">REG_NAND_CMD_OFFSET</span><span class="p">);</span>
	<span class="n">nand_bcm_umi_wait_till_ready</span><span class="p">();</span>

<span class="cp">#if NAND_ECC_BCH</span>
	<span class="n">nand_bcm_umi_bch_config_ecc</span><span class="p">(</span><span class="n">NAND_ECC_NUM_BYTES</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Used to turn latch the proper register for access. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_umi_nand_hwcontrol</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* send command to hardware */</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">NAND_CLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_W</span> <span class="o">=</span> <span class="n">bcm_umi_io_base</span> <span class="o">+</span> <span class="n">REG_NAND_CMD_OFFSET</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">CMD</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">NAND_ALE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_W</span> <span class="o">=</span>
			    <span class="n">bcm_umi_io_base</span> <span class="o">+</span> <span class="n">REG_NAND_ADDR_OFFSET</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">CMD</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_W</span> <span class="o">=</span> <span class="n">bcm_umi_io_base</span> <span class="o">+</span> <span class="n">REG_NAND_DATA8_OFFSET</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">CMD:</span>
	<span class="cm">/* Send command to chip directly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">NAND_CMD_NONE</span><span class="p">)</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_W</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_umi_nand_write_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">USE_DIRECT_IO</span><span class="p">(</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Do it the old way if the buffer is small or too large.</span>
<span class="cm">		 * Probably quicker than starting and checking dma. */</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">writeb</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">IO_ADDR_W</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if USE_DMA</span>
	<span class="k">else</span>
		<span class="n">nand_dma_write</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcm_umi_nand_read_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">USE_DIRECT_IO</span><span class="p">(</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">IO_ADDR_R</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if USE_DMA</span>
	<span class="k">else</span>
		<span class="n">nand_dma_read</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">readbackbuf</span><span class="p">[</span><span class="n">NAND_MAX_PAGESIZE</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_umi_nand_verify_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Try to readback page with ECC correction. This is necessary</span>
<span class="cm">	 * for MLC parts which may have permanently stuck bits.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">read_page</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">readbackbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">readbackbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">bcm_umi_nand_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">gBanner</span><span class="p">);</span>

	<span class="cm">/* Allocate memory for MTD device structure and private data */</span>
	<span class="n">board_mtd</span> <span class="o">=</span>
	    <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nand_chip</span><span class="p">),</span>
		    <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">board_mtd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;Unable to allocate NAND MTD device structure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* map physical address */</span>
	<span class="n">bcm_umi_io_base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcm_umi_io_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ioremap to access BCM UMI NAND chip failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get pointer to private data */</span>
	<span class="n">this</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">board_mtd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="cm">/* Initialize structures */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">board_mtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">this</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nand_chip</span><span class="p">));</span>

	<span class="cm">/* Link the private data with the MTD structure */</span>
	<span class="n">board_mtd</span><span class="o">-&gt;</span><span class="n">priv</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>

	<span class="cm">/* Initialize the NAND hardware.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcm_umi_nand_inithw</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;BCM UMI NAND chip could not be initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set address of NAND IO lines */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">IO_ADDR_W</span> <span class="o">=</span> <span class="n">bcm_umi_io_base</span> <span class="o">+</span> <span class="n">REG_NAND_DATA8_OFFSET</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">IO_ADDR_R</span> <span class="o">=</span> <span class="n">bcm_umi_io_base</span> <span class="o">+</span> <span class="n">REG_NAND_DATA8_OFFSET</span><span class="p">;</span>

	<span class="cm">/* Set command delay time, see datasheet for correct value */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">chip_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Assign the device ready function, if available */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">dev_ready</span> <span class="o">=</span> <span class="n">nand_dev_ready</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">write_buf</span> <span class="o">=</span> <span class="n">bcm_umi_nand_write_buf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">read_buf</span> <span class="o">=</span> <span class="n">bcm_umi_nand_read_buf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">verify_buf</span> <span class="o">=</span> <span class="n">bcm_umi_nand_verify_buf</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_ctrl</span> <span class="o">=</span> <span class="n">bcm_umi_nand_hwcontrol</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">NAND_ECC_HW</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">NAND_ECC_NUM_BYTES</span><span class="p">;</span>
<span class="cp">#if NAND_ECC_BCH</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">read_page</span> <span class="o">=</span> <span class="n">bcm_umi_bch_read_page_hwecc</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">write_page</span> <span class="o">=</span> <span class="n">bcm_umi_bch_write_page_hwecc</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">correct</span> <span class="o">=</span> <span class="n">nand_correct_data512</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">calculate</span> <span class="o">=</span> <span class="n">bcm_umi_hamming_get_hw_ecc</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">hwctl</span> <span class="o">=</span> <span class="n">bcm_umi_hamming_enable_hwecc</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if USE_DMA</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nand_dma_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Figure out the size of the device that we have.</span>
<span class="cm">	 * We need to do this to figure out which ECC</span>
<span class="cm">	 * layout we&#39;ll be using.</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nand_scan_ident</span><span class="p">(</span><span class="n">board_mtd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nand_scan failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now that we know the nand size, we can setup the ECC layout */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">board_mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* writesize is the pagesize */</span>
	<span class="k">case</span> <span class="mi">4096</span>:
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nand_hw_eccoob_4096</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2048</span>:
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nand_hw_eccoob_2048</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">512</span>:
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nand_hw_eccoob_512</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NAND - Unrecognized pagesize: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">board_mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if NAND_ECC_BCH</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">board_mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_options</span> <span class="o">&amp;</span> <span class="n">NAND_BBT_USE_FLASH</span><span class="p">)</span>
			<span class="n">largepage_bbt</span><span class="p">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">NAND_BBT_SCAN2NDPAGE</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">badblock_pattern</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">largepage_bbt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="cp">#endif</span>

	<span class="cm">/* Now finish off the scan, now that ecc.layout has been initialized. */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nand_scan_tail</span><span class="p">(</span><span class="n">board_mtd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;nand_scan failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Register the partitions */</span>
	<span class="n">board_mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bcm_umi-nand&quot;</span><span class="p">;</span>
	<span class="n">mtd_device_parse_register</span><span class="p">(</span><span class="n">board_mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Return happy */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">bcm_umi_io_base</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">board_mtd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_umi_nand_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if USE_DMA</span>
	<span class="n">nand_dma_term</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="cm">/* Release resources, unregister device */</span>
	<span class="n">nand_release</span><span class="p">(</span><span class="n">board_mtd</span><span class="p">);</span>

	<span class="cm">/* unmap physical address */</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">bcm_umi_io_base</span><span class="p">);</span>

	<span class="cm">/* Free the MTD device structure */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">board_mtd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_umi_nand_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;MTD NAND suspend is being called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bcm_umi_nand_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;MTD NAND resume is being called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define bcm_umi_nand_suspend   NULL</span>
<span class="cp">#define bcm_umi_nand_resume    NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">nand_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		   <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;bcm-nand&quot;</span><span class="p">,</span>
		   <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		   <span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">bcm_umi_nand_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">bcm_umi_nand_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">bcm_umi_nand_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">bcm_umi_nand_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">nand_driver</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Broadcom&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;BCM UMI MTD NAND driver&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
