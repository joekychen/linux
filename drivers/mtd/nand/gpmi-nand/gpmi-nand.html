<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › nand › gpmi-nand › gpmi-nand.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>gpmi-nand.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Freescale GPMI NAND Flash Driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.</span>
<span class="cm"> * Copyright (C) 2008 Embedded Alley Solutions, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/gpmi-nand.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/partitions.h&gt;</span>
<span class="cp">#include &lt;linux/pinctrl/consumer.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &quot;gpmi-nand.h&quot;</span>

<span class="cm">/* add our owner bbt descriptor */</span>
<span class="k">static</span> <span class="kt">uint8_t</span> <span class="n">scan_ff_pattern</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xff</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="n">gpmi_bbt_descr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">options</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">offs</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">len</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pattern</span>	<span class="o">=</span> <span class="n">scan_ff_pattern</span>
<span class="p">};</span>

<span class="cm">/*  We will use all the (page + OOB). */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="n">gpmi_hw_ecclayout</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">eccbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eccpos</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">oobfree</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">bch_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="n">gpmi_clear_bch</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_done</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Calculate the ECC strength by hand:</span>
<span class="cm"> *	E : The ECC strength.</span>
<span class="cm"> *	G : the length of Galois Field.</span>
<span class="cm"> *	N : The chunk count of per page.</span>
<span class="cm"> *	O : the oobsize of the NAND chip.</span>
<span class="cm"> *	M : the metasize of per page.</span>
<span class="cm"> *</span>
<span class="cm"> *	The formula is :</span>
<span class="cm"> *		E * G * N</span>
<span class="cm"> *	      ------------ &lt;= (O - M)</span>
<span class="cm"> *                  8</span>
<span class="cm"> *</span>
<span class="cm"> *      So, we get E by:</span>
<span class="cm"> *                    (O - M) * 8</span>
<span class="cm"> *              E &lt;= -------------</span>
<span class="cm"> *                       G * N</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_ecc_strength</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span>	<span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ecc_strength</span><span class="p">;</span>

	<span class="n">ecc_strength</span> <span class="o">=</span> <span class="p">((</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span> <span class="o">-</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">metadata_size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>
			<span class="o">/</span> <span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">gf_len</span> <span class="o">*</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span><span class="p">);</span>

	<span class="cm">/* We need the minor even number. */</span>
	<span class="k">return</span> <span class="n">round_down</span><span class="p">(</span><span class="n">ecc_strength</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">common_nfc_set_geometry</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">metadata_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_mark_bit_offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The size of the metadata can be changed, though we set it to 10</span>
<span class="cm">	 * bytes now. But it can&#39;t be too large, because we have to save</span>
<span class="cm">	 * enough space for BCH.</span>
<span class="cm">	 */</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">metadata_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="cm">/* The default for the length of Galois Field. */</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">gf_len</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>

	<span class="cm">/* The default for chunk size. There is no oobsize greater then 512. */</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_size</span> <span class="o">&lt;</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">)</span>
		<span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_size</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* keep C &gt;= O */</span>

	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">/</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_size</span><span class="p">;</span>

	<span class="cm">/* We use the same ECC strength for all chunks. */</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">=</span> <span class="n">get_ecc_strength</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;We get a wrong ECC strength.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">+</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">;</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">payload_size</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The auxiliary buffer contains the metadata and the ECC status. The</span>
<span class="cm">	 * metadata is padded to the nearest 32-bit boundary. The ECC status</span>
<span class="cm">	 * contains one byte for every ECC chunk, and is also padded to the</span>
<span class="cm">	 * nearest 32-bit boundary.</span>
<span class="cm">	 */</span>
	<span class="n">metadata_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">metadata_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">status_size</span>   <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">auxiliary_size</span> <span class="o">=</span> <span class="n">metadata_size</span> <span class="o">+</span> <span class="n">status_size</span><span class="p">;</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">auxiliary_status_offset</span> <span class="o">=</span> <span class="n">metadata_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">swap_block_mark</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to compute the byte and bit offsets of</span>
<span class="cm">	 * the physical block mark within the ECC-based view of the page.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NAND chip with 2K page shows below:</span>
<span class="cm">	 *                                             (Block Mark)</span>
<span class="cm">	 *                                                   |      |</span>
<span class="cm">	 *                                                   |  D   |</span>
<span class="cm">	 *                                                   |&lt;----&gt;|</span>
<span class="cm">	 *                                                   V      V</span>
<span class="cm">	 *    +---+----------+-+----------+-+----------+-+----------+-+</span>
<span class="cm">	 *    | M |   data   |E|   data   |E|   data   |E|   data   |E|</span>
<span class="cm">	 *    +---+----------+-+----------+-+----------+-+----------+-+</span>
<span class="cm">	 *</span>
<span class="cm">	 * The position of block mark moves forward in the ECC-based view</span>
<span class="cm">	 * of page, and the delta is:</span>
<span class="cm">	 *</span>
<span class="cm">	 *                   E * G * (N - 1)</span>
<span class="cm">	 *             D = (---------------- + M)</span>
<span class="cm">	 *                          8</span>
<span class="cm">	 *</span>
<span class="cm">	 * With the formula to compute the ECC strength, and the condition</span>
<span class="cm">	 *       : C &gt;= O         (C is the ecc chunk size)</span>
<span class="cm">	 *</span>
<span class="cm">	 * It&#39;s easy to deduce to the following result:</span>
<span class="cm">	 *</span>
<span class="cm">	 *         E * G       (O - M)      C - M         C - M</span>
<span class="cm">	 *      ----------- &lt;= ------- &lt;=  --------  &lt;  ---------</span>
<span class="cm">	 *           8            N           N          (N - 1)</span>
<span class="cm">	 *</span>
<span class="cm">	 *  So, we get:</span>
<span class="cm">	 *</span>
<span class="cm">	 *                   E * G * (N - 1)</span>
<span class="cm">	 *             D = (---------------- + M) &lt; C</span>
<span class="cm">	 *                          8</span>
<span class="cm">	 *</span>
<span class="cm">	 *  The above inequality means the position of block mark</span>
<span class="cm">	 *  within the ECC-based view of the page is still in the data chunk,</span>
<span class="cm">	 *  and it&#39;s NOT in the ECC bits of the chunk.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Use the following to compute the bit position of the</span>
<span class="cm">	 *  physical block mark within the ECC-based view of the page:</span>
<span class="cm">	 *          (page_size - D) * 8</span>
<span class="cm">	 *</span>
<span class="cm">	 *  --Huang Shijie</span>
<span class="cm">	 */</span>
	<span class="n">block_mark_bit_offset</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">*</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">gf_len</span> <span class="o">*</span> <span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="o">+</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">metadata_size</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">block_mark_byte_offset</span> <span class="o">=</span> <span class="n">block_mark_bit_offset</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">block_mark_bit_offset</span>  <span class="o">=</span> <span class="n">block_mark_bit_offset</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="nf">get_dma_chan</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">chipnr</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="n">chipnr</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Can we use the upper&#39;s buffer directly for DMA? */</span>
<span class="kt">void</span> <span class="nf">prepare_data_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">data_sgl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">direct_dma_map_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* first try to map the upper buffer directly */</span>
	<span class="n">sg_init_one</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_buf</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_len</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We have to use our own DMA buffer. */</span>
		<span class="n">sg_init_one</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dr</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_buf</span><span class="p">,</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_len</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;map failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">this</span><span class="o">-&gt;</span><span class="n">direct_dma_map_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This will be called after the DMA operation is finished. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_irq_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">dma_c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_done</span><span class="p">;</span>

	<span class="n">complete</span><span class="p">(</span><span class="n">dma_c</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_FOR_COMMAND</span>:
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DMA_FOR_READ_DATA</span>:
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">data_sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">direct_dma_map_ok</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_buf</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span><span class="p">,</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DMA_FOR_WRITE_DATA</span>:
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">data_sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DMA_FOR_READ_ECC_PAGE</span>:
	<span class="k">case</span> <span class="n">DMA_FOR_WRITE_ECC_PAGE</span>:
		<span class="cm">/* We have to wait the BCH interrupt to finish. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;in wrong DMA operation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">start_dma_without_bch_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">dma_c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="n">dma_c</span><span class="p">);</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">callback</span>		<span class="o">=</span> <span class="n">dma_irq_callback</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">callback_param</span>	<span class="o">=</span> <span class="n">this</span><span class="p">;</span>
	<span class="n">dmaengine_submit</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">dma_async_issue_pending</span><span class="p">(</span><span class="n">get_dma_chan</span><span class="p">(</span><span class="n">this</span><span class="p">));</span>

	<span class="cm">/* Wait for the interrupt from the DMA block. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="n">dma_c</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DMA timeout, last DMA :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">last_dma_type</span><span class="p">);</span>
		<span class="n">gpmi_dump_info</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is used in BCH reading or BCH writing pages.</span>
<span class="cm"> * It will wait for the BCH interrupt as long as ONE second.</span>
<span class="cm"> * Actually, we must wait for two interrupts :</span>
<span class="cm"> *	[1] firstly the DMA interrupt and</span>
<span class="cm"> *	[2] secondly the BCH interrupt.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">start_dma_with_bch_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">bch_c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Prepare to receive an interrupt from the BCH block. */</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="n">bch_c</span><span class="p">);</span>

	<span class="cm">/* start the DMA */</span>
	<span class="n">start_dma_without_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>

	<span class="cm">/* Wait for the interrupt from the BCH block. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="n">bch_c</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;BCH timeout, last DMA :%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">last_dma_type</span><span class="p">);</span>
		<span class="n">gpmi_dump_info</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">acquire_register_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">platform_get_resource_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="n">res_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Can&#39;t get resource for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Can&#39;t remap %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">res_name</span><span class="p">,</span> <span class="n">GPMI_NAND_GPMI_REGS_ADDR_RES_NAME</span><span class="p">))</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">res_name</span><span class="p">,</span> <span class="n">GPMI_NAND_BCH_REGS_ADDR_RES_NAME</span><span class="p">))</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">bch_regs</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;unknown resource name : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res_name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_register_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">bch_regs</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">bch_regs</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">bch_regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">acquire_bch_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">irq_h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">res_name</span> <span class="o">=</span> <span class="n">GPMI_NAND_BCH_INTERRUPT_RES_NAME</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">platform_get_resource_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span> <span class="n">res_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Can&#39;t get resource for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">irq_h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res_name</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Can&#39;t own %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">bch_low_interrupt</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">bch_high_interrupt</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_bch_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">bch_low_interrupt</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">bch_high_interrupt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">gpmi_dma_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_channel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mxs_dma_is_apbh</span><span class="p">(</span><span class="n">chan</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * only catch the GPMI dma channels :</span>
<span class="cm">	 *	for mx23 :	MX23_DMA_GPMI0 ~ MX23_DMA_GPMI3</span>
<span class="cm">	 *		(These four channels share the same IRQ!)</span>
<span class="cm">	 *</span>
<span class="cm">	 *	for mx28 :	MX28_DMA_GPMI0 ~ MX28_DMA_GPMI7</span>
<span class="cm">	 *		(These eight channels share the same IRQ!)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_channel</span> <span class="o">==</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">chan_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_data</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_dma_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DMA_CHANS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dma_release_channel</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">acquire_dma_channels</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r_dma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">dma_chan</span><span class="p">;</span>
	<span class="n">dma_cap_mask_t</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* dma channel, we only use the first one. */</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">of_property_read_u32</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="s">&quot;fsl,gpmi-dma-channel&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma_channel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;unable to get DMA channel from dt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">acquire_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dma_channel</span><span class="p">;</span>

	<span class="cm">/* gpmi dma interrupt */</span>
	<span class="n">r_dma</span> <span class="o">=</span> <span class="n">platform_get_resource_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span>
					<span class="n">GPMI_NAND_DMA_INTERRUPT_RES_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Can&#39;t get resource for DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">acquire_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_data</span><span class="p">.</span><span class="n">chan_irq</span> <span class="o">=</span> <span class="n">r_dma</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* request dma channel */</span>
	<span class="n">dma_cap_zero</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
	<span class="n">dma_cap_set</span><span class="p">(</span><span class="n">DMA_SLAVE</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">dma_chan</span> <span class="o">=</span> <span class="n">dma_request_channel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">gpmi_dma_filter</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_chan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;dma_request_channel failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">acquire_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_chans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_chan</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">acquire_err:</span>
	<span class="n">release_dma_channels</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">acquire_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pinctrl</span> <span class="o">*</span><span class="n">pinctrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">acquire_register_block</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">GPMI_NAND_GPMI_REGS_ADDR_RES_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_regs</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">acquire_register_block</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">GPMI_NAND_BCH_REGS_ADDR_RES_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_regs</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">acquire_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">bch_irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_regs</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">acquire_dma_channels</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_dma_channels</span><span class="p">;</span>

	<span class="n">pinctrl</span> <span class="o">=</span> <span class="n">devm_pinctrl_get_select_default</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pinctrl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pinctrl</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_pin</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;can not get the clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit_clock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">exit_clock:</span>
<span class="nl">exit_pin:</span>
	<span class="n">release_dma_channels</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="nl">exit_dma_channels:</span>
	<span class="n">release_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="nl">exit_regs:</span>
	<span class="n">release_register_block</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>

	<span class="n">clk_put</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
	<span class="n">release_register_block</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="n">release_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="n">release_dma_channels</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">init_hardware</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This structure contains the &quot;safe&quot; GPMI timing that should succeed</span>
<span class="cm">	 * with any NAND Flash device</span>
<span class="cm">	 * (although, with less-than-optimal performance).</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">nand_timing</span>  <span class="n">safe_timing</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">data_setup_in_ns</span>        <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data_hold_in_ns</span>         <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
		<span class="p">.</span><span class="n">address_setup_in_ns</span>     <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
		<span class="p">.</span><span class="n">gpmi_sample_delay_in_ns</span> <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tREA_in_ns</span>              <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tRLOH_in_ns</span>             <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tRHOH_in_ns</span>             <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="cm">/* Initialize the hardwares. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_init</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">timing</span> <span class="o">=</span> <span class="n">safe_timing</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_page_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">alt_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">alt_phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">alt_size</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">**</span><span class="n">use_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">use_phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virt_addr_valid</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">dest_phys</span><span class="p">;</span>

		<span class="n">dest_phys</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
						<span class="n">length</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dest_phys</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">alt_size</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Alternate buffer is too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">map_failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">use_virt</span> <span class="o">=</span> <span class="n">destination</span><span class="p">;</span>
		<span class="o">*</span><span class="n">use_phys</span> <span class="o">=</span> <span class="n">dest_phys</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">direct_dma_map_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">map_failed:</span>
	<span class="o">*</span><span class="n">use_virt</span> <span class="o">=</span> <span class="n">alt_virt</span><span class="p">;</span>
	<span class="o">*</span><span class="n">use_phys</span> <span class="o">=</span> <span class="n">alt_phys</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">direct_dma_map_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">read_page_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">alt_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">alt_phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">alt_size</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">used_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">used_phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">direct_dma_map_ok</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">used_phys</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">read_page_swap_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">destination</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">alt_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">alt_phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">alt_size</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">used_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">used_phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">direct_dma_map_ok</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">alt_virt</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_page_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">alt_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">alt_phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">alt_size</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">**</span><span class="n">use_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">use_phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">virt_addr_valid</span><span class="p">(</span><span class="n">source</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">source_phys</span><span class="p">;</span>

		<span class="n">source_phys</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">source</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
						<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">source_phys</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">alt_size</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Alternate buffer is too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">map_failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">use_virt</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>
		<span class="o">*</span><span class="n">use_phys</span> <span class="o">=</span> <span class="n">source_phys</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">map_failed:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy the content of the source buffer into the alternate</span>
<span class="cm">	 * buffer and set up the return values accordingly.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">alt_virt</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="o">*</span><span class="n">use_virt</span> <span class="o">=</span> <span class="n">alt_virt</span><span class="p">;</span>
	<span class="o">*</span><span class="n">use_phys</span> <span class="o">=</span> <span class="n">alt_phys</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_page_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">alt_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">alt_phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">alt_size</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">used_virt</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">used_phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used_virt</span> <span class="o">==</span> <span class="n">source</span><span class="p">)</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">used_phys</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpmi_free_dma_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_virt</span> <span class="o">&amp;&amp;</span> <span class="n">virt_addr_valid</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_virt</span><span class="p">))</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_size</span><span class="p">,</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_virt</span><span class="p">,</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_buffer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span><span class="p">);</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_buffer</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_virt</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_size</span>	<span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate the DMA buffers */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_alloc_dma_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* [1] Allocate a command buffer. PAGE_SIZE is enough. */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_buffer</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_alloc</span><span class="p">;</span>

	<span class="cm">/* [2] Allocate a read/write data buffer. PAGE_SIZE is enough. */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_alloc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * [3] Allocate the page buffer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Both the payload buffer and the auxiliary buffer must appear on</span>
<span class="cm">	 * 32-bit boundaries. We presume the size of the payload buffer is a</span>
<span class="cm">	 * power of two and is much larger than four, which guarantees the</span>
<span class="cm">	 * auxiliary buffer will appear on a 32-bit boundary.</span>
<span class="cm">	 */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_size</span> <span class="o">=</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">payload_size</span> <span class="o">+</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">auxiliary_size</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_size</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_phys</span><span class="p">,</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_virt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_alloc</span><span class="p">;</span>


	<span class="cm">/* Slice up the page buffer. */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_virt</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_phys</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_buffer_phys</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_virt</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span> <span class="o">+</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">payload_size</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_phys</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_phys</span> <span class="o">+</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">payload_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_alloc:</span>
	<span class="n">gpmi_free_dma_buffer</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;allocate DMA buffer ret!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpmi_cmd_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Every operation begins with a command byte and a series of zero or</span>
<span class="cm">	 * more address bytes. These are distinguished by either the Address</span>
<span class="cm">	 * Latch Enable (ALE) or Command Latch Enable (CLE) signals being</span>
<span class="cm">	 * asserted. When MTD is ready to execute the command, it will deassert</span>
<span class="cm">	 * both latch enables.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Rather than run a separate DMA operation for every single byte, we</span>
<span class="cm">	 * queue them up and run a single DMA operation for the entire series</span>
<span class="cm">	 * of command and data bytes. NAND_CMD_NONE means the END of the queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NAND_ALE</span> <span class="o">|</span> <span class="n">NAND_CLE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="n">NAND_CMD_NONE</span><span class="p">)</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_buffer</span><span class="p">[</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">command_length</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">command_length</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_send_command</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Chip: %u, Error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">command_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_dev_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">gpmi_is_ready</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpmi_select_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chipnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">chipnr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">gpmi_begin</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">chipnr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">gpmi_end</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span> <span class="o">=</span> <span class="n">chipnr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpmi_read_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;len is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_buf</span>	<span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_len</span>	<span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">gpmi_read_data</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpmi_write_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;len is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_buf</span>	<span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_len</span>	<span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">gpmi_send_data</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint8_t</span> <span class="nf">gpmi_read_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span><span class="p">;</span>

	<span class="n">gpmi_read_buf</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handles block mark swapping.</span>
<span class="cm"> * It can be called in swapping the block mark, or swapping it back,</span>
<span class="cm"> * because the the operations are the same.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">block_mark_swapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">auxiliary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">nfc_geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">bit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">from_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">from_oob</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">swap_block_mark</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If control arrives here, we&#39;re swapping. Make some convenience</span>
<span class="cm">	 * variables.</span>
<span class="cm">	 */</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">block_mark_bit_offset</span><span class="p">;</span>
	<span class="n">p</span>   <span class="o">=</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">block_mark_byte_offset</span><span class="p">;</span>
	<span class="n">a</span>   <span class="o">=</span> <span class="n">auxiliary</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the byte from the data area that overlays the block mark. Since</span>
<span class="cm">	 * the ECC engine applies its own view to the bits in the page, the</span>
<span class="cm">	 * physical block mark won&#39;t (in general) appear on a byte boundary in</span>
<span class="cm">	 * the data.</span>
<span class="cm">	 */</span>
	<span class="n">from_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">bit</span><span class="p">));</span>

	<span class="cm">/* Get the byte from the OOB. */</span>
	<span class="n">from_oob</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Swap them. */</span>
	<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_data</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">from_oob</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">from_oob</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">bit</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_ecc_read_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">nfc_geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="kt">void</span>          <span class="o">*</span><span class="n">payload_virt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>    <span class="n">payload_phys</span><span class="p">;</span>
	<span class="kt">void</span>          <span class="o">*</span><span class="n">auxiliary_virt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>    <span class="n">auxiliary_phys</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">failed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>  <span class="n">corrected</span><span class="p">;</span>
	<span class="kt">int</span>           <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;page number is : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">read_page_prepare</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_phys</span><span class="p">,</span>
					<span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">payload_size</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">payload_virt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload_phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Inadequate DMA buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">auxiliary_virt</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_virt</span><span class="p">;</span>
	<span class="n">auxiliary_phys</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_phys</span><span class="p">;</span>

	<span class="cm">/* go! */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_read_page</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">payload_phys</span><span class="p">,</span> <span class="n">auxiliary_phys</span><span class="p">);</span>
	<span class="n">read_page_end</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_phys</span><span class="p">,</span>
			<span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">payload_size</span><span class="p">,</span>
			<span class="n">payload_virt</span><span class="p">,</span> <span class="n">payload_phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error in ECC-based read: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_nfc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* handle the block mark swapping */</span>
	<span class="n">block_mark_swapping</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">payload_virt</span><span class="p">,</span> <span class="n">auxiliary_virt</span><span class="p">);</span>

	<span class="cm">/* Loop over status bytes, accumulating ECC status. */</span>
	<span class="n">failed</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">corrected</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">status</span>		<span class="o">=</span> <span class="n">auxiliary_virt</span> <span class="o">+</span> <span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">auxiliary_status_offset</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">status</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">status</span> <span class="o">==</span> <span class="n">STATUS_GOOD</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">==</span> <span class="n">STATUS_ERASED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">status</span> <span class="o">==</span> <span class="n">STATUS_UNCORRECTABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">corrected</span> <span class="o">+=</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Propagate ECC status to the owning MTD only when failed or</span>
<span class="cm">	 * corrected times nearly reaches our ECC correction threshold.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">failed</span> <span class="o">||</span> <span class="n">corrected</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecc_stats</span><span class="p">.</span><span class="n">failed</span>    <span class="o">+=</span> <span class="n">failed</span><span class="p">;</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecc_stats</span><span class="p">.</span><span class="n">corrected</span> <span class="o">+=</span> <span class="n">corrected</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oob_required</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s time to deliver the OOB bytes. See gpmi_ecc_read_oob()</span>
<span class="cm">		 * for details about our policy for delivering the OOB.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We fill the caller&#39;s buffer with set bits, and then copy the</span>
<span class="cm">		 * block mark to th caller&#39;s buffer. Note that, if block mark</span>
<span class="cm">		 * swapping was necessary, it has already been done, so we can</span>
<span class="cm">		 * rely on the first byte of the auxiliary buffer to contain</span>
<span class="cm">		 * the block mark.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">auxiliary_virt</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">read_page_swap_end</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_phys</span><span class="p">,</span>
				<span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">payload_size</span><span class="p">,</span>
				<span class="n">payload_virt</span><span class="p">,</span> <span class="n">payload_phys</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">exit_nfc:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpmi_ecc_write_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oob_required</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">nfc_geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">payload_virt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">payload_phys</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">auxiliary_virt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">auxiliary_phys</span><span class="p">;</span>
	<span class="kt">int</span>        <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ecc write page.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">swap_block_mark</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If control arrives here, we&#39;re doing block mark swapping.</span>
<span class="cm">		 * Since we can&#39;t modify the caller&#39;s buffers, we must copy them</span>
<span class="cm">		 * into our own.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">);</span>
		<span class="n">payload_virt</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span><span class="p">;</span>
		<span class="n">payload_phys</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_phys</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_virt</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span>
				<span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">auxiliary_size</span><span class="p">);</span>
		<span class="n">auxiliary_virt</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_virt</span><span class="p">;</span>
		<span class="n">auxiliary_phys</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_phys</span><span class="p">;</span>

		<span class="cm">/* Handle block mark swapping. */</span>
		<span class="n">block_mark_swapping</span><span class="p">(</span><span class="n">this</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">payload_virt</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">auxiliary_virt</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If control arrives here, we&#39;re not doing block mark swapping,</span>
<span class="cm">		 * so we can to try and use the caller&#39;s buffers.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">send_page_prepare</span><span class="p">(</span><span class="n">this</span><span class="p">,</span>
				<span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_phys</span><span class="p">,</span>
				<span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">payload_size</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">payload_virt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload_phys</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Inadequate payload DMA buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">send_page_prepare</span><span class="p">(</span><span class="n">this</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">,</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_virt</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_phys</span><span class="p">,</span>
				<span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">auxiliary_size</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">auxiliary_virt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">auxiliary_phys</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Inadequate auxiliary DMA buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit_auxiliary</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Ask the NFC. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_send_page</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">payload_phys</span><span class="p">,</span> <span class="n">auxiliary_phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error in ECC-based write: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">swap_block_mark</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_page_end</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">,</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_virt</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">auxiliary_phys</span><span class="p">,</span>
				<span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">auxiliary_size</span><span class="p">,</span>
				<span class="n">auxiliary_virt</span><span class="p">,</span> <span class="n">auxiliary_phys</span><span class="p">);</span>
<span class="nl">exit_auxiliary:</span>
		<span class="n">send_page_end</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_virt</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">payload_phys</span><span class="p">,</span>
				<span class="n">nfc_geo</span><span class="o">-&gt;</span><span class="n">payload_size</span><span class="p">,</span>
				<span class="n">payload_virt</span><span class="p">,</span> <span class="n">payload_phys</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are several places in this driver where we have to handle the OOB and</span>
<span class="cm"> * block marks. This is the function where things are the most complicated, so</span>
<span class="cm"> * this is where we try to explain it all. All the other places refer back to</span>
<span class="cm"> * here.</span>
<span class="cm"> *</span>
<span class="cm"> * These are the rules, in order of decreasing importance:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Nothing the caller does can be allowed to imperil the block mark.</span>
<span class="cm"> *</span>
<span class="cm"> * 2) In read operations, the first byte of the OOB we return must reflect the</span>
<span class="cm"> *    true state of the block mark, no matter where that block mark appears in</span>
<span class="cm"> *    the physical page.</span>
<span class="cm"> *</span>
<span class="cm"> * 3) ECC-based read operations return an OOB full of set bits (since we never</span>
<span class="cm"> *    allow ECC-based writes to the OOB, it doesn&#39;t matter what ECC-based reads</span>
<span class="cm"> *    return).</span>
<span class="cm"> *</span>
<span class="cm"> * 4) &quot;Raw&quot; read operations return a direct view of the physical bytes in the</span>
<span class="cm"> *    page, using the conventional definition of which bytes are data and which</span>
<span class="cm"> *    are OOB. This gives the caller a way to see the actual, physical bytes</span>
<span class="cm"> *    in the page, without the distortions applied by our ECC engine.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * What we do for this specific read operation depends on two questions:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Are we doing a &quot;raw&quot; read, or an ECC-based read?</span>
<span class="cm"> *</span>
<span class="cm"> * 2) Are we using block mark swapping or transcription?</span>
<span class="cm"> *</span>
<span class="cm"> * There are four cases, illustrated by the following Karnaugh map:</span>
<span class="cm"> *</span>
<span class="cm"> *                    |           Raw           |         ECC-based       |</span>
<span class="cm"> *       -------------+-------------------------+-------------------------+</span>
<span class="cm"> *                    | Read the conventional   |                         |</span>
<span class="cm"> *                    | OOB at the end of the   |                         |</span>
<span class="cm"> *       Swapping     | page and return it. It  |                         |</span>
<span class="cm"> *                    | contains exactly what   |                         |</span>
<span class="cm"> *                    | we want.                | Read the block mark and |</span>
<span class="cm"> *       -------------+-------------------------+ return it in a buffer   |</span>
<span class="cm"> *                    | Read the conventional   | full of set bits.       |</span>
<span class="cm"> *                    | OOB at the end of the   |                         |</span>
<span class="cm"> *                    | page and also the block |                         |</span>
<span class="cm"> *       Transcribing | mark in the metadata.   |                         |</span>
<span class="cm"> *                    | Copy the block mark     |                         |</span>
<span class="cm"> *                    | into the first byte of  |                         |</span>
<span class="cm"> *                    | the OOB.                |                         |</span>
<span class="cm"> *       -------------+-------------------------+-------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we break rule #4 in the Transcribing/Raw case because we&#39;re not</span>
<span class="cm"> * giving an accurate view of the actual, physical bytes in the page (we&#39;re</span>
<span class="cm"> * overwriting the block mark). That&#39;s OK because it&#39;s more important to follow</span>
<span class="cm"> * rule #2.</span>
<span class="cm"> *</span>
<span class="cm"> * It turns out that knowing whether we want an &quot;ECC-based&quot; or &quot;raw&quot; read is not</span>
<span class="cm"> * easy. When reading a page, for example, the NAND Flash MTD code calls our</span>
<span class="cm"> * ecc.read_page or ecc.read_page_raw function. Thus, the fact that MTD wants an</span>
<span class="cm"> * ECC-based or raw view of the page is implicit in which function it calls</span>
<span class="cm"> * (there is a similar pair of ECC-based/raw functions for writing).</span>
<span class="cm"> *</span>
<span class="cm"> * Since MTD assumes the OOB is not covered by ECC, there is no pair of</span>
<span class="cm"> * ECC-based/raw functions for reading or or writing the OOB. The fact that the</span>
<span class="cm"> * caller wants an ECC-based or raw view of the page is not propagated down to</span>
<span class="cm"> * this driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_ecc_read_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;page number is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="cm">/* clear the OOB buffer */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">);</span>

	<span class="cm">/* Read out the conventional OOB. */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_READ0</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">read_buf</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now, we want to make sure the block mark is correct. In the</span>
<span class="cm">	 * Swapping/Raw case, we already have it. Otherwise, we need to</span>
<span class="cm">	 * explicitly read it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">swap_block_mark</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the block mark into the first byte of the OOB buffer. */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_READ0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">read_byte</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">gpmi_ecc_write_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The BCH will use all the (page + oob).</span>
<span class="cm">	 * Our gpmi_hw_ecclayout can only prohibit the JFFS2 to write the oob.</span>
<span class="cm">	 * But it can not stop some ioctls such MEMWRITEOOB which uses</span>
<span class="cm">	 * MTD_OPS_PLACE_OOB. So We have to implement this function to prohibit</span>
<span class="cm">	 * these ioctls too.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_block_markbad</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">block_mark</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">column</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">chipnr</span><span class="p">;</span>

	<span class="cm">/* Get block number */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">bbt_erase_shift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bbt</span><span class="p">)</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">bbt</span><span class="p">[</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Do we have a flash based bad block table ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">bbt_options</span> <span class="o">&amp;</span> <span class="n">NAND_BBT_USE_FLASH</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nand_update_bbt</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">chipnr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_shift</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chipnr</span><span class="p">);</span>

		<span class="n">column</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">swap_block_mark</span> <span class="o">?</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Write the block mark. */</span>
		<span class="n">block_mark</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">data_buffer_dma</span><span class="p">;</span>
		<span class="n">block_mark</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* bad block marker */</span>

		<span class="cm">/* Shift to get page */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">page_shift</span><span class="p">);</span>

		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">write_buf</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block_mark</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">waitfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NAND_STATUS_FAIL</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">ecc_stats</span><span class="p">.</span><span class="n">badblocks</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_boot_set_geometry</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">boot_rom_geometry</span> <span class="o">*</span><span class="n">geometry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rom_geometry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the boot block stride size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In principle, we should be reading this from the OTP bits, since</span>
<span class="cm">	 * that&#39;s where the ROM is going to get it. In fact, we don&#39;t have any</span>
<span class="cm">	 * way to read the OTP bits, so we go with the default and hope for the</span>
<span class="cm">	 * best.</span>
<span class="cm">	 */</span>
	<span class="n">geometry</span><span class="o">-&gt;</span><span class="n">stride_size_in_pages</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the search area stride exponent.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In principle, we should be reading this from the OTP bits, since</span>
<span class="cm">	 * that&#39;s where the ROM is going to get it. In fact, we don&#39;t have any</span>
<span class="cm">	 * way to read the OTP bits, so we go with the default and hope for the</span>
<span class="cm">	 * best.</span>
<span class="cm">	 */</span>
	<span class="n">geometry</span><span class="o">-&gt;</span><span class="n">search_area_stride_exponent</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">fingerprint</span> <span class="o">=</span> <span class="s">&quot;STMP&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mx23_check_transcription_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">boot_rom_geometry</span> <span class="o">*</span><span class="n">rom_geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rom_geometry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">search_area_size_in_strides</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">byte</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="o">-&gt;</span><span class="n">databuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">saved_chip_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found_an_ncb_fingerprint</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Compute the number of strides in a search area. */</span>
	<span class="n">search_area_size_in_strides</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">rom_geo</span><span class="o">-&gt;</span><span class="n">search_area_stride_exponent</span><span class="p">;</span>

	<span class="n">saved_chip_number</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop through the first search area, looking for the NCB fingerprint.</span>
<span class="cm">	 */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Scanning for an NCB fingerprint...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">stride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&lt;</span> <span class="n">search_area_size_in_strides</span><span class="p">;</span> <span class="n">stride</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Compute the page and byte addresses. */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">stride</span> <span class="o">*</span> <span class="n">rom_geo</span><span class="o">-&gt;</span><span class="n">stride_size_in_pages</span><span class="p">;</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">page</span>   <span class="o">*</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">;</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Looking for a fingerprint in page 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read the NCB fingerprint. The fingerprint is four bytes long</span>
<span class="cm">		 * and starts in the 12th byte of the page.</span>
<span class="cm">		 */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_READ0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">read_buf</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">fingerprint</span><span class="p">));</span>

		<span class="cm">/* Look for the fingerprint. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">fingerprint</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">fingerprint</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">found_an_ncb_fingerprint</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">saved_chip_number</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found_an_ncb_fingerprint</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Found a fingerprint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">No fingerprint found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">found_an_ncb_fingerprint</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Writes a transcription stamp. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mx23_write_transcription_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">boot_rom_geometry</span> <span class="o">*</span><span class="n">rom_geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rom_geometry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_size_in_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">search_area_size_in_strides</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">search_area_size_in_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">search_area_size_in_blocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">loff_t</span>       <span class="n">byte</span><span class="p">;</span>
	<span class="kt">uint8_t</span>      <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">buffers</span><span class="o">-&gt;</span><span class="n">databuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">saved_chip_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Compute the search area geometry. */</span>
	<span class="n">block_size_in_pages</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">/</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">;</span>
	<span class="n">search_area_size_in_strides</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">rom_geo</span><span class="o">-&gt;</span><span class="n">search_area_stride_exponent</span><span class="p">;</span>
	<span class="n">search_area_size_in_pages</span> <span class="o">=</span> <span class="n">search_area_size_in_strides</span> <span class="o">*</span>
					<span class="n">rom_geo</span><span class="o">-&gt;</span><span class="n">stride_size_in_pages</span><span class="p">;</span>
	<span class="n">search_area_size_in_blocks</span> <span class="o">=</span>
		  <span class="p">(</span><span class="n">search_area_size_in_pages</span> <span class="o">+</span> <span class="p">(</span><span class="n">block_size_in_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span>
				    <span class="n">block_size_in_pages</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Search Area Geometry :</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">in Blocks : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">search_area_size_in_blocks</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">in Strides: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">search_area_size_in_strides</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">in Pages  : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">search_area_size_in_pages</span><span class="p">);</span>

	<span class="cm">/* Select chip 0. */</span>
	<span class="n">saved_chip_number</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Loop over blocks in the first search area, erasing them. */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Erasing the search area...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">search_area_size_in_blocks</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Compute the page address. */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">block</span> <span class="o">*</span> <span class="n">block_size_in_pages</span><span class="p">;</span>

		<span class="cm">/* Erase this block. */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Erasing block 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_ERASE1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_ERASE2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Wait for the erase to finish. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">waitfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NAND_STATUS_FAIL</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[%s] Erase failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Write the NCB fingerprint into the page buffer. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">oob_poi</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span> <span class="n">fingerprint</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">fingerprint</span><span class="p">));</span>

	<span class="cm">/* Loop through the first search area, writing NCB fingerprints. */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Writing NCB fingerprints...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">stride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&lt;</span> <span class="n">search_area_size_in_strides</span><span class="p">;</span> <span class="n">stride</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Compute the page and byte addresses. */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">stride</span> <span class="o">*</span> <span class="n">rom_geo</span><span class="o">-&gt;</span><span class="n">stride_size_in_pages</span><span class="p">;</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">page</span>   <span class="o">*</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">;</span>

		<span class="cm">/* Write the first page of the current stride. */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Writing an NCB fingerprint in page 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">write_page_raw</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Wait for the write to finish. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">waitfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">NAND_STATUS_FAIL</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;[%s] Write failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Deselect chip 0. */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">saved_chip_number</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mx23_boot_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span>  <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">int</span>     <span class="n">chipnr</span><span class="p">;</span>
	<span class="kt">int</span>     <span class="n">page</span><span class="p">;</span>
	<span class="n">loff_t</span>  <span class="n">byte</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">block_mark</span><span class="p">;</span>
	<span class="kt">int</span>     <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If control arrives here, we can&#39;t use block mark swapping, which</span>
<span class="cm">	 * means we&#39;re forced to use transcription. First, scan for the</span>
<span class="cm">	 * transcription stamp. If we find it, then we don&#39;t have to do</span>
<span class="cm">	 * anything -- the block marks are already transcribed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mx23_check_transcription_stamp</span><span class="p">(</span><span class="n">this</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If control arrives here, we couldn&#39;t find a transcription stamp, so</span>
<span class="cm">	 * so we presume the block marks are in the conventional location.</span>
<span class="cm">	 */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Transcribing bad block marks...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Compute the number of blocks in the entire medium. */</span>
	<span class="n">block_count</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">chipsize</span> <span class="o">&gt;&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">phys_erase_shift</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loop over all the blocks in the medium, transcribing block marks as</span>
<span class="cm">	 * we go.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">block_count</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute the chip, page and byte addresses for this block&#39;s</span>
<span class="cm">		 * conventional mark.</span>
<span class="cm">		 */</span>
		<span class="n">chipnr</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">chip_shift</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">phys_erase_shift</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">phys_erase_shift</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">page_shift</span><span class="p">);</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&lt;&lt;</span>  <span class="n">chip</span><span class="o">-&gt;</span><span class="n">phys_erase_shift</span><span class="p">;</span>

		<span class="cm">/* Send the command to read the conventional block mark. */</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">chipnr</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_READ0</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">block_mark</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">read_byte</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if the block is marked bad. If so, we need to mark it</span>
<span class="cm">		 * again, but this time the result will be a mark in the</span>
<span class="cm">		 * location where we transcribe block marks.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_mark</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Transcribing mark in block %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">block_markbad</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">byte</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to mark block bad with &quot;</span>
							<span class="s">&quot;ret %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Write the stamp that indicates we&#39;ve transcribed the block marks. */</span>
	<span class="n">mx23_write_transcription_stamp</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_boot_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span>  <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nand_boot_set_geometry</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

	<span class="cm">/* This is ROM arch-specific initilization before the BBT scanning. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GPMI_IS_MX23</span><span class="p">(</span><span class="n">this</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">mx23_boot_init</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_set_geometry</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Free the temporary DMA memory for reading ID. */</span>
	<span class="n">gpmi_free_dma_buffer</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

	<span class="cm">/* Set up the NFC geometry which is used by BCH. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">bch_set_geometry</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;set geometry ret : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Alloc the new DMA buffers according to the pagesize and oobsize */</span>
	<span class="k">return</span> <span class="n">gpmi_alloc_dma_buffer</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_pre_bbt_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span>  <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Set up swap_block_mark, must be set before the gpmi_set_geometry() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GPMI_IS_MX23</span><span class="p">(</span><span class="n">this</span><span class="p">))</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">swap_block_mark</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">swap_block_mark</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Set up the medium geometry */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_set_geometry</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Adjust the ECC strength according to the chip. */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">.</span><span class="n">ecc_strength</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">ecc_strength</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">.</span><span class="n">ecc_strength</span><span class="p">;</span>

	<span class="cm">/* NAND boot init, depends on the gpmi_set_geometry(). */</span>
	<span class="k">return</span> <span class="n">nand_boot_init</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_scan_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Prepare for the BBT scan. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_pre_bbt_scan</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* use the default BBT implementation */</span>
	<span class="k">return</span> <span class="n">nand_default_bbt</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gpmi_nfc_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nand_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">gpmi_free_dma_buffer</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">gpmi_nfc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span>  <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_part_parser_data</span> <span class="n">ppdata</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* init current chip */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span>	<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* init the MTD data structures */</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span>		<span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gpmi-nand&quot;</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

	<span class="cm">/* init the nand_chip{}, we don&#39;t support a 16-bit NAND Flash bus. */</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">priv</span>		<span class="o">=</span> <span class="n">this</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">select_chip</span>	<span class="o">=</span> <span class="n">gpmi_select_chip</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">cmd_ctrl</span>		<span class="o">=</span> <span class="n">gpmi_cmd_ctrl</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev_ready</span>		<span class="o">=</span> <span class="n">gpmi_dev_ready</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">read_byte</span>		<span class="o">=</span> <span class="n">gpmi_read_byte</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">read_buf</span>		<span class="o">=</span> <span class="n">gpmi_read_buf</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">write_buf</span>		<span class="o">=</span> <span class="n">gpmi_write_buf</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">read_page</span>	<span class="o">=</span> <span class="n">gpmi_ecc_read_page</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">write_page</span>	<span class="o">=</span> <span class="n">gpmi_ecc_write_page</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">read_oob</span>	<span class="o">=</span> <span class="n">gpmi_ecc_read_oob</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">write_oob</span>	<span class="o">=</span> <span class="n">gpmi_ecc_write_oob</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">scan_bbt</span>		<span class="o">=</span> <span class="n">gpmi_scan_bbt</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">badblock_pattern</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">gpmi_bbt_descr</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">block_markbad</span>	<span class="o">=</span> <span class="n">gpmi_block_markbad</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">options</span>		<span class="o">|=</span> <span class="n">NAND_NO_SUBPAGE_WRITE</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="n">NAND_ECC_HW</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">size</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">strength</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">gpmi_hw_ecclayout</span><span class="p">;</span>

	<span class="cm">/* Allocate a temporary DMA buffer for reading ID in the nand_scan() */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">.</span><span class="n">payload_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">.</span><span class="n">auxiliary_size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_alloc_dma_buffer</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nand_scan</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Chip scan failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ppdata</span><span class="p">.</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_device_parse_register</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ppdata</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="n">gpmi_nfc_exit</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">platform_device_id</span> <span class="n">gpmi_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;imx23-gpmi-nand&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">IS_MX23</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;imx28-gpmi-nand&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">IS_MX28</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;imx6q-gpmi-nand&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">IS_MX6Q</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">gpmi_nand_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;fsl,imx23-gpmi-nand&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">gpmi_ids</span><span class="p">[</span><span class="n">IS_MX23</span><span class="p">]</span>
	<span class="p">},</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;fsl,imx28-gpmi-nand&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">gpmi_ids</span><span class="p">[</span><span class="n">IS_MX28</span><span class="p">]</span>
	<span class="p">},</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;fsl,imx6q-gpmi-nand&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">gpmi_ids</span><span class="p">[</span><span class="n">IS_MX6Q</span><span class="p">]</span>
	<span class="p">},</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">gpmi_nand_id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">gpmi_nand_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="n">of_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">of_id</span> <span class="o">=</span> <span class="n">of_match_device</span><span class="p">(</span><span class="n">gpmi_nand_id_table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id_entry</span> <span class="o">=</span> <span class="n">of_id</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to find the right device id.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">this</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to allocate per-device memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">pdev</span>  <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">acquire_resources</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_acquire_resources</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">init_hardware</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_nfc_init</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_nfc_init</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_nfc_init</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">exit_nfc_init:</span>
	<span class="n">release_resources</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="nl">exit_acquire_resources:</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">gpmi_nand_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">gpmi_nfc_exit</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="n">release_resources</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">gpmi_nand_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;gpmi-nand&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">gpmi_nand_id_table</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>   <span class="o">=</span> <span class="n">gpmi_nand_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>  <span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">gpmi_nand_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">gpmi_ids</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">gpmi_nand_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpmi_nand_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;GPMI NAND driver registered. (IMX)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;i.MX GPMI NAND driver registration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">gpmi_nand_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpmi_nand_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">gpmi_nand_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">gpmi_nand_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Freescale Semiconductor, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;i.MX GPMI NAND Flash Controller Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
