<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › nand › gpmi-nand › gpmi-lib.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>gpmi-lib.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Freescale GPMI NAND Flash Driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2011 Freescale Semiconductor, Inc.</span>
<span class="cm"> * Copyright (C) 2008 Embedded Alley Solutions, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/mtd/gpmi-nand.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>

<span class="cp">#include &quot;gpmi-nand.h&quot;</span>
<span class="cp">#include &quot;gpmi-regs.h&quot;</span>
<span class="cp">#include &quot;bch-regs.h&quot;</span>

<span class="k">struct</span> <span class="n">timing_threshod</span> <span class="n">timing_default_threshold</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">max_data_setup_cycles</span>       <span class="o">=</span> <span class="p">(</span><span class="n">BM_GPMI_TIMING0_DATA_SETUP</span> <span class="o">&gt;&gt;</span>
						<span class="n">BP_GPMI_TIMING0_DATA_SETUP</span><span class="p">),</span>
	<span class="p">.</span><span class="n">internal_data_setup_in_ns</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sample_delay_factor</span>     <span class="o">=</span> <span class="p">(</span><span class="n">BM_GPMI_CTRL1_RDN_DELAY</span> <span class="o">&gt;&gt;</span>
						<span class="n">BP_GPMI_CTRL1_RDN_DELAY</span><span class="p">),</span>
	<span class="p">.</span><span class="n">max_dll_clock_period_in_ns</span>  <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_dll_delay_in_ns</span>         <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define MXS_SET_ADDR		0x4</span>
<span class="cp">#define MXS_CLR_ADDR		0x8</span>
<span class="cm">/*</span>
<span class="cm"> * Clear the bit and poll it cleared.  This is usually called with</span>
<span class="cm"> * a reset address and mask being either SFTRST(bit 31) or CLKGATE</span>
<span class="cm"> * (bit 30).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clear_poll_bit</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mh">0x400</span><span class="p">;</span>

	<span class="cm">/* clear the bit */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">MXS_CLR_ADDR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SFTRST needs 3 GPMI clocks to settle, the reference manual</span>
<span class="cm">	 * recommends to wait 1us.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* poll the bit becoming clear */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">timeout</span><span class="p">)</span>
		<span class="cm">/* nothing */</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">timeout</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define MODULE_CLKGATE		(1 &lt;&lt; 30)</span>
<span class="cp">#define MODULE_SFTRST		(1 &lt;&lt; 31)</span>
<span class="cm">/*</span>
<span class="cm"> * The current mxs_reset_block() will do two things:</span>
<span class="cm"> *  [1] enable the module.</span>
<span class="cm"> *  [2] reset the module.</span>
<span class="cm"> *</span>
<span class="cm"> * In most of the cases, it&#39;s ok.</span>
<span class="cm"> * But in MX23, there is a hardware bug in the BCH block (see erratum #2847).</span>
<span class="cm"> * If you try to soft reset the BCH block, it becomes unusable until</span>
<span class="cm"> * the next hard reset. This case occurs in the NAND boot mode. When the board</span>
<span class="cm"> * boots by NAND, the ROM of the chip will initialize the BCH blocks itself.</span>
<span class="cm"> * So If the driver tries to reset the BCH again, the BCH will not work anymore.</span>
<span class="cm"> * You will see a DMA timeout in this case. The bug has been fixed</span>
<span class="cm"> * in the following chips, such as MX28.</span>
<span class="cm"> *</span>
<span class="cm"> * To avoid this bug, just add a new parameter `just_enable` for</span>
<span class="cm"> * the mxs_reset_block(), and rewrite it here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_reset_block</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reset_addr</span><span class="p">,</span> <span class="n">bool</span> <span class="n">just_enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mh">0x400</span><span class="p">;</span>

	<span class="cm">/* clear and poll SFTRST */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">clear_poll_bit</span><span class="p">(</span><span class="n">reset_addr</span><span class="p">,</span> <span class="n">MODULE_SFTRST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* clear CLKGATE */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">MODULE_CLKGATE</span><span class="p">,</span> <span class="n">reset_addr</span> <span class="o">+</span> <span class="n">MXS_CLR_ADDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">just_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set SFTRST to reset the block */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">MODULE_SFTRST</span><span class="p">,</span> <span class="n">reset_addr</span> <span class="o">+</span> <span class="n">MXS_SET_ADDR</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* poll CLKGATE becoming set */</span>
		<span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">reset_addr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MODULE_CLKGATE</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">timeout</span><span class="p">)</span>
			<span class="cm">/* nothing */</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear and poll SFTRST */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">clear_poll_bit</span><span class="p">(</span><span class="n">reset_addr</span><span class="p">,</span> <span class="n">MODULE_SFTRST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* clear and poll CLKGATE */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">clear_poll_bit</span><span class="p">(</span><span class="n">reset_addr</span><span class="p">,</span> <span class="n">MODULE_CLKGATE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(%p): module reset timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">reset_addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gpmi_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_prepare_enable</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_reset_block</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/* Choose NAND mode. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_GPMI_MODE</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_CLR</span><span class="p">);</span>

	<span class="cm">/* Set the IRQ polarity. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_ATA_IRQRDY_POLARITY</span><span class="p">,</span>
				<span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_SET</span><span class="p">);</span>

	<span class="cm">/* Disable Write-Protection. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_DEV_RESET</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_SET</span><span class="p">);</span>

	<span class="cm">/* Select BCH ECC. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_BCH_MODE</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_SET</span><span class="p">);</span>

	<span class="n">clk_disable_unprepare</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function is very useful. It is called only when the bug occur. */</span>
<span class="kt">void</span> <span class="nf">gpmi_dump_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Show GPMI registers :</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">HW_GPMI_DEBUG</span> <span class="o">/</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mh">0x10</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;offset 0x%.3x : 0x%.8x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* start to print out the BCH info */</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;BCH Geometry :</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;GF length              : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">gf_len</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ECC Strength           : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Page Size in Bytes     : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Metadata Size in Bytes : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">metadata_size</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ECC Chunk Size in Bytes: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_size</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ECC Chunk Count        : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Payload Size in Bytes  : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">payload_size</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Auxiliary Size in Bytes: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">auxiliary_size</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Auxiliary Status Offset: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">auxiliary_status_offset</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Block Mark Byte Offset : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">block_mark_byte_offset</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Block Mark Bit Offset  : %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">block_mark_bit_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Configures the geometry for BCH.  */</span>
<span class="kt">int</span> <span class="nf">bch_set_geometry</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">bch_geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">metadata_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecc_strength</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">common_nfc_set_geometry</span><span class="p">(</span><span class="n">this</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">block_count</span>   <span class="o">=</span> <span class="n">bch_geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">block_size</span>    <span class="o">=</span> <span class="n">bch_geo</span><span class="o">-&gt;</span><span class="n">ecc_chunk_size</span><span class="p">;</span>
	<span class="n">metadata_size</span> <span class="o">=</span> <span class="n">bch_geo</span><span class="o">-&gt;</span><span class="n">metadata_size</span><span class="p">;</span>
	<span class="n">ecc_strength</span>  <span class="o">=</span> <span class="n">bch_geo</span><span class="o">-&gt;</span><span class="n">ecc_strength</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">page_size</span>     <span class="o">=</span> <span class="n">bch_geo</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_prepare_enable</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	* Due to erratum #2847 of the MX23, the BCH cannot be soft reset on this</span>
<span class="cm">	* chip, otherwise it will lock up. So we skip resetting BCH on the MX23.</span>
<span class="cm">	* On the other hand, the MX28 needs the reset, because one case has been</span>
<span class="cm">	* seen where the BCH produced ECC errors constantly after 10000</span>
<span class="cm">	* consecutive reboots. The latter case has not been seen on the MX23 yet,</span>
<span class="cm">	* still we don&#39;t know if it could happen there as well.</span>
<span class="cm">	*/</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpmi_reset_block</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">bch_regs</span><span class="p">,</span> <span class="n">GPMI_IS_MX23</span><span class="p">(</span><span class="n">this</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="cm">/* Configure layout 0. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BF_BCH_FLASH0LAYOUT0_NBLOCKS</span><span class="p">(</span><span class="n">block_count</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">BF_BCH_FLASH0LAYOUT0_META_SIZE</span><span class="p">(</span><span class="n">metadata_size</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">BF_BCH_FLASH0LAYOUT0_ECC0</span><span class="p">(</span><span class="n">ecc_strength</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">BF_BCH_FLASH0LAYOUT0_DATA0_SIZE</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">this</span><span class="p">),</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">bch_regs</span> <span class="o">+</span> <span class="n">HW_BCH_FLASH0LAYOUT0</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">BF_BCH_FLASH0LAYOUT1_PAGE_SIZE</span><span class="p">(</span><span class="n">page_size</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">BF_BCH_FLASH0LAYOUT1_ECCN</span><span class="p">(</span><span class="n">ecc_strength</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">BF_BCH_FLASH0LAYOUT1_DATAN_SIZE</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">this</span><span class="p">),</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">bch_regs</span> <span class="o">+</span> <span class="n">HW_BCH_FLASH0LAYOUT1</span><span class="p">);</span>

	<span class="cm">/* Set *all* chip selects to use layout 0. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">bch_regs</span> <span class="o">+</span> <span class="n">HW_BCH_LAYOUTSELECT</span><span class="p">);</span>

	<span class="cm">/* Enable interrupts. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_BCH_CTRL_COMPLETE_IRQ_EN</span><span class="p">,</span>
				<span class="n">r</span><span class="o">-&gt;</span><span class="n">bch_regs</span> <span class="o">+</span> <span class="n">HW_BCH_CTRL_SET</span><span class="p">);</span>

	<span class="n">clk_disable_unprepare</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Converts time in nanoseconds to cycles. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ns_to_cycles</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">period</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span> <span class="o">+</span> <span class="n">period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">period</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define DEF_MIN_PROP_DELAY	5</span>
<span class="cp">#define DEF_MAX_PROP_DELAY	9</span>
<span class="cm">/* Apply timing to current hardware conditions. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpmi_nfc_compute_hardware_timing</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">gpmi_nfc_hardware_timing</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timing_threshod</span> <span class="o">*</span><span class="n">nfc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timing_default_threshold</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">nand</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_timing</span> <span class="n">target</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">timing</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">improved_timing_is_available</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clock_frequency_in_hz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dll_use_half_periods</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dll_delay_shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_sample_delay_in_ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address_setup_in_cycles</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_setup_in_ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_setup_in_cycles</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_hold_in_cycles</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ideal_sample_delay_in_ns</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sample_delay_factor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tEYE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_prop_delay_in_ns</span> <span class="o">=</span> <span class="n">DEF_MIN_PROP_DELAY</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_prop_delay_in_ns</span> <span class="o">=</span> <span class="n">DEF_MAX_PROP_DELAY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are multiple chips, we need to relax the timings to allow</span>
<span class="cm">	 * for signal distortion due to higher capacitance.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nand</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target</span><span class="p">.</span><span class="n">data_setup_in_ns</span>    <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">target</span><span class="p">.</span><span class="n">data_hold_in_ns</span>     <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">target</span><span class="p">.</span><span class="n">address_setup_in_ns</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nand</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target</span><span class="p">.</span><span class="n">data_setup_in_ns</span>    <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">target</span><span class="p">.</span><span class="n">data_hold_in_ns</span>     <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">target</span><span class="p">.</span><span class="n">address_setup_in_ns</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if improved timing information is available. */</span>
	<span class="n">improved_timing_is_available</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">tREA_in_ns</span>  <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">tRLOH_in_ns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">tRHOH_in_ns</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">;</span>

	<span class="cm">/* Inspect the clock. */</span>
	<span class="n">clock_frequency_in_hz</span> <span class="o">=</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">clock_frequency_in_hz</span><span class="p">;</span>
	<span class="n">clock_period_in_ns</span>    <span class="o">=</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="n">clock_frequency_in_hz</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The NFC quantizes setup and hold parameters in terms of clock cycles.</span>
<span class="cm">	 * Here, we quantize the setup and hold timing parameters to the</span>
<span class="cm">	 * next-highest clock period to make sure we apply at least the</span>
<span class="cm">	 * specified times.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For data setup and data hold, the hardware interprets a value of zero</span>
<span class="cm">	 * as the largest possible delay. This is not what&#39;s intended by a zero</span>
<span class="cm">	 * in the input parameter, so we impose a minimum of one cycle.</span>
<span class="cm">	 */</span>
	<span class="n">data_setup_in_cycles</span>    <span class="o">=</span> <span class="n">ns_to_cycles</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">data_setup_in_ns</span><span class="p">,</span>
							<span class="n">clock_period_in_ns</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">data_hold_in_cycles</span>     <span class="o">=</span> <span class="n">ns_to_cycles</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">data_hold_in_ns</span><span class="p">,</span>
							<span class="n">clock_period_in_ns</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">address_setup_in_cycles</span> <span class="o">=</span> <span class="n">ns_to_cycles</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">address_setup_in_ns</span><span class="p">,</span>
							<span class="n">clock_period_in_ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The clock&#39;s period affects the sample delay in a number of ways:</span>
<span class="cm">	 *</span>
<span class="cm">	 * (1) The NFC HAL tells us the maximum clock period the sample delay</span>
<span class="cm">	 *     DLL can tolerate. If the clock period is greater than half that</span>
<span class="cm">	 *     maximum, we must configure the DLL to be driven by half periods.</span>
<span class="cm">	 *</span>
<span class="cm">	 * (2) We need to convert from an ideal sample delay, in ns, to a</span>
<span class="cm">	 *     &quot;sample delay factor,&quot; which the NFC uses. This factor depends on</span>
<span class="cm">	 *     whether we&#39;re driving the DLL with full or half periods.</span>
<span class="cm">	 *     Paraphrasing the reference manual:</span>
<span class="cm">	 *</span>
<span class="cm">	 *         AD = SDF x 0.125 x RP</span>
<span class="cm">	 *</span>
<span class="cm">	 * where:</span>
<span class="cm">	 *</span>
<span class="cm">	 *     AD   is the applied delay, in ns.</span>
<span class="cm">	 *     SDF  is the sample delay factor, which is dimensionless.</span>
<span class="cm">	 *     RP   is the reference period, in ns, which is a full clock period</span>
<span class="cm">	 *          if the DLL is being driven by full periods, or half that if</span>
<span class="cm">	 *          the DLL is being driven by half periods.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Let&#39;s re-arrange this in a way that&#39;s more useful to us:</span>
<span class="cm">	 *</span>
<span class="cm">	 *                        8</span>
<span class="cm">	 *         SDF  =  AD x ----</span>
<span class="cm">	 *                       RP</span>
<span class="cm">	 *</span>
<span class="cm">	 * The reference period is either the clock period or half that, so this</span>
<span class="cm">	 * is:</span>
<span class="cm">	 *</span>
<span class="cm">	 *                        8       AD x DDF</span>
<span class="cm">	 *         SDF  =  AD x -----  =  --------</span>
<span class="cm">	 *                      f x P        P</span>
<span class="cm">	 *</span>
<span class="cm">	 * where:</span>
<span class="cm">	 *</span>
<span class="cm">	 *       f  is 1 or 1/2, depending on how we&#39;re driving the DLL.</span>
<span class="cm">	 *       P  is the clock period.</span>
<span class="cm">	 *     DDF  is the DLL Delay Factor, a dimensionless value that</span>
<span class="cm">	 *          incorporates all the constants in the conversion.</span>
<span class="cm">	 *</span>
<span class="cm">	 * DDF will be either 8 or 16, both of which are powers of two. We can</span>
<span class="cm">	 * reduce the cost of this conversion by using bit shifts instead of</span>
<span class="cm">	 * multiplication or division. Thus:</span>
<span class="cm">	 *</span>
<span class="cm">	 *                 AD &lt;&lt; DDS</span>
<span class="cm">	 *         SDF  =  ---------</span>
<span class="cm">	 *                     P</span>
<span class="cm">	 *</span>
<span class="cm">	 *     or</span>
<span class="cm">	 *</span>
<span class="cm">	 *         AD  =  (SDF &gt;&gt; DDS) x P</span>
<span class="cm">	 *</span>
<span class="cm">	 * where:</span>
<span class="cm">	 *</span>
<span class="cm">	 *     DDS  is the DLL Delay Shift, the logarithm to base 2 of the DDF.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clock_period_in_ns</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_dll_clock_period_in_ns</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dll_use_half_periods</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">dll_delay_shift</span>      <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dll_use_half_periods</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">dll_delay_shift</span>      <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the maximum sample delay the NFC allows, under current</span>
<span class="cm">	 * conditions. If the clock is running too slowly, no sample delay is</span>
<span class="cm">	 * possible.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clock_period_in_ns</span> <span class="o">&gt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_dll_clock_period_in_ns</span><span class="p">)</span>
		<span class="n">max_sample_delay_in_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Compute the delay implied by the largest sample delay factor</span>
<span class="cm">		 * the NFC allows.</span>
<span class="cm">		 */</span>
		<span class="n">max_sample_delay_in_ns</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_sample_delay_factor</span> <span class="o">*</span> <span class="n">clock_period_in_ns</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
								<span class="n">dll_delay_shift</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if the implied sample delay larger than the NFC</span>
<span class="cm">		 * actually allows.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_sample_delay_in_ns</span> <span class="o">&gt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_dll_delay_in_ns</span><span class="p">)</span>
			<span class="n">max_sample_delay_in_ns</span> <span class="o">=</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_dll_delay_in_ns</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if improved timing information is available. If not, we have to</span>
<span class="cm">	 * use a less-sophisticated algorithm.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">improved_timing_is_available</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fold the read setup time required by the NFC into the ideal</span>
<span class="cm">		 * sample delay.</span>
<span class="cm">		 */</span>
		<span class="n">ideal_sample_delay_in_ns</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">gpmi_sample_delay_in_ns</span> <span class="o">+</span>
						<span class="n">nfc</span><span class="o">-&gt;</span><span class="n">internal_data_setup_in_ns</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The ideal sample delay may be greater than the maximum</span>
<span class="cm">		 * allowed by the NFC. If so, we can trade off sample delay time</span>
<span class="cm">		 * for more data setup time.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In each iteration of the following loop, we add a cycle to</span>
<span class="cm">		 * the data setup time and subtract a corresponding amount from</span>
<span class="cm">		 * the sample delay until we&#39;ve satisified the constraints or</span>
<span class="cm">		 * can&#39;t do any better.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">ideal_sample_delay_in_ns</span> <span class="o">&gt;</span> <span class="n">max_sample_delay_in_ns</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">data_setup_in_cycles</span> <span class="o">&lt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_data_setup_cycles</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">data_setup_in_cycles</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ideal_sample_delay_in_ns</span> <span class="o">-=</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ideal_sample_delay_in_ns</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ideal_sample_delay_in_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Compute the sample delay factor that corresponds most closely</span>
<span class="cm">		 * to the ideal sample delay. If the result is too large for the</span>
<span class="cm">		 * NFC, use the maximum value.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Notice that we use the ns_to_cycles function to compute the</span>
<span class="cm">		 * sample delay factor. We do this because the form of the</span>
<span class="cm">		 * computation is the same as that for calculating cycles.</span>
<span class="cm">		 */</span>
		<span class="n">sample_delay_factor</span> <span class="o">=</span>
			<span class="n">ns_to_cycles</span><span class="p">(</span>
				<span class="n">ideal_sample_delay_in_ns</span> <span class="o">&lt;&lt;</span> <span class="n">dll_delay_shift</span><span class="p">,</span>
							<span class="n">clock_period_in_ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sample_delay_factor</span> <span class="o">&gt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_sample_delay_factor</span><span class="p">)</span>
			<span class="n">sample_delay_factor</span> <span class="o">=</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_sample_delay_factor</span><span class="p">;</span>

		<span class="cm">/* Skip to the part where we return our results. */</span>
		<span class="k">goto</span> <span class="n">return_results</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If control arrives here, we have more detailed timing information,</span>
<span class="cm">	 * so we can use a better algorithm.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fold the read setup time required by the NFC into the maximum</span>
<span class="cm">	 * propagation delay.</span>
<span class="cm">	 */</span>
	<span class="n">max_prop_delay_in_ns</span> <span class="o">+=</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">internal_data_setup_in_ns</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Earlier, we computed the number of clock cycles required to satisfy</span>
<span class="cm">	 * the data setup time. Now, we need to know the actual nanoseconds.</span>
<span class="cm">	 */</span>
	<span class="n">data_setup_in_ns</span> <span class="o">=</span> <span class="n">clock_period_in_ns</span> <span class="o">*</span> <span class="n">data_setup_in_cycles</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute tEYE, the width of the data eye when reading from the NAND</span>
<span class="cm">	 * Flash. The eye width is fundamentally determined by the data setup</span>
<span class="cm">	 * time, perturbed by propagation delays and some characteristics of the</span>
<span class="cm">	 * NAND Flash device.</span>
<span class="cm">	 *</span>
<span class="cm">	 * start of the eye = max_prop_delay + tREA</span>
<span class="cm">	 * end of the eye   = min_prop_delay + tRHOH + data_setup</span>
<span class="cm">	 */</span>
	<span class="n">tEYE</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">min_prop_delay_in_ns</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">target</span><span class="p">.</span><span class="n">tRHOH_in_ns</span> <span class="o">+</span>
							<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">data_setup_in_ns</span><span class="p">;</span>

	<span class="n">tEYE</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">max_prop_delay_in_ns</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">target</span><span class="p">.</span><span class="n">tREA_in_ns</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The eye must be open. If it&#39;s not, we can try to open it by</span>
<span class="cm">	 * increasing its main forcer, the data setup time.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In each iteration of the following loop, we increase the data setup</span>
<span class="cm">	 * time by a single clock cycle. We do this until either the eye is</span>
<span class="cm">	 * open or we run into NFC limits.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">tEYE</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">data_setup_in_cycles</span> <span class="o">&lt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_data_setup_cycles</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Give a cycle to data setup. */</span>
		<span class="n">data_setup_in_cycles</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Synchronize the data setup time with the cycles. */</span>
		<span class="n">data_setup_in_ns</span> <span class="o">+=</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>
		<span class="cm">/* Adjust tEYE accordingly. */</span>
		<span class="n">tEYE</span> <span class="o">+=</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When control arrives here, the eye is open. The ideal time to sample</span>
<span class="cm">	 * the data is in the center of the eye:</span>
<span class="cm">	 *</span>
<span class="cm">	 *     end of the eye + start of the eye</span>
<span class="cm">	 *     ---------------------------------  -  data_setup</span>
<span class="cm">	 *                    2</span>
<span class="cm">	 *</span>
<span class="cm">	 * After some algebra, this simplifies to the code immediately below.</span>
<span class="cm">	 */</span>
	<span class="n">ideal_sample_delay_in_ns</span> <span class="o">=</span>
		<span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">max_prop_delay_in_ns</span> <span class="o">+</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">target</span><span class="p">.</span><span class="n">tREA_in_ns</span> <span class="o">+</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">min_prop_delay_in_ns</span> <span class="o">+</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">target</span><span class="p">.</span><span class="n">tRHOH_in_ns</span> <span class="o">-</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">data_setup_in_ns</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following figure illustrates some aspects of a NAND Flash read:</span>
<span class="cm">	 *</span>
<span class="cm">	 *</span>
<span class="cm">	 *           __                   _____________________________________</span>
<span class="cm">	 * RDN         \_________________/</span>
<span class="cm">	 *</span>
<span class="cm">	 *                                         &lt;---- tEYE -----&gt;</span>
<span class="cm">	 *                                        /-----------------\</span>
<span class="cm">	 * Read Data ----------------------------&lt;                   &gt;---------</span>
<span class="cm">	 *                                        \-----------------/</span>
<span class="cm">	 *             ^                 ^                 ^              ^</span>
<span class="cm">	 *             |                 |                 |              |</span>
<span class="cm">	 *             |&lt;--Data Setup --&gt;|&lt;--Delay Time --&gt;|              |</span>
<span class="cm">	 *             |                 |                 |              |</span>
<span class="cm">	 *             |                 |                                |</span>
<span class="cm">	 *             |                 |&lt;--   Quantized Delay Time   --&gt;|</span>
<span class="cm">	 *             |                 |                                |</span>
<span class="cm">	 *</span>
<span class="cm">	 *</span>
<span class="cm">	 * We have some issues we must now address:</span>
<span class="cm">	 *</span>
<span class="cm">	 * (1) The *ideal* sample delay time must not be negative. If it is, we</span>
<span class="cm">	 *     jam it to zero.</span>
<span class="cm">	 *</span>
<span class="cm">	 * (2) The *ideal* sample delay time must not be greater than that</span>
<span class="cm">	 *     allowed by the NFC. If it is, we can increase the data setup</span>
<span class="cm">	 *     time, which will reduce the delay between the end of the data</span>
<span class="cm">	 *     setup and the center of the eye. It will also make the eye</span>
<span class="cm">	 *     larger, which might help with the next issue...</span>
<span class="cm">	 *</span>
<span class="cm">	 * (3) The *quantized* sample delay time must not fall either before the</span>
<span class="cm">	 *     eye opens or after it closes (the latter is the problem</span>
<span class="cm">	 *     illustrated in the above figure).</span>
<span class="cm">	 */</span>

	<span class="cm">/* Jam a negative ideal sample delay to zero. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ideal_sample_delay_in_ns</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ideal_sample_delay_in_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Extend the data setup as needed to reduce the ideal sample delay</span>
<span class="cm">	 * below the maximum permitted by the NFC.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">ideal_sample_delay_in_ns</span> <span class="o">&gt;</span> <span class="n">max_sample_delay_in_ns</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">data_setup_in_cycles</span> <span class="o">&lt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_data_setup_cycles</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Give a cycle to data setup. */</span>
		<span class="n">data_setup_in_cycles</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Synchronize the data setup time with the cycles. */</span>
		<span class="n">data_setup_in_ns</span> <span class="o">+=</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>
		<span class="cm">/* Adjust tEYE accordingly. */</span>
		<span class="n">tEYE</span> <span class="o">+=</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Decrease the ideal sample delay by one half cycle, to keep it</span>
<span class="cm">		 * in the middle of the eye.</span>
<span class="cm">		 */</span>
		<span class="n">ideal_sample_delay_in_ns</span> <span class="o">-=</span> <span class="p">(</span><span class="n">clock_period_in_ns</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Jam a negative ideal sample delay to zero. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ideal_sample_delay_in_ns</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ideal_sample_delay_in_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the sample delay factor that corresponds to the ideal sample</span>
<span class="cm">	 * delay. If the result is too large, then use the maximum allowed</span>
<span class="cm">	 * value.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Notice that we use the ns_to_cycles function to compute the sample</span>
<span class="cm">	 * delay factor. We do this because the form of the computation is the</span>
<span class="cm">	 * same as that for calculating cycles.</span>
<span class="cm">	 */</span>
	<span class="n">sample_delay_factor</span> <span class="o">=</span>
		<span class="n">ns_to_cycles</span><span class="p">(</span><span class="n">ideal_sample_delay_in_ns</span> <span class="o">&lt;&lt;</span> <span class="n">dll_delay_shift</span><span class="p">,</span>
							<span class="n">clock_period_in_ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sample_delay_factor</span> <span class="o">&gt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_sample_delay_factor</span><span class="p">)</span>
		<span class="n">sample_delay_factor</span> <span class="o">=</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_sample_delay_factor</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These macros conveniently encapsulate a computation we&#39;ll use to</span>
<span class="cm">	 * continuously evaluate whether or not the data sample delay is inside</span>
<span class="cm">	 * the eye.</span>
<span class="cm">	 */</span>
	<span class="cp">#define IDEAL_DELAY  ((int) ideal_sample_delay_in_ns)</span>

	<span class="cp">#define QUANTIZED_DELAY  \</span>
<span class="cp">		((int) ((sample_delay_factor * clock_period_in_ns) &gt;&gt; \</span>
<span class="cp">							dll_delay_shift))</span>

	<span class="cp">#define DELAY_ERROR  (abs(QUANTIZED_DELAY - IDEAL_DELAY))</span>

	<span class="cp">#define SAMPLE_IS_NOT_WITHIN_THE_EYE  (DELAY_ERROR &gt; (tEYE &gt;&gt; 1))</span>

	<span class="cm">/*</span>
<span class="cm">	 * While the quantized sample time falls outside the eye, reduce the</span>
<span class="cm">	 * sample delay or extend the data setup to move the sampling point back</span>
<span class="cm">	 * toward the eye. Do not allow the number of data setup cycles to</span>
<span class="cm">	 * exceed the maximum allowed by the NFC.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">SAMPLE_IS_NOT_WITHIN_THE_EYE</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">data_setup_in_cycles</span> <span class="o">&lt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_data_setup_cycles</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If control arrives here, the quantized sample delay falls</span>
<span class="cm">		 * outside the eye. Check if it&#39;s before the eye opens, or after</span>
<span class="cm">		 * the eye closes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">QUANTIZED_DELAY</span> <span class="o">&gt;</span> <span class="n">IDEAL_DELAY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If control arrives here, the quantized sample delay</span>
<span class="cm">			 * falls after the eye closes. Decrease the quantized</span>
<span class="cm">			 * delay time and then go back to re-evaluate.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sample_delay_factor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sample_delay_factor</span><span class="o">--</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If control arrives here, the quantized sample delay falls</span>
<span class="cm">		 * before the eye opens. Shift the sample point by increasing</span>
<span class="cm">		 * data setup time. This will also make the eye larger.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Give a cycle to data setup. */</span>
		<span class="n">data_setup_in_cycles</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Synchronize the data setup time with the cycles. */</span>
		<span class="n">data_setup_in_ns</span> <span class="o">+=</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>
		<span class="cm">/* Adjust tEYE accordingly. */</span>
		<span class="n">tEYE</span> <span class="o">+=</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Decrease the ideal sample delay by one half cycle, to keep it</span>
<span class="cm">		 * in the middle of the eye.</span>
<span class="cm">		 */</span>
		<span class="n">ideal_sample_delay_in_ns</span> <span class="o">-=</span> <span class="p">(</span><span class="n">clock_period_in_ns</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* ...and one less period for the delay time. */</span>
		<span class="n">ideal_sample_delay_in_ns</span> <span class="o">-=</span> <span class="n">clock_period_in_ns</span><span class="p">;</span>

		<span class="cm">/* Jam a negative ideal sample delay to zero. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ideal_sample_delay_in_ns</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ideal_sample_delay_in_ns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We have a new ideal sample delay, so re-compute the quantized</span>
<span class="cm">		 * delay.</span>
<span class="cm">		 */</span>
		<span class="n">sample_delay_factor</span> <span class="o">=</span>
			<span class="n">ns_to_cycles</span><span class="p">(</span>
				<span class="n">ideal_sample_delay_in_ns</span> <span class="o">&lt;&lt;</span> <span class="n">dll_delay_shift</span><span class="p">,</span>
							<span class="n">clock_period_in_ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sample_delay_factor</span> <span class="o">&gt;</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_sample_delay_factor</span><span class="p">)</span>
			<span class="n">sample_delay_factor</span> <span class="o">=</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">max_sample_delay_factor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Control arrives here when we&#39;re ready to return our results. */</span>
<span class="nl">return_results:</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">data_setup_in_cycles</span>    <span class="o">=</span> <span class="n">data_setup_in_cycles</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">data_hold_in_cycles</span>     <span class="o">=</span> <span class="n">data_hold_in_cycles</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">address_setup_in_cycles</span> <span class="o">=</span> <span class="n">address_setup_in_cycles</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">use_half_periods</span>        <span class="o">=</span> <span class="n">dll_use_half_periods</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">sample_delay_factor</span>     <span class="o">=</span> <span class="n">sample_delay_factor</span><span class="p">;</span>

	<span class="cm">/* Return success. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Begin the I/O */</span>
<span class="kt">void</span> <span class="nf">gpmi_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timing_threshod</span> <span class="o">*</span><span class="n">nfc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">timing_default_threshold</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">gpmi_regs</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">clock_period_in_ns</span><span class="p">;</span>
	<span class="kt">uint32_t</span>       <span class="n">reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>   <span class="n">dll_wait_time_in_us</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpmi_nfc_hardware_timing</span>  <span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Enable the clock. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_prepare_enable</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;We failed in enable the clk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set ready/busy timeout */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x500</span> <span class="o">&lt;&lt;</span> <span class="n">BP_GPMI_TIMING1_BUSY_TIMEOUT</span><span class="p">,</span>
		<span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_TIMING1</span><span class="p">);</span>

	<span class="cm">/* Get the timing information we need. */</span>
	<span class="n">nfc</span><span class="o">-&gt;</span><span class="n">clock_frequency_in_hz</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
	<span class="n">clock_period_in_ns</span> <span class="o">=</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="n">nfc</span><span class="o">-&gt;</span><span class="n">clock_frequency_in_hz</span><span class="p">;</span>

	<span class="n">gpmi_nfc_compute_hardware_timing</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Set up all the simple timing parameters. */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">BF_GPMI_TIMING0_ADDRESS_SETUP</span><span class="p">(</span><span class="n">hw</span><span class="p">.</span><span class="n">address_setup_in_cycles</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">BF_GPMI_TIMING0_DATA_HOLD</span><span class="p">(</span><span class="n">hw</span><span class="p">.</span><span class="n">data_hold_in_cycles</span><span class="p">)</span>         <span class="o">|</span>
		<span class="n">BF_GPMI_TIMING0_DATA_SETUP</span><span class="p">(</span><span class="n">hw</span><span class="p">.</span><span class="n">data_setup_in_cycles</span><span class="p">)</span>       <span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_TIMING0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * DLL_ENABLE must be set to 0 when setting RDN_DELAY or HALF_PERIOD.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_DLL_ENABLE</span><span class="p">,</span> <span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_CLR</span><span class="p">);</span>

	<span class="cm">/* Clear out the DLL control fields. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_RDN_DELAY</span><span class="p">,</span>   <span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_CLR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_HALF_PERIOD</span><span class="p">,</span> <span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_CLR</span><span class="p">);</span>

	<span class="cm">/* If no sample delay is called for, return immediately. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_delay_factor</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Configure the HALF_PERIOD flag. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="p">.</span><span class="n">use_half_periods</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_HALF_PERIOD</span><span class="p">,</span>
						<span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_SET</span><span class="p">);</span>

	<span class="cm">/* Set the delay factor. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BF_GPMI_CTRL1_RDN_DELAY</span><span class="p">(</span><span class="n">hw</span><span class="p">.</span><span class="n">sample_delay_factor</span><span class="p">),</span>
						<span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_SET</span><span class="p">);</span>

	<span class="cm">/* Enable the DLL. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_GPMI_CTRL1_DLL_ENABLE</span><span class="p">,</span> <span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_CTRL1_SET</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * After we enable the GPMI DLL, we have to wait 64 clock cycles before</span>
<span class="cm">	 * we can use the GPMI.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Calculate the amount of time we need to wait, in microseconds.</span>
<span class="cm">	 */</span>
	<span class="n">dll_wait_time_in_us</span> <span class="o">=</span> <span class="p">(</span><span class="n">clock_period_in_ns</span> <span class="o">*</span> <span class="mi">64</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dll_wait_time_in_us</span><span class="p">)</span>
		<span class="n">dll_wait_time_in_us</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Wait for the DLL to settle. */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">dll_wait_time_in_us</span><span class="p">);</span>

<span class="nl">err_out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">gpmi_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="n">clk_disable_unprepare</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Clears a BCH interrupt. */</span>
<span class="kt">void</span> <span class="nf">gpmi_clear_bch</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BM_BCH_CTRL_COMPLETE_IRQ</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">bch_regs</span> <span class="o">+</span> <span class="n">HW_BCH_CTRL_CLR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns the Ready/Busy status of the given chip. */</span>
<span class="kt">int</span> <span class="nf">gpmi_is_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resources</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">resources</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">GPMI_IS_MX23</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">MX23_BM_GPMI_DEBUG_READY0</span> <span class="o">&lt;&lt;</span> <span class="n">chip</span><span class="p">;</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_DEBUG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">GPMI_IS_MX28</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">||</span> <span class="n">GPMI_IS_MX6Q</span><span class="p">(</span><span class="n">this</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* MX28 shares the same R/B register as MX6Q. */</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">MX28_BF_GPMI_STAT_READY_BUSY</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chip</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">gpmi_regs</span> <span class="o">+</span> <span class="n">HW_GPMI_STAT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;unknow arch.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_dma_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">dma_ops_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">last_dma_type</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_type</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">dma_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gpmi_send_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">get_dma_chan</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chip</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="cm">/* [1] send out the PIO words */</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">BF_GPMI_CTRL0_COMMAND_MODE</span><span class="p">(</span><span class="n">BV_GPMI_CTRL0_COMMAND_MODE__WRITE</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BM_GPMI_CTRL0_WORD_LENGTH</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_CS</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_LOCK_CS</span><span class="p">(</span><span class="n">LOCK_CS_ENABLE</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_ADDRESS</span><span class="p">(</span><span class="n">BV_GPMI_CTRL0_ADDRESS__NAND_CLE</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BM_GPMI_CTRL0_ADDRESS_INCREMENT</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_XFER_COUNT</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">command_length</span><span class="p">);</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">pio</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pio</span><span class="p">),</span> <span class="n">DMA_TRANS_NONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 1 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* [2] send out the COMMAND + ADDRESS string stored in @buffer */</span>
	<span class="n">sgl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_sgl</span><span class="p">;</span>

	<span class="n">sg_init_one</span><span class="p">(</span><span class="n">sgl</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_buffer</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">command_length</span><span class="p">);</span>
	<span class="n">dma_map_sg</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
				<span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DMA_MEM_TO_DEV</span><span class="p">,</span>
				<span class="n">DMA_PREP_INTERRUPT</span> <span class="o">|</span> <span class="n">DMA_CTRL_ACK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 2 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* [3] submit the DMA */</span>
	<span class="n">set_dma_type</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DMA_FOR_COMMAND</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">start_dma_without_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gpmi_send_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">get_dma_chan</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chip</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">command_mode</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pio</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/* [1] PIO */</span>
	<span class="n">command_mode</span> <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_COMMAND_MODE__WRITE</span><span class="p">;</span>
	<span class="n">address</span>      <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_ADDRESS__NAND_DATA</span><span class="p">;</span>

	<span class="n">pio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">BF_GPMI_CTRL0_COMMAND_MODE</span><span class="p">(</span><span class="n">command_mode</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BM_GPMI_CTRL0_WORD_LENGTH</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_CS</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_LOCK_CS</span><span class="p">(</span><span class="n">LOCK_CS_ENABLE</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_ADDRESS</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_XFER_COUNT</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_len</span><span class="p">);</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">pio</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pio</span><span class="p">),</span> <span class="n">DMA_TRANS_NONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 1 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* [2] send DMA request */</span>
	<span class="n">prepare_data_dma</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">data_sgl</span><span class="p">,</span>
					<span class="mi">1</span><span class="p">,</span> <span class="n">DMA_MEM_TO_DEV</span><span class="p">,</span>
					<span class="n">DMA_PREP_INTERRUPT</span> <span class="o">|</span> <span class="n">DMA_CTRL_ACK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 2 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* [3] submit the DMA */</span>
	<span class="n">set_dma_type</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DMA_FOR_WRITE_DATA</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">start_dma_without_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gpmi_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">get_dma_chan</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chip</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pio</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/* [1] : send PIO */</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">BF_GPMI_CTRL0_COMMAND_MODE</span><span class="p">(</span><span class="n">BV_GPMI_CTRL0_COMMAND_MODE__READ</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BM_GPMI_CTRL0_WORD_LENGTH</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_CS</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_LOCK_CS</span><span class="p">(</span><span class="n">LOCK_CS_ENABLE</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_ADDRESS</span><span class="p">(</span><span class="n">BV_GPMI_CTRL0_ADDRESS__NAND_DATA</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_XFER_COUNT</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">upper_len</span><span class="p">);</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">pio</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pio</span><span class="p">),</span> <span class="n">DMA_TRANS_NONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 1 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* [2] : send DMA request */</span>
	<span class="n">prepare_data_dma</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">data_sgl</span><span class="p">,</span>
					<span class="mi">1</span><span class="p">,</span> <span class="n">DMA_DEV_TO_MEM</span><span class="p">,</span>
					<span class="n">DMA_PREP_INTERRUPT</span> <span class="o">|</span> <span class="n">DMA_CTRL_ACK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 2 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* [3] : submit the DMA */</span>
	<span class="n">set_dma_type</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DMA_FOR_READ_DATA</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">start_dma_without_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gpmi_send_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			<span class="n">dma_addr_t</span> <span class="n">payload</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">auxiliary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">command_mode</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ecc_command</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">buffer_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">get_dma_chan</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chip</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pio</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="cm">/* A DMA descriptor that does an ECC page read. */</span>
	<span class="n">command_mode</span> <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_COMMAND_MODE__WRITE</span><span class="p">;</span>
	<span class="n">address</span>      <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_ADDRESS__NAND_DATA</span><span class="p">;</span>
	<span class="n">ecc_command</span>  <span class="o">=</span> <span class="n">BV_GPMI_ECCCTRL_ECC_CMD__BCH_ENCODE</span><span class="p">;</span>
	<span class="n">buffer_mask</span>  <span class="o">=</span> <span class="n">BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_PAGE</span> <span class="o">|</span>
				<span class="n">BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_AUXONLY</span><span class="p">;</span>

	<span class="n">pio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">BF_GPMI_CTRL0_COMMAND_MODE</span><span class="p">(</span><span class="n">command_mode</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BM_GPMI_CTRL0_WORD_LENGTH</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_CS</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_LOCK_CS</span><span class="p">(</span><span class="n">LOCK_CS_ENABLE</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_ADDRESS</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_XFER_COUNT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">BM_GPMI_ECCCTRL_ENABLE_ECC</span>
		<span class="o">|</span> <span class="n">BF_GPMI_ECCCTRL_ECC_CMD</span><span class="p">(</span><span class="n">ecc_command</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_ECCCTRL_BUFFER_MASK</span><span class="p">(</span><span class="n">buffer_mask</span><span class="p">);</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">;</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">payload</span><span class="p">;</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">auxiliary</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">pio</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pio</span><span class="p">),</span> <span class="n">DMA_TRANS_NONE</span><span class="p">,</span>
					<span class="n">DMA_CTRL_ACK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 2 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set_dma_type</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DMA_FOR_WRITE_ECC_PAGE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">start_dma_with_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gpmi_read_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpmi_nand_data</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
				<span class="n">dma_addr_t</span> <span class="n">payload</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">auxiliary</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bch_geometry</span> <span class="o">*</span><span class="n">geo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">bch_geometry</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">command_mode</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ecc_command</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">buffer_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_async_tx_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_chan</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">get_dma_chan</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chip</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">current_chip</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pio</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="cm">/* [1] Wait for the chip to report ready. */</span>
	<span class="n">command_mode</span> <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_COMMAND_MODE__WAIT_FOR_READY</span><span class="p">;</span>
	<span class="n">address</span>      <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_ADDRESS__NAND_DATA</span><span class="p">;</span>

	<span class="n">pio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">BF_GPMI_CTRL0_COMMAND_MODE</span><span class="p">(</span><span class="n">command_mode</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BM_GPMI_CTRL0_WORD_LENGTH</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_CS</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_LOCK_CS</span><span class="p">(</span><span class="n">LOCK_CS_ENABLE</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_ADDRESS</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_XFER_COUNT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">pio</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
				<span class="n">DMA_TRANS_NONE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 1 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* [2] Enable the BCH block and read. */</span>
	<span class="n">command_mode</span> <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_COMMAND_MODE__READ</span><span class="p">;</span>
	<span class="n">address</span>      <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_ADDRESS__NAND_DATA</span><span class="p">;</span>
	<span class="n">ecc_command</span>  <span class="o">=</span> <span class="n">BV_GPMI_ECCCTRL_ECC_CMD__BCH_DECODE</span><span class="p">;</span>
	<span class="n">buffer_mask</span>  <span class="o">=</span> <span class="n">BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_PAGE</span>
			<span class="o">|</span> <span class="n">BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_AUXONLY</span><span class="p">;</span>

	<span class="n">pio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">BF_GPMI_CTRL0_COMMAND_MODE</span><span class="p">(</span><span class="n">command_mode</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BM_GPMI_CTRL0_WORD_LENGTH</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_CS</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_LOCK_CS</span><span class="p">(</span><span class="n">LOCK_CS_ENABLE</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_ADDRESS</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_XFER_COUNT</span><span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">);</span>

	<span class="n">pio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">BM_GPMI_ECCCTRL_ENABLE_ECC</span>
		<span class="o">|</span> <span class="n">BF_GPMI_ECCCTRL_ECC_CMD</span><span class="p">(</span><span class="n">ecc_command</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_ECCCTRL_BUFFER_MASK</span><span class="p">(</span><span class="n">buffer_mask</span><span class="p">);</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">geo</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">;</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">payload</span><span class="p">;</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">auxiliary</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">pio</span><span class="p">,</span>
					<span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pio</span><span class="p">),</span> <span class="n">DMA_TRANS_NONE</span><span class="p">,</span>
					<span class="n">DMA_PREP_INTERRUPT</span> <span class="o">|</span> <span class="n">DMA_CTRL_ACK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 2 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* [3] Disable the BCH block */</span>
	<span class="n">command_mode</span> <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_COMMAND_MODE__WAIT_FOR_READY</span><span class="p">;</span>
	<span class="n">address</span>      <span class="o">=</span> <span class="n">BV_GPMI_CTRL0_ADDRESS__NAND_DATA</span><span class="p">;</span>

	<span class="n">pio</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">BF_GPMI_CTRL0_COMMAND_MODE</span><span class="p">(</span><span class="n">command_mode</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BM_GPMI_CTRL0_WORD_LENGTH</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_CS</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_LOCK_CS</span><span class="p">(</span><span class="n">LOCK_CS_ENABLE</span><span class="p">,</span> <span class="n">this</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_ADDRESS</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">BF_GPMI_CTRL0_XFER_COUNT</span><span class="p">(</span><span class="n">geo</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">);</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pio</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* clear GPMI_HW_GPMI_ECCCTRL, disable the BCH. */</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="n">dmaengine_prep_slave_sg</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="p">)</span><span class="n">pio</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
				<span class="n">DMA_TRANS_NONE</span><span class="p">,</span>
				<span class="n">DMA_PREP_INTERRUPT</span> <span class="o">|</span> <span class="n">DMA_CTRL_ACK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;step 3 error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* [4] submit the DMA */</span>
	<span class="n">set_dma_type</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">DMA_FOR_READ_ECC_PAGE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">start_dma_with_bch_irq</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
