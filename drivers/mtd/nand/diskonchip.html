<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › nand › diskonchip.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>diskonchip.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/mtd/nand/diskonchip.c</span>
<span class="cm"> *</span>
<span class="cm"> * (C) 2003 Red Hat, Inc.</span>
<span class="cm"> * (C) 2004 Dan Brown &lt;dan_brown@ieee.org&gt;</span>
<span class="cm"> * (C) 2004 Kalev Lember &lt;kalev@smartlink.ee&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Author: David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> * Additional Diskonchip 2000 and Millennium support by Dan Brown &lt;dan_brown@ieee.org&gt;</span>
<span class="cm"> * Diskonchip Millennium Plus support by Kalev Lember &lt;kalev@smartlink.ee&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Error correction code lifted from the old docecc code</span>
<span class="cm"> * Author: Fabrice Bellard (fabrice.bellard@netgem.com)</span>
<span class="cm"> * Copyright (C) 2000 Netgem S.A.</span>
<span class="cm"> * converted to the generic Reed-Solomon library by Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Interface to generic NAND code for M-Systems DiskOnChip devices</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/rslib.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nand.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/doc2000.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/partitions.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/inftl.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cm">/* Where to look for the devices? */</span>
<span class="cp">#ifndef CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS</span>
<span class="cp">#define CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS 0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">doc_locations</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)</span>
<span class="cp">#ifdef CONFIG_MTD_NAND_DISKONCHIP_PROBE_HIGH</span>
	<span class="mh">0xfffc8000</span><span class="p">,</span> <span class="mh">0xfffca000</span><span class="p">,</span> <span class="mh">0xfffcc000</span><span class="p">,</span> <span class="mh">0xfffce000</span><span class="p">,</span>
	<span class="mh">0xfffd0000</span><span class="p">,</span> <span class="mh">0xfffd2000</span><span class="p">,</span> <span class="mh">0xfffd4000</span><span class="p">,</span> <span class="mh">0xfffd6000</span><span class="p">,</span>
	<span class="mh">0xfffd8000</span><span class="p">,</span> <span class="mh">0xfffda000</span><span class="p">,</span> <span class="mh">0xfffdc000</span><span class="p">,</span> <span class="mh">0xfffde000</span><span class="p">,</span>
	<span class="mh">0xfffe0000</span><span class="p">,</span> <span class="mh">0xfffe2000</span><span class="p">,</span> <span class="mh">0xfffe4000</span><span class="p">,</span> <span class="mh">0xfffe6000</span><span class="p">,</span>
	<span class="mh">0xfffe8000</span><span class="p">,</span> <span class="mh">0xfffea000</span><span class="p">,</span> <span class="mh">0xfffec000</span><span class="p">,</span> <span class="mh">0xfffee000</span><span class="p">,</span>
<span class="cp">#else </span><span class="cm">/*  CONFIG_MTD_DOCPROBE_HIGH */</span><span class="cp"></span>
	<span class="mh">0xc8000</span><span class="p">,</span> <span class="mh">0xca000</span><span class="p">,</span> <span class="mh">0xcc000</span><span class="p">,</span> <span class="mh">0xce000</span><span class="p">,</span>
	<span class="mh">0xd0000</span><span class="p">,</span> <span class="mh">0xd2000</span><span class="p">,</span> <span class="mh">0xd4000</span><span class="p">,</span> <span class="mh">0xd6000</span><span class="p">,</span>
	<span class="mh">0xd8000</span><span class="p">,</span> <span class="mh">0xda000</span><span class="p">,</span> <span class="mh">0xdc000</span><span class="p">,</span> <span class="mh">0xde000</span><span class="p">,</span>
	<span class="mh">0xe0000</span><span class="p">,</span> <span class="mh">0xe2000</span><span class="p">,</span> <span class="mh">0xe4000</span><span class="p">,</span> <span class="mh">0xe6000</span><span class="p">,</span>
	<span class="mh">0xe8000</span><span class="p">,</span> <span class="mh">0xea000</span><span class="p">,</span> <span class="mh">0xec000</span><span class="p">,</span> <span class="mh">0xee000</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/*  CONFIG_MTD_DOCPROBE_HIGH */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#warning Unknown architecture for DiskOnChip. No default probe locations defined</span>
<span class="cp">#endif</span>
	<span class="mh">0xffffffff</span> <span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">doclist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">doc_priv</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physadr</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">ChipID</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">CDSNControl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chips_per_floor</span><span class="p">;</span>	<span class="cm">/* The number of chips detected on each floor */</span>
	<span class="kt">int</span> <span class="n">curfloor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curchip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mh0_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mh1_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">nextdoc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This is the syndrome computed by the HW ecc generator upon reading an empty</span>
<span class="cm">   page, one with all 0xff for data and stored ecc code. */</span>
<span class="k">static</span> <span class="n">u_char</span> <span class="n">empty_read_syndrome</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x26</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="mh">0x73</span><span class="p">,</span> <span class="mh">0x7a</span> <span class="p">};</span>

<span class="cm">/* This is the ecc value computed by the HW ecc generator upon writing an empty</span>
<span class="cm">   page, one with all 0xff for data. */</span>
<span class="k">static</span> <span class="n">u_char</span> <span class="n">empty_write_ecc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0x0e</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">,</span> <span class="mh">0xf7</span> <span class="p">};</span>

<span class="cp">#define INFTL_BBT_RESERVED_BLOCKS 4</span>

<span class="cp">#define DoC_is_MillenniumPlus(doc) ((doc)-&gt;ChipID == DOC_ChipID_DocMilPlus16 || (doc)-&gt;ChipID == DOC_ChipID_DocMilPlus32)</span>
<span class="cp">#define DoC_is_Millennium(doc) ((doc)-&gt;ChipID == DOC_ChipID_DocMil)</span>
<span class="cp">#define DoC_is_2000(doc) ((doc)-&gt;ChipID == DOC_ChipID_Doc2k)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bitmask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">doc200x_select_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">try_dword</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">try_dword</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">no_ecc_failures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">no_ecc_failures</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">no_autopart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">no_autopart</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">show_firmware_partition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">show_firmware_partition</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MTD_NAND_DISKONCHIP_BBTWRITE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">inftl_bbt_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">inftl_bbt_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">inftl_bbt_write</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">doc_config_location</span> <span class="o">=</span> <span class="n">CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">doc_config_location</span><span class="p">,</span> <span class="n">ulong</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">doc_config_location</span><span class="p">,</span> <span class="s">&quot;Physical memory address at which to probe for DiskOnChip&quot;</span><span class="p">);</span>

<span class="cm">/* Sector size for HW ECC */</span>
<span class="cp">#define SECTOR_SIZE 512</span>
<span class="cm">/* The sector bytes are packed into NB_DATA 10 bit words */</span>
<span class="cp">#define NB_DATA (((SECTOR_SIZE + 1) * 8 + 6) / 10)</span>
<span class="cm">/* Number of roots */</span>
<span class="cp">#define NROOTS 4</span>
<span class="cm">/* First consective root */</span>
<span class="cp">#define FCR 510</span>
<span class="cm">/* Number of symbols */</span>
<span class="cp">#define NN 1023</span>

<span class="cm">/* the Reed Solomon control structure */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="n">rs_decoder</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The HW decoder in the DoC ASIC&#39;s provides us a error syndrome,</span>
<span class="cm"> * which we must convert to a standard syndrome usable by the generic</span>
<span class="cm"> * Reed-Solomon library code.</span>
<span class="cm"> *</span>
<span class="cm"> * Fabrice Bellard figured this out in the old docecc code. I added</span>
<span class="cm"> * some comments, improved a minor bit and converted it to make use</span>
<span class="cm"> * of the generic Reed-Solomon library. tglx</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc_ecc_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">rs_control</span> <span class="o">*</span><span class="n">rs</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ecc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">nerr</span><span class="p">,</span> <span class="n">errpos</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">parity</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ds</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">errval</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">syn</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">syn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">syn</span><span class="p">));</span>
	<span class="cm">/* Convert the ecc bytes into words */</span>
	<span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xfc</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">ds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">ecc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">parity</span> <span class="o">=</span> <span class="n">ecc</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Initialize the syndrome buffer */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NROOTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Evaluate</span>
<span class="cm">	 *  s[i] = ds[3]x^3 + ds[2]x^2 + ds[1]x^1 + ds[0]</span>
<span class="cm">	 *  where x = alpha^(FCR + i)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">NROOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">[</span><span class="n">ds</span><span class="p">[</span><span class="n">j</span><span class="p">]];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NROOTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">alpha_to</span><span class="p">[</span><span class="n">rs_modnn</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+</span> <span class="p">(</span><span class="n">FCR</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span><span class="p">)];</span>
	<span class="p">}</span>

	<span class="cm">/* Calc syn[i] = s[i] / alpha^(v + i) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NROOTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">syn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rs_modnn</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">rs</span><span class="o">-&gt;</span><span class="n">index_of</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">NN</span> <span class="o">-</span> <span class="n">FCR</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/* Call the decoder library */</span>
	<span class="n">nerr</span> <span class="o">=</span> <span class="n">decode_rs16</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1019</span><span class="p">,</span> <span class="n">syn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">errpos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">errval</span><span class="p">);</span>

	<span class="cm">/* Incorrectable errors ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nerr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nerr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Correct the errors. The bitpositions are a bit of magic,</span>
<span class="cm">	 * but they are given by the design of the de/encoder circuit</span>
<span class="cm">	 * in the DoC ASIC&#39;s.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nerr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">bitpos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">1015</span> <span class="o">-</span> <span class="n">errpos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">NB_DATA</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">1019</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">NB_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* extract bit position (MSB first) */</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">NB_DATA</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="p">;</span>
			<span class="cm">/* now correct the following 10 bits. At most two bytes</span>
<span class="cm">			   can be modified since pos is even */</span>
			<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">^</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">bitpos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SECTOR_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="p">(</span><span class="n">SECTOR_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span><span class="n">errval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">bitpos</span><span class="p">));</span>
				<span class="n">parity</span> <span class="o">^=</span> <span class="n">val</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">SECTOR_SIZE</span><span class="p">)</span>
					<span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">^=</span> <span class="n">val</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">index</span> <span class="o">=</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">bitpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitpos</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bitpos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">bitpos</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">SECTOR_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="n">index</span> <span class="o">==</span> <span class="p">(</span><span class="n">SECTOR_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span><span class="n">errval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="n">bitpos</span><span class="p">));</span>
				<span class="n">parity</span> <span class="o">^=</span> <span class="n">val</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">SECTOR_SIZE</span><span class="p">)</span>
					<span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">^=</span> <span class="n">val</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* If the parity is wrong, no rescue possible */</span>
	<span class="k">return</span> <span class="n">parity</span> <span class="o">?</span> <span class="o">-</span><span class="n">EBADMSG</span> <span class="o">:</span> <span class="n">nerr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">DoC_Delay</span><span class="p">(</span><span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cycles</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cycles</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_Millennium</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_NOP</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">DOCStatus</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cp">#define CDSN_CTRL_FR_B_MASK	(CDSN_CTRL_FR_B0 | CDSN_CTRL_FR_B1)</span>

<span class="cm">/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">_DoC_WaitReady</span><span class="p">(</span><span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;_DoC_WaitReady...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Out-of-line routine to wait for chip response */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CDSN_CTRL_FR_B_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;_DoC_WaitReady timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;_DoC_WaitReady timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">DoC_WaitReady</span><span class="p">(</span><span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CDSN_CTRL_FR_B_MASK</span><span class="p">)</span>
			<span class="cm">/* Call the out-of-line routine to wait */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">_DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B</span><span class="p">))</span>
			<span class="cm">/* Call the out-of-line routine to wait */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">_DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DoC_WaitReady OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2000_write_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">datum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;write_byte %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">datum</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">datum</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">datum</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_CDSN_IO</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u_char</span> <span class="nf">doc2000_read_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_CDSN_IO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;read_byte returns %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2000_writebuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;writebuf of %d bytes: &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WriteDOC_</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">DoC_2k_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2000_readbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;readbuf of %d bytes: &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2000_readbuf_dword</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;readbuf_dword of %d bytes: &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span><span class="p">)</span> <span class="o">|</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">docptr</span> <span class="o">+</span> <span class="n">DoC_2k_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc2000_verifybuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_CDSN_IO</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint16_t</span> <span class="n">__init</span> <span class="nf">doc200x_ident_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">doc200x_select_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_READID</span><span class="p">,</span>
			  <span class="n">NAND_CTRL_CLE</span> <span class="o">|</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">);</span>
	<span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NAND_CTRL_ALE</span> <span class="o">|</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">);</span>
	<span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_NONE</span><span class="p">,</span> <span class="n">NAND_NCE</span> <span class="o">|</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">);</span>

	<span class="cm">/* We can&#39;t use dev_ready here, but at least we wait for the</span>
<span class="cm">	 * command to complete</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">read_byte</span><span class="p">(</span><span class="n">mtd</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">read_byte</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">ChipID</span> <span class="o">==</span> <span class="n">DOC_ChipID_Doc2k</span> <span class="o">&amp;&amp;</span> <span class="n">try_dword</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First chip probe. See if we get same results by 32-bit access */</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">dword</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">ident</span><span class="p">;</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

		<span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_READID</span><span class="p">,</span>
				  <span class="n">NAND_CTRL_CLE</span> <span class="o">|</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">);</span>
		<span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NAND_CTRL_ALE</span> <span class="o">|</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">);</span>
		<span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_NONE</span><span class="p">,</span>
				  <span class="n">NAND_NCE</span> <span class="o">|</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">);</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

		<span class="n">ident</span><span class="p">.</span><span class="n">dword</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">docptr</span> <span class="o">+</span> <span class="n">DoC_2k_CDSN_IO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">ident</span><span class="p">.</span><span class="n">byte</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">ident</span><span class="p">.</span><span class="n">byte</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;DiskOnChip 2000 responds to DWORD access</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">read_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">doc2000_readbuf_dword</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">doc2000_count_chips</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">mfrid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Max 4 chips per floor on DiskOnChip 2000 */</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Find out what the first chip is */</span>
	<span class="n">mfrid</span> <span class="o">=</span> <span class="n">doc200x_ident_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Find how many chips in each floor. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">doc200x_ident_chip</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mfrid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Detected %d chips per floor.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc200x_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">DoC_WaitReady</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">read_byte</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2001_write_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">datum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">datum</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNSlowIO</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">datum</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">datum</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u_char</span> <span class="nf">doc2001_read_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>ReadDOC(docptr, CDSNSlowIO);</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* 11.4.5 -- delay twice to allow extended length cycle */</span>
	<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>return ReadDOC(docptr, Mil<em>CDSN</em>IO);</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2001_writebuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">WriteDOC_</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">DoC_Mil_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="cm">/* Terminate write pipeline */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">WritePipeTerm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2001_readbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Start read pipeline */</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">));</span>

	<span class="cm">/* Terminate read pipeline */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc2001_verifybuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Start read pipeline */</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ReadPipeInit</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">LastDataRead</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u_char</span> <span class="nf">doc2001plus_read_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ReadPipeInit</span><span class="p">);</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ReadPipeInit</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_LastDataRead</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;read_byte returns %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2001plus_writebuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;writebuf of %d bytes: &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WriteDOC_</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">DoC_Mil_CDSN_IO</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2001plus_readbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;readbuf of %d bytes: &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Start read pipeline */</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ReadPipeInit</span><span class="p">);</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ReadPipeInit</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Terminate read pipeline */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_LastDataRead</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_LastDataRead</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc2001plus_verifybuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;verifybuf of %d bytes: &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Start read pipeline */</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ReadPipeInit</span><span class="p">);</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ReadPipeInit</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mil_CDSN_IO</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_LastDataRead</span><span class="p">);</span>
			<span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_LastDataRead</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_LastDataRead</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_LastDataRead</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2001plus_select_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;select chip (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable flash internally */</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashSelect</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">floor</span> <span class="o">=</span> <span class="n">chip</span> <span class="o">/</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span><span class="p">;</span>
	<span class="n">chip</span> <span class="o">-=</span> <span class="p">(</span><span class="n">floor</span> <span class="o">*</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span><span class="p">);</span>

	<span class="cm">/* Assert ChipEnable and deassert WriteProtect */</span>
	<span class="n">WriteDOC</span><span class="p">((</span><span class="n">DOC_FLASH_CE</span><span class="p">),</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashSelect</span><span class="p">);</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">cmdfunc</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_RESET</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">floor</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc200x_select_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;select chip (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">floor</span> <span class="o">=</span> <span class="n">chip</span> <span class="o">/</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span><span class="p">;</span>
	<span class="n">chip</span> <span class="o">-=</span> <span class="p">(</span><span class="n">floor</span> <span class="o">*</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span><span class="p">);</span>

	<span class="cm">/* 11.4.4 -- deassert CE before changing chip */</span>
	<span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_NONE</span><span class="p">,</span> <span class="mi">0</span> <span class="o">|</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">);</span>

	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">floor</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">FloorSelect</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNDeviceSelect</span><span class="p">);</span>

	<span class="n">doc200x_hwcontrol</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">NAND_CMD_NONE</span><span class="p">,</span> <span class="n">NAND_NCE</span> <span class="o">|</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">);</span>

	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">curchip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">curfloor</span> <span class="o">=</span> <span class="n">floor</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CDSN_CTRL_MSK (CDSN_CTRL_CE | CDSN_CTRL_CLE | CDSN_CTRL_ALE)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc200x_hwcontrol</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">doc</span><span class="o">-&gt;</span><span class="n">CDSNControl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CDSN_CTRL_MSK</span><span class="p">;</span>
		<span class="n">doc</span><span class="o">-&gt;</span><span class="n">CDSNControl</span> <span class="o">|=</span> <span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_MSK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;hwcontrol(%d): %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">CDSNControl</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">CDSNControl</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
		<span class="cm">/* 11.4.3 -- 4 NOPs after CSDNControl write */</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">NAND_CMD_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_2000</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
			<span class="n">doc2000_write_byte</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">doc2001_write_byte</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2001plus_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">command</span><span class="p">,</span> <span class="kt">int</span> <span class="n">column</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must terminate write pipeline before sending any commands</span>
<span class="cm">	 * to the device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">NAND_CMD_PAGEPROG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_WritePipeTerm</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_WritePipeTerm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write out the command to the device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">NAND_CMD_SEQIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">readcmd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">column</span> <span class="o">&gt;=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* OOB area */</span>
			<span class="n">column</span> <span class="o">-=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">;</span>
			<span class="n">readcmd</span> <span class="o">=</span> <span class="n">NAND_CMD_READOOB</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">column</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* First 256 bytes --&gt; READ0 */</span>
			<span class="n">readcmd</span> <span class="o">=</span> <span class="n">NAND_CMD_READ0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">column</span> <span class="o">-=</span> <span class="mi">256</span><span class="p">;</span>
			<span class="n">readcmd</span> <span class="o">=</span> <span class="n">NAND_CMD_READ1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">readcmd</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashCmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashCmd</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_WritePipeTerm</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_WritePipeTerm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">column</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">page_addr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Serially input address */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">column</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Adjust columns for 16 bit buswidth */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">NAND_BUSWIDTH_16</span><span class="p">)</span>
				<span class="n">column</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashAddress</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_addr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WriteDOC</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">page_addr</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">),</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashAddress</span><span class="p">);</span>
			<span class="n">WriteDOC</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)((</span><span class="n">page_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">),</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashAddress</span><span class="p">);</span>
			<span class="cm">/* One more address cycle for higher density devices */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chipsize</span> <span class="o">&amp;</span> <span class="mh">0x0c000000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">WriteDOC</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)((</span><span class="n">page_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">),</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashAddress</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;high density</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_WritePipeTerm</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_WritePipeTerm</span><span class="p">);</span>
		<span class="cm">/* deassert ALE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">NAND_CMD_READ0</span> <span class="o">||</span> <span class="n">command</span> <span class="o">==</span> <span class="n">NAND_CMD_READ1</span> <span class="o">||</span>
		    <span class="n">command</span> <span class="o">==</span> <span class="n">NAND_CMD_READOOB</span> <span class="o">||</span> <span class="n">command</span> <span class="o">==</span> <span class="n">NAND_CMD_READID</span><span class="p">)</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashControl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * program and erase have their own busy handlers</span>
<span class="cm">	 * status and sequential in needs no delay</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">NAND_CMD_PAGEPROG</span>:
	<span class="k">case</span> <span class="n">NAND_CMD_ERASE1</span>:
	<span class="k">case</span> <span class="n">NAND_CMD_ERASE2</span>:
	<span class="k">case</span> <span class="n">NAND_CMD_SEQIN</span>:
	<span class="k">case</span> <span class="n">NAND_CMD_STATUS</span>:
		<span class="k">return</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">NAND_CMD_RESET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev_ready</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chip_delay</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">NAND_CMD_STATUS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashCmd</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_WritePipeTerm</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_WritePipeTerm</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">read_byte</span><span class="p">(</span><span class="n">mtd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">))</span> <span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>

		<span class="cm">/* This applies to read commands */</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we don&#39;t have access to the busy pin, we apply the given</span>
<span class="cm">		 * command delay</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev_ready</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chip_delay</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Apply this short delay always to ensure that we do wait tWB in</span>
<span class="cm">	 * any case on any machine. */</span>
	<span class="n">ndelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="cm">/* wait until command is processed */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">dev_ready</span><span class="p">(</span><span class="n">mtd</span><span class="p">))</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc200x_dev_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* 11.4.2 -- must NOP four times before checking FR/B# */</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_FlashControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CDSN_CTRL_FR_B_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;not ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;was ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 11.4.2 -- must NOP four times before checking FR/B# */</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CDSN_CTRL_FR_B</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;not ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* 11.4.2 -- Must NOP twice if it&#39;s ready */</span>
		<span class="n">DoC_Delay</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;was ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc200x_block_bad</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">getchip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is our last resort if we couldn&#39;t find or create a BBT.  Just</span>
<span class="cm">	   pretend all blocks are good. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc200x_enable_hwecc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="cm">/* Prime the ECC engine */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NAND_ECC_READ</span>:
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_EN</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_ECC_WRITE</span>:
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_EN</span> <span class="o">|</span> <span class="n">DOC_ECC_RW</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">doc2001plus_enable_hwecc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>

	<span class="cm">/* Prime the ECC engine */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NAND_ECC_READ</span>:
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_EN</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_ECC_WRITE</span>:
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_RESET</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_EN</span> <span class="o">|</span> <span class="n">DOC_ECC_RW</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This code is only called on write */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc200x_calculate_ecc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">dat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ecc_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">emptymatch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* flush the pipeline */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_2000</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">CDSNControl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CDSN_CTRL_FLASH_IO</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_CDSN_IO</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_CDSN_IO</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_CDSN_IO</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">CDSNControl</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">CDSNControl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_NOP</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_NOP</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_NOP</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">NOP</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
			<span class="n">ecc_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">DoC_Mplus_ECCSyndrome0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ecc_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">DoC_ECCSyndrome0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecc_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">empty_write_ecc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">emptymatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* If emptymatch=1, we might have an all-0xff data buffer.  Check. */</span>
<span class="c">	if (emptymatch) {</span>
<span class="c">		/* Note: this somewhat expensive test should not be triggered</span>
<span class="c">		   often.  It could be optimized away by examining the data in</span>
<span class="c">		   the writebuf routine, and remembering the result. */</span>
<span class="c">		for (i = 0; i &lt; 512; i++) {</span>
<span class="c">			if (dat[i] == 0xff)</span>
<span class="c">				continue;</span>
<span class="c">			emptymatch = 0;</span>
<span class="c">			break;</span>
<span class="c">		}</span>
<span class="c">	}</span>
<span class="c">	/* If emptymatch still =1, we do have an all-0xff data buffer.</span>
<span class="c">	   Return all-0xff ecc value instead of the computed one, so</span>
<span class="c">	   it&#39;ll look just like a freshly-erased page. */</span>
<span class="c">	if (emptymatch)</span>
<span class="c">		memset(ecc_code, 0xff, 6);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">doc200x_correct_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">dat</span><span class="p">,</span>
				<span class="n">u_char</span> <span class="o">*</span><span class="n">read_ecc</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">isnull</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">docptr</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">calc_ecc</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="k">volatile</span> <span class="n">u_char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">emptymatch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* flush the pipeline */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_2000</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_ECCStatus</span><span class="p">);</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_ECCStatus</span><span class="p">);</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="mi">2</span><span class="n">k_ECCStatus</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
		<span class="n">dummy</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Error occurred ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dummy</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
				<span class="n">calc_ecc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">DoC_Mplus_ECCSyndrome0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">calc_ecc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">docptr</span><span class="p">,</span> <span class="n">DoC_ECCSyndrome0</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">calc_ecc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">empty_read_syndrome</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">emptymatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If emptymatch=1, the read syndrome is consistent with an</span>
<span class="cm">		   all-0xff data and stored ecc block.  Check the stored ecc. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emptymatch</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">read_ecc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">emptymatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* If emptymatch still =1, check the data block. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emptymatch</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Note: this somewhat expensive test should not be triggered</span>
<span class="cm">			   often.  It could be optimized away by examining the data in</span>
<span class="cm">			   the readbuf routine, and remembering the result. */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">emptymatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* If emptymatch still =1, this is almost certainly a freshly-</span>
<span class="cm">		   erased block, in which case the ECC will not come out right.</span>
<span class="cm">		   We&#39;ll suppress the error and tell the caller everything&#39;s</span>
<span class="cm">		   OK.  Because it is. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">emptymatch</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_ecc_decode</span><span class="p">(</span><span class="n">rs_decoder</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span> <span class="n">calc_ecc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;doc200x_correct_data corrected %d errors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">Mplus_ECCConf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_ECC_DIS</span><span class="p">,</span> <span class="n">docptr</span><span class="p">,</span> <span class="n">ECCConf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">no_ecc_failures</span> <span class="o">&amp;&amp;</span> <span class="n">mtd_is_eccerr</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;suppressing ECC failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>u_char mydatabuf[528];</p></td><td class="code"><div class="highlight"><pre><span class="cm">/* The strange out-of-order .oobfree list below is a (possibly unneeded)</span>
<span class="cm"> * attempt to retain compatibility.  It used to read:</span>
<span class="cm"> * 	.oobfree = { {8, 8} }</span>
<span class="cm"> * Since that leaves two bytes unusable, it was changed.  But the following</span>
<span class="cm"> * scheme might affect existing jffs2 installs by moving the cleanmarker:</span>
<span class="cm"> * 	.oobfree = { {6, 10} }</span>
<span class="cm"> * jffs2 seems to handle the above gracefully, but the current scheme seems</span>
<span class="cm"> * safer.  The only problem with it is that any code that parses oobfree must</span>
<span class="cm"> * be able to handle out-of-order segments.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="n">doc200x_oobinfo</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">eccbytes</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eccpos</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
	<span class="p">.</span><span class="n">oobfree</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">}}</span>
<span class="p">};</span>

<span class="cm">/* Find the (I)NFTL Media Header, and optionally also the mirror media header.</span>
<span class="cm">   On successful return, buf will contain a copy of the media header for</span>
<span class="cm">   further processing.  id is the string to scan for, and will presumably be</span>
<span class="cm">   either &quot;ANAND&quot; or &quot;BNAND&quot;.  If findmirror=1, also look for the mirror media</span>
<span class="cm">   header.  The page #s of the found media headers are placed in mh0_page and</span>
<span class="cm">   mh1_page in the DOC private structure. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">find_media_headers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">findmirror</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">offs</span> <span class="o">+=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ECC error scanning DOC at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Found DiskOnChip %s Media Header at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh0_page</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh0_page</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_shift</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">findmirror</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh1_page</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_shift</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh0_page</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;DiskOnChip %s Media Header not found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Only one mediaheader was found.  We want buf to contain a</span>
<span class="cm">	   mediaheader on return, so we&#39;ll have to re-read the one we found. */</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh0_page</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_shift</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Insanity.  Give up. */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Read DiskOnChip Media Header once, but can&#39;t reread it???</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nftl_partscan</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mtd_partition</span> <span class="o">*</span><span class="n">parts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">NFTLMediaHeader</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">psize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numparts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">maxblocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="n">numheaders</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DiskOnChip mediaheader kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">numheaders</span> <span class="o">=</span> <span class="n">find_media_headers</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="s">&quot;ANAND&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">mh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NFTLMediaHeader</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">le16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NumEraseUnits</span><span class="p">);</span>
	<span class="n">le16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">FirstPhysicalEUN</span><span class="p">);</span>
	<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">FormattedSize</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;    DataOrgID        = %s</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    NumEraseUnits    = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    FirstPhysicalEUN = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    FormattedSize    = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    UnitSizeFactor   = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">DataOrgID</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">NumEraseUnits</span><span class="p">,</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">FirstPhysicalEUN</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">FormattedSize</span><span class="p">,</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span><span class="p">);</span>

	<span class="n">blocks</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">phys_erase_shift</span><span class="p">;</span>
	<span class="n">maxblocks</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">32768U</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">-</span> <span class="n">psize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Auto-determine UnitSizeFactor.  The constraints are:</span>
<span class="cm">		   - There can be at most 32768 virtual blocks.</span>
<span class="cm">		   - There can be at most (virtual block size - page size)</span>
<span class="cm">		   virtual blocks (because MediaHeader+BBT must fit in 1).</span>
<span class="cm">		 */</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;</span> <span class="n">maxblocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blocks</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">maxblocks</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">32768U</span><span class="p">,</span> <span class="p">(</span><span class="n">maxblocks</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">psize</span><span class="p">);</span>
			<span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;UnitSizeFactor=0x00 detected.  Correct value is assumed to be 0x%02x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE: The lines below modify internal variables of the NAND and MTD</span>
<span class="cm">	   layers; variables with have already been configured by nand_scan.</span>
<span class="cm">	   Unfortunately, we didn&#39;t know before this point what these values</span>
<span class="cm">	   should be.  Thus, this code is somewhat dependent on the exact</span>
<span class="cm">	   implementation of the NAND layer.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_erase_shift</span> <span class="o">+=</span> <span class="p">(</span><span class="mh">0xff</span> <span class="o">-</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span><span class="p">);</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="mh">0xff</span> <span class="o">-</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Setting virtual erase size to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">);</span>
		<span class="n">blocks</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_erase_shift</span><span class="p">;</span>
		<span class="n">maxblocks</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">32768U</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">-</span> <span class="n">psize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;</span> <span class="n">maxblocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;UnitSizeFactor of 0x%02x is inconsistent with device size.  Aborting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">UnitSizeFactor</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip past the media headers. */</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh0_page</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh1_page</span><span class="p">);</span>
	<span class="n">offs</span> <span class="o">&lt;&lt;=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_shift</span><span class="p">;</span>
	<span class="n">offs</span> <span class="o">+=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">show_firmware_partition</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot; DiskOnChip Firmware / Media Header partition&quot;</span><span class="p">;</span>
		<span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">numparts</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot; DiskOnChip BDTL partition&quot;</span><span class="p">;</span>
	<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NumEraseUnits</span> <span class="o">-</span> <span class="n">numheaders</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_erase_shift</span><span class="p">;</span>

	<span class="n">offs</span> <span class="o">+=</span> <span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="n">numparts</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">&lt;</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot; DiskOnChip Remainder partition&quot;</span><span class="p">;</span>
		<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">numparts</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">numparts</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is a stripped-down copy of the code in inftlmount.c */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">inftl_partscan</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mtd_partition</span> <span class="o">*</span><span class="n">parts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">INFTLMediaHeader</span> <span class="o">*</span><span class="n">mh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">INFTLPartition</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numparts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vshift</span><span class="p">,</span> <span class="n">lastvunit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inftl_bbt_write</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">-=</span> <span class="p">(</span><span class="n">INFTL_BBT_RESERVED_BLOCKS</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">phys_erase_shift</span><span class="p">);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DiskOnChip mediaheader kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">find_media_headers</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="s">&quot;BNAND&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh1_page</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh0_page</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4096</span> <span class="o">&gt;&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">page_shift</span><span class="p">);</span>
	<span class="n">mh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">INFTLMediaHeader</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBootImageBlocks</span><span class="p">);</span>
	<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBinaryPartitions</span><span class="p">);</span>
	<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span><span class="p">);</span>
	<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">);</span>
	<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">FormatFlags</span><span class="p">);</span>
	<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">PercentUsed</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;    bootRecordID          = %s</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    NoOfBootImageBlocks   = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    NoOfBinaryPartitions  = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    NoOfBDTLPartitions    = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    BlockMultiplerBits    = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    FormatFlgs            = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    OsakVersion           = %d.%d.%d.%d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    PercentUsed           = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">bootRecordID</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBootImageBlocks</span><span class="p">,</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBinaryPartitions</span><span class="p">,</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span><span class="p">,</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">FormatFlags</span><span class="p">,</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">OsakVersion</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">OsakVersion</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">OsakVersion</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span>
		<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">OsakVersion</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">,</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">PercentUsed</span><span class="p">);</span>

	<span class="n">vshift</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">phys_erase_shift</span> <span class="o">+</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">;</span>

	<span class="n">blocks</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">vshift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;</span> <span class="mi">32768</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;BlockMultiplierBits=%d is inconsistent with device size.  Aborting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">blocks</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">chip_shift</span> <span class="o">-</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">phys_erase_shift</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inftl_bbt_write</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">blocks</span> <span class="o">&gt;</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Writeable BBTs spanning more than one erase block are not yet supported.  FIX ME!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Scan the partitions */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">Partitions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">virtualUnits</span><span class="p">);</span>
		<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">);</span>
		<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span><span class="p">);</span>
		<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">spareUnits</span><span class="p">);</span>
		<span class="n">le32_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">Reserved0</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>	<span class="s">&quot;    PARTITION[%d] -&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;        virtualUnits    = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;        firstUnit       = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;        lastUnit        = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;        flags           = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;        spareUnits      = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">virtualUnits</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">,</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">spareUnits</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">show_firmware_partition</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot; DiskOnChip IPL / Media Header partition&quot;</span><span class="p">;</span>
			<span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">*</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">;</span>
			<span class="n">numparts</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INFTL_BINARY</span><span class="p">)</span>
			<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot; DiskOnChip BDK partition&quot;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot; DiskOnChip BDTL partition&quot;</span><span class="p">;</span>
		<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span> <span class="o">&lt;&lt;</span> <span class="n">vshift</span><span class="p">;</span>
		<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span> <span class="o">-</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">vshift</span><span class="p">;</span>
		<span class="n">numparts</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span> <span class="o">&gt;</span> <span class="n">lastvunit</span><span class="p">)</span>
			<span class="n">lastvunit</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INFTL_LAST</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lastvunit</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lastvunit</span> <span class="o">&lt;&lt;</span> <span class="n">vshift</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot; DiskOnChip Remainder partition&quot;</span><span class="p">;</span>
		<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">lastvunit</span> <span class="o">&lt;&lt;</span> <span class="n">vshift</span><span class="p">;</span>
		<span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">parts</span><span class="p">[</span><span class="n">numparts</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">numparts</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">numparts</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nftl_scan_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">numparts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_partition</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">parts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parts</span><span class="p">));</span>
	<span class="cm">/* On NFTL, we have to find the media headers before we can read the</span>
<span class="cm">	   BBTs, since they&#39;re stored in the media header eraseblocks. */</span>
	<span class="n">numparts</span> <span class="o">=</span> <span class="n">nftl_partscan</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">parts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numparts</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">NAND_BBT_ABSPAGE</span> <span class="o">|</span> <span class="n">NAND_BBT_8BIT</span> <span class="o">|</span>
				<span class="n">NAND_BBT_SAVECONTENT</span> <span class="o">|</span> <span class="n">NAND_BBT_WRITE</span> <span class="o">|</span>
				<span class="n">NAND_BBT_VERSION</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">veroffs</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh0_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh1_page</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">NAND_BBT_ABSPAGE</span> <span class="o">|</span> <span class="n">NAND_BBT_8BIT</span> <span class="o">|</span>
					<span class="n">NAND_BBT_SAVECONTENT</span> <span class="o">|</span> <span class="n">NAND_BBT_WRITE</span> <span class="o">|</span>
					<span class="n">NAND_BBT_VERSION</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">veroffs</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh1_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* It&#39;s safe to set bd=NULL below because NAND_BBT_CREATE is not set.</span>
<span class="cm">	   At least as nand_bbt.c is currently written. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">nand_scan_bbt</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">mtd_device_register</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_autopart</span><span class="p">)</span>
		<span class="n">mtd_device_register</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">numparts</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">inftl_scan_bbt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">numparts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_partition</span> <span class="n">parts</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">numchips</span> <span class="o">&gt;</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Multi-floor INFTL devices not yet supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DoC_is_MillenniumPlus</span><span class="p">(</span><span class="n">doc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">NAND_BBT_2BIT</span> <span class="o">|</span> <span class="n">NAND_BBT_ABSPAGE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inftl_bbt_write</span><span class="p">)</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">NAND_BBT_WRITE</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">NAND_BBT_LASTBLOCK</span> <span class="o">|</span> <span class="n">NAND_BBT_8BIT</span> <span class="o">|</span> <span class="n">NAND_BBT_VERSION</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inftl_bbt_write</span><span class="p">)</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">NAND_BBT_WRITE</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">veroffs</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">maxblocks</span> <span class="o">=</span> <span class="n">INFTL_BBT_RESERVED_BLOCKS</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">reserved_block_code</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="o">-&gt;</span><span class="n">pattern</span> <span class="o">=</span> <span class="s">&quot;MSYS_BBT&quot;</span><span class="p">;</span>

		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">=</span> <span class="n">NAND_BBT_LASTBLOCK</span> <span class="o">|</span> <span class="n">NAND_BBT_8BIT</span> <span class="o">|</span> <span class="n">NAND_BBT_VERSION</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inftl_bbt_write</span><span class="p">)</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">NAND_BBT_WRITE</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">veroffs</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">maxblocks</span> <span class="o">=</span> <span class="n">INFTL_BBT_RESERVED_BLOCKS</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">reserved_block_code</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="o">-&gt;</span><span class="n">pattern</span> <span class="o">=</span> <span class="s">&quot;TBB_SYSM&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* It&#39;s safe to set bd=NULL below because NAND_BBT_CREATE is not set.</span>
<span class="cm">	   At least as nand_bbt.c is currently written. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">nand_scan_bbt</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">parts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parts</span><span class="p">));</span>
	<span class="n">numparts</span> <span class="o">=</span> <span class="n">inftl_partscan</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">parts</span><span class="p">);</span>
	<span class="cm">/* At least for now, require the INFTL Media Header.  We could probably</span>
<span class="cm">	   do without it for non-INFTL use, since all it gives us is</span>
<span class="cm">	   autopartitioning, but I want to give it more thought. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numparts</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">mtd_device_register</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_autopart</span><span class="p">)</span>
		<span class="n">mtd_device_register</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">numparts</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">doc2000_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">read_byte</span> <span class="o">=</span> <span class="n">doc2000_read_byte</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">write_buf</span> <span class="o">=</span> <span class="n">doc2000_writebuf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">read_buf</span> <span class="o">=</span> <span class="n">doc2000_readbuf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">verify_buf</span> <span class="o">=</span> <span class="n">doc2000_verifybuf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">scan_bbt</span> <span class="o">=</span> <span class="n">nftl_scan_bbt</span><span class="p">;</span>

	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">CDSNControl</span> <span class="o">=</span> <span class="n">CDSN_CTRL_FLASH_IO</span> <span class="o">|</span> <span class="n">CDSN_CTRL_ECC_IO</span><span class="p">;</span>
	<span class="n">doc2000_count_chips</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DiskOnChip 2000 (NFTL Model)&quot;</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">doc2001_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">read_byte</span> <span class="o">=</span> <span class="n">doc2001_read_byte</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">write_buf</span> <span class="o">=</span> <span class="n">doc2001_writebuf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">read_buf</span> <span class="o">=</span> <span class="n">doc2001_readbuf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">verify_buf</span> <span class="o">=</span> <span class="n">doc2001_verifybuf</span><span class="p">;</span>

	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ChipID</span><span class="p">);</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ChipID</span><span class="p">);</span>
	<span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ChipID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ChipID</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DOC_ChipID_DocMil</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* It&#39;s not a Millennium; it&#39;s one of the newer</span>
<span class="cm">		   DiskOnChip 2000 units with a similar ASIC.</span>
<span class="cm">		   Treat it like a Millennium, except that it</span>
<span class="cm">		   can have multiple chips. */</span>
		<span class="n">doc2000_count_chips</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DiskOnChip 2000 (INFTL Model)&quot;</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">scan_bbt</span> <span class="o">=</span> <span class="n">inftl_scan_bbt</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Bog-standard Millennium */</span>
		<span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DiskOnChip Millennium&quot;</span><span class="p">;</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">scan_bbt</span> <span class="o">=</span> <span class="n">nftl_scan_bbt</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">doc2001plus_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">this</span><span class="o">-&gt;</span><span class="n">read_byte</span> <span class="o">=</span> <span class="n">doc2001plus_read_byte</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">write_buf</span> <span class="o">=</span> <span class="n">doc2001plus_writebuf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">read_buf</span> <span class="o">=</span> <span class="n">doc2001plus_readbuf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">verify_buf</span> <span class="o">=</span> <span class="n">doc2001plus_verifybuf</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">scan_bbt</span> <span class="o">=</span> <span class="n">inftl_scan_bbt</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">cmd_ctrl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">select_chip</span> <span class="o">=</span> <span class="n">doc2001plus_select_chip</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">cmdfunc</span> <span class="o">=</span> <span class="n">doc2001plus_command</span><span class="p">;</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">hwctl</span> <span class="o">=</span> <span class="n">doc2001plus_enable_hwecc</span><span class="p">;</span>

	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">chips_per_floor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;DiskOnChip Millennium Plus&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">doc_probe</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physadr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ChipID</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">nand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">virtadr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">save_control</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmpb</span><span class="p">,</span> <span class="n">tmpc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">numchips</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">virtadr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">physadr</span><span class="p">,</span> <span class="n">DOC_IOREMAP_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virtadr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Diskonchip ioremap failed: 0x%x bytes at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DOC_IOREMAP_LEN</span><span class="p">,</span> <span class="n">physadr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* It&#39;s not possible to cleanly detect the DiskOnChip - the</span>
<span class="cm">	 * bootup procedure will put the device into reset mode, and</span>
<span class="cm">	 * it&#39;s not possible to talk to it without actually writing</span>
<span class="cm">	 * to the DOCControl register. So we store the current contents</span>
<span class="cm">	 * of the DOCControl register&#39;s location, in case we later decide</span>
<span class="cm">	 * that it&#39;s not a DiskOnChip, and want to put it back how we</span>
<span class="cm">	 * found it.</span>
<span class="cm">	 */</span>
	<span class="n">save_control</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">DOCControl</span><span class="p">);</span>

	<span class="cm">/* Reset the DiskOnChip ASIC */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_MODE_CLR_ERR</span> <span class="o">|</span> <span class="n">DOC_MODE_MDWREN</span> <span class="o">|</span> <span class="n">DOC_MODE_RESET</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">DOCControl</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_MODE_CLR_ERR</span> <span class="o">|</span> <span class="n">DOC_MODE_MDWREN</span> <span class="o">|</span> <span class="n">DOC_MODE_RESET</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">DOCControl</span><span class="p">);</span>

	<span class="cm">/* Enable the DiskOnChip ASIC */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_MODE_CLR_ERR</span> <span class="o">|</span> <span class="n">DOC_MODE_MDWREN</span> <span class="o">|</span> <span class="n">DOC_MODE_NORMAL</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">DOCControl</span><span class="p">);</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">DOC_MODE_CLR_ERR</span> <span class="o">|</span> <span class="n">DOC_MODE_MDWREN</span> <span class="o">|</span> <span class="n">DOC_MODE_NORMAL</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">DOCControl</span><span class="p">);</span>

	<span class="n">ChipID</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ChipID</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ChipID</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DOC_ChipID_Doc2k</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="n">DoC_2k_ECCStatus</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DOC_ChipID_DocMil</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="n">DoC_ECCConf</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DOC_ChipID_DocMilPlus16</span>:
	<span class="k">case</span> <span class="n">DOC_ChipID_DocMilPlus32</span>:
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* Possible Millennium Plus, need to do more checks */</span>
		<span class="cm">/* Possibly release from power down mode */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">);</span> <span class="n">tmp</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ReadDOC</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_Power</span><span class="p">);</span>

		<span class="cm">/* Reset the Millennium Plus ASIC */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">DOC_MODE_RESET</span> <span class="o">|</span> <span class="n">DOC_MODE_MDWREN</span> <span class="o">|</span> <span class="n">DOC_MODE_RST_LAT</span> <span class="o">|</span> <span class="n">DOC_MODE_BDECT</span><span class="p">;</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_DOCControl</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="o">~</span><span class="n">tmp</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_CtrlConfirm</span><span class="p">);</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* Enable the Millennium Plus ASIC */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">DOC_MODE_NORMAL</span> <span class="o">|</span> <span class="n">DOC_MODE_MDWREN</span> <span class="o">|</span> <span class="n">DOC_MODE_RST_LAT</span> <span class="o">|</span> <span class="n">DOC_MODE_BDECT</span><span class="p">;</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_DOCControl</span><span class="p">);</span>
		<span class="n">WriteDOC</span><span class="p">(</span><span class="o">~</span><span class="n">tmp</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_CtrlConfirm</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">ChipID</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">ChipID</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ChipID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DOC_ChipID_DocMilPlus16</span>:
			<span class="n">reg</span> <span class="o">=</span> <span class="n">DoC_Mplus_Toggle</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DOC_ChipID_DocMilPlus32</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DiskOnChip Millennium Plus 32MB is not supported, ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="nl">default:</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">notfound</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">notfound</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check the TOGGLE bit in the ECC register */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DOC_TOGGLE_BIT</span><span class="p">;</span>
	<span class="n">tmpb</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DOC_TOGGLE_BIT</span><span class="p">;</span>
	<span class="n">tmpc</span> <span class="o">=</span> <span class="n">ReadDOC_</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DOC_TOGGLE_BIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">tmpb</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">tmpc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Possible DiskOnChip at 0x%lx failed TOGGLE test, dropping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">physadr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">notfound</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">doclist</span><span class="p">;</span> <span class="n">mtd</span><span class="p">;</span> <span class="n">mtd</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">nextdoc</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">oldval</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">newval</span><span class="p">;</span>
		<span class="n">nand</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="n">doc</span> <span class="o">=</span> <span class="n">nand</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="cm">/* Use the alias resolution register to determine if this is</span>
<span class="cm">		   in fact the same DOC aliased to a new address.  If writes</span>
<span class="cm">		   to one chip&#39;s alias resolution register change the value on</span>
<span class="cm">		   the other chip, they&#39;re the same chip. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ChipID</span> <span class="o">==</span> <span class="n">DOC_ChipID_DocMilPlus16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oldval</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_AliasResolution</span><span class="p">);</span>
			<span class="n">newval</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_AliasResolution</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">oldval</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
			<span class="n">newval</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldval</span> <span class="o">!=</span> <span class="n">newval</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ChipID</span> <span class="o">==</span> <span class="n">DOC_ChipID_DocMilPlus16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="o">~</span><span class="n">newval</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_AliasResolution</span><span class="p">);</span>
			<span class="n">oldval</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_AliasResolution</span><span class="p">);</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="n">newval</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">Mplus_AliasResolution</span><span class="p">);</span>	<span class="c1">// restore it</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="o">~</span><span class="n">newval</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
			<span class="n">oldval</span> <span class="o">=</span> <span class="n">ReadDOC</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>
			<span class="n">WriteDOC</span><span class="p">(</span><span class="n">newval</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">AliasResolution</span><span class="p">);</span>	<span class="c1">// restore it</span>
		<span class="p">}</span>
		<span class="n">newval</span> <span class="o">=</span> <span class="o">~</span><span class="n">newval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldval</span> <span class="o">==</span> <span class="n">newval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Found alias of DOC at 0x%lx to 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">physadr</span><span class="p">,</span> <span class="n">physadr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">notfound</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;DiskOnChip found at 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">physadr</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span><span class="p">)</span> <span class="o">+</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nand_chip</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">doc_priv</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nand_bbt_descr</span><span class="p">));</span>
	<span class="n">mtd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mtd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DiskOnChip kmalloc (%d bytes) failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nand</span>			<span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mtd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">doc</span>			<span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">nand</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">bbt_td</span>		<span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nand_bbt_descr</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">doc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">bbt_md</span>		<span class="o">=</span> <span class="n">nand</span><span class="o">-&gt;</span><span class="n">bbt_td</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span>		<span class="o">=</span> <span class="n">nand</span><span class="p">;</span>
	<span class="n">mtd</span><span class="o">-&gt;</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">priv</span>		<span class="o">=</span> <span class="n">doc</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">select_chip</span>	<span class="o">=</span> <span class="n">doc200x_select_chip</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">cmd_ctrl</span>		<span class="o">=</span> <span class="n">doc200x_hwcontrol</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">dev_ready</span>		<span class="o">=</span> <span class="n">doc200x_dev_ready</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">waitfunc</span>		<span class="o">=</span> <span class="n">doc200x_wait</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">block_bad</span>		<span class="o">=</span> <span class="n">doc200x_block_bad</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">hwctl</span>		<span class="o">=</span> <span class="n">doc200x_enable_hwecc</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">calculate</span>	<span class="o">=</span> <span class="n">doc200x_calculate_ecc</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">correct</span>	<span class="o">=</span> <span class="n">doc200x_correct_data</span><span class="p">;</span>

	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">doc200x_oobinfo</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">mode</span>		<span class="o">=</span> <span class="n">NAND_ECC_HW_SYNDROME</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">size</span>		<span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">bytes</span>		<span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">strength</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">nand</span><span class="o">-&gt;</span><span class="n">bbt_options</span>	<span class="o">=</span> <span class="n">NAND_BBT_USE_FLASH</span><span class="p">;</span>

	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">physadr</span>		<span class="o">=</span> <span class="n">physadr</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span>		<span class="o">=</span> <span class="n">virtadr</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">ChipID</span>		<span class="o">=</span> <span class="n">ChipID</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">curfloor</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">curchip</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh0_page</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">mh1_page</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">doc</span><span class="o">-&gt;</span><span class="n">nextdoc</span>		<span class="o">=</span> <span class="n">doclist</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ChipID</span> <span class="o">==</span> <span class="n">DOC_ChipID_Doc2k</span><span class="p">)</span>
		<span class="n">numchips</span> <span class="o">=</span> <span class="n">doc2000_init</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ChipID</span> <span class="o">==</span> <span class="n">DOC_ChipID_DocMilPlus16</span><span class="p">)</span>
		<span class="n">numchips</span> <span class="o">=</span> <span class="n">doc2001plus_init</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">numchips</span> <span class="o">=</span> <span class="n">doc2001_init</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">nand_scan</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">numchips</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* DBB note: i believe nand_release is necessary here, as</span>
<span class="cm">		   buffers may have been allocated in nand_base.  Check with</span>
<span class="cm">		   Thomas. FIX ME! */</span>
		<span class="cm">/* nand_release will call mtd_device_unregister, but we</span>
<span class="cm">		   haven&#39;t yet added it.  This is handled without incident by</span>
<span class="cm">		   mtd_device_unregister, as far as I can tell. */</span>
		<span class="n">nand_release</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Success! */</span>
	<span class="n">doclist</span> <span class="o">=</span> <span class="n">mtd</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">notfound:</span>
	<span class="cm">/* Put back the contents of the DOCControl register, in case it&#39;s not</span>
<span class="cm">	   actually a DiskOnChip.  */</span>
	<span class="n">WriteDOC</span><span class="p">(</span><span class="n">save_control</span><span class="p">,</span> <span class="n">virtadr</span><span class="p">,</span> <span class="n">DOCControl</span><span class="p">);</span>
 <span class="nl">fail:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">virtadr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_nanddoc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="o">*</span><span class="n">nextmtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">nand</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doc_priv</span> <span class="o">*</span><span class="n">doc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">doclist</span><span class="p">;</span> <span class="n">mtd</span><span class="p">;</span> <span class="n">mtd</span> <span class="o">=</span> <span class="n">nextmtd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nand</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
		<span class="n">doc</span> <span class="o">=</span> <span class="n">nand</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

		<span class="n">nextmtd</span> <span class="o">=</span> <span class="n">doc</span><span class="o">-&gt;</span><span class="n">nextdoc</span><span class="p">;</span>
		<span class="n">nand_release</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">doc</span><span class="o">-&gt;</span><span class="n">virtadr</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_nanddoc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* We could create the decoder on demand, if memory is a concern.</span>
<span class="cm">	 * This way we have it handy, if an error happens</span>
<span class="cm">	 *</span>
<span class="cm">	 * Symbolsize is 10 (bits)</span>
<span class="cm">	 * Primitve polynomial is x^10+x^3+1</span>
<span class="cm">	 * first consecutive root is 510</span>
<span class="cm">	 * primitve element to generate roots = 1</span>
<span class="cm">	 * generator polinomial degree = 4</span>
<span class="cm">	 */</span>
	<span class="n">rs_decoder</span> <span class="o">=</span> <span class="n">init_rs</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mh">0x409</span><span class="p">,</span> <span class="n">FCR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NROOTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rs_decoder</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;DiskOnChip: Could not create a RS decoder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">doc_config_location</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Using configured DiskOnChip probe address 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">doc_config_location</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">doc_probe</span><span class="p">(</span><span class="n">doc_config_location</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">outerr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">doc_locations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">doc_probe</span><span class="p">(</span><span class="n">doc_locations</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* No banner message any more. Print a message if no DiskOnChip</span>
<span class="cm">	   found, so the user knows we at least tried. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">doclist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;No valid DiskOnChip devices found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">outerr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">outerr:</span>
	<span class="n">free_rs</span><span class="p">(</span><span class="n">rs_decoder</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_nanddoc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Cleanup the nand/DoC resources */</span>
	<span class="n">release_nanddoc</span><span class="p">();</span>

	<span class="cm">/* Free the reed solomon resources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rs_decoder</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_rs</span><span class="p">(</span><span class="n">rs_decoder</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_nanddoc</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_nanddoc</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Woodhouse &lt;dwmw2@infradead.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;M-Systems DiskOnChip 2000, Millennium and Millennium Plus device driver&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
