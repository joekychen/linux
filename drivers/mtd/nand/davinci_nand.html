<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › nand › davinci_nand.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>davinci_nand.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * davinci_nand.c - NAND Flash Driver for DaVinci family chips</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2006 Texas Instruments.</span>
<span class="cm"> *</span>
<span class="cm"> * Port to 2.6.23 Copyright © 2008 by:</span>
<span class="cm"> *   Sander Huijsen &lt;Shuijsen@optelecom-nkf.com&gt;</span>
<span class="cm"> *   Troy Kisky &lt;troy.kisky@boundarydevices.com&gt;</span>
<span class="cm"> *   Dirk Behme &lt;Dirk.Behme@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nand.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/partitions.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;mach/nand.h&gt;</span>
<span class="cp">#include &lt;mach/aemif.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This is a device driver for the NAND flash controller found on the</span>
<span class="cm"> * various DaVinci family chips.  It handles up to four SoC chipselects,</span>
<span class="cm"> * and some flavors of secondary chipselect (e.g. based on A12) as used</span>
<span class="cm"> * with multichip packages.</span>
<span class="cm"> *</span>
<span class="cm"> * The 1-bit ECC hardware is supported, as well as the newer 4-bit ECC</span>
<span class="cm"> * available on chips like the DM355 and OMAP-L137 and needed with the</span>
<span class="cm"> * more error-prone MLC NAND chips.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver assumes EM_WAIT connects all the NAND devices&#39; RDY/nBUSY</span>
<span class="cm"> * outputs in a &quot;wire-AND&quot; configuration, with no per-chip signals.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span>		<span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span>	<span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_ecclayout</span>	<span class="n">ecclayout</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>		<span class="o">*</span><span class="n">clk</span><span class="p">;</span>

	<span class="n">bool</span>			<span class="n">is_readmode</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>		<span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

	<span class="kt">uint32_t</span>		<span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">current_cs</span><span class="p">;</span>

	<span class="kt">uint32_t</span>		<span class="n">mask_chipsel</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">mask_ale</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">mask_cle</span><span class="p">;</span>

	<span class="kt">uint32_t</span>		<span class="n">core_chipsel</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">davinci_aemif_timing</span>	<span class="o">*</span><span class="n">timing</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">davinci_nand_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">ecc4_busy</span><span class="p">;</span>

<span class="cp">#define to_davinci_nand(m) container_of(m, struct davinci_nand_info, mtd)</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">davinci_nand_readl</span><span class="p">(</span><span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">davinci_nand_writel</span><span class="p">(</span><span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Access to hardware control lines:  ALE, CLE, secondary chipselect.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_davinci_hwcontrol</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span>	<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">to_davinci_nand</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">uint32_t</span>			<span class="n">addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">current_cs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nand_chip</span>		<span class="o">*</span><span class="n">nand</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="cm">/* Did the control lines change? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">NAND_CTRL_CHANGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">NAND_CTRL_CLE</span><span class="p">)</span> <span class="o">==</span> <span class="n">NAND_CTRL_CLE</span><span class="p">)</span>
			<span class="n">addr</span> <span class="o">|=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask_cle</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">NAND_CTRL_ALE</span><span class="p">)</span> <span class="o">==</span> <span class="n">NAND_CTRL_ALE</span><span class="p">)</span>
			<span class="n">addr</span> <span class="o">|=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask_ale</span><span class="p">;</span>

		<span class="n">nand</span><span class="o">-&gt;</span><span class="n">IO_ADDR_W</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">NAND_CMD_NONE</span><span class="p">)</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">nand</span><span class="o">-&gt;</span><span class="n">IO_ADDR_W</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_davinci_select_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span>	<span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">to_davinci_nand</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">uint32_t</span>			<span class="n">addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="cm">/* maybe kick in a second chipselect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">addr</span> <span class="o">|=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mask_chipsel</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">current_cs</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">IO_ADDR_W</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">IO_ADDR_R</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">IO_ADDR_W</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * 1-bit hardware ECC ... context maintained for each core chipselect</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">nand_davinci_readecc_1bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">to_davinci_nand</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDF1ECC_OFFSET</span>
			<span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">core_chipsel</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_davinci_hwctl_1bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">nandcfr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">to_davinci_nand</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="cm">/* Reset ECC hardware */</span>
	<span class="n">nand_davinci_readecc_1bit</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Restart ECC hardware */</span>
	<span class="n">nandcfr</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFCR_OFFSET</span><span class="p">);</span>
	<span class="n">nandcfr</span> <span class="o">|=</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">core_chipsel</span><span class="p">);</span>
	<span class="n">davinci_nand_writel</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFCR_OFFSET</span><span class="p">,</span> <span class="n">nandcfr</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read hardware ECC value and pack into three bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_davinci_calculate_1bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">dat</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">ecc_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecc_val</span> <span class="o">=</span> <span class="n">nand_davinci_readecc_1bit</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecc24</span> <span class="o">=</span> <span class="p">(</span><span class="n">ecc_val</span> <span class="o">&amp;</span> <span class="mh">0x0fff</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">ecc_val</span> <span class="o">&amp;</span> <span class="mh">0x0fff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* invert so that erased block ecc is correct */</span>
	<span class="n">ecc24</span> <span class="o">=</span> <span class="o">~</span><span class="n">ecc24</span><span class="p">;</span>
	<span class="n">ecc_code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_char</span><span class="p">)(</span><span class="n">ecc24</span><span class="p">);</span>
	<span class="n">ecc_code</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_char</span><span class="p">)(</span><span class="n">ecc24</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ecc_code</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_char</span><span class="p">)(</span><span class="n">ecc24</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_davinci_correct_1bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">dat</span><span class="p">,</span>
				     <span class="n">u_char</span> <span class="o">*</span><span class="n">read_ecc</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">calc_ecc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">eccNand</span> <span class="o">=</span> <span class="n">read_ecc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_ecc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					  <span class="p">(</span><span class="n">read_ecc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">eccCalc</span> <span class="o">=</span> <span class="n">calc_ecc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">calc_ecc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					  <span class="p">(</span><span class="n">calc_ecc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">eccCalc</span> <span class="o">^</span> <span class="n">eccNand</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((((</span><span class="n">diff</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">^</span> <span class="n">diff</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Correctable error */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">diff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">12</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ecc</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dat</span><span class="p">[</span><span class="n">diff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">12</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)]</span> <span class="o">^=</span> <span class="n">BIT</span><span class="p">((</span><span class="n">diff</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">diff</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">diff</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Single bit ECC error in the ECC itself,</span>
<span class="cm">			 * nothing to fix */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Uncorrectable error */</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * 4-bit hardware ECC ... context maintained over entire AEMIF</span>
<span class="cm"> *</span>
<span class="cm"> * This is a syndrome engine, but we avoid NAND_ECC_HW_SYNDROME</span>
<span class="cm"> * since that forces use of a problematic &quot;infix OOB&quot; layout.</span>
<span class="cm"> * Among other things, it trashes manufacturer bad block markers.</span>
<span class="cm"> * Also, and specific to this hardware, it ECC-protects the &quot;prepad&quot;</span>
<span class="cm"> * in the OOB ... while having ECC protection for parts of OOB would</span>
<span class="cm"> * seem useful, the current MTD stack sometimes wants to update the</span>
<span class="cm"> * OOB without recomputing ECC.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_davinci_hwctl_4bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">to_davinci_nand</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Start 4-bit ECC calculation for read/write */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFCR_OFFSET</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">core_chipsel</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
	<span class="n">davinci_nand_writel</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFCR_OFFSET</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">is_readmode</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">NAND_ECC_READ</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Read raw ECC code after writing to NAND. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">nand_davinci_readecc_4bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u32</span> <span class="n">code</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x03ff03ff</span><span class="p">;</span>

	<span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_4BIT_ECC1_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">code</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_4BIT_ECC2_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">code</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_4BIT_ECC3_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">code</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_4BIT_ECC4_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Terminate read ECC; or return ECC (as bytes) of data written to NAND. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_davinci_calculate_4bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">dat</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">ecc_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">to_davinci_nand</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">raw_ecc</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* After a read, terminate ECC calculation by a dummy read</span>
<span class="cm">	 * of some 4-bit ECC register.  ECC covers everything that</span>
<span class="cm">	 * was read; correct() just uses the hardware state, so</span>
<span class="cm">	 * ecc_code is not needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">is_readmode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_4BIT_ECC1_OFFSET</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Pack eight raw 10-bit ecc values into ten bytes, making</span>
<span class="cm">	 * two passes which each convert four values (in upper and</span>
<span class="cm">	 * lower halves of two 32-bit words) into five bytes.  The</span>
<span class="cm">	 * ROM boot loader uses this same packing scheme.</span>
<span class="cm">	 */</span>
	<span class="n">nand_davinci_readecc_4bit</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">raw_ecc</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">raw_ecc</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ecc_code</span><span class="o">++</span> <span class="o">=</span>   <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ecc_code</span><span class="o">++</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfc</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ecc_code</span><span class="o">++</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span>  <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ecc_code</span><span class="o">++</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ecc_code</span><span class="o">++</span> <span class="o">=</span>  <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Correct up to 4 bits in data we just read, using state left in the</span>
<span class="cm"> * hardware plus the ecc_code computed when it was first written.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_davinci_correct_4bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span>
		<span class="n">u_char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">ecc_code</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">null</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">to_davinci_nand</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ecc10</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">ecc16</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">syndrome</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ecc_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">num_errors</span><span class="p">,</span> <span class="n">corrected</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>

	<span class="cm">/* All bytes 0xff?  It&#39;s an erased page; ignore its ECC. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecc_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">compare</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">compare:</span>
	<span class="cm">/* Unpack ten bytes into eight 10 bit values.  We know we&#39;re</span>
<span class="cm">	 * little-endian, and use type punning for less shifting/masking.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="mh">0x01</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">ecc_code</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ecc16</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)</span><span class="n">ecc_code</span><span class="p">;</span>

	<span class="n">ecc10</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">;</span>
	<span class="n">ecc10</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3c0</span><span class="p">);</span>
	<span class="n">ecc10</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">;</span>
	<span class="n">ecc10</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span>  <span class="o">|</span> <span class="p">((</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3fc</span><span class="p">);</span>
	<span class="n">ecc10</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">8</span><span class="p">)</span>         <span class="o">|</span> <span class="p">((</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x300</span><span class="p">);</span>
	<span class="n">ecc10</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">;</span>
	<span class="n">ecc10</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span>  <span class="o">|</span> <span class="p">((</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f0</span><span class="p">);</span>
	<span class="n">ecc10</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span><span class="n">ecc16</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span>  <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">;</span>

	<span class="cm">/* Tell ECC controller about the expected ECC codes. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">davinci_nand_writel</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_4BIT_ECC_LOAD_OFFSET</span><span class="p">,</span> <span class="n">ecc10</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* Allow time for syndrome calculation ... then read it.</span>
<span class="cm">	 * A syndrome of all zeroes 0 means no detected errors.</span>
<span class="cm">	 */</span>
	<span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFSR_OFFSET</span><span class="p">);</span>
	<span class="n">nand_davinci_readecc_4bit</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">syndrome</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">syndrome</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">syndrome</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">syndrome</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">syndrome</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any previous address calculation by doing a dummy read of an</span>
<span class="cm">	 * error address register.</span>
<span class="cm">	 */</span>
	<span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_ERR_ADD1_OFFSET</span><span class="p">);</span>

	<span class="cm">/* Start address calculation, and wait for it to complete.</span>
<span class="cm">	 * We _could_ start reading more data while this is working,</span>
<span class="cm">	 * to speed up the overall page read.</span>
<span class="cm">	 */</span>
	<span class="n">davinci_nand_writel</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFCR_OFFSET</span><span class="p">,</span>
			<span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFCR_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * ECC_STATE field reads 0x3 (Error correction complete) immediately</span>
<span class="cm">	 * after setting the 4BITECC_ADD_CALC_START bit. So if you immediately</span>
<span class="cm">	 * begin trying to poll for the state, you may fall right out of your</span>
<span class="cm">	 * loop without any of the correction calculations having taken place.</span>
<span class="cm">	 * The recommendation from the hardware team is to initially delay as</span>
<span class="cm">	 * long as ECC_STATE reads less than 4. After that, ECC HW has entered</span>
<span class="cm">	 * correction state.</span>
<span class="cm">	 */</span>
	<span class="n">timeo</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">usecs_to_jiffies</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ecc_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
				<span class="n">NANDFSR_OFFSET</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">ecc_state</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeo</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">u32</span>	<span class="n">fsr</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFSR_OFFSET</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">((</span><span class="n">fsr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:		<span class="cm">/* no error, should not happen */</span>
			<span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_ERR_ERRVAL1_OFFSET</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:		<span class="cm">/* five or more errors detected */</span>
			<span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NAND_ERR_ERRVAL1_OFFSET</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:		<span class="cm">/* error addresses computed */</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">num_errors</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">fsr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">correct</span><span class="p">;</span>
		<span class="nl">default:</span>	<span class="cm">/* still working on it */</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">correct:</span>
	<span class="cm">/* correct each error */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">corrected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_errors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error_address</span><span class="p">,</span> <span class="n">error_value</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error_address</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
						<span class="n">NAND_ERR_ADD2_OFFSET</span><span class="p">);</span>
			<span class="n">error_value</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
						<span class="n">NAND_ERR_ERRVAL2_OFFSET</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">error_address</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
						<span class="n">NAND_ERR_ADD1_OFFSET</span><span class="p">);</span>
			<span class="n">error_value</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
						<span class="n">NAND_ERR_ERRVAL1_OFFSET</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error_address</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">error_value</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error_address</span> <span class="o">&amp;=</span> <span class="mh">0x3ff</span><span class="p">;</span>
		<span class="n">error_address</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">-</span> <span class="n">error_address</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error_address</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span><span class="p">[</span><span class="n">error_address</span><span class="p">]</span> <span class="o">^=</span> <span class="n">error_value</span><span class="p">;</span>
			<span class="n">corrected</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">corrected</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE:  NAND boot requires ALE == EM_A[1], CLE == EM_A[2], so that&#39;s</span>
<span class="cm"> * how these chips are normally wired.  This translates to both 8 and 16</span>
<span class="cm"> * bit busses using ALE == BIT(3) in byte addresses, and CLE == BIT(4).</span>
<span class="cm"> *</span>
<span class="cm"> * For now we assume that configuration, or any other one which ignores</span>
<span class="cm"> * the two LSBs for NAND access ... so we can issue 32-bit reads/writes</span>
<span class="cm"> * and have that transparently morphed into multiple NAND operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_davinci_read_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="mh">0x03</span> <span class="o">&amp;</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">buf</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mh">0x03</span> <span class="o">&amp;</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ioread32_rep</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_R</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="mh">0x01</span> <span class="o">&amp;</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">buf</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&amp;</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ioread16_rep</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_R</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ioread8_rep</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_R</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nand_davinci_write_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nand_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="mh">0x03</span> <span class="o">&amp;</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">buf</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mh">0x03</span> <span class="o">&amp;</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iowrite32_rep</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_R</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="mh">0x01</span> <span class="o">&amp;</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">buf</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&amp;</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iowrite16_rep</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_R</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iowrite8_rep</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">IO_ADDR_R</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check hardware register for wait status. Returns 1 if device is ready,</span>
<span class="cm"> * 0 if it is still busy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nand_davinci_dev_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">to_davinci_nand</span><span class="p">(</span><span class="n">mtd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFSR_OFFSET</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*----------------------------------------------------------------------*/</span>

<span class="cm">/* An ECC layout for using 4-bit ECC with small-page flash, storing</span>
<span class="cm"> * ten ECC bytes plus the manufacturer&#39;s bad block marker byte, and</span>
<span class="cm"> * and not overlapping the default BBT markers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="n">hwecc4_small</span> <span class="n">__initconst</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">eccbytes</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eccpos</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
		<span class="cm">/* offset 5 holds the badblock marker */</span>
		<span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span>
		<span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">.</span><span class="n">oobfree</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="p">},</span>
		<span class="p">{.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* An ECC layout for using 4-bit ECC with large-page (2048bytes) flash,</span>
<span class="cm"> * storing ten ECC bytes plus the manufacturer&#39;s bad block marker byte,</span>
<span class="cm"> * and not overlapping the default BBT markers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nand_ecclayout</span> <span class="n">hwecc4_2048</span> <span class="n">__initconst</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">eccbytes</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eccpos</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* at the end of spare sector */</span>
		<span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span>	<span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span>
		<span class="mi">34</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span>	<span class="mi">40</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span>
		<span class="mi">44</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span>
		<span class="mi">54</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">.</span><span class="n">oobfree</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* 2 bytes at offset 0 hold manufacturer badblock markers */</span>
		<span class="p">{.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">22</span><span class="p">,</span> <span class="p">},</span>
		<span class="cm">/* 5 bytes at offset 8 hold BBT markers */</span>
		<span class="cm">/* 8 bytes at offset 16 hold JFFS2 clean markers */</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nand_davinci_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_pdata</span>	<span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span>	<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span>			<span class="o">*</span><span class="n">res1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span>			<span class="o">*</span><span class="n">res2</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">ret</span><span class="p">;</span>
	<span class="kt">uint32_t</span>			<span class="n">val</span><span class="p">;</span>
	<span class="n">nand_ecc_modes_t</span>		<span class="n">ecc_mode</span><span class="p">;</span>

	<span class="cm">/* insist on board-specific configuration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* which external chipselect will we be managing? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to allocate memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_nomem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="n">res1</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">res2</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res1</span> <span class="o">||</span> <span class="o">!</span><span class="n">res2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resource missing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_nomem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vaddr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res1</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res1</span><span class="p">));</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res2</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res2</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vaddr</span> <span class="o">||</span> <span class="o">!</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ioremap failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">base</span>		<span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">vaddr</span>		<span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">priv</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">IO_ADDR_R</span>	<span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">IO_ADDR_W</span>	<span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">chip_delay</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">select_chip</span>	<span class="o">=</span> <span class="n">nand_davinci_select_chip</span><span class="p">;</span>

	<span class="cm">/* options such as NAND_BBT_USE_FLASH */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">bbt_options</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">bbt_options</span><span class="p">;</span>
	<span class="cm">/* options such as 16-bit widths */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">options</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">bbt_td</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">bbt_td</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">bbt_md</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">bbt_md</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">timing</span>		<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">timing</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">ioaddr</span>		<span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">__force</span><span class="p">)</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">current_cs</span>	<span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">core_chipsel</span>	<span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mask_chipsel</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mask_chipsel</span><span class="p">;</span>

	<span class="cm">/* use nandboot-capable ALE/CLE masks by default */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mask_ale</span>		<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mask_ale</span> <span class="o">?</span> <span class="o">:</span> <span class="n">MASK_ALE</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mask_cle</span>		<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mask_cle</span> <span class="o">?</span> <span class="o">:</span> <span class="n">MASK_CLE</span><span class="p">;</span>

	<span class="cm">/* Set address of hardware control function */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">cmd_ctrl</span>	<span class="o">=</span> <span class="n">nand_davinci_hwcontrol</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">dev_ready</span>	<span class="o">=</span> <span class="n">nand_davinci_dev_ready</span><span class="p">;</span>

	<span class="cm">/* Speed up buffer I/O */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">read_buf</span>     <span class="o">=</span> <span class="n">nand_davinci_read_buf</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">write_buf</span>    <span class="o">=</span> <span class="n">nand_davinci_write_buf</span><span class="p">;</span>

	<span class="cm">/* Use board-specific ECC config */</span>
	<span class="n">ecc_mode</span>		<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ecc_mode</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ecc_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NAND_ECC_NONE</span>:
	<span class="k">case</span> <span class="n">NAND_ECC_SOFT</span>:
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ecc_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NAND_ECC_HW</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ecc_bits</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No sanity checks:  CPUs must support this,</span>
<span class="cm">			 * and the chips may not use NAND_BUSWIDTH_16.</span>
<span class="cm">			 */</span>

			<span class="cm">/* No sharing 4-bit hardware between chipselects yet */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ecc4_busy</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ecc4_busy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_ecc</span><span class="p">;</span>

			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">calculate</span> <span class="o">=</span> <span class="n">nand_davinci_calculate_4bit</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">correct</span> <span class="o">=</span> <span class="n">nand_davinci_correct_4bit</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">hwctl</span> <span class="o">=</span> <span class="n">nand_davinci_hwctl_4bit</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">calculate</span> <span class="o">=</span> <span class="n">nand_davinci_calculate_1bit</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">correct</span> <span class="o">=</span> <span class="n">nand_davinci_correct_1bit</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">hwctl</span> <span class="o">=</span> <span class="n">nand_davinci_hwctl_1bit</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">strength</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ecc_bits</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_ecc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">ecc_mode</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;aemif&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to get AEMIF clock, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_enable</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to enable AEMIF clock, err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_clk_enable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup Async configuration register in case we did not boot from</span>
<span class="cm">	 * NAND and so bootloader did not bother to set it up.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">A1CR_OFFSET</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">core_chipsel</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Extended Wait is not valid and Select Strobe mode is not used */</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ACR_ASIZE_MASK</span> <span class="o">|</span> <span class="n">ACR_EW_MASK</span> <span class="o">|</span> <span class="n">ACR_SS_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">NAND_BUSWIDTH_16</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="mh">0x1</span><span class="p">;</span>

	<span class="n">davinci_nand_writel</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">A1CR_OFFSET</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">core_chipsel</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">timing</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">davinci_aemif_setup_timing</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">timing</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
							<span class="n">info</span><span class="o">-&gt;</span><span class="n">core_chipsel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NAND timing values setup fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_timing</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">);</span>

	<span class="cm">/* put CSxNAND into NAND mode */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFCR_OFFSET</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">core_chipsel</span><span class="p">);</span>
	<span class="n">davinci_nand_writel</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NANDFCR_OFFSET</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">);</span>

	<span class="cm">/* Scan to find existence of the device(s) */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nand_scan_ident</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mask_chipsel</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no NAND chip(s) found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_scan</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update ECC layout if needed ... for 1-bit HW ECC, the default</span>
<span class="cm">	 * is OK, but it allocates 6 bytes when only 3 are needed (for</span>
<span class="cm">	 * each 512 bytes).  For the 4-bit HW ECC, that default is not</span>
<span class="cm">	 * usable:  10 bytes are needed, not 6.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">ecc_bits</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">chunks</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">writesize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunks</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_scan</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* For small page chips, preserve the manufacturer&#39;s</span>
<span class="cm">		 * badblock marking data ... and make sure a flash BBT</span>
<span class="cm">		 * table marker fits in the free bytes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">ecclayout</span> <span class="o">=</span> <span class="n">hwecc4_small</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">ecclayout</span><span class="p">.</span><span class="n">oobfree</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">.</span><span class="n">oobsize</span> <span class="o">-</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">syndrome_done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunks</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">ecclayout</span> <span class="o">=</span> <span class="n">hwecc4_2048</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">NAND_ECC_HW_OOB_FIRST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">syndrome_done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* 4KiB page chips are not yet supported. The eccpos from</span>
<span class="cm">		 * nand_ecclayout cannot hold 80 bytes and change to eccpos[]</span>
<span class="cm">		 * breaks userspace ioctl interface with mtd-utils. Once we</span>
<span class="cm">		 * resolve this issue, NAND_ECC_HW_OOB_FIRST mode can be used</span>
<span class="cm">		 * for the 4KiB page chips.</span>
<span class="cm">		 *</span>
<span class="cm">		 * TODO: Note that nand_ecclayout has now been expanded and can</span>
<span class="cm">		 *  hold plenty of OOB entries.</span>
<span class="cm">		 */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no 4-bit ECC support yet &quot;</span>
				<span class="s">&quot;for 4KiB-page NAND</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_scan</span><span class="p">;</span>

<span class="nl">syndrome_done:</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ecclayout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nand_scan_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_scan</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_device_parse_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">parts</span><span class="p">,</span>
					<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">nr_parts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_scan</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">davinci_nand_readl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">NRCSR_OFFSET</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;controller rev. %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_scan:</span>
<span class="nl">err_timing:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

<span class="nl">err_clk_enable:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ecc_mode</span> <span class="o">==</span> <span class="n">NAND_ECC_HW_SYNDROME</span><span class="p">)</span>
		<span class="n">ecc4_busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">);</span>

<span class="nl">err_ecc:</span>
<span class="nl">err_clk:</span>
<span class="nl">err_ioremap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

<span class="nl">err_nomem:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">nand_davinci_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">davinci_nand_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">ecc</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">NAND_ECC_HW_SYNDROME</span><span class="p">)</span>
		<span class="n">ecc4_busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">davinci_nand_lock</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">vaddr</span><span class="p">);</span>

	<span class="n">nand_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">nand_davinci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__exit_p</span><span class="p">(</span><span class="n">nand_davinci_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;davinci_nand&quot;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:davinci_nand&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nand_davinci_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nand_davinci_driver</span><span class="p">,</span> <span class="n">nand_davinci_probe</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">nand_davinci_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">nand_davinci_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nand_davinci_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">nand_davinci_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Texas Instruments&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Davinci NAND flash driver&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
