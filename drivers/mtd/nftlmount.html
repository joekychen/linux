<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › nftlmount.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nftlmount.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NFTL mount code with extensive checks</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Fabrice Bellard (fabrice.bellard@netgem.com)</span>
<span class="cm"> * Copyright © 2000 Netgem S.A.</span>
<span class="cm"> * Copyright © 1999-2010 David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;asm/errno.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nand.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nftl.h&gt;</span>

<span class="cp">#define SECTORSIZE 512</span>

<span class="cm">/* find_boot_record: Find the NFTL Media Header and its Spare copy which contains the</span>
<span class="cm"> *	various device information of the NFTL partition and Bad Unit Table. Update</span>
<span class="cm"> *	the ReplUnitTable[] table according to the Bad Unit Table. ReplUnitTable[]</span>
<span class="cm"> *	is used for management of Erase Unit in other routines in nftl.c and nftlmount.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_boot_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nftl_uci1</span> <span class="n">h1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">boot_record_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="n">SECTORSIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">NFTLMediaHeader</span> <span class="o">*</span><span class="n">mh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">MediaHdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="cm">/* Assume logical EraseSize == physical erasesize for starting the scan.</span>
<span class="cm">	   We&#39;ll sort it out later if we find a MediaHeader which says otherwise */</span>
	<span class="cm">/* Actually, we won&#39;t.  The new DiskOnChip driver has already scanned</span>
<span class="cm">	   the MediaHeader and adjusted the virtual erasesize it presents in</span>
<span class="cm">	   the mtd device accordingly.  We could even get rid of</span>
<span class="cm">	   nftl-&gt;EraseSize if there were any point in doing so. */</span>
	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">;</span>
        <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>

	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">MediaUnit</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">SpareMediaUnit</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

	<span class="cm">/* search for a valid boot record */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* Check for ANAND header first. Then can whinge if it&#39;s found but later</span>
<span class="cm">		   checks fail */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="n">SECTORSIZE</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="cm">/* We ignore ret in case the ECC of the MediaHeader is invalid</span>
<span class="cm">		   (which is apparently acceptable) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">SECTORSIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">int</span> <span class="n">warncount</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">warncount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Block read at 0x%x of mtd%d failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">warncount</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Further failures for this block will not be printed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;ANAND&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* ANAND\0 not found. Continue */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">			printk(KERN_DEBUG &quot;ANAND header not found at 0x%x in mtd%d\n&quot;,</span>
<span class="c">			       block * nftl-&gt;EraseSize, nftl-&gt;mbd.mtd-&gt;index);</span>
<span class="cp">#endif</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* To be safer with BIOS, also use erase mark as discriminant */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span>
					 <span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ANAND header found at 0x%x in mtd%d, but OOB data read failed (err %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"> /* Some people seem to have devices without ECC or erase marks</span>
<span class="c">	 on the Media Header blocks. There are enough other sanity</span>
<span class="c">	 checks in here that we can probably do without it.</span>
<span class="c">      */</span>
<span class="c">		if (le16_to_cpu(h1.EraseMark | h1.EraseMark1) != ERASE_MARK) {</span>
<span class="c">			printk(KERN_NOTICE &quot;ANAND header found at 0x%x in mtd%d, but erase mark not present (0x%04x,0x%04x instead)\n&quot;,</span>
<span class="c">			       block * nftl-&gt;EraseSize, nftl-&gt;mbd.mtd-&gt;index,</span>
<span class="c">			       le16_to_cpu(h1.EraseMark), le16_to_cpu(h1.EraseMark1));</span>
<span class="c">			continue;</span>
<span class="c">		}</span>

<span class="c">		/* Finally reread to check ECC */</span>
<span class="c">		if ((ret = mtd-&gt;read(mtd, block * nftl-&gt;EraseSize, SECTORSIZE,</span>
<span class="c">				     &amp;retlen, buf) &lt; 0)) {</span>
<span class="c">			printk(KERN_NOTICE &quot;ANAND header found at 0x%x in mtd%d, but ECC read failed (err %d)\n&quot;,</span>
<span class="c">			       block * nftl-&gt;EraseSize, nftl-&gt;mbd.mtd-&gt;index, ret);</span>
<span class="c">			continue;</span>
<span class="c">		}</span>

<span class="c">		/* Paranoia. Check the ANAND header is still there after the ECC read */</span>
<span class="c">		if (memcmp(buf, &quot;ANAND&quot;, 6)) {</span>
<span class="c">			printk(KERN_NOTICE &quot;ANAND header found at 0x%x in mtd%d, but went away on reread!\n&quot;,</span>
<span class="c">			       block * nftl-&gt;EraseSize, nftl-&gt;mbd.mtd-&gt;index);</span>
<span class="c">			printk(KERN_NOTICE &quot;New data are: %02x %02x %02x %02x %02x %02x\n&quot;,</span>
<span class="c">			       buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);</span>
<span class="c">			continue;</span>
<span class="c">		}</span>
<span class="cp">#endif</span>
		<span class="cm">/* OK, we like it. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">boot_record_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We&#39;ve already processed one. So we just check if</span>
<span class="cm">			   this one is the same as the first one we found */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLMediaHeader</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;NFTL Media Headers at 0x%x and 0x%x disagree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">MediaUnit</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">);</span>
				<span class="cm">/* if (debug) Print both side by side */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">boot_record_count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* We haven&#39;t yet seen two real ones */</span>
					<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">boot_record_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">SpareMediaUnit</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>

			<span class="cm">/* Mark this boot record (NFTL MediaHeader) block as reserved */</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>


			<span class="n">boot_record_count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* This is the first we&#39;ve seen. Copy the media header structure into place */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLMediaHeader</span><span class="p">));</span>

		<span class="cm">/* Do some sanity checks on it */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">The new DiskOnChip driver scans the MediaHeader itself, and presents a virtual</span>
<span class="c">erasesize based on UnitSizeFactor.  So the erasesize we read from the mtd</span>
<span class="c">device is already correct.</span>
<span class="c">		if (mh-&gt;UnitSizeFactor == 0) {</span>
<span class="c">			printk(KERN_NOTICE &quot;NFTL: UnitSizeFactor 0x00 detected. This violates the spec but we think we know what it means...\n&quot;);</span>
<span class="c">		} else if (mh-&gt;UnitSizeFactor &lt; 0xfc) {</span>
<span class="c">			printk(KERN_NOTICE &quot;Sorry, we don&#39;t support UnitSizeFactor 0x%02x\n&quot;,</span>
<span class="c">			       mh-&gt;UnitSizeFactor);</span>
<span class="c">			return -1;</span>
<span class="c">		} else if (mh-&gt;UnitSizeFactor != 0xff) {</span>
<span class="c">			printk(KERN_NOTICE &quot;WARNING: Support for NFTL with UnitSizeFactor 0x%02x is experimental\n&quot;,</span>
<span class="c">			       mh-&gt;UnitSizeFactor);</span>
<span class="c">			nftl-&gt;EraseSize = nftl-&gt;mbd.mtd-&gt;erasesize &lt;&lt; (0xff - mh-&gt;UnitSizeFactor);</span>
<span class="c">			nftl-&gt;nb_blocks = (u32)nftl-&gt;mbd.mtd-&gt;size / nftl-&gt;EraseSize;</span>
<span class="c">		}</span>
<span class="cp">#endif</span>
		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">FirstPhysicalEUN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;NFTL Media Header sanity check failed:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;nb_boot_blocks (%d) + 2 &gt; nb_blocks (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">numvunits</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">FormattedSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">numvunits</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">-</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;NFTL Media Header sanity check failed:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;numvunits (%d) &gt; nb_blocks (%d) - nb_boot_blocks(%d) - 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">numvunits</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span>  <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">numvunits</span> <span class="o">*</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="n">SECTORSIZE</span><span class="p">);</span>

		<span class="cm">/* If we&#39;re not using the last sectors in the device for some reason,</span>
<span class="cm">		   reduce nb_blocks accordingly so we forget they&#39;re there */</span>
		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NumEraseUnits</span><span class="p">)</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">FirstPhysicalEUN</span><span class="p">);</span>

		<span class="cm">/* XXX: will be suppressed */</span>
		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">lastEUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* memory alloc */</span>
		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;NFTL: allocation of EUNtable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;NFTL: allocation of ReplUnitTable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* mark the bios blocks (blocks before NFTL MediaHeader) as reserved */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
		<span class="cm">/* mark all remaining blocks as potentially containing data */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Mark this boot record (NFTL MediaHeader) block as reserved */</span>
		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>

		<span class="cm">/* read the Bad Erase Unit Table and modify ReplUnitTable[] accordingly */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">The new DiskOnChip driver already scanned the bad block table.  Just query it.</span>
<span class="c">			if ((i &amp; (SECTORSIZE - 1)) == 0) {</span>
<span class="c">				/* read one sector for every SECTORSIZE of blocks */</span>
<span class="c">				if ((ret = mtd-&gt;read(nftl-&gt;mbd.mtd, block * nftl-&gt;EraseSize +</span>
<span class="c">						     i + SECTORSIZE, SECTORSIZE, &amp;retlen,</span>
<span class="c">						     buf)) &lt; 0) {</span>
<span class="c">					printk(KERN_NOTICE &quot;Read of bad sector table failed (err %d)\n&quot;,</span>
<span class="c">					       ret);</span>
<span class="c">					kfree(nftl-&gt;ReplUnitTable);</span>
<span class="c">					kfree(nftl-&gt;EUNtable);</span>
<span class="c">					return -1;</span>
<span class="c">				}</span>
<span class="c">			}</span>
<span class="c">			/* mark the Bad Erase Unit as RESERVED in ReplUnitTable */</span>
<span class="c">			if (buf[i &amp; (SECTORSIZE - 1)] != 0xff)</span>
<span class="c">				nftl-&gt;ReplUnitTable[i] = BLOCK_RESERVED;</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtd_block_isbad</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">,</span>
					    <span class="n">i</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">))</span>
				<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">MediaUnit</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
		<span class="n">boot_record_count</span><span class="o">++</span><span class="p">;</span>

	<span class="p">}</span> <span class="cm">/* foreach (block) */</span>

	<span class="k">return</span> <span class="n">boot_record_count</span><span class="o">?</span><span class="mi">0</span><span class="o">:-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memcmpb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* check_free_sector: check if a free sector is actually FREE, i.e. All 0xff in data and oob area */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_free_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">check_oob</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">SECTORSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">SECTORSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmpb</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">SECTORSIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">check_oob</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">SECTORSIZE</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmpb</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">SECTORSIZE</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">address</span> <span class="o">+=</span> <span class="n">SECTORSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* NFTL_format: format a Erase Unit by erasing ALL Erase Zones in the Erase Unit and</span>
<span class="cm"> *              Update NFTL metadata. Each erase operation is checked with check_free_sectors</span>
<span class="cm"> *</span>
<span class="cm"> * Return: 0 when succeed, -1 on error.</span>
<span class="cm"> *</span>
<span class="cm"> *  ToDo: 1. Is it necessary to check_free_sector after erasing ??</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">NFTL_formatblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nb_erases</span><span class="p">,</span> <span class="n">erase_mark</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_uci1</span> <span class="n">uci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">instr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>

	<span class="cm">/* Read the Unit Control Information #1 for Wear-Leveling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
			  <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">default_uci1</span><span class="p">;</span>

	<span class="n">erase_mark</span> <span class="o">=</span> <span class="n">le16_to_cpu</span> <span class="p">((</span><span class="n">uci</span><span class="p">.</span><span class="n">EraseMark</span> <span class="o">|</span> <span class="n">uci</span><span class="p">.</span><span class="n">EraseMark1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">erase_mark</span> <span class="o">!=</span> <span class="n">ERASE_MARK</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default_uci1:</span>
		<span class="n">uci</span><span class="p">.</span><span class="n">EraseMark</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ERASE_MARK</span><span class="p">);</span>
		<span class="n">uci</span><span class="p">.</span><span class="n">EraseMark1</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ERASE_MARK</span><span class="p">);</span>
		<span class="n">uci</span><span class="p">.</span><span class="n">WearInfo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">erase_info</span><span class="p">));</span>

	<span class="cm">/* XXX: use async erase interface, XXX: test return code */</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>
	<span class="n">mtd_erase</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">instr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MTD_ERASE_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Error while formatting block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

		<span class="cm">/* increase and write Wear-Leveling info */</span>
		<span class="n">nb_erases</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">uci</span><span class="p">.</span><span class="n">WearInfo</span><span class="p">);</span>
		<span class="n">nb_erases</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* wrap (almost impossible with current flash) or free block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nb_erases</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">nb_erases</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* check the &quot;freeness&quot; of Erase Unit before updating metadata</span>
<span class="cm">		 * FixMe:  is this check really necessary ? since we have check the</span>
<span class="cm">		 *         return code after the erase operation. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_free_sectors</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">uci</span><span class="p">.</span><span class="n">WearInfo</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">nb_erases</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nftl_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">SECTORSIZE</span> <span class="o">+</span>
				   <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="cm">/* could not format, update the bad block table (caller is responsible</span>
<span class="cm">	   for setting the ReplUnitTable to BLOCK_RESERVED on failure) */</span>
	<span class="n">mtd_block_markbad</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* check_sectors_in_chain: Check that each sector of a Virtual Unit Chain is correct.</span>
<span class="cm"> *	Mark as &#39;IGNORE&#39; each incorrect sector. This check is only done if the chain</span>
<span class="cm"> *	was being folded when NFTL was interrupted.</span>
<span class="cm"> *</span>
<span class="cm"> *	The check_free_sectors in this function is necessary. There is a possible</span>
<span class="cm"> *	situation that after writing the Data area, the Block Control Information is</span>
<span class="cm"> *	not updated according (due to power failure or something) which leaves the block</span>
<span class="cm"> *	in an inconsistent state. So we have to check if a block is really FREE in this</span>
<span class="cm"> *	case. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_sectors_in_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_bci</span> <span class="n">bci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sectors_per_block</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>

	<span class="n">sectors_per_block</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="n">SECTORSIZE</span><span class="p">;</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sectors_per_block</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span>
					  <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">SECTORSIZE</span><span class="p">,</span>
					  <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">SECTOR_IGNORE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">bci</span><span class="p">.</span><span class="n">Status</span> <span class="o">|</span> <span class="n">bci</span><span class="p">.</span><span class="n">Status1</span><span class="p">;</span>

			<span class="k">switch</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SECTOR_FREE</span>:
				<span class="cm">/* verify that the sector is really free. If not, mark</span>
<span class="cm">				   as ignore */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">memcmpb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bci</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
				    <span class="n">check_free_sectors</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">SECTORSIZE</span><span class="p">,</span>
						       <span class="n">SECTORSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Incorrect free sector %d in block %d: &quot;</span>
					       <span class="s">&quot;marking it as ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">i</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>

					<span class="cm">/* sector not free actually : mark it as SECTOR_IGNORE  */</span>
					<span class="n">bci</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">SECTOR_IGNORE</span><span class="p">;</span>
					<span class="n">bci</span><span class="p">.</span><span class="n">Status1</span> <span class="o">=</span> <span class="n">SECTOR_IGNORE</span><span class="p">;</span>
					<span class="n">nftl_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span>
						       <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span>
						       <span class="n">i</span> <span class="o">*</span> <span class="n">SECTORSIZE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bci</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* proceed to next Erase Unit on the chain */</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span> <span class="o">||</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;incorrect ReplUnitTable[] : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span> <span class="o">||</span> <span class="n">block</span> <span class="o">&gt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* calc_chain_length: Walk through a Virtual Unit Chain and estimate chain length */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calc_chain_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">length</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* avoid infinite loops, although this is guaranteed not to</span>
<span class="cm">		   happen because of the previous checks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;nftl: length too long %d !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">block</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span> <span class="o">||</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;incorrect ReplUnitTable[] : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span> <span class="o">||</span> <span class="n">block</span> <span class="o">&gt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* format_chain: Format an invalid Virtual Unit chain. It frees all the Erase Units in a</span>
<span class="cm"> *	Virtual Unit Chain, i.e. all the units are disconnected.</span>
<span class="cm"> *</span>
<span class="cm"> *	It is not strictly correct to begin from the first block of the chain because</span>
<span class="cm"> *	if we stop the code, we may see again a valid chain if there was a first_block</span>
<span class="cm"> *	flag in a block inside it. But is it really a problem ?</span>
<span class="cm"> *</span>
<span class="cm"> * FixMe: Figure out what the last statement means. What if power failure when we are</span>
<span class="cm"> *	in the for (;;) loop formatting blocks ??</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">format_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">block1</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Formatting chain at block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">block1</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Formatting block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NFTL_formatblock</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* cannot format !!!! Mark it as Bad Unit */</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_FREE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* goto next block on the chain */</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">block1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span> <span class="o">||</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;incorrect ReplUnitTable[] : %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span> <span class="o">||</span> <span class="n">block</span> <span class="o">&gt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* check_and_mark_free_block: Verify that a block is free in the NFTL sense (valid erase mark) or</span>
<span class="cm"> *	totally free (only 0xff).</span>
<span class="cm"> *</span>
<span class="cm"> * Definition: Free Erase Unit -- A properly erased/formatted Free Erase Unit should have meet the</span>
<span class="cm"> *	following criteria:</span>
<span class="cm"> *	1. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_and_mark_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_uci1</span> <span class="n">h1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">erase_mark</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>

	<span class="cm">/* check erase mark. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">erase_mark</span> <span class="o">=</span> <span class="n">le16_to_cpu</span> <span class="p">((</span><span class="n">h1</span><span class="p">.</span><span class="n">EraseMark</span> <span class="o">|</span> <span class="n">h1</span><span class="p">.</span><span class="n">EraseMark1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">erase_mark</span> <span class="o">!=</span> <span class="n">ERASE_MARK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if no erase mark, the block must be totally free. This is</span>
<span class="cm">		   possible in two cases : empty filesystem or interrupted erase (very unlikely) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_free_sectors</span> <span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* free block : write erase mark */</span>
		<span class="n">h1</span><span class="p">.</span><span class="n">EraseMark</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ERASE_MARK</span><span class="p">);</span>
		<span class="n">h1</span><span class="p">.</span><span class="n">EraseMark1</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ERASE_MARK</span><span class="p">);</span>
		<span class="n">h1</span><span class="p">.</span><span class="n">WearInfo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nftl_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span>
				   <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/* if erase mark present, need to skip it when doing check */</span>
<span class="c">		for (i = 0; i &lt; nftl-&gt;EraseSize; i += SECTORSIZE) {</span>
<span class="c">			/* check free sector */</span>
<span class="c">			if (check_free_sectors (nftl, block * nftl-&gt;EraseSize + i,</span>
<span class="c">						SECTORSIZE, 0) != 0)</span>
<span class="c">				return -1;</span>

<span class="c">			if (nftl_read_oob(mtd, block * nftl-&gt;EraseSize + i,</span>
<span class="c">					  16, &amp;retlen, buf) &lt; 0)</span>
<span class="c">				return -1;</span>
<span class="c">			if (i == SECTORSIZE) {</span>
<span class="c">				/* skip erase mark */</span>
<span class="c">				if (memcmpb(buf, 0xff, 8))</span>
<span class="c">					return -1;</span>
<span class="c">			} else {</span>
<span class="c">				if (memcmpb(buf, 0xff, 16))</span>
<span class="c">					return -1;</span>
<span class="c">			}</span>
<span class="c">		}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* get_fold_mark: Read fold mark from Unit Control Information #2, we use FOLD_MARK_IN_PROGRESS</span>
<span class="cm"> *	to indicate that we are in the progression of a Virtual Unit Chain folding. If the UCI #2</span>
<span class="cm"> *	is FOLD_MARK_IN_PROGRESS when mounting the NFTL, the (previous) folding process is interrupted</span>
<span class="cm"> *	for some reason. A clean up/check of the VUC is necessary in this case.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: return 0 if read error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_fold_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_uci2</span> <span class="n">uci</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
			  <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">le16_to_cpu</span><span class="p">((</span><span class="n">uci</span><span class="p">.</span><span class="n">FoldMark</span> <span class="o">|</span> <span class="n">uci</span><span class="p">.</span><span class="n">FoldMark1</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">NFTL_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_logical_block</span><span class="p">,</span> <span class="n">logical_block</span><span class="p">,</span> <span class="n">rep_block</span><span class="p">,</span> <span class="n">nb_erases</span><span class="p">,</span> <span class="n">erase_mark</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">is_first_block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chain_length</span><span class="p">,</span> <span class="n">do_format_chain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_uci0</span> <span class="n">h0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_uci1</span> <span class="n">h1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>

	<span class="cm">/* search for NFTL MediaHeader and Spare NFTL Media Header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_boot_record</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Could not find valid boot record</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* init the logical to physical table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* first pass : explore each block chain */</span>
	<span class="n">first_logical_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">first_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">first_block</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">first_block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if the block was not already explored, we can look at it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">first_block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
			<span class="n">chain_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">do_format_chain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
				<span class="cm">/* read the block header. If error, we format the chain */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span>
						  <span class="n">block</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
				    <span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span>
						  <span class="n">block</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span>
						  <span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
					<span class="n">do_format_chain</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">logical_block</span> <span class="o">=</span> <span class="n">le16_to_cpu</span> <span class="p">((</span><span class="n">h0</span><span class="p">.</span><span class="n">VirtUnitNum</span> <span class="o">|</span> <span class="n">h0</span><span class="p">.</span><span class="n">SpareVirtUnitNum</span><span class="p">));</span>
				<span class="n">rep_block</span> <span class="o">=</span> <span class="n">le16_to_cpu</span> <span class="p">((</span><span class="n">h0</span><span class="p">.</span><span class="n">ReplUnitNum</span> <span class="o">|</span> <span class="n">h0</span><span class="p">.</span><span class="n">SpareReplUnitNum</span><span class="p">));</span>
				<span class="n">nb_erases</span> <span class="o">=</span> <span class="n">le32_to_cpu</span> <span class="p">(</span><span class="n">h1</span><span class="p">.</span><span class="n">WearInfo</span><span class="p">);</span>
				<span class="n">erase_mark</span> <span class="o">=</span> <span class="n">le16_to_cpu</span> <span class="p">((</span><span class="n">h1</span><span class="p">.</span><span class="n">EraseMark</span> <span class="o">|</span> <span class="n">h1</span><span class="p">.</span><span class="n">EraseMark1</span><span class="p">));</span>

				<span class="n">is_first_block</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">logical_block</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">);</span>
				<span class="n">logical_block</span> <span class="o">=</span> <span class="n">logical_block</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">;</span>

				<span class="cm">/* invalid/free block test */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">erase_mark</span> <span class="o">!=</span> <span class="n">ERASE_MARK</span> <span class="o">||</span> <span class="n">logical_block</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">chain_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* if not currently in a chain, we can handle it safely */</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">check_and_mark_free_block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
							<span class="cm">/* not really free: format it */</span>
							<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Formatting block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">NFTL_formatblock</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
								<span class="cm">/* could not format: reserve the block */</span>
								<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
							<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
								<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_FREE</span><span class="p">;</span>
							<span class="p">}</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="cm">/* free block: mark it */</span>
							<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_FREE</span><span class="p">;</span>
						<span class="p">}</span>
						<span class="cm">/* directly examine the next block. */</span>
						<span class="k">goto</span> <span class="n">examine_ReplUnitTable</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="cm">/* the block was in a chain : this is bad. We</span>
<span class="cm">						   must format all the chain */</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block %d: free but referenced in chain %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						       <span class="n">block</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
						<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
						<span class="n">do_format_chain</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="cm">/* we accept only first blocks here */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chain_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* this block is not the first block in chain :</span>
<span class="cm">					   ignore it, it will be included in a chain</span>
<span class="cm">					   later, or marked as not explored */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_first_block</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">examine_ReplUnitTable</span><span class="p">;</span>
					<span class="n">first_logical_block</span> <span class="o">=</span> <span class="n">logical_block</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">logical_block</span> <span class="o">!=</span> <span class="n">first_logical_block</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block %d: incorrect logical block: %d expected: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						       <span class="n">block</span><span class="p">,</span> <span class="n">logical_block</span><span class="p">,</span> <span class="n">first_logical_block</span><span class="p">);</span>
						<span class="cm">/* the chain is incorrect : we must format it,</span>
<span class="cm">						   but we need to read it completely */</span>
						<span class="n">do_format_chain</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">is_first_block</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* we accept that a block is marked as first</span>
<span class="cm">						   block while being last block in a chain</span>
<span class="cm">						   only if the chain is being folded */</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">get_fold_mark</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FOLD_MARK_IN_PROGRESS</span> <span class="o">||</span>
						    <span class="n">rep_block</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block %d: incorrectly marked as first block in chain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							       <span class="n">block</span><span class="p">);</span>
							<span class="cm">/* the chain is incorrect : we must format it,</span>
<span class="cm">							   but we need to read it completely */</span>
							<span class="n">do_format_chain</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block %d: folding in progress - ignoring first block flag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							       <span class="n">block</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">chain_length</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rep_block</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* no more blocks after */</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rep_block</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block %d: referencing invalid block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">block</span><span class="p">,</span> <span class="n">rep_block</span><span class="p">);</span>
					<span class="n">do_format_chain</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">rep_block</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* same problem as previous &#39;is_first_block&#39; test:</span>
<span class="cm">					   we accept that the last block of a chain has</span>
<span class="cm">					   the first_block flag set if folding is in</span>
<span class="cm">					   progress. We handle here the case where the</span>
<span class="cm">					   last block appeared first */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">rep_block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span> <span class="o">&amp;&amp;</span>
					    <span class="n">s</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">first_logical_block</span><span class="p">]</span> <span class="o">==</span> <span class="n">rep_block</span> <span class="o">&amp;&amp;</span>
					    <span class="n">get_fold_mark</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">first_block</span><span class="p">)</span> <span class="o">==</span> <span class="n">FOLD_MARK_IN_PROGRESS</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* EUNtable[] will be set after */</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block %d: folding in progress - ignoring first block flag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						       <span class="n">rep_block</span><span class="p">);</span>
						<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">rep_block</span><span class="p">;</span>
						<span class="n">s</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">first_logical_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Block %d: referencing block %d already in another chain</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						       <span class="n">block</span><span class="p">,</span> <span class="n">rep_block</span><span class="p">);</span>
						<span class="cm">/* XXX: should handle correctly fold in progress chains */</span>
						<span class="n">do_format_chain</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
						<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* this is OK */</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">rep_block</span><span class="p">;</span>
					<span class="n">block</span> <span class="o">=</span> <span class="n">rep_block</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/* the chain was completely explored. Now we can decide</span>
<span class="cm">			   what to do with it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">do_format_chain</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* invalid chain : format it */</span>
				<span class="n">format_chain</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_block1</span><span class="p">,</span> <span class="n">chain_to_format</span><span class="p">,</span> <span class="n">chain_length1</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">fold_mark</span><span class="p">;</span>

				<span class="cm">/* valid chain : get foldmark */</span>
				<span class="n">fold_mark</span> <span class="o">=</span> <span class="n">get_fold_mark</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fold_mark</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* cannot get foldmark : format the chain */</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Could read foldmark at block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
					<span class="n">format_chain</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">fold_mark</span> <span class="o">==</span> <span class="n">FOLD_MARK_IN_PROGRESS</span><span class="p">)</span>
						<span class="n">check_sectors_in_chain</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>

					<span class="cm">/* now handle the case where we find two chains at the</span>
<span class="cm">					   same virtual address : we select the longer one,</span>
<span class="cm">					   because the shorter one is the one which was being</span>
<span class="cm">					   folded if the folding was not done in place */</span>
					<span class="n">first_block1</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">first_logical_block</span><span class="p">];</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">first_block1</span> <span class="o">!=</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* XXX: what to do if same length ? */</span>
						<span class="n">chain_length1</span> <span class="o">=</span> <span class="n">calc_chain_length</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">first_block1</span><span class="p">);</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Two chains at blocks %d (len=%d) and %d (len=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						       <span class="n">first_block1</span><span class="p">,</span> <span class="n">chain_length1</span><span class="p">,</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">chain_length</span><span class="p">);</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">chain_length</span> <span class="o">&gt;=</span> <span class="n">chain_length1</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">chain_to_format</span> <span class="o">=</span> <span class="n">first_block1</span><span class="p">;</span>
							<span class="n">s</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">first_logical_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="n">chain_to_format</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
						<span class="p">}</span>
						<span class="n">format_chain</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chain_to_format</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">s</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">first_logical_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="nl">examine_ReplUnitTable:</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* second pass to format unreferenced blocks  and init free block count */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">numfreeEUNs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">MediaHdr</span><span class="p">.</span><span class="n">FirstPhysicalEUN</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unreferenced block %d, formatting it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">NFTL_formatblock</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_FREE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">numfreeEUNs</span><span class="o">++</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
