<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › inftlmount.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inftlmount.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * inftlmount.c -- INFTL mount code with extensive checks.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Greg Ungerer (gerg@snapgear.com)</span>
<span class="cm"> * Copyright © 2002-2003, Greg Ungerer (gerg@snapgear.com)</span>
<span class="cm"> *</span>
<span class="cm"> * Based heavily on the nftlmount.c code which is:</span>
<span class="cm"> * Author: Fabrice Bellard (fabrice.bellard@netgem.com)</span>
<span class="cm"> * Copyright © 2000 Netgem S.A.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/errno.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nftl.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/inftl.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * find_boot_record: Find the INFTL Media Header and its Spare copy which</span>
<span class="cm"> *	contains the various device information of the INFTL partition and</span>
<span class="cm"> *	Bad Unit Table. Update the PUtable[] table according to the Bad</span>
<span class="cm"> *	Unit Table. PUtable[] is used for management of Erase Unit in</span>
<span class="cm"> *	other routines in inftlcore.c and inftlmount.c.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_boot_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLrecord</span> <span class="o">*</span><span class="n">inftl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inftl_unittail</span> <span class="n">h1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>struct inftl_oob oob;</p></td><td class="code"><div class="highlight"><pre>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="n">SECTORSIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">INFTLMediaHeader</span> <span class="o">*</span><span class="n">mh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">MediaHdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">INFTLPartition</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL: find_boot_record(inftl=%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inftl</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">	 * Assume logical EraseSize == physical erasesize for starting the</span>
<span class="cm">	 * scan. We&#39;ll sort it out later if we find a MediaHeader which says</span>
<span class="cm">	 * otherwise.</span>
<span class="cm">	 */</span>
	<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">;</span>
        <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>

	<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">MediaUnit</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

	<span class="cm">/* Search for a valid boot record */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for BNAND header first. Then whinge if it&#39;s found</span>
<span class="cm">		 * but later checks fail.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="n">SECTORSIZE</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="cm">/* We ignore ret in case the ECC of the MediaHeader is invalid</span>
<span class="cm">		   (which is apparently acceptable) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">SECTORSIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">int</span> <span class="n">warncount</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">warncount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: block read at 0x%x &quot;</span>
					<span class="s">&quot;of mtd%d failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">block</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span>
					<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">warncount</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: further &quot;</span>
						<span class="s">&quot;failures for this block will &quot;</span>
						<span class="s">&quot;not be printed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;BNAND&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* BNAND\0 not found. Continue */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* To be safer with BIOS, also use erase mark as discriminant */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">inftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span>
				     <span class="n">block</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
				     <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: ANAND header found at &quot;</span>
				<span class="s">&quot;0x%x in mtd%d, but OOB data read failed &quot;</span>
				<span class="s">&quot;(err %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span>
				<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="cm">/*</span>
<span class="cm">		 * This is the first we&#39;ve seen.</span>
<span class="cm">		 * Copy the media header structure into place.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLMediaHeader</span><span class="p">));</span>

		<span class="cm">/* Read the spare media header at offset 4096 */</span>
		<span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">SECTORSIZE</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">SECTORSIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: Unable to read spare &quot;</span>
			       <span class="s">&quot;Media Header</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Check if this one is the same as the first one we found. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">mh</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLMediaHeader</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: Primary and spare Media &quot;</span>
			       <span class="s">&quot;Headers disagree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBootImageBlocks</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBootImageBlocks</span><span class="p">);</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBinaryPartitions</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBinaryPartitions</span><span class="p">);</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span><span class="p">);</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">);</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">FormatFlags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">FormatFlags</span><span class="p">);</span>
		<span class="n">mh</span><span class="o">-&gt;</span><span class="n">PercentUsed</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">PercentUsed</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL: Media Header -&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    bootRecordID          = %s</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    NoOfBootImageBlocks   = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    NoOfBinaryPartitions  = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    NoOfBDTLPartitions    = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    BlockMultiplerBits    = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    FormatFlgs            = %d</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    OsakVersion           = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;    PercentUsed           = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">mh</span><span class="o">-&gt;</span><span class="n">bootRecordID</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBootImageBlocks</span><span class="p">,</span>
			 <span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBinaryPartitions</span><span class="p">,</span>
			 <span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span><span class="p">,</span>
			 <span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">FormatFlags</span><span class="p">,</span>
			 <span class="n">mh</span><span class="o">-&gt;</span><span class="n">OsakVersion</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">PercentUsed</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: Media Header sanity check &quot;</span>
				<span class="s">&quot;failed: NoOfBDTLPartitions (%d) == 0, &quot;</span>
				<span class="s">&quot;must be at least 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span> <span class="o">+</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBinaryPartitions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: Media Header sanity check &quot;</span>
				<span class="s">&quot;failed: Total Partitions (%d) &gt; 4, &quot;</span>
				<span class="s">&quot;BDTL=%d Binary=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span> <span class="o">+</span>
				<span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBinaryPartitions</span><span class="p">,</span>
				<span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBDTLPartitions</span><span class="p">,</span>
				<span class="n">mh</span><span class="o">-&gt;</span><span class="n">NoOfBinaryPartitions</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: sorry, we don&#39;t support &quot;</span>
				<span class="s">&quot;UnitSizeFactor 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: support for INFTL with &quot;</span>
				<span class="s">&quot;UnitSizeFactor 0x%02x is experimental</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">);</span>
			<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span> <span class="o">&lt;&lt;</span>
				<span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">;</span>
			<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">/</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>
			<span class="n">block</span> <span class="o">&gt;&gt;=</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">BlockMultiplierBits</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Scan the partitions */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mh</span><span class="o">-&gt;</span><span class="n">Partitions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">virtualUnits</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">virtualUnits</span><span class="p">);</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">);</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span><span class="p">);</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">spareUnits</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">spareUnits</span><span class="p">);</span>
			<span class="n">ip</span><span class="o">-&gt;</span><span class="n">Reserved0</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">Reserved0</span><span class="p">);</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    PARTITION[%d] -&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
				 <span class="s">&quot;        virtualUnits    = %d</span><span class="se">\n</span><span class="s">&quot;</span>
				 <span class="s">&quot;        firstUnit       = %d</span><span class="se">\n</span><span class="s">&quot;</span>
				 <span class="s">&quot;        lastUnit        = %d</span><span class="se">\n</span><span class="s">&quot;</span>
				 <span class="s">&quot;        flags           = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span>
				 <span class="s">&quot;        spareUnits      = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">i</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">virtualUnits</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">,</span>
				 <span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				 <span class="n">ip</span><span class="o">-&gt;</span><span class="n">spareUnits</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">Reserved0</span> <span class="o">!=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">instr</span><span class="p">;</span>

				<span class="n">instr</span><span class="o">-&gt;</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * 	Most likely this is using the</span>
<span class="cm">				 * 	undocumented qiuck mount feature.</span>
<span class="cm">				 * 	We don&#39;t support that, we will need</span>
<span class="cm">				 * 	to erase the hidden block for full</span>
<span class="cm">				 * 	compatibility.</span>
<span class="cm">				 */</span>
				<span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">Reserved0</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>
				<span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>
				<span class="n">mtd_erase</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">instr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span> <span class="o">-</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">virtualUnits</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: Media Header &quot;</span>
					<span class="s">&quot;Partition %d sanity check failed</span><span class="se">\n</span><span class="s">&quot;</span>
					<span class="s">&quot;    firstUnit %d : lastUnit %d  &gt;  &quot;</span>
					<span class="s">&quot;virtualUnits %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span><span class="p">,</span>
					<span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">Reserved0</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">Reserved1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: Media Header &quot;</span>
					<span class="s">&quot;Partition %d sanity check failed: &quot;</span>
					<span class="s">&quot;Reserved1 %d != 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">Reserved1</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INFTL_BDTL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: Media Header Partition &quot;</span>
				<span class="s">&quot;sanity check failed:</span><span class="se">\n</span><span class="s">       No partition &quot;</span>
				<span class="s">&quot;marked as Disk Partition</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">;</span>
		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">numvunits</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">virtualUnits</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">numvunits</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">-</span>
		    <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: Media Header sanity check &quot;</span>
				<span class="s">&quot;failed:</span><span class="se">\n</span><span class="s">        numvunits (%d) &gt; nb_blocks &quot;</span>
				<span class="s">&quot;(%d) - nb_boot_blocks(%d) - 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">numvunits</span><span class="p">,</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">,</span>
				<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span>  <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">numvunits</span> <span class="o">*</span>
			<span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="n">SECTORSIZE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Block count is set to last used EUN (we won&#39;t need to keep</span>
<span class="cm">		 * any meta-data past that point).</span>
<span class="cm">		 */</span>
		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">firstEUN</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">firstUnit</span><span class="p">;</span>
		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">lastEUN</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span><span class="p">;</span>
		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">lastUnit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Memory alloc */</span>
		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: allocation of PUtable &quot;</span>
				<span class="s">&quot;failed (%zd bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">VUtable</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">VUtable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: allocation of VUtable &quot;</span>
				<span class="s">&quot;failed (%zd bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Mark the blocks before INFTL MediaHeader as reserved */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
		<span class="cm">/* Mark all remaining blocks as potentially containing data */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">;</span>

		<span class="cm">/* Mark this boot record (NFTL MediaHeader) block as reserved */</span>
		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>

		<span class="cm">/* Read Bad Erase Unit Table and modify PUtable[] accordingly */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">physblock</span><span class="p">;</span>
			<span class="cm">/* If any of the physical eraseblocks are bad, don&#39;t</span>
<span class="cm">			   use the unit. */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">physblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">physblock</span> <span class="o">&lt;</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span> <span class="n">physblock</span> <span class="o">+=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mtd_block_isbad</span><span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">,</span>
						    <span class="n">i</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">physblock</span><span class="p">))</span>
					<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">MediaUnit</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Not found. */</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memcmpb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * check_free_sector: check if a free sector is actually FREE,</span>
<span class="cm"> *	i.e. All 0xff in data and oob area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_free_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLrecord</span> <span class="o">*</span><span class="n">inftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check_oob</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">SECTORSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">SECTORSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmpb</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">SECTORSIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">check_oob</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">inftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">SECTORSIZE</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmpb</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">SECTORSIZE</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">address</span> <span class="o">+=</span> <span class="n">SECTORSIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * INFTL_format: format a Erase Unit by erasing ALL Erase Zones in the Erase</span>
<span class="cm"> *		 Unit and Update INFTL metadata. Each erase operation is</span>
<span class="cm"> *		 checked with check_free_sectors.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: 0 when succeed, -1 on error.</span>
<span class="cm"> *</span>
<span class="cm"> * ToDo: 1. Is it necessary to check_free_sector after erasing ??</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">INFTL_formatblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLrecord</span> <span class="o">*</span><span class="n">inftl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inftl_unittail</span> <span class="n">uci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">erase_info</span> <span class="o">*</span><span class="n">instr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">instr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">physblock</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL: INFTL_formatblock(inftl=%p,block=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inftl</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">erase_info</span><span class="p">));</span>

	<span class="cm">/* FIXME: Shouldn&#39;t we be setting the &#39;discarded&#39; flag to zero</span>
<span class="cm">	   _first_? */</span>

	<span class="cm">/* Use async erase interface, test return code */</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">block</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">erasesize</span><span class="p">;</span>
	<span class="cm">/* Erase one physical eraseblock at a time, even though the NAND api</span>
<span class="cm">	   allows us to group them.  This way we if we have a failure, we can</span>
<span class="cm">	   mark only the failed block in the bbt. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">physblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">physblock</span> <span class="o">&lt;</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span>
	     <span class="n">physblock</span> <span class="o">+=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+=</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtd_erase</span><span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">,</span> <span class="n">instr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">instr</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">MTD_ERASE_FAILED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: error while formatting block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">block</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check the &quot;freeness&quot; of Erase Unit before updating metadata.</span>
<span class="cm">		 * FixMe: is this check really necessary? Since we have check</span>
<span class="cm">		 * the return code after the erase operation.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_free_sectors</span><span class="p">(</span><span class="n">inftl</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uci</span><span class="p">.</span><span class="n">EraseMark</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ERASE_MARK</span><span class="p">);</span>
	<span class="n">uci</span><span class="p">.</span><span class="n">EraseMark1</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ERASE_MARK</span><span class="p">);</span>
	<span class="n">uci</span><span class="p">.</span><span class="n">Reserved</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uci</span><span class="p">.</span><span class="n">Reserved</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uci</span><span class="p">.</span><span class="n">Reserved</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uci</span><span class="p">.</span><span class="n">Reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">block</span> <span class="o">*</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="n">SECTORSIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inftl_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="cm">/* could not format, update the bad block table (caller is responsible</span>
<span class="cm">	   for setting the PUtable to BLOCK_RESERVED on failure) */</span>
	<span class="n">mtd_block_markbad</span><span class="p">(</span><span class="n">inftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">,</span> <span class="n">instr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * format_chain: Format an invalid Virtual Unit chain. It frees all the Erase</span>
<span class="cm"> *	Units in a Virtual Unit Chain, i.e. all the units are disconnected.</span>
<span class="cm"> *</span>
<span class="cm"> *	Since the chain is invalid then we will have to erase it from its</span>
<span class="cm"> *	head (normally for INFTL we go from the oldest). But if it has a</span>
<span class="cm"> *	loop then there is no oldest...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">format_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLrecord</span> <span class="o">*</span><span class="n">inftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">block1</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: formatting chain at block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">first_block</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">block1</span> <span class="o">=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: formatting block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">INFTL_formatblock</span><span class="p">(</span><span class="n">inftl</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Cannot format !!!! Mark it as Bad Unit,</span>
<span class="cm">			 */</span>
			<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inftl</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_FREE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Goto next block on the chain */</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">block1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span> <span class="o">||</span> <span class="n">block</span> <span class="o">&gt;=</span> <span class="n">inftl</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">INFTL_dumptables</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLrecord</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;-------------------------------------------&quot;</span>
		<span class="s">&quot;----------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;VUtable[%d] -&gt;&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%04x: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%04x &quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">VUtable</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">-------------------------------------------&quot;</span>
		<span class="s">&quot;----------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PUtable[%d-%d=%d] -&gt;&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">firstEUN</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">%04x: &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%04x &quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">-------------------------------------------&quot;</span>
		<span class="s">&quot;----------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL -&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  EraseSize       = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  h/s/c           = %d/%d/%d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  numvunits       = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  firstEUN        = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  lastEUN         = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  numfreeEUNs     = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  LastFreeEUN     = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  nb_blocks       = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;  nb_boot_blocks  = %d&quot;</span><span class="p">,</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cylinders</span><span class="p">,</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">numvunits</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">firstEUN</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">numfreeEUNs</span><span class="p">,</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_boot_blocks</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">-------------------------------------------&quot;</span>
		<span class="s">&quot;----------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">INFTL_dumpVUchains</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLrecord</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">logical</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;-------------------------------------------&quot;</span>
		<span class="s">&quot;----------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL Virtual Unit Chains:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">logical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">logical</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">logical</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">VUtable</span><span class="p">[</span><span class="n">logical</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  LOGICAL %d --&gt; %d &quot;</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;-------------------------------------------&quot;</span>
		<span class="s">&quot;----------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">INFTL_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">INFTLrecord</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">prev_block</span><span class="p">,</span> <span class="n">last_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_logical_block</span><span class="p">,</span> <span class="n">logical_block</span><span class="p">,</span> <span class="n">erase_mark</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chain_length</span><span class="p">,</span> <span class="n">do_format_chain</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inftl_unithead1</span> <span class="n">h0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inftl_unittail</span> <span class="n">h1</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ANACtable</span><span class="p">,</span> <span class="n">ANAC</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL: INFTL_mount(inftl=%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="cm">/* Search for INFTL MediaHeader and Spare INFTL Media Header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_boot_record</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: could not find valid boot record?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init the logical to physical table */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">VUtable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

	<span class="n">logical_block</span> <span class="o">=</span> <span class="n">block</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

	<span class="cm">/* Temporary buffer to store ANAC numbers. */</span>
	<span class="n">ANACtable</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ANACtable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: allocation of ANACtable &quot;</span>
				<span class="s">&quot;failed (%zd bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * First pass is to explore each physical unit, and construct the</span>
<span class="cm">	 * virtual chains that exist (newest physical unit goes into VUtable).</span>
<span class="cm">	 * Any block that is in any way invalid will be left in the</span>
<span class="cm">	 * NOTEXPLORED state. Then at the end we will try to format it and</span>
<span class="cm">	 * mark it as free.</span>
<span class="cm">	 */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL: pass 1, explore each unit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">first_block</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">firstEUN</span><span class="p">;</span> <span class="n">first_block</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">;</span> <span class="n">first_block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">first_block</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">do_format_chain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">first_logical_block</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
		<span class="n">last_block</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">chain_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">chain_length</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">chain_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Nothing to do here, onto next block */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">inftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
					   <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
			    <span class="n">inftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">block</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span>
					   <span class="mi">2</span> <span class="o">*</span> <span class="n">SECTORSIZE</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">h1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Should never happen? */</span>
				<span class="n">do_format_chain</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">logical_block</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">h0</span><span class="p">.</span><span class="n">virtualUnitNo</span><span class="p">);</span>
			<span class="n">prev_block</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">h0</span><span class="p">.</span><span class="n">prevUnitNo</span><span class="p">);</span>
			<span class="n">erase_mark</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">((</span><span class="n">h1</span><span class="p">.</span><span class="n">EraseMark</span> <span class="o">|</span> <span class="n">h1</span><span class="p">.</span><span class="n">EraseMark1</span><span class="p">));</span>
			<span class="n">ANACtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">h0</span><span class="p">.</span><span class="n">ANAC</span><span class="p">;</span>

			<span class="cm">/* Previous block is relative to start of Partition */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev_block</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span>
				<span class="n">prev_block</span> <span class="o">+=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">firstEUN</span><span class="p">;</span>

			<span class="cm">/* Already explored partial chain? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Check if chain for this logical */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">logical_block</span> <span class="o">==</span> <span class="n">first_logical_block</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">!=</span> <span class="n">BLOCK_NIL</span><span class="p">)</span>
						<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">last_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Check for invalid block */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">erase_mark</span> <span class="o">!=</span> <span class="n">ERASE_MARK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: corrupt block %d &quot;</span>
					<span class="s">&quot;in chain %d, chain length %d, erase &quot;</span>
					<span class="s">&quot;mark 0x%x?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">first_block</span><span class="p">,</span>
					<span class="n">chain_length</span><span class="p">,</span> <span class="n">erase_mark</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Assume end of chain, probably incomplete</span>
<span class="cm">				 * fold/erase...</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chain_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">do_format_chain</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Check for it being free already then... */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">logical_block</span> <span class="o">==</span> <span class="n">BLOCK_FREE</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">logical_block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_FREE</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Sanity checks on block numbers */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">logical_block</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">((</span><span class="n">prev_block</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="p">(</span><span class="n">prev_block</span> <span class="o">!=</span> <span class="n">BLOCK_NIL</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">chain_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: corrupt &quot;</span>
						<span class="s">&quot;block %d in chain %d?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">block</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
					<span class="n">do_format_chain</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">first_logical_block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">first_logical_block</span> <span class="o">=</span> <span class="n">logical_block</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">first_logical_block</span> <span class="o">!=</span> <span class="n">logical_block</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Normal for folded chain... */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Current block is valid, so if we followed a virtual</span>
<span class="cm">			 * chain to get here then we can set the previous</span>
<span class="cm">			 * block pointer in our PUtable now. Then move onto</span>
<span class="cm">			 * the previous block in the chain.</span>
<span class="cm">			 */</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">!=</span> <span class="n">BLOCK_NIL</span><span class="p">)</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">last_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">last_block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">prev_block</span><span class="p">;</span>

			<span class="cm">/* Check for end of chain */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* Validate next block before following it... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: invalid previous &quot;</span>
					<span class="s">&quot;block %d in chain %d?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
					<span class="n">first_block</span><span class="p">);</span>
				<span class="n">do_format_chain</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_format_chain</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">format_chain</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Looks like a valid chain then. It may not really be the</span>
<span class="cm">		 * newest block in the chain, but it is the newest we have</span>
<span class="cm">		 * found so far. We might update it in later iterations of</span>
<span class="cm">		 * this loop if we find something newer.</span>
<span class="cm">		 */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">VUtable</span><span class="p">[</span><span class="n">first_logical_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
		<span class="n">logical_block</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INFTL_dumptables</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Second pass, check for infinite loops in chains. These are</span>
<span class="cm">	 * possible because we don&#39;t update the previous pointers when</span>
<span class="cm">	 * we fold chains. No big deal, just fix them up in PUtable.</span>
<span class="cm">	 */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL: pass 2, validate virtual chains</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">logical_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">logical_block</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">numvunits</span><span class="p">;</span> <span class="n">logical_block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">VUtable</span><span class="p">[</span><span class="n">logical_block</span><span class="p">];</span>
		<span class="n">last_block</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

		<span class="cm">/* Check for free/reserved/nil */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">BLOCK_RESERVED</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ANAC</span> <span class="o">=</span> <span class="n">ANACtable</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">numvunits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;INFTL: invalid prev %d, &quot;</span>
					<span class="s">&quot;in virtual chain %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">],</span> <span class="n">logical_block</span><span class="p">);</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ANACtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ANAC</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Chain must point back to itself. This is ok,</span>
<span class="cm">				 * but we will need adjust the tables with this</span>
<span class="cm">				 * newest block and oldest block.</span>
<span class="cm">				 */</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">VUtable</span><span class="p">[</span><span class="n">logical_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">last_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ANAC</span><span class="o">--</span><span class="p">;</span>
			<span class="n">last_block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">block</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Uhoo, infinite chain with valid ANACS!</span>
<span class="cm">			 * Format whole chain...</span>
<span class="cm">			 */</span>
			<span class="n">format_chain</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">INFTL_dumptables</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">INFTL_dumpVUchains</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Third pass, format unreferenced blocks and init free block count.</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">numfreeEUNs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;INFTL: pass 3, format unused blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">firstEUN</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_NOTEXPLORED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;INFTL: unreferenced block %d, formatting it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">block</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">INFTL_formatblock</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_FREE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">PUtable</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">numfreeEUNs</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ANACtable</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
