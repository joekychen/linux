<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › maps › dmv182.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dmv182.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/mtd/maps/dmv182.c</span>
<span class="cm"> *</span>
<span class="cm"> * Flash map driver for the Dy4 SVME182 board</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2003-2004, TimeSys Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Based on the SVME181 flash map, by Tom Nelson, Dot4, Inc. for TimeSys Corp.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/map.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/partitions.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This driver currently handles only the 16MiB user flash bank 1 on the</span>
<span class="cm"> * board.  It does not provide access to bank 0 (contains the Dy4 FFW), bank 2</span>
<span class="cm"> * (VxWorks boot), or the optional 48MiB expansion flash.</span>
<span class="cm"> *</span>
<span class="cm"> * scott.wood@timesys.com: On the newer boards with 128MiB flash, it</span>
<span class="cm"> * now supports the first 96MiB (the boot flash bank containing FFW</span>
<span class="cm"> * is excluded).  The VxWorks loader is in partition 1.</span>
<span class="cm"> */</span>

<span class="cp">#define FLASH_BASE_ADDR 0xf0000000</span>
<span class="cp">#define FLASH_BANK_SIZE (128*1024*1024)</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Scott Wood, TimeSys Corporation &lt;scott.wood@timesys.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;User-programmable flash device on the Dy4 SVME182 board&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">map_info</span> <span class="n">svme182_map</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;Dy4 SVME182&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bankwidth</span>	<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">size</span>		<span class="o">=</span>  <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="p">};</span>

<span class="cp">#define BOOTIMAGE_PART_SIZE		((6*1024*1024)-RESERVED_PART_SIZE)</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Allow 6MiB for the kernel</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define NEW_BOOTIMAGE_PART_SIZE  (6 * 1024 * 1024)</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Allow 1MiB for the bootloader</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define NEW_BOOTLOADER_PART_SIZE (1024 * 1024)</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Use the remaining 9MiB at the end of flash for the RFS</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define NEW_RFS_PART_SIZE        (0x01000000 - NEW_BOOTLOADER_PART_SIZE - \</span>
<span class="cp">                                  NEW_BOOTIMAGE_PART_SIZE)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_partition</span> <span class="n">svme182_partitions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>The Lower PABS is only 128KiB, but the partition code doesn't
like partitions that don't end on the largest erase block
size of the device, even if all of the erase blocks in the
partition are small ones.  The hardware should prevent
writes to the actual PABS areas.</p></td><td class="code"><div class="highlight"><pre>	<span class="p">{</span>
		<span class="nl">name:</span>       <span class="s">&quot;Lower PABS and CPU 0 bootloader or kernel&quot;</span><span class="p">,</span>
		<span class="nl">size:</span>       <span class="mi">6</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span>
		<span class="nl">offset:</span>     <span class="mi">0</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="nl">name:</span>       <span class="s">&quot;Root Filesystem&quot;</span><span class="p">,</span>
		<span class="nl">size:</span>       <span class="mi">10</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span>
		<span class="nl">offset:</span>     <span class="n">MTDPART_OFS_NXTBLK</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="nl">name:</span>       <span class="s">&quot;CPU1 Bootloader&quot;</span><span class="p">,</span>
		<span class="nl">size:</span>       <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span>
		<span class="nl">offset:</span>     <span class="n">MTDPART_OFS_NXTBLK</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="nl">name:</span>       <span class="s">&quot;Extra&quot;</span><span class="p">,</span>
		<span class="nl">size:</span>       <span class="mi">110</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span>
		<span class="nl">offset:</span>     <span class="n">MTDPART_OFS_NXTBLK</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="nl">name:</span>       <span class="s">&quot;Foundation Firmware and Upper PABS&quot;</span><span class="p">,</span>
		<span class="nl">size:</span>       <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span>
		<span class="nl">offset:</span>     <span class="n">MTDPART_OFS_NXTBLK</span><span class="p">,</span>
		<span class="nl">mask_flags:</span> <span class="n">MTD_WRITEABLE</span> <span class="c1">// read-only</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">this_mtd</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_svme182</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_partition</span> <span class="o">*</span><span class="n">partitions</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_parts</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">svme182_partitions</span><span class="p">);</span>

	<span class="n">partitions</span> <span class="o">=</span> <span class="n">svme182_partitions</span><span class="p">;</span>

	<span class="n">svme182_map</span><span class="p">.</span><span class="n">virt</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">FLASH_BASE_ADDR</span><span class="p">,</span> <span class="n">svme182_map</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">svme182_map</span><span class="p">.</span><span class="n">virt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Failed to ioremap FLASH memory area.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">simple_map_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">svme182_map</span><span class="p">);</span>

	<span class="n">this_mtd</span> <span class="o">=</span> <span class="n">do_map_probe</span><span class="p">(</span><span class="s">&quot;cfi_probe&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">svme182_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_mtd</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">svme182_map</span><span class="p">.</span><span class="n">virt</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;SVME182 flash device: %dMiB at 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">this_mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="n">FLASH_BASE_ADDR</span><span class="p">);</span>

	<span class="n">this_mtd</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">mtd_device_register</span><span class="p">(</span><span class="n">this_mtd</span><span class="p">,</span> <span class="n">partitions</span><span class="p">,</span> <span class="n">num_parts</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_svme182</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_mtd</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">mtd_device_unregister</span><span class="p">(</span><span class="n">this_mtd</span><span class="p">);</span>
		<span class="n">map_destroy</span><span class="p">(</span><span class="n">this_mtd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">svme182_map</span><span class="p">.</span><span class="n">virt</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">svme182_map</span><span class="p">.</span><span class="n">virt</span><span class="p">);</span>
		<span class="n">svme182_map</span><span class="p">.</span><span class="n">virt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_svme182</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_svme182</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
