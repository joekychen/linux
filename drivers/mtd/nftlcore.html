<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › mtd › nftlcore.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nftlcore.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux driver for NAND Flash Translation Layer</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 1999 Machine Vision Holdings, Inc.</span>
<span class="cm"> * Copyright © 1999-2010 David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#define PRERELEASE</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;asm/errno.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/hdreg.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>

<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nand.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/nftl.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/blktrans.h&gt;</span>

<span class="cm">/* maximum number of loops while examining next block, to have a</span>
<span class="cm">   chance to detect consistency problems (they should never happen</span>
<span class="cm">   because of the checks done in the mounting */</span>

<span class="cp">#define MAX_LOOPS 10000</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">nftl_add_mtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_blktrans_ops</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">MTD_NANDFLASH</span> <span class="o">||</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* OK, this is moderately ugly.  But probably safe.  Alternatives? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;DiskOnChip&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NFTL: add_mtd for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">nftl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nftl</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">mtd</span><span class="p">;</span>
	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">devnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">NFTL_mount</span><span class="p">(</span><span class="n">nftl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NFTL: could not mount device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nftl</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="cm">/* OK, it&#39;s a new one. Set up all the data structures. */</span>

	<span class="cm">/* Calculate geometry */</span>
	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">;</span>
	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span> <span class="o">%</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">;</span>
		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">temp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span> <span class="o">%</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span><span class="o">++</span><span class="p">;</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">;</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		  Oh no we don&#39;t have</span>
<span class="cm">		   mbd.size == heads * cylinders * sectors</span>
<span class="cm">		*/</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NFTL: cannot calculate a geometry to &quot;</span>
		       <span class="s">&quot;match size of 0x%lx.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NFTL: using C:%d H:%d S:%d &quot;</span>
			<span class="s">&quot;(== 0x%lx sects)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">cylinders</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">*</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">*</span>
			<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_mtd_blktrans_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nftl</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef PSYCHO_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NFTL: Found new nftl%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">devnum</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nftl_remove_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_blktrans_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NFTL: remove_dev (i=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>

	<span class="n">del_mtd_blktrans_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read oob data from flash</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nftl_read_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		  <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">ops</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">ooboffs</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">ooblen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">oobbuf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">datbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">mtd_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">offs</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>
	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">oobretlen</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write oob data to flash</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nftl_write_oob</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">ops</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">ooboffs</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">ooblen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">oobbuf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">datbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">mtd_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">offs</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>
	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">oobretlen</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NFTL_RW</span>

<span class="cm">/*</span>
<span class="cm"> * Write data and oob to flash</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nftl_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		      <span class="kt">size_t</span> <span class="o">*</span><span class="n">retlen</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">oob</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">writesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_oob_ops</span> <span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">ops</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MTD_OPS_PLACE_OOB</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">ooboffs</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">ooblen</span> <span class="o">=</span> <span class="n">mtd</span><span class="o">-&gt;</span><span class="n">oobsize</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">oobbuf</span> <span class="o">=</span> <span class="n">oob</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">datbuf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">ops</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">mtd_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">offs</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ops</span><span class="p">);</span>
	<span class="o">*</span><span class="n">retlen</span> <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">retlen</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Actual NFTL access routines */</span>
<span class="cm">/* NFTL_findfreeblock: Find a free Erase Unit on the NFTL partition. This function is used</span>
<span class="cm"> *	when the give Virtual Unit Chain</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">NFTL_findfreeblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">desperate</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* For a given Virtual Unit Chain: find or create a free block and</span>
<span class="cm">	   add it to the chain */</span>
	<span class="cm">/* We&#39;re passed the number of the last EUN in the chain, to save us from</span>
<span class="cm">	   having to look it up again */</span>
	<span class="n">u16</span> <span class="n">pot</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">silly</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">;</span>

	<span class="cm">/* Normally, we force a fold to happen before we run out of free blocks completely */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desperate</span> <span class="o">&amp;&amp;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">numfreeEUNs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NFTL_findfreeblock: there are too few free EUNs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Scan for a free block */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">pot</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span> <span class="o">=</span> <span class="n">pot</span><span class="p">;</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">numfreeEUNs</span><span class="o">--</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">pot</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* This will probably point to the MediaHdr unit itself,</span>
<span class="cm">		   right at the beginning of the partition. But that unit</span>
<span class="cm">		   (and the backup unit too) should have the UCI set</span>
<span class="cm">		   up so that it&#39;s not selected for overwriting */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pot</span> <span class="o">&gt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">)</span>
			<span class="n">pot</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">MediaHdr</span><span class="p">.</span><span class="n">FirstPhysicalEUN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silly</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Argh! No free blocks found! LastFreeEUN = %d, &quot;</span>
			       <span class="s">&quot;FirstEUN = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span><span class="p">,</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">MediaHdr</span><span class="p">.</span><span class="n">FirstPhysicalEUN</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pot</span> <span class="o">!=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">LastFreeEUN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">NFTL_foldchain</span> <span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">thisVUC</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pendingblock</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">BlockMap</span><span class="p">[</span><span class="n">MAX_SECTORS_PER_UNIT</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">BlockLastState</span><span class="p">[</span><span class="n">MAX_SECTORS_PER_UNIT</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">BlockFreeFound</span><span class="p">[</span><span class="n">MAX_SECTORS_PER_UNIT</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">thisEUN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">silly</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">targetEUN</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_oob</span> <span class="n">oob</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inplace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">BlockMap</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BlockMap</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">BlockFreeFound</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">BlockFreeFound</span><span class="p">));</span>

	<span class="n">thisEUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">thisVUC</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thisEUN</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Trying to fold non-existent &quot;</span>
		       <span class="s">&quot;Virtual Unit Chain %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">thisVUC</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Scan to find the Erase Unit which holds the actual data for each</span>
<span class="cm">	   512-byte block within the Chain.</span>
<span class="cm">	*/</span>
	<span class="n">silly</span> <span class="o">=</span> <span class="n">MAX_LOOPS</span><span class="p">;</span>
	<span class="n">targetEUN</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">thisEUN</span> <span class="o">&lt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">lastEUN</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">foldmark</span><span class="p">;</span>

		<span class="n">targetEUN</span> <span class="o">=</span> <span class="n">thisEUN</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">;</span> <span class="n">block</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">thisEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">)</span> <span class="o">+</span>
				      <span class="p">(</span><span class="n">block</span> <span class="o">*</span> <span class="mi">512</span><span class="p">),</span> <span class="mi">16</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">foldmark</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">FoldMark</span> <span class="o">|</span> <span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">FoldMark1</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">foldmark</span> <span class="o">==</span> <span class="n">FOLD_MARK_IN_PROGRESS</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Write Inhibited on EUN %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">thisEUN</span><span class="p">);</span>
					<span class="n">inplace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* There&#39;s no other reason not to do inplace,</span>
<span class="cm">					   except ones that come later. So we don&#39;t need</span>
<span class="cm">					   to preserve inplace */</span>
					<span class="n">inplace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">Status</span> <span class="o">|</span> <span class="n">oob</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">Status1</span><span class="p">;</span>
			<span class="n">BlockLastState</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

			<span class="k">switch</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SECTOR_FREE</span>:
				<span class="n">BlockFreeFound</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SECTOR_USED</span>:
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BlockFreeFound</span><span class="p">[</span><span class="n">block</span><span class="p">])</span>
					<span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisEUN</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
					       <span class="s">&quot;SECTOR_USED found after SECTOR_FREE &quot;</span>
					       <span class="s">&quot;in Virtual Unit Chain %d for block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">thisVUC</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SECTOR_DELETED</span>:
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BlockFreeFound</span><span class="p">[</span><span class="n">block</span><span class="p">])</span>
					<span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
					       <span class="s">&quot;SECTOR_DELETED found after SECTOR_FREE &quot;</span>
					       <span class="s">&quot;in Virtual Unit Chain %d for block %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">thisVUC</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SECTOR_IGNORE</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unknown status for block %d in EUN %d: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">block</span><span class="p">,</span> <span class="n">thisEUN</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silly</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Infinite loop in Virtual Unit Chain 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">thisVUC</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">thisEUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">thisEUN</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inplace</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We&#39;re being asked to be a fold-in-place. Check</span>
<span class="cm">		   that all blocks which actually have data associated</span>
<span class="cm">		   with them (i.e. BlockMap[block] != BLOCK_NIL) are</span>
<span class="cm">		   either already present or SECTOR_FREE in the target</span>
<span class="cm">		   block. If not, we&#39;re going to have to fold out-of-place</span>
<span class="cm">		   anyway.</span>
<span class="cm">		*/</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span> <span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">BlockLastState</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SECTOR_FREE</span> <span class="o">&amp;&amp;</span>
			    <span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BLOCK_NIL</span> <span class="o">&amp;&amp;</span>
			    <span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">!=</span> <span class="n">targetEUN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Setting inplace to 0. VUC %d, &quot;</span>
				      <span class="s">&quot;block %d was %x lastEUN, &quot;</span>
				      <span class="s">&quot;and is in EUN %d (%s) %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">thisVUC</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">BlockLastState</span><span class="p">[</span><span class="n">block</span><span class="p">],</span>
				      <span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">],</span>
				      <span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">==</span> <span class="n">targetEUN</span> <span class="o">?</span> <span class="s">&quot;==&quot;</span> <span class="o">:</span> <span class="s">&quot;!=&quot;</span><span class="p">,</span>
				      <span class="n">targetEUN</span><span class="p">);</span>
				<span class="n">inplace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pendingblock</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">thisVUC</span> <span class="o">*</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pendingblock</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">thisVUC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">BlockLastState</span><span class="p">[</span><span class="n">pendingblock</span> <span class="o">-</span> <span class="p">(</span><span class="n">thisVUC</span> <span class="o">*</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">))]</span> <span class="o">!=</span>
		    <span class="n">SECTOR_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Pending write not free in EUN %d. &quot;</span>
			      <span class="s">&quot;Folding out of place.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">targetEUN</span><span class="p">);</span>
			<span class="n">inplace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inplace</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Cannot fold Virtual Unit Chain %d in place. &quot;</span>
		      <span class="s">&quot;Trying out-of-place</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">thisVUC</span><span class="p">);</span>
		<span class="cm">/* We need to find a targetEUN to fold into. */</span>
		<span class="n">targetEUN</span> <span class="o">=</span> <span class="n">NFTL_findfreeblock</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">targetEUN</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Ouch. Now we&#39;re screwed. We need to do a</span>
<span class="cm">			   fold-in-place of another chain to make room</span>
<span class="cm">			   for this one. We need a better way of selecting</span>
<span class="cm">			   which chain to fold, because makefreeblock will</span>
<span class="cm">			   only ask us to fold the same one again.</span>
<span class="cm">			*/</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;NFTL_findfreeblock(desperate) returns 0xffff.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We put a fold mark in the chain we are folding only if we</span>
<span class="cm">               fold in place to help the mount check code. If we do not fold in</span>
<span class="cm">               place, it is possible to find the valid chain by selecting the</span>
<span class="cm">               longer one */</span>
		<span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">FoldMark</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">FoldMark1</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">FOLD_MARK_IN_PROGRESS</span><span class="p">);</span>
		<span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">unused</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
		<span class="n">nftl_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">*</span> <span class="n">targetEUN</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">512</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
			       <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* OK. We now know the location of every block in the Virtual Unit Chain,</span>
<span class="cm">	   and the Erase Unit into which we are supposed to be copying.</span>
<span class="cm">	   Go for it.</span>
<span class="cm">	*/</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Folding chain %d into unit %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">thisVUC</span><span class="p">,</span> <span class="n">targetEUN</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">block</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span> <span class="p">;</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">movebuf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* If it&#39;s in the target EUN already, or if it&#39;s pending write, do nothing */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">==</span> <span class="n">targetEUN</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">pendingblock</span> <span class="o">==</span> <span class="p">(</span><span class="n">thisVUC</span> <span class="o">*</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">)</span> <span class="o">+</span> <span class="n">block</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* copy only in non free block (free blocks can only</span>
<span class="cm">                   happen in case of media errors or deleted blocks) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">*</span> <span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">block</span> <span class="o">*</span> <span class="mi">512</span><span class="p">),</span>
			       <span class="mi">512</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span>
			       <span class="n">movebuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mtd_is_bitflip</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">*</span> <span class="n">BlockMap</span><span class="p">[</span><span class="n">block</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">block</span> <span class="o">*</span> <span class="mi">512</span><span class="p">),</span>
				       <span class="mi">512</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span>
				       <span class="n">movebuf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Error went away on retry.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nftl_oob</span><span class="p">));</span>
		<span class="n">oob</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">Status1</span> <span class="o">=</span> <span class="n">SECTOR_USED</span><span class="p">;</span>

		<span class="n">nftl_write</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">*</span> <span class="n">targetEUN</span><span class="p">)</span> <span class="o">+</span>
			   <span class="p">(</span><span class="n">block</span> <span class="o">*</span> <span class="mi">512</span><span class="p">),</span> <span class="mi">512</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">movebuf</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* add the header so that it is now a valid chain */</span>
	<span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">VirtUnitNum</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">SpareVirtUnitNum</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">thisVUC</span><span class="p">);</span>
	<span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">ReplUnitNum</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">SpareReplUnitNum</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

	<span class="n">nftl_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">*</span> <span class="n">targetEUN</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
		       <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">);</span>

	<span class="cm">/* OK. We&#39;ve moved the whole lot into the new block. Now we have to free the original blocks. */</span>

	<span class="cm">/* At this point, we have two different chains for this Virtual Unit, and no way to tell</span>
<span class="cm">	   them apart. If we crash now, we get confused. However, both contain the same data, so we</span>
<span class="cm">	   shouldn&#39;t actually lose data in this case. It&#39;s just that when we load up on a medium which</span>
<span class="cm">	   has duplicate chains, we need to free one of the chains because it&#39;s not necessary any more.</span>
<span class="cm">	*/</span>
	<span class="n">thisEUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">thisVUC</span><span class="p">];</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Want to erase</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* For each block in the old chain (except the targetEUN of course),</span>
<span class="cm">	   free it and make it available for future use */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">thisEUN</span> <span class="o">&lt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">lastEUN</span> <span class="o">&amp;&amp;</span> <span class="n">thisEUN</span> <span class="o">!=</span> <span class="n">targetEUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">EUNtmp</span><span class="p">;</span>

		<span class="n">EUNtmp</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">thisEUN</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">NFTL_formatblock</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="n">thisEUN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* could not erase : mark block as reserved</span>
<span class="cm">			 */</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">thisEUN</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_RESERVED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* correctly erased : mark it as free */</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">thisEUN</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_FREE</span><span class="p">;</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">numfreeEUNs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">thisEUN</span> <span class="o">=</span> <span class="n">EUNtmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make this the new start of chain for thisVUC */</span>
	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">targetEUN</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
	<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">thisVUC</span><span class="p">]</span> <span class="o">=</span> <span class="n">targetEUN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">targetEUN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">NFTL_makefreeblock</span><span class="p">(</span> <span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span> <span class="p">,</span> <span class="kt">unsigned</span> <span class="n">pendingblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is the part that needs some cleverness applied.</span>
<span class="cm">	   For now, I&#39;m doing the minimum applicable to actually</span>
<span class="cm">	   get the thing to work.</span>
<span class="cm">	   Wear-levelling and other clever stuff needs to be implemented</span>
<span class="cm">	   and we also need to do some assessment of the results when</span>
<span class="cm">	   the system loses power half-way through the routine.</span>
<span class="cm">	*/</span>
	<span class="n">u16</span> <span class="n">LongestChain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ChainLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">thislen</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">chain</span><span class="p">,</span> <span class="n">EUN</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">chain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chain</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">MediaHdr</span><span class="p">.</span><span class="n">FormattedSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">;</span> <span class="n">chain</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">EUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">chain</span><span class="p">];</span>
		<span class="n">thislen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">EUN</span> <span class="o">&lt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">thislen</span><span class="o">++</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>printk("VUC %d reaches len %d with EUN %d\n", chain, thislen, EUN);</p></td><td class="code"><div class="highlight"><pre>			<span class="n">EUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">EUN</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x7fff</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">thislen</span> <span class="o">&gt;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Endless loop in Virtual Chain %d: Unit %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">chain</span><span class="p">,</span> <span class="n">EUN</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">thislen</span> <span class="o">&gt;</span> <span class="mh">0xff10</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Actually, don&#39;t return failure. Just ignore this chain and</span>
<span class="cm">				   get on with it. */</span>
				<span class="n">thislen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">thislen</span> <span class="o">&gt;</span> <span class="n">ChainLength</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>printk("New longest chain is %d with length %d\n", chain, thislen);</p></td><td class="code"><div class="highlight"><pre>			<span class="n">ChainLength</span> <span class="o">=</span> <span class="n">thislen</span><span class="p">;</span>
			<span class="n">LongestChain</span> <span class="o">=</span> <span class="n">chain</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ChainLength</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;No Virtual Unit Chains available for folding. &quot;</span>
		       <span class="s">&quot;Failing request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NFTL_foldchain</span> <span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="n">LongestChain</span><span class="p">,</span> <span class="n">pendingblock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* NFTL_findwriteunit: Return the unit number into which we can write</span>
<span class="cm">                       for this block. Make it available if it isn&#39;t already</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">NFTL_findwriteunit</span><span class="p">(</span><span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">lastEUN</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">thisVUC</span> <span class="o">=</span> <span class="n">block</span> <span class="o">/</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">writeEUN</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blockofs</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">*</span> <span class="mi">512</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">silly</span><span class="p">,</span> <span class="n">silly2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_oob</span> <span class="n">oob</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Scan the media to find a unit in the VUC which has</span>
<span class="cm">		   a free space for the block in question.</span>
<span class="cm">		*/</span>

		<span class="cm">/* This condition catches the 0x[7f]fff cases, as well as</span>
<span class="cm">		   being a sanity check for past-end-of-media access</span>
<span class="cm">		*/</span>
		<span class="n">lastEUN</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
		<span class="n">writeEUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">thisVUC</span><span class="p">];</span>
		<span class="n">silly</span> <span class="o">=</span> <span class="n">MAX_LOOPS</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">writeEUN</span> <span class="o">&lt;=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">lastEUN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">nftl_bci</span> <span class="n">bci</span><span class="p">;</span>
			<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

			<span class="n">lastEUN</span> <span class="o">=</span> <span class="n">writeEUN</span><span class="p">;</span>

			<span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span>
				      <span class="p">(</span><span class="n">writeEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">blockofs</span><span class="p">,</span>
				      <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bci</span><span class="p">);</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Status of block %d in EUN %d is %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">block</span> <span class="p">,</span> <span class="n">writeEUN</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">bci</span><span class="p">.</span><span class="n">Status</span><span class="p">));</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">bci</span><span class="p">.</span><span class="n">Status</span> <span class="o">|</span> <span class="n">bci</span><span class="p">.</span><span class="n">Status1</span><span class="p">;</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SECTOR_FREE</span>:
				<span class="k">return</span> <span class="n">writeEUN</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">SECTOR_DELETED</span>:
			<span class="k">case</span> <span class="n">SECTOR_USED</span>:
			<span class="k">case</span> <span class="n">SECTOR_IGNORE</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Invalid block. Don't use it any more. Must implement.</p></td><td class="code"><div class="highlight"><pre>				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silly</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				       <span class="s">&quot;Infinite loop in Virtual Unit Chain 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">thisVUC</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Skip to next block in chain */</span>
			<span class="n">writeEUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">writeEUN</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="cm">/* OK. We didn&#39;t find one in the existing chain, or there</span>
<span class="cm">		   is no existing chain. */</span>

		<span class="cm">/* Try to find an already-free block */</span>
		<span class="n">writeEUN</span> <span class="o">=</span> <span class="n">NFTL_findfreeblock</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">writeEUN</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* That didn&#39;t work - there were no free blocks just</span>
<span class="cm">			   waiting to be picked up. We&#39;re going to have to fold</span>
<span class="cm">			   a chain to make room.</span>
<span class="cm">			*/</span>

			<span class="cm">/* First remember the start of this chain */</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>u16 startEUN = nftl->EUNtable[thisVUC];</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>printk("Write to VirtualUnitChain %d, calling makefreeblock()\n", thisVUC);</p></td><td class="code"><div class="highlight"><pre>			<span class="n">writeEUN</span> <span class="o">=</span> <span class="n">NFTL_makefreeblock</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="n">BLOCK_NIL</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">writeEUN</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* OK, we accept that the above comment is</span>
<span class="cm">				   lying - there may have been free blocks</span>
<span class="cm">				   last time we called NFTL_findfreeblock(),</span>
<span class="cm">				   but they are reserved for when we&#39;re</span>
<span class="cm">				   desperate. Well, now we&#39;re desperate.</span>
<span class="cm">				*/</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Using desperate==1 to find free EUN to accommodate write to VUC %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">thisVUC</span><span class="p">);</span>
				<span class="n">writeEUN</span> <span class="o">=</span> <span class="n">NFTL_findfreeblock</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">writeEUN</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Ouch. This should never happen - we should</span>
<span class="cm">				   always be able to make some room somehow.</span>
<span class="cm">				   If we get here, we&#39;ve allocated more storage</span>
<span class="cm">				   space than actual media, or our makefreeblock</span>
<span class="cm">				   routine is missing something.</span>
<span class="cm">				*/</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Cannot make free space.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>printk("Restarting scan\n");</p></td><td class="code"><div class="highlight"><pre>			<span class="n">lastEUN</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We&#39;ve found a free block. Insert it into the chain. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lastEUN</span> <span class="o">!=</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">thisVUC</span> <span class="o">|=</span> <span class="mh">0x8000</span><span class="p">;</span> <span class="cm">/* It&#39;s a replacement block */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* The first block in a new chain */</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">thisVUC</span><span class="p">]</span> <span class="o">=</span> <span class="n">writeEUN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* set up the actual EUN we&#39;re writing into */</span>
		<span class="cm">/* Both in our cache... */</span>
		<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">writeEUN</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

		<span class="cm">/* ... and on the flash itself */</span>
		<span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">writeEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">);</span>

		<span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">VirtUnitNum</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">SpareVirtUnitNum</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">thisVUC</span><span class="p">);</span>

		<span class="n">nftl_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">writeEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">);</span>

		<span class="cm">/* we link the new block to the chain only after the</span>
<span class="cm">                   block is ready. It avoids the case where the chain</span>
<span class="cm">                   could point to a free block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastEUN</span> <span class="o">!=</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Both in our cache... */</span>
			<span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">lastEUN</span><span class="p">]</span> <span class="o">=</span> <span class="n">writeEUN</span><span class="p">;</span>
			<span class="cm">/* ... and on the flash itself */</span>
			<span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">lastEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
				      <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">);</span>

			<span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">ReplUnitNum</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">SpareReplUnitNum</span>
				<span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">writeEUN</span><span class="p">);</span>

			<span class="n">nftl_write_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">lastEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span>
				       <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">.</span><span class="n">u</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">writeEUN</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">silly2</span><span class="o">--</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Error folding to make room for Virtual Unit Chain 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">thisVUC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nftl_writeblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_blktrans_dev</span> <span class="o">*</span><span class="n">mbd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mbd</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">writeEUN</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blockofs</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">*</span> <span class="mi">512</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_oob</span> <span class="n">oob</span><span class="p">;</span>

	<span class="n">writeEUN</span> <span class="o">=</span> <span class="n">NFTL_findwriteunit</span><span class="p">(</span><span class="n">nftl</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writeEUN</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;NFTL_writeblock(): Cannot find block to write to</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* If we _still_ haven&#39;t got a block to use, we&#39;re screwed */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nftl_oob</span><span class="p">));</span>
	<span class="n">oob</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">oob</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">Status1</span> <span class="o">=</span> <span class="n">SECTOR_USED</span><span class="p">;</span>

	<span class="n">nftl_write</span><span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">writeEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">blockofs</span><span class="p">,</span>
		   <span class="mi">512</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">oob</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NFTL_RW */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nftl_readblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_blktrans_dev</span> <span class="o">*</span><span class="n">mbd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mbd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">mtd</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">mbd</span><span class="p">.</span><span class="n">mtd</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">lastgoodEUN</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">thisEUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EUNtable</span><span class="p">[</span><span class="n">block</span> <span class="o">/</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blockofs</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">*</span> <span class="mi">512</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">silly</span> <span class="o">=</span> <span class="n">MAX_LOOPS</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nftl_bci</span> <span class="n">bci</span><span class="p">;</span>

	<span class="n">lastgoodEUN</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thisEUN</span> <span class="o">!=</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">thisEUN</span> <span class="o">&lt;</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">nb_blocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nftl_read_oob</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="p">(</span><span class="n">thisEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">)</span> <span class="o">+</span>
					  <span class="n">blockofs</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bci</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">SECTOR_IGNORE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">bci</span><span class="p">.</span><span class="n">Status</span> <span class="o">|</span> <span class="n">bci</span><span class="p">.</span><span class="n">Status1</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SECTOR_FREE</span>:
				<span class="cm">/* no modification of a sector should follow a free sector */</span>
				<span class="k">goto</span> <span class="n">the_end</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SECTOR_DELETED</span>:
				<span class="n">lastgoodEUN</span> <span class="o">=</span> <span class="n">BLOCK_NIL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SECTOR_USED</span>:
				<span class="n">lastgoodEUN</span> <span class="o">=</span> <span class="n">thisEUN</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SECTOR_IGNORE</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unknown status for block %ld in EUN %d: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">block</span><span class="p">,</span> <span class="n">thisEUN</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silly</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Infinite loop in Virtual Unit Chain 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">block</span> <span class="o">/</span> <span class="p">(</span><span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span> <span class="o">/</span> <span class="mi">512</span><span class="p">));</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">thisEUN</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">ReplUnitTable</span><span class="p">[</span><span class="n">thisEUN</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">the_end:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastgoodEUN</span> <span class="o">==</span> <span class="n">BLOCK_NIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the requested block is not on the media, return all 0x00 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">lastgoodEUN</span> <span class="o">*</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">EraseSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">blockofs</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">mtd_read</span><span class="p">(</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mtd_is_bitflip</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nftl_getgeo</span><span class="p">(</span><span class="k">struct</span> <span class="n">mtd_blktrans_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="n">geo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">NFTLrecord</span> <span class="o">*</span><span class="n">nftl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">heads</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">;</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">;</span>
	<span class="n">geo</span><span class="o">-&gt;</span><span class="n">cylinders</span> <span class="o">=</span> <span class="n">nftl</span><span class="o">-&gt;</span><span class="n">cylinders</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Module stuff</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">mtd_blktrans_ops</span> <span class="n">nftl_tr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;nftl&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">major</span>		<span class="o">=</span> <span class="n">NFTL_MAJOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">part_bits</span>	<span class="o">=</span> <span class="n">NFTL_PARTN_BITS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">blksize</span> 	<span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getgeo</span>		<span class="o">=</span> <span class="n">nftl_getgeo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readsect</span>	<span class="o">=</span> <span class="n">nftl_readblock</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NFTL_RW</span>
	<span class="p">.</span><span class="n">writesect</span>	<span class="o">=</span> <span class="n">nftl_writeblock</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">add_mtd</span>	<span class="o">=</span> <span class="n">nftl_add_mtd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove_dev</span>	<span class="o">=</span> <span class="n">nftl_remove_dev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_nftl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_mtd_blktrans</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nftl_tr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cleanup_nftl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">deregister_mtd_blktrans</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nftl_tr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_nftl</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_nftl</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;David Woodhouse &lt;dwmw2@infradead.org&gt;, Fabrice Bellard &lt;fabrice.bellard@netgem.com&gt; et al.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Support code for NAND Flash Translation Layer, used on M-Systems DiskOnChip 2000 and Millennium&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_BLOCKDEV_MAJOR</span><span class="p">(</span><span class="n">NFTL_MAJOR</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
