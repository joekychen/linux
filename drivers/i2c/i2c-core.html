<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › i2c › i2c-core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>i2c-core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* i2c-core.c - a device driver for the iic-bus interface		     */</span>
<span class="cm">/* ------------------------------------------------------------------------- */</span>
<span class="cm">/*   Copyright (C) 1995-99 Simon G. Vogl</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,</span>
<span class="cm">    MA 02110-1301 USA.							     */</span>
<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="cm">/* With some changes from Kyösti Mälkki &lt;kmalkki@cc.hut.fi&gt;.</span>
<span class="cm">   All SMBus-related things are written by Frodo Looijaard &lt;frodol@dds.nl&gt;</span>
<span class="cm">   SMBus 2.0 support by Mark Studebaker &lt;mdsxyz123@yahoo.com&gt; and</span>
<span class="cm">   Jean Delvare &lt;khali@linux-fr.org&gt;</span>
<span class="cm">   Mux support by Rodolfo Giometti &lt;giometti@enneenne.com&gt; and</span>
<span class="cm">   Michael Lawnick &lt;michael.lawnick.ext@nsn.com&gt; */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/of_device.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/irqflags.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &quot;i2c-core.h&quot;</span>


<span class="cm">/* core_lock protects i2c_adapter_idr, and guarantees</span>
<span class="cm">   that device detection, deletion of detected devices, and attach_adapter</span>
<span class="cm">   and detach_adapter calls are serialized */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">core_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_IDR</span><span class="p">(</span><span class="n">i2c_adapter_idr</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">i2c_client_type</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">i2c_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">);</span>

<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="nf">i2c_match_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
		<span class="n">id</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Attempt an OF style match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_driver_match_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">drv</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">driver</span> <span class="o">=</span> <span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="cm">/* match on an id table if there is one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i2c_match_id</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span> <span class="n">client</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef	CONFIG_HOTPLUG</span>

<span class="cm">/* uevent helps with hotplug: modprobe -q $(MODALIAS) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">to_i2c_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;MODALIAS=%s%s&quot;</span><span class="p">,</span>
			   <span class="n">I2C_MODULE_PREFIX</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;uevent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define i2c_device_uevent	NULL</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_HOTPLUG */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">driver</span> <span class="o">=</span> <span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">probe</span> <span class="o">||</span> <span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device_can_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">device_init_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_CLIENT_WAKE</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;probe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">i2c_match_id</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span> <span class="n">client</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">i2c_set_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_driver</span>	<span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">driver</span> <span class="o">=</span> <span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;remove</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">i2c_set_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2c_device_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">driver</span> <span class="o">=</span> <span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_legacy_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">driver</span> <span class="o">=</span> <span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">mesg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_legacy_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">driver</span> <span class="o">=</span> <span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_pm_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">i2c_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_pm_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">i2c_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_pm_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_freeze</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">i2c_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_FREEZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_pm_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_thaw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">i2c_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_pm_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_poweroff</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">i2c_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_HIBERNATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_device_pm_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pm_generic_restore</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">i2c_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>
<span class="cp">#define i2c_device_pm_suspend	NULL</span>
<span class="cp">#define i2c_device_pm_resume	NULL</span>
<span class="cp">#define i2c_device_pm_freeze	NULL</span>
<span class="cp">#define i2c_device_pm_thaw	NULL</span>
<span class="cp">#define i2c_device_pm_poweroff	NULL</span>
<span class="cp">#define i2c_device_pm_restore	NULL</span>
<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2c_client_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">to_i2c_client</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">i2c_client_type</span> <span class="o">?</span>
		       <span class="n">to_i2c_client</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">show_modalias</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">to_i2c_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">I2C_MODULE_PREFIX</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">show_name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">modalias</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">show_modalias</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">i2c_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_name</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="cm">/* modalias helps coldplug:  modprobe $(cat .../modalias) */</span>
	<span class="o">&amp;</span><span class="n">dev_attr_modalias</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">i2c_dev_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span>		<span class="o">=</span> <span class="n">i2c_dev_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">i2c_dev_attr_groups</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">i2c_dev_attr_group</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">i2c_device_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">i2c_device_pm_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">i2c_device_pm_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="n">i2c_device_pm_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">i2c_device_pm_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poweroff</span> <span class="o">=</span> <span class="n">i2c_device_pm_poweroff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">i2c_device_pm_restore</span><span class="p">,</span>
	<span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span>
		<span class="n">pm_generic_runtime_suspend</span><span class="p">,</span>
		<span class="n">pm_generic_runtime_resume</span><span class="p">,</span>
		<span class="n">pm_generic_runtime_idle</span>
	<span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">i2c_bus_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;i2c&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span>		<span class="o">=</span> <span class="n">i2c_device_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">i2c_device_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">i2c_device_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">i2c_device_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pm</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">i2c_device_pm_ops</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_bus_type</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">i2c_client_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">groups</span>		<span class="o">=</span> <span class="n">i2c_dev_attr_groups</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span>		<span class="o">=</span> <span class="n">i2c_device_uevent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">i2c_client_dev_release</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * i2c_verify_client - return parameter as i2c_client, or NULL</span>
<span class="cm"> * @dev: device, probably from some driver model iterator</span>
<span class="cm"> *</span>
<span class="cm"> * When traversing the driver model tree, perhaps using driver model</span>
<span class="cm"> * iterators like @device_for_each_child(), you can&#39;t assume very much</span>
<span class="cm"> * about the nodes you find.  Use this function to avoid oopses caused</span>
<span class="cm"> * by wrongly treating some non-I2C device as an i2c_client.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="nf">i2c_verify_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">i2c_client_type</span><span class="p">)</span>
			<span class="o">?</span> <span class="n">to_i2c_client</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
			<span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_verify_client</span><span class="p">);</span>


<span class="cm">/* This is a permissive address validity check, I2C address map constraints</span>
<span class="cm"> * are purposely not enforced, except for the general call address. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_check_client_addr_validity</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_CLIENT_TEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 10-bit address, all values are valid */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="mh">0x3ff</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 7-bit address, reject the general call address */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="mh">0x00</span> <span class="o">||</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&gt;</span> <span class="mh">0x7f</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* And this is a strict address validity check, used when probing. If a</span>
<span class="cm"> * device uses a reserved address, then it shouldn&#39;t be probed. 7-bit</span>
<span class="cm"> * addressing is assumed, 10-bit address devices are rare and should be</span>
<span class="cm"> * explicitly enumerated. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_check_addr_validity</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Reserved addresses per I2C specification:</span>
<span class="cm">	 *  0x00       General call address / START byte</span>
<span class="cm">	 *  0x01       CBUS address</span>
<span class="cm">	 *  0x02       Reserved for different bus format</span>
<span class="cm">	 *  0x03       Reserved for future purposes</span>
<span class="cm">	 *  0x04-0x07  Hs-mode master code</span>
<span class="cm">	 *  0x78-0x7b  10-bit slave addressing</span>
<span class="cm">	 *  0x7c-0x7f  Reserved for future purposes</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="mh">0x08</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;</span> <span class="mh">0x77</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__i2c_check_addr_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">addrp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">client</span> <span class="o">&amp;&amp;</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* walk up mux tree */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_check_mux_parents</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i2c_parent_is_i2c_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span>
					<span class="n">__i2c_check_addr_busy</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2c_check_mux_parents</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* recurse down mux tree */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_check_mux_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addrp</span><span class="p">,</span>
						<span class="n">i2c_check_mux_children</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__i2c_check_addr_busy</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addrp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_check_addr_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i2c_parent_is_i2c_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2c_check_mux_parents</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span>
						<span class="n">i2c_check_mux_children</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_lock_adapter - Get exclusive access to an I2C bus segment</span>
<span class="cm"> * @adapter: Target I2C bus segment</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2c_lock_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i2c_parent_is_i2c_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">i2c_lock_adapter</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rt_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bus_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_lock_adapter</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_trylock_adapter - Try to get exclusive access to an I2C bus segment</span>
<span class="cm"> * @adapter: Target I2C bus segment</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_trylock_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i2c_parent_is_i2c_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i2c_trylock_adapter</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">rt_mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bus_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_unlock_adapter - Release exclusive access to an I2C bus segment</span>
<span class="cm"> * @adapter: Target I2C bus segment</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2c_unlock_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i2c_parent_is_i2c_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">i2c_unlock_adapter</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rt_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bus_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_unlock_adapter</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_new_device - instantiate an i2c device</span>
<span class="cm"> * @adap: the adapter managing the device</span>
<span class="cm"> * @info: describes one I2C device; bus_num is ignored</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * Create an i2c device. Binding is handled through driver model</span>
<span class="cm"> * probe()/remove() methods.  A driver may be bound to this device when we</span>
<span class="cm"> * return from this function, or any later moment (e.g. maybe hotplugging will</span>
<span class="cm"> * load the driver module).  This call is not appropriate for use by mainboard</span>
<span class="cm"> * initialization logic, which usually runs during an arch_initcall() long</span>
<span class="cm"> * before any i2c_adapter could exist.</span>
<span class="cm"> *</span>
<span class="cm"> * This returns the new i2c client, which may be saved for later use with</span>
<span class="cm"> * i2c_unregister_device(); or NULL to indicate an error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span>
<span class="nf">i2c_new_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="k">const</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">client</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">client</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adap</span><span class="p">;</span>

	<span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">)</span>
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">archdata</span> <span class="o">=</span> <span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">archdata</span><span class="p">;</span>

	<span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>

	<span class="cm">/* Check for address validity */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_check_client_addr_validity</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid %d-bit I2C address 0x%02hx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_CLIENT_TEN</span> <span class="o">?</span> <span class="mi">10</span> <span class="o">:</span> <span class="mi">7</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err_silent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for address business */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_check_addr_busy</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2c_client_type</span><span class="p">;</span>
	<span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">;</span>

	<span class="cm">/* For 10-bit clients, add an arbitrary offset to avoid collisions */</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%d-%04x&quot;</span><span class="p">,</span> <span class="n">i2c_adapter_id</span><span class="p">(</span><span class="n">adap</span><span class="p">),</span>
		     <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">|</span> <span class="p">((</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_CLIENT_TEN</span><span class="p">)</span>
				     <span class="o">?</span> <span class="mh">0xa000</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;client [%s] registered with bus id %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">client</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to register i2c client %s at 0x%02x &quot;</span>
		<span class="s">&quot;(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="nl">out_err_silent:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_new_device</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * i2c_unregister_device - reverse effect of i2c_new_device()</span>
<span class="cm"> * @client: value returned from i2c_new_device()</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2c_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_unregister_device</span><span class="p">);</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="n">dummy_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;dummy&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="n">dummy_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;dummy&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">dummy_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">dummy_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">dummy_id</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_new_dummy - return a new i2c device bound to a dummy driver</span>
<span class="cm"> * @adapter: the adapter managing the device</span>
<span class="cm"> * @address: seven bit address to be used</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This returns an I2C client bound to the &quot;dummy&quot; driver, intended for use</span>
<span class="cm"> * with devices that consume multiple addresses.  Examples of such chips</span>
<span class="cm"> * include various EEPROMS (like 24c04 and 24c08 models).</span>
<span class="cm"> *</span>
<span class="cm"> * These dummy devices have two main uses.  First, most I2C and SMBus calls</span>
<span class="cm"> * except i2c_transfer() need a client handle; the dummy will be that handle.</span>
<span class="cm"> * And second, this prevents the specified address from being bound to a</span>
<span class="cm"> * different driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This returns the new i2c client, which should be saved for later use with</span>
<span class="cm"> * i2c_unregister_device(); or NULL to indicate an error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="nf">i2c_new_dummy</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u16</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">I2C_BOARD_INFO</span><span class="p">(</span><span class="s">&quot;dummy&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">i2c_new_device</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_new_dummy</span><span class="p">);</span>

<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="cm">/* I2C bus adapters -- one roots each I2C or SMBUS segment */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2c_adapter_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev_released</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Let users instantiate I2C devices through sysfs. This can be used when</span>
<span class="cm"> * platform initialization code doesn&#39;t contain the proper data for</span>
<span class="cm"> * whatever reason. Also useful for drivers that do device detection and</span>
<span class="cm"> * detection fails, either because the device uses an unexpected address,</span>
<span class="cm"> * or this is a compatible device with different ID register values.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameter checking may look overzealous, but we really don&#39;t want</span>
<span class="cm"> * the user to provide incorrect parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">i2c_sysfs_new_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">blank</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_board_info</span><span class="p">));</span>

	<span class="n">blank</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blank</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Missing parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;new_device&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blank</span> <span class="o">-</span> <span class="n">buf</span> <span class="o">&gt;</span> <span class="n">I2C_NAME_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Invalid device name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;new_device&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">blank</span> <span class="o">-</span> <span class="n">buf</span><span class="p">);</span>

	<span class="cm">/* Parse remaining parameters, reject extra parameters */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="o">++</span><span class="n">blank</span><span class="p">,</span> <span class="s">&quot;%hi%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Can&#39;t parse I2C address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;new_device&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="mi">1</span>  <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Extra parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;new_device&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">client</span> <span class="o">=</span> <span class="n">i2c_new_device</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Keep track of the added device */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">detected</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients_lock</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Instantiated device %s at 0x%02hx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;new_device&quot;</span><span class="p">,</span>
		 <span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * And of course let the users delete the devices they instantiated, if</span>
<span class="cm"> * they got it wrong. This interface can only be used to delete devices</span>
<span class="cm"> * instantiated by i2c_sysfs_new_device above. This guarantees that we</span>
<span class="cm"> * don&#39;t delete devices to which some kernel code still has references.</span>
<span class="cm"> *</span>
<span class="cm"> * Parameter checking may look overzealous, but we really don&#39;t want</span>
<span class="cm"> * the user to delete the wrong device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">i2c_sysfs_delete_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Parse parameters, reject extra parameters */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%hi%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Can&#39;t parse I2C address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;delete_device&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="mi">1</span>  <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Extra parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;delete_device&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure the device was added through sysfs */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients</span><span class="p">,</span>
				 <span class="n">detected</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Deleting device %s at 0x%02hx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="s">&quot;delete_device&quot;</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">detected</span><span class="p">);</span>
			<span class="n">i2c_unregister_device</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Can&#39;t find device in list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="s">&quot;delete_device&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">new_device</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i2c_sysfs_new_device</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">delete_device</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i2c_sysfs_delete_device</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">i2c_adapter_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_name</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_new_device</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_delete_device</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">i2c_adapter_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span>		<span class="o">=</span> <span class="n">i2c_adapter_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">i2c_adapter_attr_groups</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">i2c_adapter_attr_group</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device_type</span> <span class="n">i2c_adapter_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">groups</span>		<span class="o">=</span> <span class="n">i2c_adapter_attr_groups</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">i2c_adapter_dev_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_adapter_type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_verify_adapter - return parameter as i2c_adapter or NULL</span>
<span class="cm"> * @dev: device, probably from some driver model iterator</span>
<span class="cm"> *</span>
<span class="cm"> * When traversing the driver model tree, perhaps using driver model</span>
<span class="cm"> * iterators like @device_for_each_child(), you can&#39;t assume very much</span>
<span class="cm"> * about the nodes you find.  Use this function to avoid oopses caused</span>
<span class="cm"> * by wrongly treating some non-I2C device as an i2c_adapter.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="nf">i2c_verify_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">)</span>
			<span class="o">?</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>
			<span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_verify_adapter</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_I2C_COMPAT</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">class_compat</span> <span class="o">*</span><span class="n">i2c_adapter_compat_class</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2c_scan_static_board_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_devinfo</span>	<span class="o">*</span><span class="n">devinfo</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__i2c_board_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">devinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__i2c_board_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">busnum</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nr</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i2c_new_device</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">board_info</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Can&#39;t create device at 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">board_info</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__i2c_board_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_do_add_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Detect supported devices on that bus, and instantiate them */</span>
	<span class="n">i2c_detect</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

	<span class="cm">/* Let legacy drivers scan this bus for matching devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">attach_adapter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: attach_adapter method is deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Please use another way to instantiate &quot;</span>
			 <span class="s">&quot;your i2c_client</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* We ignore the return code; if it fails, too bad */</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">attach_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__process_new_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2c_do_add_adapter</span><span class="p">(</span><span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_register_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Can&#39;t register until after driver model init */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">i2c_bus_type</span><span class="p">.</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_list</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Sanity checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;i2c-core: Attempt to register an adapter with &quot;</span>
		       <span class="s">&quot;no name!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;i2c-core: Attempt to register adapter &#39;%s&#39; with &quot;</span>
		       <span class="s">&quot;no algo!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rt_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">bus_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients</span><span class="p">);</span>

	<span class="cm">/* Set default timeout to 1 second if not already set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">adap</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;i2c-%d&quot;</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">;</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_list</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;adapter [%s] registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_I2C_COMPAT</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">class_compat_create_link</span><span class="p">(</span><span class="n">i2c_adapter_compat_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				       <span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;Failed to create compatibility class link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* create pre-declared device nodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">__i2c_first_dynamic_bus_num</span><span class="p">)</span>
		<span class="n">i2c_scan_static_board_info</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>

	<span class="cm">/* Notify drivers */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="n">bus_for_each_drv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">adap</span><span class="p">,</span> <span class="n">__process_new_adapter</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_list:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_add_adapter - declare i2c adapter, use dynamic bus number</span>
<span class="cm"> * @adapter: the adapter to add</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to declare an I2C adapter when its bus number</span>
<span class="cm"> * doesn&#39;t matter.  Examples: for I2C adapters dynamically added by</span>
<span class="cm"> * USB links or PCI plugin cards.</span>
<span class="cm"> *</span>
<span class="cm"> * When this returns zero, a new bus number was allocated and stored</span>
<span class="cm"> * in adap-&gt;nr, and the specified adapter became available for clients.</span>
<span class="cm"> * Otherwise, a negative errno value is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2c_add_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">id</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="cm">/* &quot;above&quot; here means &quot;above or equal to&quot;, sigh */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">adapter</span><span class="p">,</span>
				<span class="n">__i2c_first_dynamic_bus_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i2c_register_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_add_adapter</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_add_numbered_adapter - declare i2c adapter, use static bus number</span>
<span class="cm"> * @adap: the adapter to register (with adap-&gt;nr initialized)</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to declare an I2C adapter when its bus number</span>
<span class="cm"> * matters.  For example, use it for I2C adapters from system-on-chip CPUs,</span>
<span class="cm"> * or otherwise built in to the system&#39;s mainboard, and where i2c_board_info</span>
<span class="cm"> * is used to properly configure I2C devices.</span>
<span class="cm"> *</span>
<span class="cm"> * If the requested bus number is set to -1, then this function will behave</span>
<span class="cm"> * identically to i2c_add_adapter, and will dynamically assign a bus number.</span>
<span class="cm"> *</span>
<span class="cm"> * If no devices have pre-been declared for this bus, then be sure to</span>
<span class="cm"> * register the adapter before any dynamically allocated ones.  Otherwise</span>
<span class="cm"> * the required bus ID may not be available.</span>
<span class="cm"> *</span>
<span class="cm"> * When this returns zero, the specified adapter became available for</span>
<span class="cm"> * clients using the bus number provided in adap-&gt;nr.  Also, the table</span>
<span class="cm"> * of I2C devices pre-declared using i2c_register_board_info() is scanned,</span>
<span class="cm"> * and the appropriate driver model device nodes are created.  Otherwise, a</span>
<span class="cm"> * negative errno value is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2c_add_numbered_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="cm">/* -1 means dynamically assign bus id */</span>
		<span class="k">return</span> <span class="n">i2c_add_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAX_ID_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="cm">/* &quot;above&quot; here means &quot;above or equal to&quot;, sigh;</span>
<span class="cm">	 * we need the &quot;equal to&quot; result to force the result</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">adap</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">!=</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_register_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_add_numbered_adapter</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_do_del_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="o">*</span><span class="n">_n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Remove the devices we created ourselves as the result of hardware</span>
<span class="cm">	 * probing (using a driver&#39;s detect method) */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">_n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">,</span> <span class="n">detected</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">==</span> <span class="n">adapter</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Removing %s at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">detected</span><span class="p">);</span>
			<span class="n">i2c_unregister_device</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">detach_adapter</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: detach_adapter method is deprecated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">detach_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;detach_adapter failed (%d) &quot;</span>
			<span class="s">&quot;for driver [%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__unregister_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">client</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;dummy&quot;</span><span class="p">))</span>
		<span class="n">i2c_unregister_device</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__unregister_dummy</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">)</span>
		<span class="n">i2c_unregister_device</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__process_removed_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2c_do_del_adapter</span><span class="p">(</span><span class="n">to_i2c_driver</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_del_adapter - unregister I2C adapter</span>
<span class="cm"> * @adap: the adapter being unregistered</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> *</span>
<span class="cm"> * This unregisters an I2C adapter which was previously registered</span>
<span class="cm"> * by @i2c_add_adapter or @i2c_add_numbered_adapter.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2c_del_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">found</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* First make sure that this adapter was ever added */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">!=</span> <span class="n">adap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;i2c-core: attempting to delete unregistered &quot;</span>
			 <span class="s">&quot;adapter [%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tell drivers about this removal */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">bus_for_each_drv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">adap</span><span class="p">,</span>
			       <span class="n">__process_removed_adapter</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Remove devices instantiated from sysfs */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients</span><span class="p">,</span>
				 <span class="n">detected</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Removing %s at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">detected</span><span class="p">);</span>
		<span class="n">i2c_unregister_device</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">userspace_clients_lock</span><span class="p">);</span>

	<span class="cm">/* Detach any active clients. This can&#39;t fail, thus we do not</span>
<span class="cm">	 * check the returned value. This is a two-pass process, because</span>
<span class="cm">	 * we can&#39;t remove the dummy devices during the first pass: they</span>
<span class="cm">	 * could have been instantiated by real devices wishing to clean</span>
<span class="cm">	 * them up properly, so we give them a chance to do that first. */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">__unregister_client</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">__unregister_dummy</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_I2C_COMPAT</span>
	<span class="n">class_compat_remove_link</span><span class="p">(</span><span class="n">i2c_adapter_compat_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* device name is gone after device_unregister */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;adapter [%s] unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* clean up the sysfs representation */</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev_released</span><span class="p">);</span>
	<span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* wait for sysfs to drop all references */</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev_released</span><span class="p">);</span>

	<span class="cm">/* free bus id */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>

	<span class="cm">/* Clear the device structure in case this adapter is ever going to be</span>
<span class="cm">	   added again */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_del_adapter</span><span class="p">);</span>


<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="kt">int</span> <span class="nf">i2c_for_each_dev</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">bus_for_each_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_for_each_dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__process_new_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i2c_do_add_adapter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * An i2c_driver is used with one or more i2c_client (device) nodes to access</span>
<span class="cm"> * i2c slave chips, on a bus instance associated with some i2c_adapter.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">i2c_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Can&#39;t register until after driver model init */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">i2c_bus_type</span><span class="p">.</span><span class="n">p</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="cm">/* add the driver to the list of i2c drivers in the driver core */</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">;</span>

	<span class="cm">/* When registration returns, the driver core</span>
<span class="cm">	 * will have called probe() for all matching-but-unbound devices.</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Drivers should switch to dev_pm_ops instead. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;i2c-core: driver [%s] using legacy suspend method</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;i2c-core: driver [%s] using legacy resume method</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;i2c-core: driver [%s] registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">);</span>
	<span class="cm">/* Walk the adapters that are already present */</span>
	<span class="n">i2c_for_each_dev</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">__process_new_driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_register_driver</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__process_removed_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i2c_do_del_adapter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_del_driver - unregister I2C driver</span>
<span class="cm"> * @driver: the driver being unregistered</span>
<span class="cm"> * Context: can sleep</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2c_del_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2c_for_each_dev</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">__process_removed_driver</span><span class="p">);</span>

	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;i2c-core: driver [%s] unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_del_driver</span><span class="p">);</span>

<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_use_client - increments the reference count of the i2c client structure</span>
<span class="cm"> * @client: the client being referenced</span>
<span class="cm"> *</span>
<span class="cm"> * Each live reference to a client should be refcounted. The driver model does</span>
<span class="cm"> * that automatically as part of driver binding, so that most drivers don&#39;t</span>
<span class="cm"> * need to do this explicitly: they hold a reference until they&#39;re unbound</span>
<span class="cm"> * from the device.</span>
<span class="cm"> *</span>
<span class="cm"> * A pointer to the client with the incremented reference counter is returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="nf">i2c_use_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">client</span> <span class="o">&amp;&amp;</span> <span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">client</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_use_client</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_release_client - release a use of the i2c client structure</span>
<span class="cm"> * @client: the client being no longer referenced</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called when a user of a client is finished with it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2c_release_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_release_client</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">i2c_cmd_arg</span> <span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">arg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span>	<span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_cmd_arg</span>	<span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">_arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">client</span> <span class="o">&amp;&amp;</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span>
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">i2c_clients_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_cmd_arg</span>	<span class="n">cmd_arg</span><span class="p">;</span>

	<span class="n">cmd_arg</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">cmd_arg</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_arg</span><span class="p">,</span> <span class="n">i2c_cmd</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_clients_command</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">i2c_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_I2C_COMPAT</span>
	<span class="n">i2c_adapter_compat_class</span> <span class="o">=</span> <span class="n">class_compat_register</span><span class="p">(</span><span class="s">&quot;i2c-adapter&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c_adapter_compat_class</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bus_err</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">i2c_add_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">class_err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">class_err:</span>
<span class="cp">#ifdef CONFIG_I2C_COMPAT</span>
	<span class="n">class_compat_unregister</span><span class="p">(</span><span class="n">i2c_adapter_compat_class</span><span class="p">);</span>
<span class="nl">bus_err:</span>
<span class="cp">#endif</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i2c_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2c_del_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy_driver</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_I2C_COMPAT</span>
	<span class="n">class_compat_unregister</span><span class="p">(</span><span class="n">i2c_adapter_compat_class</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* We must initialize early, because some subsystems register i2c drivers</span>
<span class="cm"> * in subsys_initcall() code, but are linked (and initialized) before i2c.</span>
<span class="cm"> */</span>
<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">i2c_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i2c_exit</span><span class="p">);</span>

<span class="cm">/* ----------------------------------------------------</span>
<span class="cm"> * the functional interface to the i2c busses.</span>
<span class="cm"> * ----------------------------------------------------</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_transfer - execute a single or combined I2C message</span>
<span class="cm"> * @adap: Handle to I2C bus</span>
<span class="cm"> * @msgs: One or more messages to execute before STOP is issued to</span>
<span class="cm"> *	terminate the operation; each message begins with a START.</span>
<span class="cm"> * @num: Number of messages to be executed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative errno, else the number of messages executed.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that there is no requirement that each message be sent to</span>
<span class="cm"> * the same slave address, although that is the most common model.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2c_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_msg</span> <span class="o">*</span><span class="n">msgs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_jiffies</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">try</span><span class="p">;</span>

	<span class="cm">/* REVISIT the fault reporting model here is weak:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  - When we get an error after receiving N bytes from a slave,</span>
<span class="cm">	 *    there is no way to report &quot;N&quot;.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  - When we get a NAK after transmitting N bytes to a slave,</span>
<span class="cm">	 *    there is no way to report &quot;N&quot; ... or to let the master</span>
<span class="cm">	 *    continue executing the rest of this combined message, if</span>
<span class="cm">	 *    that&#39;s the appropriate response.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  - When for example &quot;num&quot; is two and we successfully complete</span>
<span class="cm">	 *    the first message but get an error part way through the</span>
<span class="cm">	 *    second, it&#39;s unclear whether that should be reported as</span>
<span class="cm">	 *    one (discarding status on the second message) or errno</span>
<span class="cm">	 *    (discarding status on the first one).</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo</span><span class="o">-&gt;</span><span class="n">master_xfer</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">ret</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;master_xfer[%d] %c, addr=0x%02x, &quot;</span>
				<span class="s">&quot;len=%d%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="p">(</span><span class="n">msgs</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RD</span><span class="p">)</span>
				<span class="o">?</span> <span class="sc">&#39;R&#39;</span> <span class="o">:</span> <span class="sc">&#39;W&#39;</span><span class="p">,</span> <span class="n">msgs</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">addr</span><span class="p">,</span> <span class="n">msgs</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">len</span><span class="p">,</span>
				<span class="p">(</span><span class="n">msgs</span><span class="p">[</span><span class="n">ret</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RECV_LEN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;+&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_atomic</span><span class="p">()</span> <span class="o">||</span> <span class="n">irqs_disabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_trylock_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="cm">/* I2C activity is ongoing. */</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">i2c_lock_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Retry automatically on arbitration loss */</span>
		<span class="n">orig_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">try</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">try</span> <span class="o">&lt;=</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">;</span> <span class="n">try</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo</span><span class="o">-&gt;</span><span class="n">master_xfer</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">msgs</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">orig_jiffies</span> <span class="o">+</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i2c_unlock_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;I2C level transfers not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_transfer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_master_send - issue a single I2C message in master transmit mode</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @buf: Data that will be written to the slave</span>
<span class="cm"> * @count: How many bytes to write, must be less than 64k since msg.len is u16</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative errno, or else the number of bytes written.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2c_master_send</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msg</span><span class="p">;</span>

	<span class="n">msg</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_TEN</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If everything went ok (i.e. 1 msg transmitted), return #bytes</span>
<span class="cm">	 * transmitted, else error code.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_master_send</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_master_recv - issue a single I2C message in master receive mode</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @buf: Where to store data read from slave</span>
<span class="cm"> * @count: How many bytes to read, must be less than 64k since msg.len is u16</span>
<span class="cm"> *</span>
<span class="cm"> * Returns negative errno, or else the number of bytes read.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2c_master_recv</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">msg</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_TEN</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">I2C_M_RD</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If everything went ok (i.e. 1 msg received), return #bytes received,</span>
<span class="cm">	 * else error code.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_master_recv</span><span class="p">);</span>

<span class="cm">/* ----------------------------------------------------</span>
<span class="cm"> * the i2c address scanning function</span>
<span class="cm"> * Will not work for 10-bit addresses!</span>
<span class="cm"> * ----------------------------------------------------</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Legacy default probe function, mostly relevant for SMBus. The default</span>
<span class="cm"> * probe method is a quick write, but it is known to corrupt the 24RF08</span>
<span class="cm"> * EEPROMs due to a state machine bug, and could also irreversibly</span>
<span class="cm"> * write-protect some EEPROMs, so for address ranges 0x30-0x37 and 0x50-0x5f,</span>
<span class="cm"> * we use a short byte read instead. Also, some bus drivers don&#39;t implement</span>
<span class="cm"> * quick write, so we fallback to a byte read in that case too.</span>
<span class="cm"> * On x86, there is another special case for FSC hardware monitoring chips,</span>
<span class="cm"> * which want regular byte reads (address 0x73.) Fortunately, these are the</span>
<span class="cm"> * only known chips using this I2C address on PC hardware.</span>
<span class="cm"> * Returns 1 if probe succeeded, 0 if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_default_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">dummy</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mh">0x73</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;</span> <span class="n">I2C_CLASS_HWMON</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">I2C_FUNC_SMBUS_READ_BYTE_DATA</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x07</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x30</span> <span class="o">||</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0f</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x50</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">I2C_FUNC_SMBUS_QUICK</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_QUICK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i2c_check_functionality</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">I2C_FUNC_SMBUS_READ_BYTE</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">I2C_SMBUS_BYTE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No suitable probing method supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_detect_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">temp_client</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">temp_client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">temp_client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Make sure the address is valid */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">i2c_check_addr_validity</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid probe address 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip if already in use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2c_check_addr_busy</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make sure there is something at this address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c_default_probe</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Finally call the custom detection function */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_board_info</span><span class="p">));</span>
	<span class="n">info</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">detect</span><span class="p">(</span><span class="n">temp_client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* -ENODEV is returned if the detection fails. We catch it</span>
<span class="cm">		   here as this isn&#39;t an error. */</span>
		<span class="k">return</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Consistency check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s detection function provided &quot;</span>
			<span class="s">&quot;no name for 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>

		<span class="cm">/* Detection succeeded, instantiate the device */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Creating %s at 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">client</span> <span class="o">=</span> <span class="n">i2c_new_device</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">client</span><span class="p">)</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">detected</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">clients</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed creating %s at 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">address_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">temp_client</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">adap_id</span> <span class="o">=</span> <span class="n">i2c_adapter_id</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">address_list</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">address_list</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">detect</span> <span class="o">||</span> <span class="o">!</span><span class="n">address_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Stop here if the classes do not match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Set up a temporary client to help detect callback */</span>
	<span class="n">temp_client</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">temp_client</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">temp_client</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">address_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">I2C_CLIENT_END</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;found normal entry for adapter %d, &quot;</span>
			<span class="s">&quot;addr 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adap_id</span><span class="p">,</span> <span class="n">address_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">temp_client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">address_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">i2c_detect_address</span><span class="p">(</span><span class="n">temp_client</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">temp_client</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">i2c_probe_func_quick_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_QUICK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_probe_func_quick_read</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span>
<span class="nf">i2c_new_probed_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">short</span> <span class="k">const</span> <span class="o">*</span><span class="n">addr_list</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">addr</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">probe</span><span class="p">)</span>
		<span class="n">probe</span> <span class="o">=</span> <span class="n">i2c_default_probe</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">I2C_CLIENT_END</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check address validity */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2c_check_addr_validity</span><span class="p">(</span><span class="n">addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid 7-bit address &quot;</span>
				 <span class="s">&quot;0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check address availability */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2c_check_addr_busy</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Address 0x%02x already in &quot;</span>
				<span class="s">&quot;use, not probing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Test address responsiveness */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">I2C_CLIENT_END</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Probing failed, no device found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">i2c_new_device</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2c_new_probed_device</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="nf">i2c_get_adapter</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_adapter_idr</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="n">adapter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">adapter</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_get_adapter</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">i2c_put_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_put_adapter</span><span class="p">);</span>

<span class="cm">/* The SMBus parts */</span>

<span class="cp">#define POLY    (0x1070U &lt;&lt; 3)</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">crc8</span><span class="p">(</span><span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">^</span> <span class="n">POLY</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Incremental CRC8 over count bytes in the array pointed to by p */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">i2c_smbus_pec</span><span class="p">(</span><span class="n">u8</span> <span class="n">crc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="n">crc8</span><span class="p">((</span><span class="n">crc</span> <span class="o">^</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">crc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Assume a 7-bit address, which is reasonable for SMBus */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">i2c_smbus_msg_pec</span><span class="p">(</span><span class="n">u8</span> <span class="n">pec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The address will be sent first */</span>
	<span class="n">u8</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">!!</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RD</span><span class="p">);</span>
	<span class="n">pec</span> <span class="o">=</span> <span class="n">i2c_smbus_pec</span><span class="p">(</span><span class="n">pec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* The data buffer follows */</span>
	<span class="k">return</span> <span class="n">i2c_smbus_pec</span><span class="p">(</span><span class="n">pec</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used for write only transactions */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2c_smbus_add_pec</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">i2c_smbus_msg_pec</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return &lt;0 on CRC error</span>
<span class="cm">   If there was a write before this read (most cases) we need to take the</span>
<span class="cm">   partial CRC from the write part into account.</span>
<span class="cm">   Note that this function does modify the message (we need to decrease the</span>
<span class="cm">   message length to hide the CRC byte from the caller). */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2c_smbus_check_pec</span><span class="p">(</span><span class="n">u8</span> <span class="n">cpec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2c_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">rpec</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="o">--</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">];</span>
	<span class="n">cpec</span> <span class="o">=</span> <span class="n">i2c_smbus_msg_pec</span><span class="p">(</span><span class="n">cpec</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rpec</span> <span class="o">!=</span> <span class="n">cpec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;i2c-core: Bad PEC 0x%02x vs. 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rpec</span><span class="p">,</span> <span class="n">cpec</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_read_byte - SMBus &quot;receive byte&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;receive byte&quot; protocol, returning negative errno</span>
<span class="cm"> * else the byte received from the device.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_read_byte</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_BYTE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="n">data</span><span class="p">.</span><span class="n">byte</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_read_byte</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_write_byte - SMBus &quot;send byte&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @value: Byte to be sent</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;send byte&quot; protocol, returning negative errno</span>
<span class="cm"> * else zero on success.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_write_byte</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
	                      <span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">I2C_SMBUS_BYTE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_write_byte</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_read_byte_data - SMBus &quot;read byte&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @command: Byte interpreted by slave</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;read byte&quot; protocol, returning negative errno</span>
<span class="cm"> * else a data byte received from the device.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_read_byte_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="n">data</span><span class="p">.</span><span class="n">byte</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_read_byte_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_write_byte_data - SMBus &quot;write byte&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @command: Byte interpreted by slave</span>
<span class="cm"> * @value: Byte being written</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;write byte&quot; protocol, returning negative errno</span>
<span class="cm"> * else zero on success.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
			      <span class="n">u8</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">byte</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_write_byte_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_read_word_data - SMBus &quot;read word&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @command: Byte interpreted by slave</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;read word&quot; protocol, returning negative errno</span>
<span class="cm"> * else a 16-bit unsigned &quot;word&quot; received from the device.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_read_word_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_WORD_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="n">data</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_read_word_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_write_word_data - SMBus &quot;write word&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @command: Byte interpreted by slave</span>
<span class="cm"> * @value: 16-bit &quot;word&quot; being written</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;write word&quot; protocol, returning negative errno</span>
<span class="cm"> * else zero on success.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_write_word_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
			      <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_WORD_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_write_word_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_process_call - SMBus &quot;process call&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @command: Byte interpreted by slave</span>
<span class="cm"> * @value: 16-bit &quot;word&quot; being written</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;process call&quot; protocol, returning negative errno</span>
<span class="cm"> * else a 16-bit unsigned &quot;word&quot; received from the device.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_process_call</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
			   <span class="n">u16</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_PROC_CALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="n">data</span><span class="p">.</span><span class="n">word</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_process_call</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_read_block_data - SMBus &quot;block read&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @command: Byte interpreted by slave</span>
<span class="cm"> * @values: Byte array into which data will be read; big enough to hold</span>
<span class="cm"> *	the data returned by the slave.  SMBus allows at most 32 bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;block read&quot; protocol, returning negative errno</span>
<span class="cm"> * else the number of data bytes in the slave&#39;s response.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that using this function requires that the client&#39;s adapter support</span>
<span class="cm"> * the I2C_FUNC_SMBUS_READ_BLOCK_DATA functionality.  Not all adapter drivers</span>
<span class="cm"> * support this; its emulation through I2C messaging relies on a specific</span>
<span class="cm"> * mechanism (I2C_M_RECV_LEN) which may not be implemented.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_read_block_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
			      <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_BLOCK_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_read_block_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_write_block_data - SMBus &quot;block write&quot; protocol</span>
<span class="cm"> * @client: Handle to slave device</span>
<span class="cm"> * @command: Byte interpreted by slave</span>
<span class="cm"> * @length: Size of data block; SMBus allows at most 32 bytes</span>
<span class="cm"> * @values: Byte array which will be written.</span>
<span class="cm"> *</span>
<span class="cm"> * This executes the SMBus &quot;block write&quot; protocol, returning negative errno</span>
<span class="cm"> * else zero on success.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_write_block_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="n">length</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">values</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_BLOCK_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_write_block_data</span><span class="p">);</span>

<span class="cm">/* Returns the number of read bytes */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_read_i2c_block_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="n">length</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_READ</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
				<span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_read_i2c_block_data</span><span class="p">);</span>

<span class="n">s32</span> <span class="nf">i2c_smbus_write_i2c_block_data</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
				   <span class="n">u8</span> <span class="n">length</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_WRITE</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
			      <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_write_i2c_block_data</span><span class="p">);</span>

<span class="cm">/* Simulate a SMBus command using the i2c protocol</span>
<span class="cm">   No checking of parameters is done!  */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">i2c_smbus_xfer_emulated</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="n">read_write</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				   <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* So we need to generate a series of msgs. In the case of writing, we</span>
<span class="cm">	  need to use only one message; when reading, we need two. We initialize</span>
<span class="cm">	  most things with sane defaults, to keep the code below somewhat</span>
<span class="cm">	  simpler. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msgbuf0</span><span class="p">[</span><span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">msgbuf1</span><span class="p">[</span><span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">msgbuf0</span> <span class="p">},</span>
	                          <span class="p">{</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">I2C_M_RD</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msgbuf1</span> <span class="p">}</span>
	                        <span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">partial_pec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">msgbuf0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_QUICK</span>:
		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Special case: The read/write field is used as data */</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span> <span class="o">?</span>
					<span class="n">I2C_M_RD</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_BYTE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Special case: only a read! */</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">I2C_M_RD</span> <span class="o">|</span> <span class="n">flags</span><span class="p">;</span>
			<span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_BYTE_DATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">msgbuf0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_WORD_DATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">msgbuf0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">msgbuf0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_PROC_CALL</span>:
		<span class="n">num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Special case */</span>
		<span class="n">read_write</span> <span class="o">=</span> <span class="n">I2C_SMBUS_READ</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">msgbuf0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">msgbuf0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_BLOCK_DATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">I2C_M_RECV_LEN</span><span class="p">;</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* block length will be added by</span>
<span class="cm">					   the underlying bus driver */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Invalid block write size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">msgbuf0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_BLOCK_PROC_CALL</span>:
		<span class="n">num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* Another special case */</span>
		<span class="n">read_write</span> <span class="o">=</span> <span class="n">I2C_SMBUS_READ</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Invalid block write size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">msgbuf0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">I2C_M_RECV_LEN</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* block length will be added by</span>
<span class="cm">				   the underlying bus driver */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Invalid block write size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">msgbuf0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unsupported transaction %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_CLIENT_PEC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_QUICK</span>
				      <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Compute PEC if first message is a write */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RD</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/* Write only */</span>
				<span class="n">i2c_smbus_add_pec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">else</span> <span class="cm">/* Write followed by read */</span>
				<span class="n">partial_pec</span> <span class="o">=</span> <span class="n">i2c_smbus_msg_pec</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="cm">/* Ask for PEC if last message is a read */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RD</span><span class="p">)</span>
			<span class="n">msg</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Check PEC if last message is a read */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">i2c_smbus_check_pec</span><span class="p">(</span><span class="n">partial_pec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">I2C_SMBUS_BYTE</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">byte</span> <span class="o">=</span> <span class="n">msgbuf0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">I2C_SMBUS_BYTE_DATA</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">byte</span> <span class="o">=</span> <span class="n">msgbuf1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">I2C_SMBUS_WORD_DATA</span>:
		<span class="k">case</span> <span class="n">I2C_SMBUS_PROC_CALL</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">=</span> <span class="n">msgbuf1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">msgbuf1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span>:
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msgbuf1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">I2C_SMBUS_BLOCK_DATA</span>:
		<span class="k">case</span> <span class="n">I2C_SMBUS_BLOCK_PROC_CALL</span>:
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msgbuf1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">msgbuf1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_smbus_xfer - execute SMBus protocol operations</span>
<span class="cm"> * @adapter: Handle to I2C bus</span>
<span class="cm"> * @addr: Address of SMBus slave on that bus</span>
<span class="cm"> * @flags: I2C_CLIENT_* flags (usually zero or I2C_CLIENT_PEC)</span>
<span class="cm"> * @read_write: I2C_SMBUS_READ or I2C_SMBUS_WRITE</span>
<span class="cm"> * @command: Byte interpreted by slave, for protocols which use such bytes</span>
<span class="cm"> * @protocol: SMBus protocol operation to execute, such as I2C_SMBUS_PROC_CALL</span>
<span class="cm"> * @data: Data to be read or written</span>
<span class="cm"> *</span>
<span class="cm"> * This executes an SMBus protocol operation, and returns a negative</span>
<span class="cm"> * errno code else zero on success.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">i2c_smbus_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span>
		   <span class="kt">char</span> <span class="n">read_write</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
		   <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_jiffies</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">try</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">I2C_M_TEN</span> <span class="o">|</span> <span class="n">I2C_CLIENT_PEC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">algo</span><span class="o">-&gt;</span><span class="n">smbus_xfer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2c_lock_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="cm">/* Retry automatically on arbitration loss */</span>
		<span class="n">orig_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">try</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">try</span> <span class="o">&lt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">;</span> <span class="n">try</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">algo</span><span class="o">-&gt;</span><span class="n">smbus_xfer</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
							<span class="n">read_write</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
							<span class="n">protocol</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				       <span class="n">orig_jiffies</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i2c_unlock_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer_emulated</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">read_write</span><span class="p">,</span>
					      <span class="n">command</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">i2c_smbus_xfer</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Simon G. Vogl &lt;simon@tk.uni-linz.ac.at&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;I2C-Bus main module&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
