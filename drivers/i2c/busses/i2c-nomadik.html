<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › i2c › busses › i2c-nomadik.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>i2c-nomadik.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2009 ST-Ericsson SA</span>
<span class="cm"> * Copyright (C) 2009 STMicroelectronics</span>
<span class="cm"> *</span>
<span class="cm"> * I2C master mode controller driver, used in Nomadik 8815</span>
<span class="cm"> * and Ux500 platforms.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Srinidhi Kasagar &lt;srinidhi.kasagar@stericsson.com&gt;</span>
<span class="cm"> * Author: Sachin Verma &lt;sachin.verma@st.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2, as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/regulator/consumer.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>

<span class="cp">#include &lt;plat/i2c.h&gt;</span>

<span class="cp">#define DRIVER_NAME &quot;nmk-i2c&quot;</span>

<span class="cm">/* I2C Controller register offsets */</span>
<span class="cp">#define I2C_CR		(0x000)</span>
<span class="cp">#define I2C_SCR		(0x004)</span>
<span class="cp">#define I2C_HSMCR	(0x008)</span>
<span class="cp">#define I2C_MCR		(0x00C)</span>
<span class="cp">#define I2C_TFR		(0x010)</span>
<span class="cp">#define I2C_SR		(0x014)</span>
<span class="cp">#define I2C_RFR		(0x018)</span>
<span class="cp">#define I2C_TFTR	(0x01C)</span>
<span class="cp">#define I2C_RFTR	(0x020)</span>
<span class="cp">#define I2C_DMAR	(0x024)</span>
<span class="cp">#define I2C_BRCR	(0x028)</span>
<span class="cp">#define I2C_IMSCR	(0x02C)</span>
<span class="cp">#define I2C_RISR	(0x030)</span>
<span class="cp">#define I2C_MISR	(0x034)</span>
<span class="cp">#define I2C_ICR		(0x038)</span>

<span class="cm">/* Control registers */</span>
<span class="cp">#define I2C_CR_PE		(0x1 &lt;&lt; 0)	</span><span class="cm">/* Peripheral Enable */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_OM		(0x3 &lt;&lt; 1)	</span><span class="cm">/* Operating mode */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_SAM		(0x1 &lt;&lt; 3)	</span><span class="cm">/* Slave addressing mode */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_SM		(0x3 &lt;&lt; 4)	</span><span class="cm">/* Speed mode */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_SGCM		(0x1 &lt;&lt; 6)	</span><span class="cm">/* Slave general call mode */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_FTX		(0x1 &lt;&lt; 7)	</span><span class="cm">/* Flush Transmit */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_FRX		(0x1 &lt;&lt; 8)	</span><span class="cm">/* Flush Receive */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_DMA_TX_EN	(0x1 &lt;&lt; 9)	</span><span class="cm">/* DMA Tx enable */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_DMA_RX_EN	(0x1 &lt;&lt; 10)	</span><span class="cm">/* DMA Rx Enable */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_DMA_SLE		(0x1 &lt;&lt; 11)	</span><span class="cm">/* DMA sync. logic enable */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_LM		(0x1 &lt;&lt; 12)	</span><span class="cm">/* Loopback mode */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_FON		(0x3 &lt;&lt; 13)	</span><span class="cm">/* Filtering on */</span><span class="cp"></span>
<span class="cp">#define I2C_CR_FS		(0x3 &lt;&lt; 15)	</span><span class="cm">/* Force stop enable */</span><span class="cp"></span>

<span class="cm">/* Master controller (MCR) register */</span>
<span class="cp">#define I2C_MCR_OP		(0x1 &lt;&lt; 0)	</span><span class="cm">/* Operation */</span><span class="cp"></span>
<span class="cp">#define I2C_MCR_A7		(0x7f &lt;&lt; 1)	</span><span class="cm">/* 7-bit address */</span><span class="cp"></span>
<span class="cp">#define I2C_MCR_EA10		(0x7 &lt;&lt; 8)	</span><span class="cm">/* 10-bit Extended address */</span><span class="cp"></span>
<span class="cp">#define I2C_MCR_SB		(0x1 &lt;&lt; 11)	</span><span class="cm">/* Extended address */</span><span class="cp"></span>
<span class="cp">#define I2C_MCR_AM		(0x3 &lt;&lt; 12)	</span><span class="cm">/* Address type */</span><span class="cp"></span>
<span class="cp">#define I2C_MCR_STOP		(0x1 &lt;&lt; 14)	</span><span class="cm">/* Stop condition */</span><span class="cp"></span>
<span class="cp">#define I2C_MCR_LENGTH		(0x7ff &lt;&lt; 15)	</span><span class="cm">/* Transaction length */</span><span class="cp"></span>

<span class="cm">/* Status register (SR) */</span>
<span class="cp">#define I2C_SR_OP		(0x3 &lt;&lt; 0)	</span><span class="cm">/* Operation */</span><span class="cp"></span>
<span class="cp">#define I2C_SR_STATUS		(0x3 &lt;&lt; 2)	</span><span class="cm">/* controller status */</span><span class="cp"></span>
<span class="cp">#define I2C_SR_CAUSE		(0x7 &lt;&lt; 4)	</span><span class="cm">/* Abort cause */</span><span class="cp"></span>
<span class="cp">#define I2C_SR_TYPE		(0x3 &lt;&lt; 7)	</span><span class="cm">/* Receive type */</span><span class="cp"></span>
<span class="cp">#define I2C_SR_LENGTH		(0x7ff &lt;&lt; 9)	</span><span class="cm">/* Transfer length */</span><span class="cp"></span>

<span class="cm">/* Interrupt mask set/clear (IMSCR) bits */</span>
<span class="cp">#define I2C_IT_TXFE		(0x1 &lt;&lt; 0)</span>
<span class="cp">#define I2C_IT_TXFNE		(0x1 &lt;&lt; 1)</span>
<span class="cp">#define I2C_IT_TXFF		(0x1 &lt;&lt; 2)</span>
<span class="cp">#define I2C_IT_TXFOVR		(0x1 &lt;&lt; 3)</span>
<span class="cp">#define I2C_IT_RXFE		(0x1 &lt;&lt; 4)</span>
<span class="cp">#define I2C_IT_RXFNF		(0x1 &lt;&lt; 5)</span>
<span class="cp">#define I2C_IT_RXFF		(0x1 &lt;&lt; 6)</span>
<span class="cp">#define I2C_IT_RFSR		(0x1 &lt;&lt; 16)</span>
<span class="cp">#define I2C_IT_RFSE		(0x1 &lt;&lt; 17)</span>
<span class="cp">#define I2C_IT_WTSR		(0x1 &lt;&lt; 18)</span>
<span class="cp">#define I2C_IT_MTD		(0x1 &lt;&lt; 19)</span>
<span class="cp">#define I2C_IT_STD		(0x1 &lt;&lt; 20)</span>
<span class="cp">#define I2C_IT_MAL		(0x1 &lt;&lt; 24)</span>
<span class="cp">#define I2C_IT_BERR		(0x1 &lt;&lt; 25)</span>
<span class="cp">#define I2C_IT_MTDWS		(0x1 &lt;&lt; 28)</span>

<span class="cp">#define GEN_MASK(val, mask, sb)  (((val) &lt;&lt; (sb)) &amp; (mask))</span>

<span class="cm">/* some bits in ICR are reserved */</span>
<span class="cp">#define I2C_CLEAR_ALL_INTS	0x131f007f</span>

<span class="cm">/* first three msb bits are reserved */</span>
<span class="cp">#define IRQ_MASK(mask)		(mask &amp; 0x1fffffff)</span>

<span class="cm">/* maximum threshold value */</span>
<span class="cp">#define MAX_I2C_FIFO_THRESHOLD	15</span>

<span class="k">enum</span> <span class="n">i2c_status</span> <span class="p">{</span>
	<span class="n">I2C_NOP</span><span class="p">,</span>
	<span class="n">I2C_ON_GOING</span><span class="p">,</span>
	<span class="n">I2C_OK</span><span class="p">,</span>
	<span class="n">I2C_ABORT</span>
<span class="p">};</span>

<span class="cm">/* operation */</span>
<span class="k">enum</span> <span class="n">i2c_operation</span> <span class="p">{</span>
	<span class="n">I2C_NO_OPERATION</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">,</span>
	<span class="n">I2C_WRITE</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">I2C_READ</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct i2c_nmk_client - client specific data</span>
<span class="cm"> * @slave_adr: 7-bit slave address</span>
<span class="cm"> * @count: no. bytes to be transferred</span>
<span class="cm"> * @buffer: client data buffer</span>
<span class="cm"> * @xfer_bytes: bytes transferred till now</span>
<span class="cm"> * @operation: current I2C operation</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_nmk_client</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">slave_adr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">xfer_bytes</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">i2c_operation</span>	<span class="n">operation</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct nmk_i2c_dev - private data structure of the controller.</span>
<span class="cm"> * @pdev: parent platform device.</span>
<span class="cm"> * @adap: corresponding I2C adapter.</span>
<span class="cm"> * @irq: interrupt line for the controller.</span>
<span class="cm"> * @virtbase: virtual io memory area.</span>
<span class="cm"> * @clk: hardware i2c block clock.</span>
<span class="cm"> * @cfg: machine provided controller configuration.</span>
<span class="cm"> * @cli: holder of client specific data.</span>
<span class="cm"> * @stop: stop condition.</span>
<span class="cm"> * @xfer_complete: acknowledge completion for a I2C message.</span>
<span class="cm"> * @result: controller propogated result.</span>
<span class="cm"> * @regulator: pointer to i2c regulator.</span>
<span class="cm"> * @busy: Busy doing transfer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span>		<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span>		<span class="n">adap</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">irq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span>			<span class="o">*</span><span class="n">virtbase</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span>			<span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nmk_i2c_controller</span>	<span class="n">cfg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_nmk_client</span>		<span class="n">cli</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">stop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>		<span class="n">xfer_complete</span><span class="p">;</span>
	<span class="kt">int</span>				<span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">regulator</span>		<span class="o">*</span><span class="n">regulator</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">busy</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* controller&#39;s abort causes */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">abort_causes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;no ack received after address transmission&quot;</span><span class="p">,</span>
	<span class="s">&quot;no ack received during data phase&quot;</span><span class="p">,</span>
	<span class="s">&quot;ack received after xmission of master code&quot;</span><span class="p">,</span>
	<span class="s">&quot;master lost arbitration&quot;</span><span class="p">,</span>
	<span class="s">&quot;slave restarts&quot;</span><span class="p">,</span>
	<span class="s">&quot;slave reset&quot;</span><span class="p">,</span>
	<span class="s">&quot;overflow, maxsize is 2047 bytes&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2c_set_bit</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2c_clr_bit</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * flush_i2c_fifo() - This function flushes the I2C FIFO</span>
<span class="cm"> * @dev: private data of I2C Driver</span>
<span class="cm"> *</span>
<span class="cm"> * This function flushes the I2C Tx and Rx FIFOs. It returns</span>
<span class="cm"> * 0 on successful flushing of FIFO</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flush_i2c_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define LOOP_ATTEMPTS 10</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * flush the transmit and receive FIFO. The flushing</span>
<span class="cm">	 * operation takes several cycles before to be completed.</span>
<span class="cm">	 * On the completion, the I2C internal logic clears these</span>
<span class="cm">	 * bits, until then no one must access Tx, Rx FIFO and</span>
<span class="cm">	 * should poll on these bits waiting for the completion.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">I2C_CR_FTX</span> <span class="o">|</span> <span class="n">I2C_CR_FRX</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOOP_ATTEMPTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">.</span><span class="n">timeout</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="n">I2C_CR_FTX</span> <span class="o">|</span> <span class="n">I2C_CR_FRX</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;flushing operation timed out giving up after %d attempts&quot;</span><span class="p">,</span>
		<span class="n">LOOP_ATTEMPTS</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disable_all_interrupts() - Disable all interrupts of this I2c Bus</span>
<span class="cm"> * @dev: private data of I2C Driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_all_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">IRQ_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_IMSCR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clear_all_interrupts() - Clear all interrupts of I2C Controller</span>
<span class="cm"> * @dev: private data of I2C Driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_all_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">IRQ_MASK</span><span class="p">(</span><span class="n">I2C_CLEAR_ALL_INTS</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_ICR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_hw() - initialize the I2C hardware</span>
<span class="cm"> * @dev: private data of I2C Driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">stat</span> <span class="o">=</span> <span class="n">flush_i2c_fifo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/* disable the controller */</span>
	<span class="n">i2c_clr_bit</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span> <span class="p">,</span> <span class="n">I2C_CR_PE</span><span class="p">);</span>

	<span class="n">disable_all_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">clear_all_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">operation</span> <span class="o">=</span> <span class="n">I2C_NO_OPERATION</span><span class="p">;</span>

<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* enable peripheral, master mode operation */</span>
<span class="cp">#define DEFAULT_I2C_REG_CR	((1 &lt;&lt; 1) | I2C_CR_PE)</span>

<span class="cm">/**</span>
<span class="cm"> * load_i2c_mcr_reg() - load the MCR register</span>
<span class="cm"> * @dev: private data of controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">load_i2c_mcr_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mcr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 7-bit address transaction */</span>
	<span class="n">mcr</span> <span class="o">|=</span> <span class="n">GEN_MASK</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">I2C_MCR_AM</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">mcr</span> <span class="o">|=</span> <span class="n">GEN_MASK</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">slave_adr</span><span class="p">,</span> <span class="n">I2C_MCR_A7</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* start byte procedure not applied */</span>
	<span class="n">mcr</span> <span class="o">|=</span> <span class="n">GEN_MASK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">I2C_MCR_SB</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>

	<span class="cm">/* check the operation, master read/write? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">operation</span> <span class="o">==</span> <span class="n">I2C_WRITE</span><span class="p">)</span>
		<span class="n">mcr</span> <span class="o">|=</span> <span class="n">GEN_MASK</span><span class="p">(</span><span class="n">I2C_WRITE</span><span class="p">,</span> <span class="n">I2C_MCR_OP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mcr</span> <span class="o">|=</span> <span class="n">GEN_MASK</span><span class="p">(</span><span class="n">I2C_READ</span><span class="p">,</span> <span class="n">I2C_MCR_OP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* stop or repeated start? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
		<span class="n">mcr</span> <span class="o">|=</span> <span class="n">GEN_MASK</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">I2C_MCR_STOP</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mcr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">GEN_MASK</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">I2C_MCR_STOP</span><span class="p">,</span> <span class="mi">14</span><span class="p">));</span>

	<span class="n">mcr</span> <span class="o">|=</span> <span class="n">GEN_MASK</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">I2C_MCR_LENGTH</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mcr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * setup_i2c_controller() - setup the controller</span>
<span class="cm"> * @dev: private data of controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_i2c_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">brcr1</span><span class="p">,</span> <span class="n">brcr2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i2c_clk</span><span class="p">,</span> <span class="n">div</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_HSMCR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_TFTR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_RFTR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_DMAR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * set the slsu:</span>
<span class="cm">	 *</span>
<span class="cm">	 * slsu defines the data setup time after SCL clock</span>
<span class="cm">	 * stretching in terms of i2c clk cycles. The</span>
<span class="cm">	 * needed setup time for the three modes are 250ns,</span>
<span class="cm">	 * 100ns, 10ns respectively thus leading to the values</span>
<span class="cm">	 * of 14, 6, 2 for a 48 MHz i2c clk.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">slsu</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_SCR</span><span class="p">);</span>

	<span class="n">i2c_clk</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* fallback to std. mode if machine has not provided it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">clk_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">clk_freq</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The spec says, in case of std. mode the divider is</span>
<span class="cm">	 * 2 whereas it is 3 for fast and fastplus mode of</span>
<span class="cm">	 * operation. TODO - high speed support.</span>
<span class="cm">	 */</span>
	<span class="n">div</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">clk_freq</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * generate the mask for baud rate counters. The controller</span>
<span class="cm">	 * has two baud rate counters. One is used for High speed</span>
<span class="cm">	 * operation, and the other is for std, fast mode, fast mode</span>
<span class="cm">	 * plus operation. Currently we do not supprt high speed mode</span>
<span class="cm">	 * so set brcr1 to 0.</span>
<span class="cm">	 */</span>
	<span class="n">brcr1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">brcr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">i2c_clk</span><span class="o">/</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">clk_freq</span> <span class="o">*</span> <span class="n">div</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>

	<span class="cm">/* set the baud rate counter register */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">brcr1</span> <span class="o">|</span> <span class="n">brcr2</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_BRCR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * set the speed mode. Currently we support</span>
<span class="cm">	 * only standard and fast mode of operation</span>
<span class="cm">	 * TODO - support for fast mode plus (up to 1Mb/s)</span>
<span class="cm">	 * and high speed (up to 3.4 Mb/s)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">sm</span> <span class="o">&gt;</span> <span class="n">I2C_FREQ_MODE_FAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;do not support this mode defaulting to std. mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">brcr2</span> <span class="o">=</span> <span class="n">i2c_clk</span><span class="o">/</span><span class="p">(</span><span class="mi">100000</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">brcr1</span> <span class="o">|</span> <span class="n">brcr2</span><span class="p">),</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_BRCR</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">I2C_FREQ_MODE_STANDARD</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">sm</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">);</span>

	<span class="cm">/* set the Tx and Rx FIFO threshold */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">tft</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_TFTR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">rft</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_RFTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_i2c() - Read from I2C client device</span>
<span class="cm"> * @dev: private data of I2C Driver</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads from i2c client device when controller is in</span>
<span class="cm"> * master mode. There is a completion timeout. If there is no transfer</span>
<span class="cm"> * before timeout error is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">mcr</span> <span class="o">=</span> <span class="n">load_i2c_mcr_reg</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mcr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_MCR</span><span class="p">);</span>

	<span class="cm">/* load the current CR value */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">)</span> <span class="o">|</span> <span class="n">DEFAULT_I2C_REG_CR</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">);</span>

	<span class="cm">/* enable the controller */</span>
	<span class="n">i2c_set_bit</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">,</span> <span class="n">I2C_CR_PE</span><span class="p">);</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_complete</span><span class="p">);</span>

	<span class="cm">/* enable interrupts by setting the mask */</span>
	<span class="n">irq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">I2C_IT_RXFNF</span> <span class="o">|</span> <span class="n">I2C_IT_RXFF</span> <span class="o">|</span>
			<span class="n">I2C_IT_MAL</span> <span class="o">|</span> <span class="n">I2C_IT_BERR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
		<span class="n">irq_mask</span> <span class="o">|=</span> <span class="n">I2C_IT_MTD</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">irq_mask</span> <span class="o">|=</span> <span class="n">I2C_IT_MTDWS</span><span class="p">;</span>

	<span class="n">irq_mask</span> <span class="o">=</span> <span class="n">I2C_CLEAR_ALL_INTS</span> <span class="o">&amp;</span> <span class="n">IRQ_MASK</span><span class="p">(</span><span class="n">irq_mask</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_IMSCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">irq_mask</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_IMSCR</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span>
		<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_complete</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">.</span><span class="n">timeout</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;wait_for_completion_timeout &quot;</span>
			<span class="s">&quot;returned %d waiting for event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Controller timed out */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;read from slave 0x%x timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">slave_adr</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_tx_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">no_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">no_bytes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
			<span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* write to the Tx FIFO */</span>
		<span class="n">writeb</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_TFR</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">xfer_bytes</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_i2c() - Write data to I2C client.</span>
<span class="cm"> * @dev: private data of I2C Driver</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes data to I2C client</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_i2c</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mcr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">irq_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">mcr</span> <span class="o">=</span> <span class="n">load_i2c_mcr_reg</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">mcr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_MCR</span><span class="p">);</span>

	<span class="cm">/* load the current CR value */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">)</span> <span class="o">|</span> <span class="n">DEFAULT_I2C_REG_CR</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">);</span>

	<span class="cm">/* enable the controller */</span>
	<span class="n">i2c_set_bit</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span> <span class="p">,</span> <span class="n">I2C_CR_PE</span><span class="p">);</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_complete</span><span class="p">);</span>

	<span class="cm">/* enable interrupts by settings the masks */</span>
	<span class="n">irq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">I2C_IT_TXFOVR</span> <span class="o">|</span> <span class="n">I2C_IT_MAL</span> <span class="o">|</span> <span class="n">I2C_IT_BERR</span><span class="p">);</span>

	<span class="cm">/* Fill the TX FIFO with transmit data */</span>
	<span class="n">fill_tx_fifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MAX_I2C_FIFO_THRESHOLD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">irq_mask</span> <span class="o">|=</span> <span class="n">I2C_IT_TXFNE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check if we want to transfer a single or multiple bytes, if so</span>
<span class="cm">	 * set the MTDWS bit (Master Transaction Done Without Stop)</span>
<span class="cm">	 * to start repeated start operation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
		<span class="n">irq_mask</span> <span class="o">|=</span> <span class="n">I2C_IT_MTD</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">irq_mask</span> <span class="o">|=</span> <span class="n">I2C_IT_MTDWS</span><span class="p">;</span>

	<span class="n">irq_mask</span> <span class="o">=</span> <span class="n">I2C_CLEAR_ALL_INTS</span> <span class="o">&amp;</span> <span class="n">IRQ_MASK</span><span class="p">(</span><span class="n">irq_mask</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_IMSCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">irq_mask</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_IMSCR</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span>
		<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_complete</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">.</span><span class="n">timeout</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;wait_for_completion_timeout &quot;</span>
			<span class="s">&quot;returned %d waiting for event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Controller timed out */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;write to slave 0x%x timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">slave_adr</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nmk_i2c_xfer_one() - transmit a single I2C message</span>
<span class="cm"> * @dev: device with a message encoded into it</span>
<span class="cm"> * @flags: message flags</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nmk_i2c_xfer_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* read operation */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">operation</span> <span class="o">=</span> <span class="n">I2C_READ</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">read_i2c</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* write operation */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">operation</span> <span class="o">=</span> <span class="n">I2C_WRITE</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">write_i2c</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">||</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">i2c_sr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">cause</span><span class="p">;</span>

		<span class="n">i2c_sr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_SR</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if the controller I2C operation status</span>
<span class="cm">		 * is set to ABORT(11b).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">i2c_sr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* get the abort cause */</span>
			<span class="n">cause</span> <span class="o">=</span>	<span class="p">(</span><span class="n">i2c_sr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cause</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">abort_causes</span><span class="p">)</span> <span class="o">?</span>
				<span class="s">&quot;unknown reason&quot;</span> <span class="o">:</span>
				<span class="n">abort_causes</span><span class="p">[</span><span class="n">cause</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">init_hw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">status</span> <span class="o">?</span> <span class="n">status</span> <span class="o">:</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nmk_i2c_xfer() - I2C transfer function used by kernel framework</span>
<span class="cm"> * @i2c_adap: Adapter pointer to the controller</span>
<span class="cm"> * @msgs: Pointer to data to be written.</span>
<span class="cm"> * @num_msgs: Number of messages to be executed</span>
<span class="cm"> *</span>
<span class="cm"> * This is the function called by the generic kernel i2c_transfer()</span>
<span class="cm"> * or i2c_smbus...() API calls. Note that this code is protected by the</span>
<span class="cm"> * semaphore set in the kernel i2c_transfer() function.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:</span>
<span class="cm"> * READ TRANSFER : We impose a restriction of the first message to be the</span>
<span class="cm"> *		index message for any read transaction.</span>
<span class="cm"> *		- a no index is coded as &#39;0&#39;,</span>
<span class="cm"> *		- 2byte big endian index is coded as &#39;3&#39;</span>
<span class="cm"> *		!!! msg[0].buf holds the actual index.</span>
<span class="cm"> *		This is compatible with generic messages of smbus emulator</span>
<span class="cm"> *		that send a one byte index.</span>
<span class="cm"> *		eg. a I2C transation to read 2 bytes from index 0</span>
<span class="cm"> *			idx = 0;</span>
<span class="cm"> *			msg[0].addr = client-&gt;addr;</span>
<span class="cm"> *			msg[0].flags = 0x0;</span>
<span class="cm"> *			msg[0].len = 1;</span>
<span class="cm"> *			msg[0].buf = &amp;idx;</span>
<span class="cm"> *</span>
<span class="cm"> *			msg[1].addr = client-&gt;addr;</span>
<span class="cm"> *			msg[1].flags = I2C_M_RD;</span>
<span class="cm"> *			msg[1].len = 2;</span>
<span class="cm"> *			msg[1].buf = rd_buff</span>
<span class="cm"> *			i2c_transfer(adap, msg, 2);</span>
<span class="cm"> *</span>
<span class="cm"> * WRITE TRANSFER : The I2C standard interface interprets all data as payload.</span>
<span class="cm"> *		If you want to emulate an SMBUS write transaction put the</span>
<span class="cm"> *		index as first byte(or first and second) in the payload.</span>
<span class="cm"> *		eg. a I2C transation to write 2 bytes from index 1</span>
<span class="cm"> *			wr_buff[0] = 0x1;</span>
<span class="cm"> *			wr_buff[1] = 0x23;</span>
<span class="cm"> *			wr_buff[2] = 0x46;</span>
<span class="cm"> *			msg[0].flags = 0x0;</span>
<span class="cm"> *			msg[0].len = 3;</span>
<span class="cm"> *			msg[0].buf = wr_buff;</span>
<span class="cm"> *			i2c_transfer(adap, msg, 1);</span>
<span class="cm"> *</span>
<span class="cm"> * To read or write a block of data (multiple bytes) using SMBUS emulation</span>
<span class="cm"> * please use the i2c_smbus_read_i2c_block_data()</span>
<span class="cm"> * or i2c_smbus_write_i2c_block_data() API</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nmk_i2c_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">i2c_adap</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="n">msgs</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">num_msgs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2c_get_adapdata</span><span class="p">(</span><span class="n">i2c_adap</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">)</span>
		<span class="n">regulator_enable</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
	<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">init_hw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Attempt three times to send the message queue */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* setup the i2c controller */</span>
		<span class="n">setup_i2c_controller</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_msgs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_TEN</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;10 bit addressing not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">slave_adr</span>	<span class="o">=</span> <span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span>		<span class="o">=</span> <span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span>		<span class="o">=</span> <span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">num_msgs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">nmk_i2c_xfer_one</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">)</span>
		<span class="n">regulator_disable</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* return the no. messages processed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">num_msgs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disable_interrupts() - disable the interrupts</span>
<span class="cm"> * @dev: private data of controller</span>
<span class="cm"> * @irq: interrupt number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">disable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">IRQ_MASK</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_IMSCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">I2C_CLEAR_ALL_INTS</span> <span class="o">&amp;</span> <span class="n">irq</span><span class="p">),</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_IMSCR</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * i2c_irq_handler() - interrupt routine</span>
<span class="cm"> * @irq: interrupt number</span>
<span class="cm"> * @arg: data passed to the handler</span>
<span class="cm"> *</span>
<span class="cm"> * This is the interrupt handler for the i2c driver. Currently</span>
<span class="cm"> * it handles the major interrupts like Rx &amp; Tx FIFO management</span>
<span class="cm"> * interrupts, master transaction interrupts, arbitration and</span>
<span class="cm"> * bus error interrupts. The rest of the interrupts are treated as</span>
<span class="cm"> * unhandled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">i2c_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tft</span><span class="p">,</span> <span class="n">rft</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">misr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">src</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* load Tx FIFO and Rx FIFO threshold values */</span>
	<span class="n">tft</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_TFTR</span><span class="p">);</span>
	<span class="n">rft</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_RFTR</span><span class="p">);</span>

	<span class="cm">/* read interrupt status register */</span>
	<span class="n">misr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_MISR</span><span class="p">);</span>

	<span class="n">src</span> <span class="o">=</span> <span class="n">__ffs</span><span class="p">(</span><span class="n">misr</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">src</span><span class="p">))</span> <span class="p">{</span>

	<span class="cm">/* Transmit FIFO nearly empty interrupt */</span>
	<span class="k">case</span> <span class="n">I2C_IT_TXFNE</span>:
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">operation</span> <span class="o">==</span> <span class="n">I2C_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * in read operation why do we care for writing?</span>
<span class="cm">			 * so disable the Transmit FIFO interrupt</span>
<span class="cm">			 */</span>
			<span class="n">disable_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">I2C_IT_TXFNE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fill_tx_fifo</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="n">MAX_I2C_FIFO_THRESHOLD</span> <span class="o">-</span> <span class="n">tft</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * if done, close the transfer by disabling the</span>
<span class="cm">			 * corresponding TXFNE interrupt</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">disable_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>	<span class="n">I2C_IT_TXFNE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Rx FIFO nearly full interrupt.</span>
<span class="cm">	 * This is set when the numer of entries in Rx FIFO is</span>
<span class="cm">	 * greater or equal than the threshold value programmed</span>
<span class="cm">	 * in RFT</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">I2C_IT_RXFNF</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">rft</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Read the Rx FIFO */</span>
			<span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_RFR</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span> <span class="o">-=</span> <span class="n">rft</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">xfer_bytes</span> <span class="o">+=</span> <span class="n">rft</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Rx FIFO full */</span>
	<span class="k">case</span> <span class="n">I2C_IT_RXFF</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">MAX_I2C_FIFO_THRESHOLD</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_RFR</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span> <span class="o">-=</span> <span class="n">MAX_I2C_FIFO_THRESHOLD</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">xfer_bytes</span> <span class="o">+=</span> <span class="n">MAX_I2C_FIFO_THRESHOLD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Master Transaction Done with/without stop */</span>
	<span class="k">case</span> <span class="n">I2C_IT_MTD</span>:
	<span class="k">case</span> <span class="n">I2C_IT_MTDWS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">operation</span> <span class="o">==</span> <span class="n">I2C_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_RISR</span><span class="p">)</span>
				 <span class="o">&amp;</span> <span class="n">I2C_IT_RXFE</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="o">*</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span>
					<span class="n">readb</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_RFR</span><span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">buffer</span><span class="o">++</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">xfer_bytes</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">disable_all_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">clear_all_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;%lu bytes still remain to be xfered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cli</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">init_hw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_complete</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Master Arbitration lost interrupt */</span>
	<span class="k">case</span> <span class="n">I2C_IT_MAL</span>:
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">init_hw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">i2c_set_bit</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_ICR</span><span class="p">,</span> <span class="n">I2C_IT_MAL</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_complete</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bus Error interrupt.</span>
<span class="cm">	 * This happens when an unexpected start/stop condition occurs</span>
<span class="cm">	 * during the transaction.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">I2C_IT_BERR</span>:
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="cm">/* get the status */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_SR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="n">I2C_ABORT</span><span class="p">)</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">init_hw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">i2c_set_bit</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_ICR</span><span class="p">,</span> <span class="n">I2C_IT_BERR</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_complete</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tx FIFO overrun interrupt.</span>
<span class="cm">	 * This is set when a write operation in Tx FIFO is performed and</span>
<span class="cm">	 * the Tx FIFO is full.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">I2C_IT_TXFOVR</span>:
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">init_hw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx Fifo Over run</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xfer_complete</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* unhandled interrupts by this driver - TODO*/</span>
	<span class="k">case</span> <span class="n">I2C_IT_TXFE</span>:
	<span class="k">case</span> <span class="n">I2C_IT_TXFF</span>:
	<span class="k">case</span> <span class="n">I2C_IT_RXFE</span>:
	<span class="k">case</span> <span class="n">I2C_IT_RFSR</span>:
	<span class="k">case</span> <span class="n">I2C_IT_RFSE</span>:
	<span class="k">case</span> <span class="n">I2C_IT_WTSR</span>:
	<span class="k">case</span> <span class="n">I2C_IT_STD</span>:
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unhandled Interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;spurious Interrupt..</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nmk_i2c_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_platform_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">nmk_i2c</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nmk_i2c</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nmk_i2c_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define nmk_i2c_suspend	NULL</span>
<span class="cp">#define nmk_i2c_resume	NULL</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * We use noirq so that we suspend late and resume before the wakeup interrupt</span>
<span class="cm"> * to ensure that we do the !pm_runtime_suspended() check in resume before</span>
<span class="cm"> * there has been a regular pm runtime resume (via pm_runtime_get_sync()).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">nmk_i2c_pm</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend_noirq</span>	<span class="o">=</span> <span class="n">nmk_i2c_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume_noirq</span>	<span class="o">=</span> <span class="n">nmk_i2c_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">nmk_i2c_functionality</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">I2C_FUNC_I2C</span> <span class="o">|</span> <span class="n">I2C_FUNC_SMBUS_EMUL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_algorithm</span> <span class="n">nmk_i2c_algo</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">master_xfer</span>	<span class="o">=</span> <span class="n">nmk_i2c_xfer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">functionality</span>	<span class="o">=</span> <span class="n">nmk_i2c_functionality</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">nmk_i2c_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nmk_i2c_controller</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span>
			<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nmk_i2c_dev</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nmk_i2c_dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot allocate memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_no_mem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_no_resource</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">),</span>
		<span class="n">DRIVER_NAME</span> <span class="s">&quot;I/O region&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_no_region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_no_ioremap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">i2c_irq_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">DRIVER_NAME</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot claim the irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span> <span class="o">=</span> <span class="n">regulator_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;v-i2c&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not get i2c regulator</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pm_suspend_ignore_children</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not get i2c clock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_no_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">;</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">class</span>	<span class="o">=</span> <span class="n">I2C_CLASS_HWMON</span> <span class="o">|</span> <span class="n">I2C_CLASS_SPD</span><span class="p">;</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">nmk_i2c_algo</span><span class="p">;</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">timeout</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">?</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20000</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span>
		 <span class="s">&quot;Nomadik I2C%d at %lx&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>

	<span class="cm">/* fetch the controller id */</span>
	<span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span>	<span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="cm">/* fetch the controller configuration from machine */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">clk_freq</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">clk_freq</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">slsu</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">slsu</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">tft</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">tft</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">rft</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rft</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">.</span><span class="n">sm</span>	<span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">sm</span><span class="p">;</span>

	<span class="n">i2c_set_adapdata</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		 <span class="s">&quot;initialize %s on virtual base %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_add_numbered_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to add adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_add_adap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_add_adap:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
 <span class="nl">err_no_clk:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">)</span>
		<span class="n">regulator_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
 <span class="nl">err_irq:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span><span class="p">);</span>
 <span class="nl">err_no_ioremap:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
 <span class="nl">err_no_region:</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
 <span class="nl">err_no_resource:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">err_no_mem:</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">nmk_i2c_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nmk_i2c_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">i2c_del_adapter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">adap</span><span class="p">);</span>
	<span class="n">flush_i2c_fifo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">disable_all_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">clear_all_interrupts</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* disable the controller */</span>
	<span class="n">i2c_clr_bit</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span> <span class="o">+</span> <span class="n">I2C_CR</span><span class="p">,</span> <span class="n">I2C_CR_PE</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtbase</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">)</span>
		<span class="n">regulator_put</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">regulator</span><span class="p">);</span>
	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">nmk_i2c_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRIVER_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nmk_i2c_pm</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">nmk_i2c_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">nmk_i2c_remove</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nmk_i2c_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmk_i2c_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">nmk_i2c_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nmk_i2c_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">nmk_i2c_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">nmk_i2c_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Sachin Verma, Srinidhi KASAGAR&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Nomadik/Ux500 I2C driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:&quot;</span> <span class="n">DRIVER_NAME</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
