<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › i2c › busses › i2c-i801.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>i2c-i801.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    Copyright (c) 1998 - 2002  Frodo Looijaard &lt;frodol@dds.nl&gt;,</span>
<span class="cm">    Philip Edelbrock &lt;phil@netroedge.com&gt;, and Mark D. Studebaker</span>
<span class="cm">    &lt;mdsxyz123@yahoo.com&gt;</span>
<span class="cm">    Copyright (C) 2007 - 2012  Jean Delvare &lt;khali@linux-fr.org&gt;</span>
<span class="cm">    Copyright (C) 2010         Intel Corporation,</span>
<span class="cm">                               David Woodhouse &lt;dwmw2@infradead.org&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">  Supports the following Intel I/O Controller Hubs (ICH):</span>

<span class="cm">                                  I/O                     Block   I2C</span>
<span class="cm">                                  region  SMBus   Block   proc.   block</span>
<span class="cm">  Chip name             PCI ID    size    PEC     buffer  call    read</span>
<span class="cm">  ----------------------------------------------------------------------</span>
<span class="cm">  82801AA  (ICH)        0x2413     16      no      no      no      no</span>
<span class="cm">  82801AB  (ICH0)       0x2423     16      no      no      no      no</span>
<span class="cm">  82801BA  (ICH2)       0x2443     16      no      no      no      no</span>
<span class="cm">  82801CA  (ICH3)       0x2483     32     soft     no      no      no</span>
<span class="cm">  82801DB  (ICH4)       0x24c3     32     hard     yes     no      no</span>
<span class="cm">  82801E   (ICH5)       0x24d3     32     hard     yes     yes     yes</span>
<span class="cm">  6300ESB               0x25a4     32     hard     yes     yes     yes</span>
<span class="cm">  82801F   (ICH6)       0x266a     32     hard     yes     yes     yes</span>
<span class="cm">  6310ESB/6320ESB       0x269b     32     hard     yes     yes     yes</span>
<span class="cm">  82801G   (ICH7)       0x27da     32     hard     yes     yes     yes</span>
<span class="cm">  82801H   (ICH8)       0x283e     32     hard     yes     yes     yes</span>
<span class="cm">  82801I   (ICH9)       0x2930     32     hard     yes     yes     yes</span>
<span class="cm">  EP80579 (Tolapai)     0x5032     32     hard     yes     yes     yes</span>
<span class="cm">  ICH10                 0x3a30     32     hard     yes     yes     yes</span>
<span class="cm">  ICH10                 0x3a60     32     hard     yes     yes     yes</span>
<span class="cm">  5/3400 Series (PCH)   0x3b30     32     hard     yes     yes     yes</span>
<span class="cm">  6 Series (PCH)        0x1c22     32     hard     yes     yes     yes</span>
<span class="cm">  Patsburg (PCH)        0x1d22     32     hard     yes     yes     yes</span>
<span class="cm">  Patsburg (PCH) IDF    0x1d70     32     hard     yes     yes     yes</span>
<span class="cm">  Patsburg (PCH) IDF    0x1d71     32     hard     yes     yes     yes</span>
<span class="cm">  Patsburg (PCH) IDF    0x1d72     32     hard     yes     yes     yes</span>
<span class="cm">  DH89xxCC (PCH)        0x2330     32     hard     yes     yes     yes</span>
<span class="cm">  Panther Point (PCH)   0x1e22     32     hard     yes     yes     yes</span>
<span class="cm">  Lynx Point (PCH)      0x8c22     32     hard     yes     yes     yes</span>

<span class="cm">  Features supported by this driver:</span>
<span class="cm">  Software PEC                     no</span>
<span class="cm">  Hardware PEC                     yes</span>
<span class="cm">  Block buffer                     yes</span>
<span class="cm">  Block process call transaction   no</span>
<span class="cm">  I2C block read transaction       yes  (doesn&#39;t use the block buffer)</span>
<span class="cm">  Slave mode                       no</span>

<span class="cm">  See the file Documentation/i2c/busses/i2c-i801 for details.</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cm">/* I801 SMBus address offsets */</span>
<span class="cp">#define SMBHSTSTS(p)	(0 + (p)-&gt;smba)</span>
<span class="cp">#define SMBHSTCNT(p)	(2 + (p)-&gt;smba)</span>
<span class="cp">#define SMBHSTCMD(p)	(3 + (p)-&gt;smba)</span>
<span class="cp">#define SMBHSTADD(p)	(4 + (p)-&gt;smba)</span>
<span class="cp">#define SMBHSTDAT0(p)	(5 + (p)-&gt;smba)</span>
<span class="cp">#define SMBHSTDAT1(p)	(6 + (p)-&gt;smba)</span>
<span class="cp">#define SMBBLKDAT(p)	(7 + (p)-&gt;smba)</span>
<span class="cp">#define SMBPEC(p)	(8 + (p)-&gt;smba)		</span><span class="cm">/* ICH3 and later */</span><span class="cp"></span>
<span class="cp">#define SMBAUXSTS(p)	(12 + (p)-&gt;smba)	</span><span class="cm">/* ICH4 and later */</span><span class="cp"></span>
<span class="cp">#define SMBAUXCTL(p)	(13 + (p)-&gt;smba)	</span><span class="cm">/* ICH4 and later */</span><span class="cp"></span>

<span class="cm">/* PCI Address Constants */</span>
<span class="cp">#define SMBBAR		4</span>
<span class="cp">#define SMBHSTCFG	0x040</span>

<span class="cm">/* Host configuration bits for SMBHSTCFG */</span>
<span class="cp">#define SMBHSTCFG_HST_EN	1</span>
<span class="cp">#define SMBHSTCFG_SMB_SMI_EN	2</span>
<span class="cp">#define SMBHSTCFG_I2C_EN	4</span>

<span class="cm">/* Auxiliary control register bits, ICH4+ only */</span>
<span class="cp">#define SMBAUXCTL_CRC		1</span>
<span class="cp">#define SMBAUXCTL_E32B		2</span>

<span class="cm">/* kill bit for SMBHSTCNT */</span>
<span class="cp">#define SMBHSTCNT_KILL		2</span>

<span class="cm">/* Other settings */</span>
<span class="cp">#define MAX_RETRIES		400</span>
<span class="cp">#define ENABLE_INT9		0	</span><span class="cm">/* set to 0x01 to enable - untested */</span><span class="cp"></span>

<span class="cm">/* I801 command constants */</span>
<span class="cp">#define I801_QUICK		0x00</span>
<span class="cp">#define I801_BYTE		0x04</span>
<span class="cp">#define I801_BYTE_DATA		0x08</span>
<span class="cp">#define I801_WORD_DATA		0x0C</span>
<span class="cp">#define I801_PROC_CALL		0x10	</span><span class="cm">/* unimplemented */</span><span class="cp"></span>
<span class="cp">#define I801_BLOCK_DATA		0x14</span>
<span class="cp">#define I801_I2C_BLOCK_DATA	0x18	</span><span class="cm">/* ICH5 and later */</span><span class="cp"></span>
<span class="cp">#define I801_BLOCK_LAST		0x34</span>
<span class="cp">#define I801_I2C_BLOCK_LAST	0x38	</span><span class="cm">/* ICH5 and later */</span><span class="cp"></span>
<span class="cp">#define I801_START		0x40</span>
<span class="cp">#define I801_PEC_EN		0x80	</span><span class="cm">/* ICH3 and later */</span><span class="cp"></span>

<span class="cm">/* I801 Hosts Status register bits */</span>
<span class="cp">#define SMBHSTSTS_BYTE_DONE	0x80</span>
<span class="cp">#define SMBHSTSTS_INUSE_STS	0x40</span>
<span class="cp">#define SMBHSTSTS_SMBALERT_STS	0x20</span>
<span class="cp">#define SMBHSTSTS_FAILED	0x10</span>
<span class="cp">#define SMBHSTSTS_BUS_ERR	0x08</span>
<span class="cp">#define SMBHSTSTS_DEV_ERR	0x04</span>
<span class="cp">#define SMBHSTSTS_INTR		0x02</span>
<span class="cp">#define SMBHSTSTS_HOST_BUSY	0x01</span>

<span class="cp">#define STATUS_FLAGS		(SMBHSTSTS_BYTE_DONE | SMBHSTSTS_FAILED | \</span>
<span class="cp">				 SMBHSTSTS_BUS_ERR | SMBHSTSTS_DEV_ERR | \</span>
<span class="cp">				 SMBHSTSTS_INTR)</span>

<span class="cm">/* Older devices have their ID defined in &lt;linux/pci_ids.h&gt; */</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_COUGARPOINT_SMBUS	0x1c22</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS	0x1d22</span>
<span class="cm">/* Patsburg also has three &#39;Integrated Device Function&#39; SMBus controllers */</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF0	0x1d70</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF1	0x1d71</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF2	0x1d72</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_PANTHERPOINT_SMBUS	0x1e22</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_DH89XXCC_SMBUS	0x2330</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_5_3400_SERIES_SMBUS	0x3b30</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_LYNXPOINT_SMBUS	0x8c22</span>

<span class="k">struct</span> <span class="n">i801_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="n">adapter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">original_hstcfg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">features</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">i801_driver</span><span class="p">;</span>

<span class="cp">#define FEATURE_SMBUS_PEC	(1 &lt;&lt; 0)</span>
<span class="cp">#define FEATURE_BLOCK_BUFFER	(1 &lt;&lt; 1)</span>
<span class="cp">#define FEATURE_BLOCK_PROC	(1 &lt;&lt; 2)</span>
<span class="cp">#define FEATURE_I2C_BLOCK_READ	(1 &lt;&lt; 3)</span>
<span class="cm">/* Not really a feature, but it&#39;s convenient to handle it as such */</span>
<span class="cp">#define FEATURE_IDF		(1 &lt;&lt; 15)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">i801_feature_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;SMBus PEC&quot;</span><span class="p">,</span>
	<span class="s">&quot;Block buffer&quot;</span><span class="p">,</span>
	<span class="s">&quot;Block process call&quot;</span><span class="p">,</span>
	<span class="s">&quot;I2C block read&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">disable_features</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">disable_features</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">disable_features</span><span class="p">,</span> <span class="s">&quot;Disable selected driver features&quot;</span><span class="p">);</span>

<span class="cm">/* Make sure the SMBus host is ready to start transmitting.</span>
<span class="cm">   Return 0 if it is, -EBUSY if it is not. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_check_pre</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_HOST_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SMBus is busy, can&#39;t use it!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">&amp;=</span> <span class="n">STATUS_FLAGS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Clearing status flags (%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">status</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STATUS_FLAGS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Failed clearing status flags (%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert the status register to an error code, and clear it. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_check_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If the SMBus is still busy, we give up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Transaction timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* try to stop the current command */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Terminating the current operation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">|</span> <span class="n">SMBHSTCNT_KILL</span><span class="p">,</span>
		       <span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">SMBHSTCNT_KILL</span><span class="p">),</span>
		       <span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>

		<span class="cm">/* Check if it worked */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_HOST_BUSY</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_FAILED</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Failed terminating the transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">STATUS_FLAGS</span><span class="p">,</span> <span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Transaction failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_DEV_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No response</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_BUS_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Lost arbitration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear error flags */</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">STATUS_FLAGS</span><span class="p">,</span> <span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">STATUS_FLAGS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed clearing status &quot;</span>
				 <span class="s">&quot;flags at end of transaction (%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xact</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i801_check_pre</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* the current contents of SMBHSTCNT can be overwritten, since PEC,</span>
<span class="cm">	 * INTREN, SMBSCMD are passed in xact */</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">xact</span> <span class="o">|</span> <span class="n">I801_START</span><span class="p">,</span> <span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>

	<span class="cm">/* We will always wait for a fraction of a second! */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_HOST_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">timeout</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">MAX_RETRIES</span><span class="p">));</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i801_check_post</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">MAX_RETRIES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">outb_p</span><span class="p">(</span><span class="n">SMBHSTSTS_INTR</span><span class="p">,</span> <span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* wait for INTR bit as advised by Intel */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">i801_wait_hwpec</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_INTR</span><span class="p">))</span>
		 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">timeout</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">MAX_RETRIES</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">MAX_RETRIES</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PEC Timeout!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">outb_p</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_block_transaction_by_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
					   <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					   <span class="kt">char</span> <span class="n">read_write</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hwpec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span> <span class="cm">/* reset the data buffer index */</span>

	<span class="cm">/* Use 32-byte buffer to process this transaction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">SMBHSTDAT0</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">SMBBLKDAT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">i801_transaction</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">I801_BLOCK_DATA</span> <span class="o">|</span> <span class="n">ENABLE_INT9</span> <span class="o">|</span>
				  <span class="n">I801_PEC_EN</span> <span class="o">*</span> <span class="n">hwpec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTDAT0</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>

		<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBBLKDAT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_block_transaction_byte_by_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
					       <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					       <span class="kt">char</span> <span class="n">read_write</span><span class="p">,</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">hwpec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">smbcmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i801_check_pre</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">SMBHSTDAT0</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">SMBBLKDAT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">)</span>
				<span class="n">smbcmd</span> <span class="o">=</span> <span class="n">I801_I2C_BLOCK_LAST</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">smbcmd</span> <span class="o">=</span> <span class="n">I801_BLOCK_LAST</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span>
			 <span class="o">&amp;&amp;</span> <span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span>
				<span class="n">smbcmd</span> <span class="o">=</span> <span class="n">I801_I2C_BLOCK_DATA</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">smbcmd</span> <span class="o">=</span> <span class="n">I801_BLOCK_DATA</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">smbcmd</span> <span class="o">|</span> <span class="n">ENABLE_INT9</span><span class="p">,</span> <span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">|</span> <span class="n">I801_START</span><span class="p">,</span>
			       <span class="n">SMBHSTCNT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>

		<span class="cm">/* We will always wait for a fraction of a second! */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">usleep_range</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SMBHSTSTS_BYTE_DONE</span><span class="p">))</span>
			 <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">timeout</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">MAX_RETRIES</span><span class="p">));</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">i801_check_post</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">MAX_RETRIES</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span>
		 <span class="o">&amp;&amp;</span> <span class="n">command</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTDAT0</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Illegal SMBus block read size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">len</span><span class="p">);</span>
				<span class="cm">/* Recover */</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&amp;</span>
				       <span class="n">SMBHSTSTS_HOST_BUSY</span><span class="p">)</span>
					<span class="n">outb_p</span><span class="p">(</span><span class="n">SMBHSTSTS_BYTE_DONE</span><span class="p">,</span>
					       <span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
				<span class="n">outb_p</span><span class="p">(</span><span class="n">SMBHSTSTS_INTR</span><span class="p">,</span> <span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Retrieve/store value in SMBBLKDAT */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBBLKDAT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">SMBBLKDAT</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>

		<span class="cm">/* signals SMBBLKDAT ready */</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">SMBHSTSTS_BYTE_DONE</span> <span class="o">|</span> <span class="n">SMBHSTSTS_INTR</span><span class="p">,</span> <span class="n">SMBHSTSTS</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_set_block_buffer_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">|</span> <span class="n">SMBAUXCTL_E32B</span><span class="p">,</span> <span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">SMBAUXCTL_E32B</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Block transaction function */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_block_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
				  <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">char</span> <span class="n">read_write</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hwpec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">hostc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* set I2C_EN bit in configuration register */</span>
			<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">SMBHSTCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hostc</span><span class="p">);</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">SMBHSTCFG</span><span class="p">,</span>
					      <span class="n">hostc</span> <span class="o">|</span> <span class="n">SMBHSTCFG_I2C_EN</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FEATURE_I2C_BLOCK_READ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;I2C block read is unsupported!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span>
	 <span class="o">||</span> <span class="n">command</span> <span class="o">==</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span>
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>	<span class="cm">/* max for SMBus block reads */</span>
	<span class="p">}</span>

	<span class="cm">/* Experience has shown that the block buffer can only be used for</span>
<span class="cm">	   SMBus (not I2C) block transactions, even though the datasheet</span>
<span class="cm">	   doesn&#39;t mention this limitation. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FEATURE_BLOCK_BUFFER</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="n">command</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span>
	 <span class="o">&amp;&amp;</span> <span class="n">i801_set_block_buffer_mode</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i801_block_transaction_by_block</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
							 <span class="n">read_write</span><span class="p">,</span> <span class="n">hwpec</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i801_block_transaction_byte_by_byte</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
							     <span class="n">read_write</span><span class="p">,</span>
							     <span class="n">command</span><span class="p">,</span> <span class="n">hwpec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hwpec</span><span class="p">)</span>
		<span class="n">i801_wait_hwpec</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span>
	 <span class="o">&amp;&amp;</span> <span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* restore saved configuration register value */</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">SMBHSTCFG</span><span class="p">,</span> <span class="n">hostc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return negative errno on error. */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">i801_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">,</span> <span class="n">u16</span> <span class="n">addr</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="n">read_write</span><span class="p">,</span> <span class="n">u8</span> <span class="n">command</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hwpec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">xact</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">i2c_get_adapdata</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>

	<span class="n">hwpec</span> <span class="o">=</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FEATURE_SMBUS_PEC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_CLIENT_PEC</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_QUICK</span>
		<span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_QUICK</span>:
		<span class="n">outb_p</span><span class="p">(((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">),</span>
		       <span class="n">SMBHSTADD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">xact</span> <span class="o">=</span> <span class="n">I801_QUICK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_BYTE</span>:
		<span class="n">outb_p</span><span class="p">(((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">),</span>
		       <span class="n">SMBHSTADD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">SMBHSTCMD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">xact</span> <span class="o">=</span> <span class="n">I801_BYTE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_BYTE_DATA</span>:
		<span class="n">outb_p</span><span class="p">(((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">),</span>
		       <span class="n">SMBHSTADD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">SMBHSTCMD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">,</span> <span class="n">SMBHSTDAT0</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">xact</span> <span class="o">=</span> <span class="n">I801_BYTE_DATA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_WORD_DATA</span>:
		<span class="n">outb_p</span><span class="p">(((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">),</span>
		       <span class="n">SMBHSTADD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">SMBHSTCMD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">SMBHSTDAT0</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
			<span class="n">outb_p</span><span class="p">((</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">SMBHSTDAT1</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">xact</span> <span class="o">=</span> <span class="n">I801_WORD_DATA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_BLOCK_DATA</span>:
		<span class="n">outb_p</span><span class="p">(((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">),</span>
		       <span class="n">SMBHSTADD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">SMBHSTCMD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">block</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span>:
		<span class="cm">/* NB: page 240 of ICH5 datasheet shows that the R/#W</span>
<span class="cm">		 * bit should be cleared here, even when reading */</span>
		<span class="n">outb_p</span><span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SMBHSTADD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* NB: page 240 of ICH5 datasheet also shows</span>
<span class="cm">			 * that DATA1 is the cmd field when reading */</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">SMBHSTDAT1</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">outb_p</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">SMBHSTCMD</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="n">block</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unsupported transaction %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwpec</span><span class="p">)</span>	<span class="cm">/* enable/disable hardware PEC */</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">|</span> <span class="n">SMBAUXCTL_CRC</span><span class="p">,</span> <span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">SMBAUXCTL_CRC</span><span class="p">),</span>
		       <span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i801_block_transaction</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">read_write</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					     <span class="n">hwpec</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i801_transaction</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">xact</span> <span class="o">|</span> <span class="n">ENABLE_INT9</span><span class="p">);</span>

	<span class="cm">/* Some BIOSes don&#39;t like it when PEC is enabled at reboot or resume</span>
<span class="cm">	   time, so we forcibly disable it after every transaction. Turn off</span>
<span class="cm">	   E32B for the same reason. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hwpec</span> <span class="o">||</span> <span class="n">block</span><span class="p">)</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&amp;</span>
		       <span class="o">~</span><span class="p">(</span><span class="n">SMBAUXCTL_CRC</span> <span class="o">|</span> <span class="n">SMBAUXCTL_E32B</span><span class="p">),</span> <span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">xact</span> <span class="o">==</span> <span class="n">I801_QUICK</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">xact</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I801_BYTE</span>:	<span class="cm">/* Result put in SMBHSTDAT0 */</span>
	<span class="k">case</span> <span class="n">I801_BYTE_DATA</span>:
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">byte</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTDAT0</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I801_WORD_DATA</span>:
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span> <span class="o">=</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTDAT0</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">+</span>
			     <span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBHSTDAT1</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">u32</span> <span class="nf">i801_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">i2c_get_adapdata</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">I2C_FUNC_SMBUS_QUICK</span> <span class="o">|</span> <span class="n">I2C_FUNC_SMBUS_BYTE</span> <span class="o">|</span>
	       <span class="n">I2C_FUNC_SMBUS_BYTE_DATA</span> <span class="o">|</span> <span class="n">I2C_FUNC_SMBUS_WORD_DATA</span> <span class="o">|</span>
	       <span class="n">I2C_FUNC_SMBUS_BLOCK_DATA</span> <span class="o">|</span> <span class="n">I2C_FUNC_SMBUS_WRITE_I2C_BLOCK</span> <span class="o">|</span>
	       <span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FEATURE_SMBUS_PEC</span><span class="p">)</span> <span class="o">?</span> <span class="n">I2C_FUNC_SMBUS_PEC</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
	       <span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FEATURE_I2C_BLOCK_READ</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">I2C_FUNC_SMBUS_READ_I2C_BLOCK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2c_algorithm</span> <span class="n">smbus_algorithm</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">smbus_xfer</span>	<span class="o">=</span> <span class="n">i801_access</span><span class="p">,</span>
	<span class="p">.</span><span class="n">functionality</span>	<span class="o">=</span> <span class="n">i801_func</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">i801_ids</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82801AA_3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82801AB_3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82801BA_2</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82801CA_3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82801DB_3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82801EB_3</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_ESB_4</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_ICH6_16</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_ICH7_17</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_ESB2_17</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_ICH8_5</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_ICH9_6</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_EP80579_1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_ICH10_4</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_ICH10_5</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_5_3400_SERIES_SMBUS</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_COUGARPOINT_SMBUS</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF0</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF1</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF2</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_DH89XXCC_SMBUS</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_PANTHERPOINT_SMBUS</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_LYNXPOINT_SMBUS</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">i801_ids</span><span class="p">);</span>

<span class="cp">#if defined CONFIG_X86 &amp;&amp; defined CONFIG_DMI</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">apanel_addr</span><span class="p">;</span>

<span class="cm">/* Scan the system ROM for the signature &quot;FJKEYINF&quot; */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">bios_signature</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">signature</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;FJKEYINF&quot;</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mh">0x10000</span><span class="p">;</span> <span class="n">offset</span> <span class="o">+=</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_signature</span><span class="p">(</span><span class="n">bios</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">bios</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">input_apanel_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bios</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">bios</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="mh">0xF0000</span><span class="p">,</span> <span class="mh">0x10000</span><span class="p">);</span> <span class="cm">/* Can&#39;t fail */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">bios_signature</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* just use the first address */</span>
		<span class="n">apanel_addr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">bios</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dmi_onboard_device_info</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i2c_addr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">i2c_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dmi_onboard_device_info</span> <span class="n">__devinitdata</span> <span class="n">dmi_devices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;Syleus&quot;</span><span class="p">,</span> <span class="n">DMI_DEV_TYPE_OTHER</span><span class="p">,</span> <span class="mh">0x73</span><span class="p">,</span> <span class="s">&quot;fscsyl&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Hermes&quot;</span><span class="p">,</span> <span class="n">DMI_DEV_TYPE_OTHER</span><span class="p">,</span> <span class="mh">0x73</span><span class="p">,</span> <span class="s">&quot;fscher&quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Hades&quot;</span><span class="p">,</span>  <span class="n">DMI_DEV_TYPE_OTHER</span><span class="p">,</span> <span class="mh">0x73</span><span class="p">,</span> <span class="s">&quot;fschds&quot;</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">dmi_check_onboard_device</span><span class="p">(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="n">info</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dmi_devices</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &amp; ~0x80, ignore enabled/disabled bit */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dmi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dmi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_board_info</span><span class="p">));</span>
		<span class="n">info</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">dmi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i2c_addr</span><span class="p">;</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">dmi_devices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">i2c_type</span><span class="p">,</span> <span class="n">I2C_NAME_SIZE</span><span class="p">);</span>
		<span class="n">i2c_new_device</span><span class="p">(</span><span class="n">adap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* We use our own function to check for onboard devices instead of</span>
<span class="cm">   dmi_find_device() as some buggy BIOS&#39;s have the devices we are interested</span>
<span class="cm">   in marked as disabled */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">dmi_check_onboard_devices</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_header</span> <span class="o">*</span><span class="n">dm</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dm</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">dm</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dmi_header</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">dm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">dm</span><span class="p">)</span> <span class="o">+</span> <span class="n">dm</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">type</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">u8</span> <span class="n">s</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">s</span><span class="o">--</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">name</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">s</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* Bogus string reference */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dmi_check_onboard_device</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">adap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Register optional slaves */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">i801_probe_optional_slaves</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Only register slaves on main SMBus channel */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FEATURE_IDF</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">apanel_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2c_board_info</span> <span class="n">info</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_board_info</span><span class="p">));</span>
		<span class="n">info</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">apanel_addr</span><span class="p">;</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;fujitsu_apanel&quot;</span><span class="p">,</span> <span class="n">I2C_NAME_SIZE</span><span class="p">);</span>
		<span class="n">i2c_new_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dmi_name_in_vendors</span><span class="p">(</span><span class="s">&quot;FUJITSU&quot;</span><span class="p">))</span>
		<span class="n">dmi_walk</span><span class="p">(</span><span class="n">dmi_check_onboard_devices</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">input_apanel_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">i801_probe_optional_slaves</span><span class="p">(</span><span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_X86 &amp;&amp; CONFIG_DMI */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">i801_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">i2c_set_adapdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">I2C_CLASS_HWMON</span> <span class="o">|</span> <span class="n">I2C_CLASS_SPD</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">.</span><span class="n">algo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smbus_algorithm</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF0</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF1</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF2</span>:
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">FEATURE_IDF</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="nl">default:</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">FEATURE_I2C_BLOCK_READ</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INTEL_82801DB_3</span>:
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">FEATURE_SMBUS_PEC</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">FEATURE_BLOCK_BUFFER</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INTEL_82801CA_3</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INTEL_82801BA_2</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INTEL_82801AB_3</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INTEL_82801AA_3</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disable features on user request */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">i801_feature_names</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">disable_features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s disabled by user</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">i801_feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">disable_features</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to enable SMBus PCI device (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Determine the address of the SMBus area */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">smba</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SMBBAR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">smba</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SMBus base address uninitialized, &quot;</span>
			<span class="s">&quot;upgrade BIOS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">acpi_check_resource_conflict</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">SMBBAR</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SMBBAR</span><span class="p">,</span> <span class="n">i801_driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to request SMBus region &quot;</span>
			<span class="s">&quot;0x%lx-0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">smba</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pci_resource_end</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SMBBAR</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">SMBHSTCFG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">original_hstcfg</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SMBHSTCFG_I2C_EN</span><span class="p">;</span>	<span class="cm">/* SMBus timing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">SMBHSTCFG_HST_EN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabling SMBus device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="n">SMBHSTCFG_HST_EN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">SMBHSTCFG</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="n">SMBHSTCFG_SMB_SMI_EN</span><span class="p">)</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SMBus using interrupt SMI#</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SMBus using PCI Interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Clear special mode bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FEATURE_SMBUS_PEC</span> <span class="o">|</span> <span class="n">FEATURE_BLOCK_BUFFER</span><span class="p">))</span>
		<span class="n">outb_p</span><span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">))</span> <span class="o">&amp;</span>
		       <span class="o">~</span><span class="p">(</span><span class="n">SMBAUXCTL_CRC</span> <span class="o">|</span> <span class="n">SMBAUXCTL_E32B</span><span class="p">),</span> <span class="n">SMBAUXCTL</span><span class="p">(</span><span class="n">priv</span><span class="p">));</span>

	<span class="cm">/* set up the sysfs linkage to our parent device */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">.</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Retry up to 3 times on lost arbitration */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">.</span><span class="n">retries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">.</span><span class="n">name</span><span class="p">),</span>
		<span class="s">&quot;SMBus I801 adapter at %04lx&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">smba</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">i2c_add_adapter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to add SMBus adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i801_probe_optional_slaves</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">exit_release:</span>
	<span class="n">pci_release_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SMBBAR</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">i801_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">i2c_del_adapter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SMBHSTCFG</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">original_hstcfg</span><span class="p">);</span>
	<span class="n">pci_release_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SMBBAR</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * do not call pci_disable_device(dev) since it can cause hard hangs on</span>
<span class="cm">	 * some systems during power-off (eg. Fujitsu-Siemens Lifebook E8010)</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">mesg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i801_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SMBHSTCFG</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">original_hstcfg</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pci_choose_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mesg</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i801_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define i801_suspend NULL</span>
<span class="cp">#define i801_resume NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">i801_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;i801_smbus&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">i801_ids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">i801_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">i801_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">i801_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">i801_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">i2c_i801_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dmi_name_in_vendors</span><span class="p">(</span><span class="s">&quot;FUJITSU&quot;</span><span class="p">))</span>
		<span class="n">input_apanel_init</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i801_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i2c_i801_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i801_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mark D. Studebaker &lt;mdsxyz123@yahoo.com&gt;, &quot;</span>
	      <span class="s">&quot;Jean Delvare &lt;khali@linux-fr.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;I801 SMBus driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">i2c_i801_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i2c_i801_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
