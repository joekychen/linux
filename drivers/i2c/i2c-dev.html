<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › i2c › i2c-dev.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>i2c-dev.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">    i2c-dev.c - i2c-bus driver, char device interface</span>

<span class="cm">    Copyright (C) 1995-97 Simon G. Vogl</span>
<span class="cm">    Copyright (C) 1998-99 Frodo Looijaard &lt;frodol@dds.nl&gt;</span>
<span class="cm">    Copyright (C) 2003 Greg Kroah-Hartman &lt;greg@kroah.com&gt;</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,</span>
<span class="cm">    MA 02110-1301 USA.</span>
<span class="cm">*/</span>

<span class="cm">/* Note that this is a complete rewrite of Simon Vogl&#39;s i2c-dev module.</span>
<span class="cm">   But I have used so much of his original code and ideas that it seems</span>
<span class="cm">   only fair to recognize him as co-author -- Frodo */</span>

<span class="cm">/* The I2C_RDWR ioctl code is written by Kolja Waschk &lt;waschk@telos.de&gt; */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/i2c.h&gt;</span>
<span class="cp">#include &lt;linux/i2c-dev.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * An i2c_dev represents an i2c_adapter ... an I2C or SMBus master, not a</span>
<span class="cm"> * slave (i2c_client) with which messages will be exchanged.  It&#39;s coupled</span>
<span class="cm"> * with a character special file which is accessed by user mode drivers.</span>
<span class="cm"> *</span>
<span class="cm"> * The list of i2c_dev structures is parallel to the i2c_adapter lists</span>
<span class="cm"> * maintained by the driver model, and is updated using bus notifications.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2c_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define I2C_MINORS	256</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">i2c_dev_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">i2c_dev_list_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="nf">i2c_dev_get_by_minor</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="n">i2c_dev</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_dev_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">i2c_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2c_dev_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i2c_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_dev_list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i2c_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="nf">get_free_i2c_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="n">i2c_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">I2C_MINORS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;i2c-dev: Out of device minors (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">i2c_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">i2c_dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">adap</span> <span class="o">=</span> <span class="n">adap</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_dev_list_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2c_dev_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_dev_list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i2c_dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">return_i2c_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="n">i2c_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_dev_list_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_dev_list_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2c_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_adapter_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="n">i2c_dev</span> <span class="o">=</span> <span class="n">i2c_dev_get_by_minor</span><span class="p">(</span><span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">show_adapter_name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> * After opening an instance of this character special file, a file</span>
<span class="cm"> * descriptor starts out associated only with an i2c_adapter (and bus).</span>
<span class="cm"> *</span>
<span class="cm"> * Using the I2C_RDWR ioctl(), you can then *immediately* issue i2c_msg</span>
<span class="cm"> * traffic to any devices on the bus used by that adapter.  That&#39;s because</span>
<span class="cm"> * the i2c_msg vectors embed all the addressing information they need, and</span>
<span class="cm"> * are submitted directly to an i2c_adapter.  However, SMBus-only adapters</span>
<span class="cm"> * don&#39;t support that interface.</span>
<span class="cm"> *</span>
<span class="cm"> * To use read()/write() system calls on that file descriptor, or to use</span>
<span class="cm"> * SMBus interfaces (and work with SMBus-only hosts!), you must first issue</span>
<span class="cm"> * an I2C_SLAVE (or I2C_SLAVE_FORCE) ioctl.  That configures an anonymous</span>
<span class="cm"> * (never registered) i2c_client so it holds the addressing information</span>
<span class="cm"> * needed by those system calls and by this SMBus interface.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">i2cdev_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">8192</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;i2c-dev: i2c-%d reading %zu bytes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">iminor</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_master_recv</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">i2cdev_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">8192</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;i2c-dev: i2c-%d writing %zu bytes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">iminor</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2c_master_send</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">i2c_verify_client</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span> <span class="o">||</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">addrp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* walk up mux tree */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_check_mux_parents</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i2c_parent_is_i2c_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">i2cdev_check</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2cdev_check_mux_parents</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* recurse down mux tree */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_check_mux_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addrp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addrp</span><span class="p">,</span>
						<span class="n">i2cdev_check_mux_children</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2cdev_check</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">addrp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This address checking function differs from the one in i2c-core</span>
<span class="cm">   in that it considers an address with a registered device, but no</span>
<span class="cm">   driver bound to it, as NOT busy. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_check_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i2c_parent_is_i2c_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2cdev_check_mux_parents</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">device_for_each_child</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span>
						<span class="n">i2cdev_check_mux_children</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">i2cdev_ioctl_rdrw</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_rdwr_ioctl_data</span> <span class="n">rdwr_arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_msg</span> <span class="o">*</span><span class="n">rdwr_pa</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">__user</span> <span class="o">**</span><span class="n">data_ptrs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdwr_arg</span><span class="p">,</span>
			   <span class="p">(</span><span class="k">struct</span> <span class="n">i2c_rdwr_ioctl_data</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">rdwr_arg</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Put an arbitrary limit on the number of messages that can</span>
<span class="cm">	 * be sent at once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rdwr_arg</span><span class="p">.</span><span class="n">nmsgs</span> <span class="o">&gt;</span> <span class="n">I2C_RDRW_IOCTL_MAX_MSGS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">rdwr_pa</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">rdwr_arg</span><span class="p">.</span><span class="n">msgs</span><span class="p">,</span>
			      <span class="n">rdwr_arg</span><span class="p">.</span><span class="n">nmsgs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_msg</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">);</span>

	<span class="n">data_ptrs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">rdwr_arg</span><span class="p">.</span><span class="n">nmsgs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_ptrs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rdwr_arg</span><span class="p">.</span><span class="n">nmsgs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Limit the size of the message to a sane amount */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data_ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">;</span>
		<span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">data_ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the message length is received from the slave (similar</span>
<span class="cm">		 * to SMBus block read), we must ensure that the buffer will</span>
<span class="cm">		 * be large enough to cope with a message length of</span>
<span class="cm">		 * I2C_SMBUS_BLOCK_MAX as this is the maximum underlying bus</span>
<span class="cm">		 * drivers allow. The first byte in the buffer must be</span>
<span class="cm">		 * pre-filled with the number of extra bytes, which must be</span>
<span class="cm">		 * at least one to hold the message length, but can be</span>
<span class="cm">		 * greater (for example to account for a checksum byte at</span>
<span class="cm">		 * the end of the message.)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RECV_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RD</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span>
			    <span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
					     <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data_ptrs</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">i2c_transfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rdwr_pa</span><span class="p">,</span> <span class="n">rdwr_arg</span><span class="p">.</span><span class="n">nmsgs</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_RD</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">data_ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">,</span>
					 <span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">))</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data_ptrs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rdwr_pa</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">i2cdev_ioctl_smbus</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_smbus_ioctl_data</span> <span class="n">data_arg</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">i2c_smbus_data</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datasize</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_arg</span><span class="p">,</span>
			   <span class="p">(</span><span class="k">struct</span> <span class="n">i2c_smbus_ioctl_data</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2c_smbus_ioctl_data</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_BYTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_QUICK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_WORD_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_PROC_CALL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_BLOCK_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_I2C_BLOCK_BROKEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_BLOCK_PROC_CALL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;size out of range (%x) in ioctl I2C_SMBUS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">data_arg</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Note that I2C_SMBUS_READ and I2C_SMBUS_WRITE are 0 and 1,</span>
<span class="cm">	   so the check is valid if size==I2C_SMBUS_QUICK too. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span> <span class="o">!=</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;read_write out of range (%x) in ioctl I2C_SMBUS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Note that command values are always valid! */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_QUICK</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_BYTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">)))</span>
		<span class="cm">/* These are special: we do not use data */</span>
		<span class="k">return</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
				      <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span><span class="p">,</span>
				      <span class="n">data_arg</span><span class="p">.</span><span class="n">command</span><span class="p">,</span> <span class="n">data_arg</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;data is NULL pointer in ioctl I2C_SMBUS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_BYTE_DATA</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_BYTE</span><span class="p">))</span>
		<span class="n">datasize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">byte</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WORD_DATA</span><span class="p">)</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_PROC_CALL</span><span class="p">))</span>
		<span class="n">datasize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">word</span><span class="p">);</span>
	<span class="k">else</span> <span class="cm">/* size == smbus block, i2c block, or block proc. call */</span>
		<span class="n">datasize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_PROC_CALL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_BLOCK_PROC_CALL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">data_arg</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">datasize</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_I2C_BLOCK_BROKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Convert old I2C block commands to the new</span>
<span class="cm">		   convention. This preserves binary compatibility. */</span>
		<span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">I2C_SMBUS_I2C_BLOCK_DATA</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)</span>
			<span class="n">temp</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I2C_SMBUS_BLOCK_MAX</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">i2c_smbus_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
	      <span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span><span class="p">,</span> <span class="n">data_arg</span><span class="p">.</span><span class="n">command</span><span class="p">,</span> <span class="n">data_arg</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_PROC_CALL</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">I2C_SMBUS_BLOCK_PROC_CALL</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">I2C_SMBUS_READ</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">data_arg</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">datasize</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">i2cdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">funcs</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ioctl, cmd=0x%02x, arg=0x%02lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2C_SLAVE</span>:
	<span class="k">case</span> <span class="n">I2C_SLAVE_FORCE</span>:
		<span class="cm">/* NOTE:  devices set up to work with &quot;new style&quot; drivers</span>
<span class="cm">		 * can&#39;t use I2C_SLAVE, even when the device node is not</span>
<span class="cm">		 * bound to a driver.  Only I2C_SLAVE_FORCE will work.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Setting the PEC flag here won&#39;t affect kernel drivers,</span>
<span class="cm">		 * which will be using the i2c_client node registered with</span>
<span class="cm">		 * the driver model core.  Likewise, when that client has</span>
<span class="cm">		 * the PEC flag already set, the i2c-dev driver won&#39;t see</span>
<span class="cm">		 * (or use) this setting.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="mh">0x3ff</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(((</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2C_M_TEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">arg</span> <span class="o">&gt;</span> <span class="mh">0x7f</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">I2C_SLAVE</span> <span class="o">&amp;&amp;</span> <span class="n">i2cdev_check_addr</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="cm">/* REVISIT: address could become busy later */</span>
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_TENBIT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span>
			<span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">I2C_M_TEN</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I2C_M_TEN</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_PEC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span>
			<span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">I2C_CLIENT_PEC</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">client</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I2C_CLIENT_PEC</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_FUNCS</span>:
		<span class="n">funcs</span> <span class="o">=</span> <span class="n">i2c_get_functionality</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">I2C_RDWR</span>:
		<span class="k">return</span> <span class="n">i2cdev_ioctl_rdrw</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">I2C_SMBUS</span>:
		<span class="k">return</span> <span class="n">i2cdev_ioctl_smbus</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">I2C_RETRIES</span>:
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I2C_TIMEOUT</span>:
		<span class="cm">/* For historical reasons, user-space sets the timeout</span>
<span class="cm">		 * value in units of 10 ms.</span>
<span class="cm">		 */</span>
		<span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">arg</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* NOTE:  returning a fault code here could cause trouble</span>
<span class="cm">		 * in buggy userspace code.  Some old kernel bugs returned</span>
<span class="cm">		 * zero in this case, and userspace code might accidentally</span>
<span class="cm">		 * have depended on that bug.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="n">i2c_dev</span><span class="p">;</span>

	<span class="n">i2c_dev</span> <span class="o">=</span> <span class="n">i2c_dev_get_by_minor</span><span class="p">(</span><span class="n">minor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">adap</span> <span class="o">=</span> <span class="n">i2c_get_adapter</span><span class="p">(</span><span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* This creates an anonymous i2c_client, which may later be</span>
<span class="cm">	 * pointed to some address using I2C_SLAVE or I2C_SLAVE_FORCE.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This client is ** NEVER REGISTERED ** with the driver model</span>
<span class="cm">	 * or I2C core code!!  It just holds private copies of addressing</span>
<span class="cm">	 * information and maybe a PEC flag.</span>
<span class="cm">	 */</span>
	<span class="n">client</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">client</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2c_put_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">I2C_NAME_SIZE</span><span class="p">,</span> <span class="s">&quot;i2c-dev %d&quot;</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>

	<span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adap</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">client</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_client</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">i2c_put_adapter</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">i2cdev_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">i2cdev_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">i2cdev_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">i2cdev_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">i2cdev_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">i2cdev_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">i2c_dev_class</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_attach_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="n">i2c_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adap</span> <span class="o">=</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">i2c_dev</span> <span class="o">=</span> <span class="n">get_free_i2c_dev</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">i2c_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">i2c_dev</span><span class="p">);</span>

	<span class="cm">/* register this i2c device with the driver core */</span>
	<span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="n">i2c_dev_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				     <span class="n">MKDEV</span><span class="p">(</span><span class="n">I2C_MAJOR</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span>
				     <span class="s">&quot;i2c-%d&quot;</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_destroy</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;i2c-dev: adapter [%s] registered as minor %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_destroy:</span>
	<span class="n">device_destroy</span><span class="p">(</span><span class="n">i2c_dev_class</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">I2C_MAJOR</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">));</span>
<span class="nl">error:</span>
	<span class="n">return_i2c_dev</span><span class="p">(</span><span class="n">i2c_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_detach_adapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2c_adapter</span> <span class="o">*</span><span class="n">adap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2c_dev</span> <span class="o">*</span><span class="n">i2c_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">i2c_adapter_type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adap</span> <span class="o">=</span> <span class="n">to_i2c_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">i2c_dev</span> <span class="o">=</span> <span class="n">i2c_dev_get_by_minor</span><span class="p">(</span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i2c_dev</span><span class="p">)</span> <span class="cm">/* attach_adapter must have failed */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">device_remove_file</span><span class="p">(</span><span class="n">i2c_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_name</span><span class="p">);</span>
	<span class="n">return_i2c_dev</span><span class="p">(</span><span class="n">i2c_dev</span><span class="p">);</span>
	<span class="n">device_destroy</span><span class="p">(</span><span class="n">i2c_dev_class</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">I2C_MAJOR</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;i2c-dev: adapter [%s] unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adap</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2cdev_notifier_call</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BUS_NOTIFY_ADD_DEVICE</span>:
		<span class="k">return</span> <span class="n">i2cdev_attach_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BUS_NOTIFY_DEL_DEVICE</span>:
		<span class="k">return</span> <span class="n">i2cdev_detach_adapter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">i2cdev_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">i2cdev_notifier_call</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* ------------------------------------------------------------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> * module load/unload record keeping</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">i2c_dev_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;i2c /dev entries driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="n">I2C_MAJOR</span><span class="p">,</span> <span class="s">&quot;i2c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2cdev_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">i2c_dev_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="s">&quot;i2c-dev&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">i2c_dev_class</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">i2c_dev_class</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unreg_chrdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Keep track of adapters which will be added or removed later */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">bus_register_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2cdev_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unreg_class</span><span class="p">;</span>

	<span class="cm">/* Bind to already existing adapters right away */</span>
	<span class="n">i2c_for_each_dev</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">i2cdev_attach_adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unreg_class:</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">i2c_dev_class</span><span class="p">);</span>
<span class="nl">out_unreg_chrdev:</span>
	<span class="n">unregister_chrdev</span><span class="p">(</span><span class="n">I2C_MAJOR</span><span class="p">,</span> <span class="s">&quot;i2c&quot;</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Driver Initialisation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i2c_dev_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bus_unregister_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2cdev_notifier</span><span class="p">);</span>
	<span class="n">i2c_for_each_dev</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">i2cdev_detach_adapter</span><span class="p">);</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">i2c_dev_class</span><span class="p">);</span>
	<span class="n">unregister_chrdev</span><span class="p">(</span><span class="n">I2C_MAJOR</span><span class="p">,</span> <span class="s">&quot;i2c&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Frodo Looijaard &lt;frodol@dds.nl&gt; and &quot;</span>
		<span class="s">&quot;Simon G. Vogl &lt;simon@tk.uni-linz.ac.at&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;I2C /dev entries driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">i2c_dev_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i2c_dev_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
