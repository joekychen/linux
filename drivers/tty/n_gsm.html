<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › n_gsm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>n_gsm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * n_gsm.c GSM 0710 tty multiplexor</span>
<span class="cm"> * Copyright (c) 2009/10 Intel Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *	* THIS IS A DEVELOPMENT SNAPSHOT IT IS NOT A FINAL RELEASE *</span>
<span class="cm"> *</span>
<span class="cm"> * TO DO:</span>
<span class="cm"> *	Mostly done:	ioctls for setting modes/timing</span>
<span class="cm"> *	Partly done:	hooks so you can pull off frames to non tty devs</span>
<span class="cm"> *	Restart DLCI 0 when it closes ?</span>
<span class="cm"> *	Improve the tx engine</span>
<span class="cm"> *	Resolve tx side locking by adding a queue_head and routing</span>
<span class="cm"> *		all control traffic via it</span>
<span class="cm"> *	General tidy/document</span>
<span class="cm"> *	Review the locking/move to refcounts more (mux now moved to an</span>
<span class="cm"> *		alloc/free model ready)</span>
<span class="cm"> *	Use newest tty open/close port helpers and install hooks</span>
<span class="cm"> *	What to do about power functions ?</span>
<span class="cm"> *	Termios setting and negotiation</span>
<span class="cm"> *	Do we need a &#39;which mux are you&#39; ioctl to correlate mux and tty sets</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/tty_driver.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/kfifo.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/arp.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/gsmmux.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>

<span class="cm">/* Defaults: these are from the specification */</span>

<span class="cp">#define T1	10		</span><span class="cm">/* 100mS */</span><span class="cp"></span>
<span class="cp">#define T2	34		</span><span class="cm">/* 333mS */</span><span class="cp"></span>
<span class="cp">#define N2	3		</span><span class="cm">/* Retry 3 times */</span><span class="cp"></span>

<span class="cm">/* Use long timers for testing at low speed with debug on */</span>
<span class="cp">#ifdef DEBUG_TIMING</span>
<span class="cp">#define T1	100</span>
<span class="cp">#define T2	200</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Semi-arbitrary buffer size limits. 0710 is normally run with 32-64 byte</span>
<span class="cm"> * limits so this is plenty</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_MRU 1500</span>
<span class="cp">#define MAX_MTU 1500</span>
<span class="cp">#define	GSM_NET_TX_TIMEOUT (HZ*10)</span>

<span class="cm">/**</span>
<span class="cm"> *	struct gsm_mux_net	-	network interface</span>
<span class="cm"> *	@struct gsm_dlci* dlci</span>
<span class="cm"> *	@struct net_device_stats stats;</span>
<span class="cm"> *</span>
<span class="cm"> *	Created when net interface is initialized.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define STATS(net) (((struct gsm_mux_net *)netdev_priv(net))-&gt;stats)</span>

<span class="cm">/*</span>
<span class="cm"> *	Each block of data we have queued to go out is in the form of</span>
<span class="cm"> *	a gsm_msg which holds everything we need in a link layer independent</span>
<span class="cm"> *	format</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">addr</span><span class="p">;</span>		<span class="cm">/* DLCI address + flags */</span>
	<span class="n">u8</span> <span class="n">ctrl</span><span class="p">;</span>		<span class="cm">/* Control byte + flags */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>	<span class="cm">/* Length of data block (can be zero) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>	<span class="cm">/* Points into buffer but not at the start */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Each active data link has a gsm_dlci structure associated which ties</span>
<span class="cm"> *	the link layer to an optional tty (if the tty side is open). To avoid</span>
<span class="cm"> *	complexity right now these are only ever freed up when the mux is</span>
<span class="cm"> *	shut down.</span>
<span class="cm"> *</span>
<span class="cm"> *	At the moment we don&#39;t free DLCI objects until the mux is torn down</span>
<span class="cm"> *	this avoid object life time issues but might be worth review later.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="cp">#define DLCI_CLOSED		0</span>
<span class="cp">#define DLCI_OPENING		1	</span><span class="cm">/* Sending SABM not seen UA */</span><span class="cp"></span>
<span class="cp">#define DLCI_OPEN		2	</span><span class="cm">/* SABM/UA complete */</span><span class="cp"></span>
<span class="cp">#define DLCI_CLOSING		3	</span><span class="cm">/* Sending DISC not seen UA/DM */</span><span class="cp"></span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">ref</span><span class="p">;</span>		<span class="cm">/* freed from port or mux close */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>

	<span class="cm">/* Link layer */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* Protects the internal state */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">t1</span><span class="p">;</span>	<span class="cm">/* Retransmit timer for SABM and UA */</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">;</span>
	<span class="cm">/* Uplink tty if active */</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="n">port</span><span class="p">;</span>	<span class="cm">/* The tty bound to this DLCI if there is one */</span>
	<span class="k">struct</span> <span class="n">kfifo</span> <span class="o">*</span><span class="n">fifo</span><span class="p">;</span>	<span class="cm">/* Queue fifo for the DLCI */</span>
	<span class="k">struct</span> <span class="n">kfifo</span> <span class="n">_fifo</span><span class="p">;</span>	<span class="cm">/* For new fifo API porting only */</span>
	<span class="kt">int</span> <span class="n">adaption</span><span class="p">;</span>		<span class="cm">/* Adaption layer in use */</span>
	<span class="kt">int</span> <span class="n">prev_adaption</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">modem_rx</span><span class="p">;</span>		<span class="cm">/* Our incoming virtual modem lines */</span>
	<span class="n">u32</span> <span class="n">modem_tx</span><span class="p">;</span>		<span class="cm">/* Our outgoing modem lines */</span>
	<span class="kt">int</span> <span class="n">dead</span><span class="p">;</span>		<span class="cm">/* Refuse re-open */</span>
	<span class="cm">/* Flow control */</span>
	<span class="kt">int</span> <span class="n">throttled</span><span class="p">;</span>		<span class="cm">/* Private copy of throttle state */</span>
	<span class="kt">int</span> <span class="n">constipated</span><span class="p">;</span>	<span class="cm">/* Throttle status for outgoing */</span>
	<span class="cm">/* Packetised I/O */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>	<span class="cm">/* Frame being sent */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">skb_list</span><span class="p">;</span>	<span class="cm">/* Queued frames */</span>
	<span class="cm">/* Data handling callback */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">prev_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span> <span class="cm">/* network interface, if created */</span>
<span class="p">};</span>

<span class="cm">/* DLCI 0, 62/63 are special or reseved see gsmtty_open */</span>

<span class="cp">#define NUM_DLCI		64</span>

<span class="cm">/*</span>
<span class="cm"> *	DLCI 0 is used to pass control blocks out of band of the data</span>
<span class="cm"> *	flow (and with a higher link priority). One command can be outstanding</span>
<span class="cm"> *	at a time and we use this structure to manage them. They are created</span>
<span class="cm"> *	and destroyed by the user context, and updated by the receive paths</span>
<span class="cm"> *	and timers</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">gsm_control</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">cmd</span><span class="p">;</span>		<span class="cm">/* Command we are issuing */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>	<span class="cm">/* Data for the command in case we retransmit */</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>	<span class="cm">/* Length of block for retransmission */</span>
	<span class="kt">int</span> <span class="n">done</span><span class="p">;</span>	<span class="cm">/* Done flag */</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>	<span class="cm">/* Error if any */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Each GSM mux we have is represented by this structure. If we are</span>
<span class="cm"> *	operating as an ldisc then we use this structure as our ldisc</span>
<span class="cm"> *	state. We need to sort out lifetimes and locking with respect</span>
<span class="cm"> *	to the gsm mux array. For now we don&#39;t free DLCI objects that</span>
<span class="cm"> *	have been instantiated until the mux itself is terminated.</span>
<span class="cm"> *</span>
<span class="cm"> *	To consider further: tty open versus mux shutdown.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>		<span class="cm">/* The tty our ldisc is bound to */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">ref</span><span class="p">;</span>

	<span class="cm">/* Events on the GSM channel */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">event</span><span class="p">;</span>

	<span class="cm">/* Bits for GSM mode decoding */</span>

	<span class="cm">/* Framing Layer */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="cp">#define GSM_SEARCH		0</span>
<span class="cp">#define GSM_START		1</span>
<span class="cp">#define GSM_ADDRESS		2</span>
<span class="cp">#define GSM_CONTROL		3</span>
<span class="cp">#define GSM_LEN			4</span>
<span class="cp">#define GSM_DATA		5</span>
<span class="cp">#define GSM_FCS			6</span>
<span class="cp">#define GSM_OVERRUN		7</span>
<span class="cp">#define GSM_LEN0		8</span>
<span class="cp">#define GSM_LEN1		9</span>
<span class="cp">#define GSM_SSOF		10</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">escape</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">encoding</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">control</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fcs</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">received_fcs</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">txframe</span><span class="p">;</span>			<span class="cm">/* TX framing buffer */</span>

	<span class="cm">/* Methods for the receiver side */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">receive</span><span class="p">)(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ch</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">error</span><span class="p">)(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ch</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flag</span><span class="p">);</span>
	<span class="cm">/* And transmit side */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">)(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">mux</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Link Layer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mru</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">initiator</span><span class="p">;</span>			<span class="cm">/* Did we initiate connection */</span>
	<span class="kt">int</span> <span class="n">dead</span><span class="p">;</span>			<span class="cm">/* Has the mux been shut down */</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">[</span><span class="n">NUM_DLCI</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">constipated</span><span class="p">;</span>		<span class="cm">/* Asked by remote to shut up */</span>

	<span class="n">spinlock_t</span> <span class="n">tx_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_bytes</span><span class="p">;</span>		<span class="cm">/* TX data outstanding */</span>
<span class="cp">#define TX_THRESH_HI		8192</span>
<span class="cp">#define TX_THRESH_LO		2048</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">tx_head</span><span class="p">;</span>	<span class="cm">/* Pending data packets */</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">tx_tail</span><span class="p">;</span>

	<span class="cm">/* Control messages */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">t2_timer</span><span class="p">;</span>	<span class="cm">/* Retransmit timer for commands */</span>
	<span class="kt">int</span> <span class="n">cretries</span><span class="p">;</span>			<span class="cm">/* Command retry counter */</span>
	<span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="n">pending_cmd</span><span class="p">;</span><span class="cm">/* Our current pending command */</span>
	<span class="n">spinlock_t</span> <span class="n">control_lock</span><span class="p">;</span>	<span class="cm">/* Protects the pending command */</span>

	<span class="cm">/* Configuration */</span>
	<span class="kt">int</span> <span class="n">adaption</span><span class="p">;</span>		<span class="cm">/* 1 or 2 supported */</span>
	<span class="n">u8</span> <span class="n">ftype</span><span class="p">;</span>		<span class="cm">/* UI or UIH */</span>
	<span class="kt">int</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>		<span class="cm">/* Timers in 1/100th of a sec */</span>
	<span class="kt">int</span> <span class="n">n2</span><span class="p">;</span>			<span class="cm">/* Retry count */</span>

	<span class="cm">/* Statistics (not currently exposed) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bad_fcs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">malformed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bad_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unsupported</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> *	Mux objects - needed so that we can translate a tty index into the</span>
<span class="cm"> *	relevant mux and DLCI.</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_MUX		4			</span><span class="cm">/* 256 minors */</span><span class="cp"></span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm_mux</span><span class="p">[</span><span class="n">MAX_MUX</span><span class="p">];</span>	<span class="cm">/* GSM muxes */</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">gsm_mux_lock</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">gsm_tty_driver</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	This section of the driver logic implements the GSM encodings</span>
<span class="cm"> *	both the basic and the &#39;advanced&#39;. Reliable transport is not</span>
<span class="cm"> *	supported.</span>
<span class="cm"> */</span>

<span class="cp">#define CR			0x02</span>
<span class="cp">#define EA			0x01</span>
<span class="cp">#define	PF			0x10</span>

<span class="cm">/* I is special: the rest are ..*/</span>
<span class="cp">#define RR			0x01</span>
<span class="cp">#define UI			0x03</span>
<span class="cp">#define RNR			0x05</span>
<span class="cp">#define REJ			0x09</span>
<span class="cp">#define DM			0x0F</span>
<span class="cp">#define SABM			0x2F</span>
<span class="cp">#define DISC			0x43</span>
<span class="cp">#define UA			0x63</span>
<span class="cp">#define	UIH			0xEF</span>

<span class="cm">/* Channel commands */</span>
<span class="cp">#define CMD_NSC			0x09</span>
<span class="cp">#define CMD_TEST		0x11</span>
<span class="cp">#define CMD_PSC			0x21</span>
<span class="cp">#define CMD_RLS			0x29</span>
<span class="cp">#define CMD_FCOFF		0x31</span>
<span class="cp">#define CMD_PN			0x41</span>
<span class="cp">#define CMD_RPN			0x49</span>
<span class="cp">#define CMD_FCON		0x51</span>
<span class="cp">#define CMD_CLD			0x61</span>
<span class="cp">#define CMD_SNC			0x69</span>
<span class="cp">#define CMD_MSC			0x71</span>

<span class="cm">/* Virtual modem bits */</span>
<span class="cp">#define MDM_FC			0x01</span>
<span class="cp">#define MDM_RTC			0x02</span>
<span class="cp">#define MDM_RTR			0x04</span>
<span class="cp">#define MDM_IC			0x20</span>
<span class="cp">#define MDM_DV			0x40</span>

<span class="cp">#define GSM0_SOF		0xF9</span>
<span class="cp">#define GSM1_SOF		0x7E</span>
<span class="cp">#define GSM1_ESCAPE		0x7D</span>
<span class="cp">#define GSM1_ESCAPE_BITS	0x20</span>
<span class="cp">#define XON			0x11</span>
<span class="cp">#define XOFF			0x13</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="n">gsm_port_ops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	CRC table for GSM 0710</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">gsm_fcs8</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="mh">0xE3</span><span class="p">,</span> <span class="mh">0x72</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x96</span><span class="p">,</span> <span class="mh">0xE4</span><span class="p">,</span> <span class="mh">0x75</span><span class="p">,</span>
	<span class="mh">0x0E</span><span class="p">,</span> <span class="mh">0x9F</span><span class="p">,</span> <span class="mh">0xED</span><span class="p">,</span> <span class="mh">0x7C</span><span class="p">,</span> <span class="mh">0x09</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0xEA</span><span class="p">,</span> <span class="mh">0x7B</span><span class="p">,</span>
	<span class="mh">0x1C</span><span class="p">,</span> <span class="mh">0x8D</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x6E</span><span class="p">,</span> <span class="mh">0x1B</span><span class="p">,</span> <span class="mh">0x8A</span><span class="p">,</span> <span class="mh">0xF8</span><span class="p">,</span> <span class="mh">0x69</span><span class="p">,</span>
	<span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xF1</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">,</span> <span class="mh">0x15</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0xF6</span><span class="p">,</span> <span class="mh">0x67</span><span class="p">,</span>
	<span class="mh">0x38</span><span class="p">,</span> <span class="mh">0xA9</span><span class="p">,</span> <span class="mh">0xDB</span><span class="p">,</span> <span class="mh">0x4A</span><span class="p">,</span> <span class="mh">0x3F</span><span class="p">,</span> <span class="mh">0xAE</span><span class="p">,</span> <span class="mh">0xDC</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span>
	<span class="mh">0x36</span><span class="p">,</span> <span class="mh">0xA7</span><span class="p">,</span> <span class="mh">0xD5</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xA0</span><span class="p">,</span> <span class="mh">0xD2</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span>
	<span class="mh">0x24</span><span class="p">,</span> <span class="mh">0xB5</span><span class="p">,</span> <span class="mh">0xC7</span><span class="p">,</span> <span class="mh">0x56</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mh">0xB2</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span>
	<span class="mh">0x2A</span><span class="p">,</span> <span class="mh">0xBB</span><span class="p">,</span> <span class="mh">0xC9</span><span class="p">,</span> <span class="mh">0x58</span><span class="p">,</span> <span class="mh">0x2D</span><span class="p">,</span> <span class="mh">0xBC</span><span class="p">,</span> <span class="mh">0xCE</span><span class="p">,</span> <span class="mh">0x5F</span><span class="p">,</span>
	<span class="mh">0x70</span><span class="p">,</span> <span class="mh">0xE1</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x77</span><span class="p">,</span> <span class="mh">0xE6</span><span class="p">,</span> <span class="mh">0x94</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span>
	<span class="mh">0x7E</span><span class="p">,</span> <span class="mh">0xEF</span><span class="p">,</span> <span class="mh">0x9D</span><span class="p">,</span> <span class="mh">0x0C</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mh">0xE8</span><span class="p">,</span> <span class="mh">0x9A</span><span class="p">,</span> <span class="mh">0x0B</span><span class="p">,</span>
	<span class="mh">0x6C</span><span class="p">,</span> <span class="mh">0xFD</span><span class="p">,</span> <span class="mh">0x8F</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mh">0x6B</span><span class="p">,</span> <span class="mh">0xFA</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x19</span><span class="p">,</span>
	<span class="mh">0x62</span><span class="p">,</span> <span class="mh">0xF3</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x65</span><span class="p">,</span> <span class="mh">0xF4</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span>
	<span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xD9</span><span class="p">,</span> <span class="mh">0xAB</span><span class="p">,</span> <span class="mh">0x3A</span><span class="p">,</span> <span class="mh">0x4F</span><span class="p">,</span> <span class="mh">0xDE</span><span class="p">,</span> <span class="mh">0xAC</span><span class="p">,</span> <span class="mh">0x3D</span><span class="p">,</span>
	<span class="mh">0x46</span><span class="p">,</span> <span class="mh">0xD7</span><span class="p">,</span> <span class="mh">0xA5</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xD0</span><span class="p">,</span> <span class="mh">0xA2</span><span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span>
	<span class="mh">0x54</span><span class="p">,</span> <span class="mh">0xC5</span><span class="p">,</span> <span class="mh">0xB7</span><span class="p">,</span> <span class="mh">0x26</span><span class="p">,</span> <span class="mh">0x53</span><span class="p">,</span> <span class="mh">0xC2</span><span class="p">,</span> <span class="mh">0xB0</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span>
	<span class="mh">0x5A</span><span class="p">,</span> <span class="mh">0xCB</span><span class="p">,</span> <span class="mh">0xB9</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x5D</span><span class="p">,</span> <span class="mh">0xCC</span><span class="p">,</span> <span class="mh">0xBE</span><span class="p">,</span> <span class="mh">0x2F</span><span class="p">,</span>
	<span class="mh">0xE0</span><span class="p">,</span> <span class="mh">0x71</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x92</span><span class="p">,</span> <span class="mh">0xE7</span><span class="p">,</span> <span class="mh">0x76</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span>
	<span class="mh">0xEE</span><span class="p">,</span> <span class="mh">0x7F</span><span class="p">,</span> <span class="mh">0x0D</span><span class="p">,</span> <span class="mh">0x9C</span><span class="p">,</span> <span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x0A</span><span class="p">,</span> <span class="mh">0x9B</span><span class="p">,</span>
	<span class="mh">0xFC</span><span class="p">,</span> <span class="mh">0x6D</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mh">0x8E</span><span class="p">,</span> <span class="mh">0xFB</span><span class="p">,</span> <span class="mh">0x6A</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span>
	<span class="mh">0xF2</span><span class="p">,</span> <span class="mh">0x63</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0xF5</span><span class="p">,</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">,</span>
	<span class="mh">0xD8</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0x3B</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0xDF</span><span class="p">,</span> <span class="mh">0x4E</span><span class="p">,</span> <span class="mh">0x3C</span><span class="p">,</span> <span class="mh">0xAD</span><span class="p">,</span>
	<span class="mh">0xD6</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span> <span class="mh">0xA4</span><span class="p">,</span> <span class="mh">0xD1</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">,</span> <span class="mh">0xA3</span><span class="p">,</span>
	<span class="mh">0xC4</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x27</span><span class="p">,</span> <span class="mh">0xB6</span><span class="p">,</span> <span class="mh">0xC3</span><span class="p">,</span> <span class="mh">0x52</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xB1</span><span class="p">,</span>
	<span class="mh">0xCA</span><span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0xB8</span><span class="p">,</span> <span class="mh">0xCD</span><span class="p">,</span> <span class="mh">0x5C</span><span class="p">,</span> <span class="mh">0x2E</span><span class="p">,</span> <span class="mh">0xBF</span><span class="p">,</span>
	<span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x73</span><span class="p">,</span> <span class="mh">0xE2</span><span class="p">,</span> <span class="mh">0x97</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="mh">0xE5</span><span class="p">,</span>
	<span class="mh">0x9E</span><span class="p">,</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x7D</span><span class="p">,</span> <span class="mh">0xEC</span><span class="p">,</span> <span class="mh">0x99</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x7A</span><span class="p">,</span> <span class="mh">0xEB</span><span class="p">,</span>
	<span class="mh">0x8C</span><span class="p">,</span> <span class="mh">0x1D</span><span class="p">,</span> <span class="mh">0x6F</span><span class="p">,</span> <span class="mh">0xFE</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x1A</span><span class="p">,</span> <span class="mh">0x68</span><span class="p">,</span> <span class="mh">0xF9</span><span class="p">,</span>
	<span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">,</span> <span class="mh">0xF0</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0xF7</span><span class="p">,</span>
	<span class="mh">0xA8</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0x4B</span><span class="p">,</span> <span class="mh">0xDA</span><span class="p">,</span> <span class="mh">0xAF</span><span class="p">,</span> <span class="mh">0x3E</span><span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span> <span class="mh">0xDD</span><span class="p">,</span>
	<span class="mh">0xA6</span><span class="p">,</span> <span class="mh">0x37</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="mh">0xD4</span><span class="p">,</span> <span class="mh">0xA1</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0xD3</span><span class="p">,</span>
	<span class="mh">0xB4</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x57</span><span class="p">,</span> <span class="mh">0xC6</span><span class="p">,</span> <span class="mh">0xB3</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">,</span>
	<span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0x2B</span><span class="p">,</span> <span class="mh">0x59</span><span class="p">,</span> <span class="mh">0xC8</span><span class="p">,</span> <span class="mh">0xBD</span><span class="p">,</span> <span class="mh">0x2C</span><span class="p">,</span> <span class="mh">0x5E</span><span class="p">,</span> <span class="mh">0xCF</span>
<span class="p">};</span>

<span class="cp">#define INIT_FCS	0xFF</span>
<span class="cp">#define GOOD_FCS	0xCF</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_fcs_add	-	update FCS</span>
<span class="cm"> *	@fcs: Current FCS</span>
<span class="cm"> *	@c: Next data</span>
<span class="cm"> *</span>
<span class="cm"> *	Update the FCS to include c. Uses the algorithm in the specification</span>
<span class="cm"> *	notes.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">gsm_fcs_add</span><span class="p">(</span><span class="n">u8</span> <span class="n">fcs</span><span class="p">,</span> <span class="n">u8</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gsm_fcs8</span><span class="p">[</span><span class="n">fcs</span> <span class="o">^</span> <span class="n">c</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_fcs_add_block	-	update FCS for a block</span>
<span class="cm"> *	@fcs: Current FCS</span>
<span class="cm"> *	@c: buffer of data</span>
<span class="cm"> *	@len: length of buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Update the FCS to include c. Uses the algorithm in the specification</span>
<span class="cm"> *	notes.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">gsm_fcs_add_block</span><span class="p">(</span><span class="n">u8</span> <span class="n">fcs</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span>
		<span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs8</span><span class="p">[</span><span class="n">fcs</span> <span class="o">^</span> <span class="o">*</span><span class="n">c</span><span class="o">++</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">fcs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_read_ea		-	read a byte into an EA</span>
<span class="cm"> *	@val: variable holding value</span>
<span class="cm"> *	c: byte going into the EA</span>
<span class="cm"> *</span>
<span class="cm"> *	Processes one byte of an EA. Updates the passed variable</span>
<span class="cm"> *	and returns 1 if the EA is now completely read</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_read_ea</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="n">u8</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Add the next 7 bits into the value */</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">&lt;&lt;=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="o">*</span><span class="n">val</span> <span class="o">|=</span> <span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Was this the last byte of the EA 1 = yes*/</span>
	<span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">EA</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_encode_modem	-	encode modem data bits</span>
<span class="cm"> *	@dlci: DLCI to encode from</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns the correct GSM encoded modem status bits (6 bit field) for</span>
<span class="cm"> *	the current status of the DLCI and attached tty object</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">gsm_encode_modem</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">modembits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* FC is true flow control not modem bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">throttled</span><span class="p">)</span>
		<span class="n">modembits</span> <span class="o">|=</span> <span class="n">MDM_FC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span> <span class="o">&amp;</span> <span class="n">TIOCM_DTR</span><span class="p">)</span>
		<span class="n">modembits</span> <span class="o">|=</span> <span class="n">MDM_RTC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span> <span class="o">&amp;</span> <span class="n">TIOCM_RTS</span><span class="p">)</span>
		<span class="n">modembits</span> <span class="o">|=</span> <span class="n">MDM_RTR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span> <span class="o">&amp;</span> <span class="n">TIOCM_RI</span><span class="p">)</span>
		<span class="n">modembits</span> <span class="o">|=</span> <span class="n">MDM_IC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span> <span class="o">&amp;</span> <span class="n">TIOCM_CD</span><span class="p">)</span>
		<span class="n">modembits</span> <span class="o">|=</span> <span class="n">MDM_DV</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">modembits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_print_packet	-	display a frame for debug</span>
<span class="cm"> *	@hdr: header to print before decode</span>
<span class="cm"> *	@addr: address EA from the frame</span>
<span class="cm"> *	@cr: C/R bit from the frame</span>
<span class="cm"> *	@control: control including PF bit</span>
<span class="cm"> *	@data: following data bytes</span>
<span class="cm"> *	@dlen: length of data</span>
<span class="cm"> *</span>
<span class="cm"> *	Displays a packet in human readable format for debugging purposes. The</span>
<span class="cm"> *	style is based on amateur radio LAP-B dump display.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_print_packet</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cr</span><span class="p">,</span>
					<span class="n">u8</span> <span class="n">control</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s %d) %c: &quot;</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="s">&quot;RC&quot;</span><span class="p">[</span><span class="n">cr</span><span class="p">]);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PF</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SABM</span>:
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;SABM&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UA</span>:
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;UA&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DISC</span>:
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;DISC&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DM</span>:
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;DM&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UI</span>:
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;UI&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UIH</span>:
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;UIH&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;I N(S)%d N(R)%d&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="mh">0x0E</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="mh">0xE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">switch</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">RR</span>:
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;RR(%d)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">RNR</span>:
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;RNR(%d)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">REJ</span>:
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;REJ(%d)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="mh">0xE0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;[%02X]&quot;</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="n">PF</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;(P)&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;(F)&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">dlen</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ct</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;    &quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;%02X &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">++</span><span class="p">);</span>
			<span class="n">ct</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	Link level transmission side</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_stuff_packet	-	bytestuff a packet</span>
<span class="cm"> *	@ibuf: input</span>
<span class="cm"> *	@obuf: output</span>
<span class="cm"> *	@len: length of input</span>
<span class="cm"> *</span>
<span class="cm"> *	Expand a buffer by bytestuffing it. The worst case size change</span>
<span class="cm"> *	is doubling and the caller is responsible for handing out</span>
<span class="cm"> *	suitable sized buffers.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_stuff_frame</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">olen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">input</span> <span class="o">==</span> <span class="n">GSM1_SOF</span> <span class="o">||</span> <span class="o">*</span><span class="n">input</span> <span class="o">==</span> <span class="n">GSM1_ESCAPE</span>
		    <span class="o">||</span> <span class="o">*</span><span class="n">input</span> <span class="o">==</span> <span class="n">XON</span> <span class="o">||</span> <span class="o">*</span><span class="n">input</span> <span class="o">==</span> <span class="n">XOFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">output</span><span class="o">++</span> <span class="o">=</span> <span class="n">GSM1_ESCAPE</span><span class="p">;</span>
			<span class="o">*</span><span class="n">output</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">input</span><span class="o">++</span> <span class="o">^</span> <span class="n">GSM1_ESCAPE_BITS</span><span class="p">;</span>
			<span class="n">olen</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="o">*</span><span class="n">output</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">input</span><span class="o">++</span><span class="p">;</span>
		<span class="n">olen</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">olen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_send	-	send a control frame</span>
<span class="cm"> *	@gsm: our GSM mux</span>
<span class="cm"> *	@addr: address for control frame</span>
<span class="cm"> *	@cr: command/response bit</span>
<span class="cm"> *	@control:  control byte including PF bit</span>
<span class="cm"> *</span>
<span class="cm"> *	Format up and transmit a control frame. These do not go via the</span>
<span class="cm"> *	queueing logic as they should be transmitted ahead of data when</span>
<span class="cm"> *	they are needed.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: Lock versus data TX path</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">control</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cbuf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ibuf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">cbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">GSM0_SOF</span><span class="p">;</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">control</span><span class="p">;</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">EA</span><span class="p">;</span>	<span class="cm">/* Length of data = 0 */</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span> <span class="o">-</span> <span class="n">gsm_fcs_add_block</span><span class="p">(</span><span class="n">INIT_FCS</span><span class="p">,</span> <span class="n">cbuf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">GSM0_SOF</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="cm">/* Control frame + packing (but not frame stuffing) in mode 1 */</span>
		<span class="n">ibuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>
		<span class="n">ibuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">control</span><span class="p">;</span>
		<span class="n">ibuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span> <span class="o">-</span> <span class="n">gsm_fcs_add_block</span><span class="p">(</span><span class="n">INIT_FCS</span><span class="p">,</span> <span class="n">ibuf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="cm">/* Stuffing may double the size worst case */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">gsm_stuff_frame</span><span class="p">(</span><span class="n">ibuf</span><span class="p">,</span> <span class="n">cbuf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="cm">/* Now add the SOF markers */</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">GSM1_SOF</span><span class="p">;</span>
		<span class="n">cbuf</span><span class="p">[</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">GSM1_SOF</span><span class="p">;</span>
		<span class="cm">/* FIXME: we can omit the lead one in many cases */</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">cbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">gsm_print_packet</span><span class="p">(</span><span class="s">&quot;--&gt;&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">cr</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_response	-	send a control response</span>
<span class="cm"> *	@gsm: our GSM mux</span>
<span class="cm"> *	@addr: address for control frame</span>
<span class="cm"> *	@control:  control byte including PF bit</span>
<span class="cm"> *</span>
<span class="cm"> *	Format up and transmit a link level response frame.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gsm_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">control</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gsm_send</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_command	-	send a control command</span>
<span class="cm"> *	@gsm: our GSM mux</span>
<span class="cm"> *	@addr: address for control frame</span>
<span class="cm"> *	@control:  control byte including PF bit</span>
<span class="cm"> *</span>
<span class="cm"> *	Format up and transmit a link level command frame.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gsm_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">control</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gsm_send</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">control</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Data transmission */</span>

<span class="cp">#define HDR_LEN		6	</span><span class="cm">/* ADDR CTRL [LEN.2] DATA FCS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_data_alloc		-	allocate data frame</span>
<span class="cm"> *	@gsm: GSM mux</span>
<span class="cm"> *	@addr: DLCI address</span>
<span class="cm"> *	@len: length excluding header and FCS</span>
<span class="cm"> *	@ctrl: control byte</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate a new data buffer for sending frames with data. Space is left</span>
<span class="cm"> *	at the front for header bytes but that is treated as an implementation</span>
<span class="cm"> *	detail and not for the high level code to use</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="nf">gsm_data_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
								<span class="n">u8</span> <span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">HDR_LEN</span><span class="p">,</span>
								<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">HDR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Allow for FCS */</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_data_kick		-	poke the queue</span>
<span class="cm"> *	@gsm: GSM Mux</span>
<span class="cm"> *</span>
<span class="cm"> *	The tty device has called us to indicate that room has appeared in</span>
<span class="cm"> *	the transmit queue. Ram more data into the pipe if we have any</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: lock against link layer control transmissions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_data_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip_sof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* FIXME: We need to apply this solely to data messages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">constipated</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">GSM1_SOF</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">gsm_stuff_frame</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span><span class="p">[</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">GSM1_SOF</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">GSM0_SOF</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span><span class="p">[</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">GSM0_SOF</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">print_hex_dump_bytes</span><span class="p">(</span><span class="s">&quot;gsm_data_kick: &quot;</span><span class="p">,</span>
					     <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span>
					     <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span> <span class="o">+</span> <span class="n">skip_sof</span><span class="p">,</span>
						<span class="n">len</span> <span class="o">-</span> <span class="n">skip_sof</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* FIXME: Can eliminate one SOF in many more cases */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">-=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="cm">/* For a burst of frames skip the extra SOF within the</span>
<span class="cm">		   burst */</span>
		<span class="n">skip_sof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__gsm_data_queue		-	queue a UI or UIH frame</span>
<span class="cm"> *	@dlci: DLCI sending the data</span>
<span class="cm"> *	@msg: message queued</span>
<span class="cm"> *</span>
<span class="cm"> *	Add data to the transmit queue and try and get stuff moving</span>
<span class="cm"> *	out of the mux tty if not already doing so. The Caller must hold</span>
<span class="cm"> *	the gsm tx lock.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__gsm_data_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">dp</span> <span class="o">+</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Fill in the header */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>
			<span class="o">*--</span><span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="o">*--</span><span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">);</span>	<span class="cm">/* bits 7 - 15 */</span>
			<span class="o">*--</span><span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">127</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* bits 0 - 6 */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*--</span><span class="n">dp</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">)</span>
		<span class="o">*--</span><span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*--</span><span class="n">dp</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>
	<span class="o">*</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add_block</span><span class="p">(</span><span class="n">INIT_FCS</span><span class="p">,</span> <span class="n">dp</span> <span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">dp</span><span class="p">);</span>
	<span class="cm">/* Ugly protocol layering violation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">ctrl</span> <span class="o">==</span> <span class="n">UI</span> <span class="o">||</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">ctrl</span> <span class="o">==</span> <span class="p">(</span><span class="n">UI</span><span class="o">|</span><span class="n">PF</span><span class="p">))</span>
		<span class="o">*</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add_block</span><span class="p">(</span><span class="o">*</span><span class="n">fcs</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">fcs</span> <span class="o">=</span> <span class="mh">0xFF</span> <span class="o">-</span> <span class="o">*</span><span class="n">fcs</span><span class="p">;</span>

	<span class="n">gsm_print_packet</span><span class="p">(</span><span class="s">&quot;Q&gt; &quot;</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">,</span>
							<span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Move the header back and adjust the length, also allow for the FCS</span>
<span class="cm">	   now tacked on the end */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">dp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">dp</span><span class="p">;</span>

	<span class="cm">/* Add to the actual output queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">)</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">gsm_data_kick</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_data_queue		-	queue a UI or UIH frame</span>
<span class="cm"> *	@dlci: DLCI sending the data</span>
<span class="cm"> *	@msg: message queued</span>
<span class="cm"> *</span>
<span class="cm"> *	Add data to the transmit queue and try and get stuff moving</span>
<span class="cm"> *	out of the mux tty if not already doing so. Take the</span>
<span class="cm"> *	the gsm tx lock and dlci lock.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_data_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__gsm_data_queue</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_data_output	-	try and push data out of a DLCI</span>
<span class="cm"> *	@gsm: mux</span>
<span class="cm"> *	@dlci: the DLCI to pull data from</span>
<span class="cm"> *</span>
<span class="cm"> *	Pull data from a DLCI and send it into the transmit queue if there</span>
<span class="cm"> *	is data. Keep to the MRU of the mux. This path handles the usual tty</span>
<span class="cm"> *	interface which is a byte stream with optional modem data.</span>
<span class="cm"> *</span>
<span class="cm"> *	Caller must hold the tx_lock of the mux.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_dlci_data_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">kfifo_len</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">total_size</span><span class="p">;</span>

		<span class="cm">/* MTU/MRU count only the data bits */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">+</span> <span class="n">h</span><span class="p">;</span>

		<span class="n">msg</span> <span class="o">=</span> <span class="n">gsm_data_alloc</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span><span class="p">);</span>
		<span class="cm">/* FIXME: need a timer or something to kick this so it can&#39;t</span>
<span class="cm">		   get stuck with no work outstanding and no buffer free */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">dp</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:	<span class="cm">/* Unstructured */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:	<span class="cm">/* Unstructed with modem bits. Always one byte as we never</span>
<span class="cm">			   send inline break data */</span>
			<span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="n">gsm_encode_modem</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">kfifo_out_locked</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">,</span> <span class="n">dp</span> <span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="o">!=</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">__gsm_data_queue</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="n">total_size</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Bytes of data we used up */</span>
	<span class="k">return</span> <span class="n">total_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_data_output_framed  -	try and push data out of a DLCI</span>
<span class="cm"> *	@gsm: mux</span>
<span class="cm"> *	@dlci: the DLCI to pull data from</span>
<span class="cm"> *</span>
<span class="cm"> *	Pull data from a DLCI and send it into the transmit queue if there</span>
<span class="cm"> *	is data. Keep to the MRU of the mux. This path handles framed data</span>
<span class="cm"> *	queued as skbuffs to the DLCI.</span>
<span class="cm"> *</span>
<span class="cm"> *	Caller must hold the tx_lock of the mux.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_dlci_data_output_framed</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">overhead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* One byte per frame is used for B/F flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">overhead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* dlci-&gt;skb is locked by tx_lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">overhead</span><span class="p">;</span>

	<span class="cm">/* MTU/MRU count only the data bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Over long frame, bin it */</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">len</span> <span class="o">+</span> <span class="n">overhead</span><span class="p">;</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">gsm_data_alloc</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span><span class="p">);</span>

	<span class="cm">/* FIXME: need a timer or something to kick this so it can&#39;t</span>
<span class="cm">	   get stuck with no work outstanding and no buffer free */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dp</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Interruptible framed (Packetised Data) */</span>
		<span class="cm">/* Flag byte to carry the start/end info */</span>
		<span class="o">*</span><span class="n">dp</span><span class="o">++</span> <span class="o">=</span> <span class="n">last</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span> <span class="o">|</span> <span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* EA */</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">__gsm_data_queue</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_data_sweep		-	look for data to send</span>
<span class="cm"> *	@gsm: the GSM mux</span>
<span class="cm"> *</span>
<span class="cm"> *	Sweep the GSM mux channels in priority order looking for ones with</span>
<span class="cm"> *	data to send. We could do with optimising this scan a bit. We aim</span>
<span class="cm"> *	to fill the queue totally or up to TX_THRESH_HI bytes. Once we hit</span>
<span class="cm"> *	TX_THRESH_LO we get called again</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: We should round robin between groups and in theory you can</span>
<span class="cm"> *	renegotiate DLCI priorities with optional stuff. Needs optimising.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_data_sweep</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="cm">/* Priority ordering: We should do priority with RR of the groups */</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_DLCI</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">&gt;</span> <span class="n">TX_THRESH_HI</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">constipated</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">gsm_dlci_data_output</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">gsm_dlci_data_output_framed</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* DLCI empty - try the next */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_data_kick	-	transmit if possible</span>
<span class="cm"> *	@dlci: DLCI to kick</span>
<span class="cm"> *</span>
<span class="cm"> *	Transmit data from this DLCI if the queue is empty. We can&#39;t rely on</span>
<span class="cm"> *	a tty wakeup except when we filled the pipe so we need to fire off</span>
<span class="cm"> *	new data ourselves in other cases.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_data_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* If we have nothing running then we need to fire up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span>
			<span class="n">gsm_dlci_data_output_framed</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">gsm_dlci_data_output</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">&lt;</span> <span class="n">TX_THRESH_LO</span><span class="p">)</span>
		<span class="n">gsm_dlci_data_sweep</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Control message processing</span>
<span class="cm"> */</span>


<span class="cm">/**</span>
<span class="cm"> *	gsm_control_reply	-	send a response frame to a control</span>
<span class="cm"> *	@gsm: gsm channel</span>
<span class="cm"> *	@cmd: the command to use</span>
<span class="cm"> *	@data: data to follow encoded info</span>
<span class="cm"> *	@dlen: length of data</span>
<span class="cm"> *</span>
<span class="cm"> *	Encode up and queue a UI/UIH frame containing our response.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_control_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">dlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">gsm_data_alloc</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dlen</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mh">0xFE</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>	<span class="cm">/* Clear C/R */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dlen</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dlen</span><span class="p">);</span>
	<span class="n">gsm_data_queue</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_process_modem	-	process received modem status</span>
<span class="cm"> *	@tty: virtual tty bound to the DLCI</span>
<span class="cm"> *	@dlci: DLCI to affect</span>
<span class="cm"> *	@modem: modem bits (full EA)</span>
<span class="cm"> *</span>
<span class="cm"> *	Used when a modem control message or line state inline in adaption</span>
<span class="cm"> *	layer 2 is processed. Sort out the local modem state and throttles</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_process_modem</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span>
							<span class="n">u32</span> <span class="n">modem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>  <span class="n">mlines</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">brk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The modem status command can either contain one octet (v.24 signals)</span>
<span class="cm">	   or two octets (v.24 signals + break signals). The length field will</span>
<span class="cm">	   either be 2 or 3 respectively. This is specified in section</span>
<span class="cm">	   5.4.6.3.7 of the  27.010 mux spec. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clen</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">modem</span> <span class="o">=</span> <span class="n">modem</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">brk</span> <span class="o">=</span> <span class="n">modem</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
		<span class="n">modem</span> <span class="o">=</span> <span class="p">(</span><span class="n">modem</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/* Flow control/ready to communicate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modem</span> <span class="o">&amp;</span> <span class="n">MDM_FC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Need to throttle our output on this device */</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">constipated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modem</span> <span class="o">&amp;</span> <span class="n">MDM_RTC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlines</span> <span class="o">|=</span> <span class="n">TIOCM_DSR</span> <span class="o">|</span> <span class="n">TIOCM_DTR</span><span class="p">;</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">constipated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gsm_dlci_data_kick</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Map modem bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modem</span> <span class="o">&amp;</span> <span class="n">MDM_RTR</span><span class="p">)</span>
		<span class="n">mlines</span> <span class="o">|=</span> <span class="n">TIOCM_RTS</span> <span class="o">|</span> <span class="n">TIOCM_CTS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modem</span> <span class="o">&amp;</span> <span class="n">MDM_IC</span><span class="p">)</span>
		<span class="n">mlines</span> <span class="o">|=</span> <span class="n">TIOCM_RI</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modem</span> <span class="o">&amp;</span> <span class="n">MDM_DV</span><span class="p">)</span>
		<span class="n">mlines</span> <span class="o">|=</span> <span class="n">TIOCM_CD</span><span class="p">;</span>

	<span class="cm">/* Carrier drop -&gt; hangup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mlines</span> <span class="o">&amp;</span> <span class="n">TIOCM_CD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_rx</span> <span class="o">&amp;</span> <span class="n">TIOCM_CD</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CLOCAL</span><span class="p">))</span>
				<span class="n">tty_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
			<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_BREAK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_rx</span> <span class="o">=</span> <span class="n">mlines</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_control_modem	-	modem status received</span>
<span class="cm"> *	@gsm: GSM channel</span>
<span class="cm"> *	@data: data following command</span>
<span class="cm"> *	@clen: command length</span>
<span class="cm"> *</span>
<span class="cm"> *	We have received a modem status control message. This is used by</span>
<span class="cm"> *	the GSM mux protocol to pass virtual modem line status and optionally</span>
<span class="cm"> *	to indicate break signals. Unpack it, convert to Linux representation</span>
<span class="cm"> *	and if need be stuff a break message down the tty.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_control_modem</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">modem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">clen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">gsm_read_ea</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">dp</span><span class="o">++</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Must be at least one byte following the EA */</span>
	<span class="n">len</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Closed port, or invalid ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">NUM_DLCI</span> <span class="o">||</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">gsm_read_ea</span><span class="p">(</span><span class="o">&amp;</span><span class="n">modem</span><span class="p">,</span> <span class="o">*</span><span class="n">dp</span><span class="o">++</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">gsm_process_modem</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">dlci</span><span class="p">,</span> <span class="n">modem</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">gsm_control_reply</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_MSC</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_control_rls		-	remote line status</span>
<span class="cm"> *	@gsm: GSM channel</span>
<span class="cm"> *	@data: data bytes</span>
<span class="cm"> *	@clen: data length</span>
<span class="cm"> *</span>
<span class="cm"> *	The modem sends us a two byte message on the control channel whenever</span>
<span class="cm"> *	it wishes to send us an error state from the virtual link. Stuff</span>
<span class="cm"> *	this into the uplink tty if present</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_control_rls</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">u8</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">clen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">gsm_read_ea</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">dp</span><span class="o">++</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Must be at least one byte following ea */</span>
	<span class="n">len</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Closed port, or invalid ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">NUM_DLCI</span> <span class="o">||</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* No error ? */</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* See if we have an uplink tty */</span>
	<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_OVERRUN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_PARITY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_FRAME</span><span class="p">);</span>
		<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">gsm_control_reply</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_RLS</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">gsm_dlci_begin_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_control_message	-	DLCI 0 control processing</span>
<span class="cm"> *	@gsm: our GSM mux</span>
<span class="cm"> *	@command:  the command EA</span>
<span class="cm"> *	@data: data beyond the command/length EAs</span>
<span class="cm"> *	@clen: length</span>
<span class="cm"> *</span>
<span class="cm"> *	Input processor for control messages from the other end of the link.</span>
<span class="cm"> *	Processes the incoming request and queues a response frame or an</span>
<span class="cm"> *	NSC response if not supported</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_control_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span>
							<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CMD_CLD</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="cm">/* Modem wishes to close down */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">gsm_dlci_begin_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_TEST</span>:
		<span class="cm">/* Modem wishes to test, reply with the data */</span>
		<span class="n">gsm_control_reply</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_TEST</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_FCON</span>:
		<span class="cm">/* Modem wants us to STFU */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">constipated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">gsm_control_reply</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_FCON</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_FCOFF</span>:
		<span class="cm">/* Modem can accept data again */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">constipated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gsm_control_reply</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_FCOFF</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Kick the link in case it is idling */</span>
		<span class="n">gsm_data_kick</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_MSC</span>:
		<span class="cm">/* Out of band modem line change indicator for a DLCI */</span>
		<span class="n">gsm_control_modem</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_RLS</span>:
		<span class="cm">/* Out of band error reception for a DLCI */</span>
		<span class="n">gsm_control_rls</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_PSC</span>:
		<span class="cm">/* Modem wishes to enter power saving state */</span>
		<span class="n">gsm_control_reply</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_PSC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Optional unsupported commands */</span>
	<span class="k">case</span> <span class="n">CMD_PN</span>:	<span class="cm">/* Parameter negotiation */</span>
	<span class="k">case</span> <span class="n">CMD_RPN</span>:	<span class="cm">/* Remote port negotiation */</span>
	<span class="k">case</span> <span class="n">CMD_SNC</span>:	<span class="cm">/* Service negotiation command */</span>
	<span class="nl">default:</span>
		<span class="cm">/* Reply to bad commands with an NSC */</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>
		<span class="n">gsm_control_reply</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_NSC</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_control_response	-	process a response to our control</span>
<span class="cm"> *	@gsm: our GSM mux</span>
<span class="cm"> *	@command: the command (response) EA</span>
<span class="cm"> *	@data: data beyond the command/length EA</span>
<span class="cm"> *	@clen: length</span>
<span class="cm"> *</span>
<span class="cm"> *	Process a response to an outstanding command. We only allow a single</span>
<span class="cm"> *	control message in flight so this is fairly easy. All the clean up</span>
<span class="cm"> *	is done by the caller, we just update the fields, flag it as done</span>
<span class="cm"> *	and return</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_control_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span>
							<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">pending_cmd</span><span class="p">;</span>
	<span class="cm">/* Does the reply match our command */</span>
	<span class="n">command</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">||</span> <span class="n">command</span> <span class="o">==</span> <span class="n">CMD_NSC</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Our command was replied to, kill the retry timer */</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2_timer</span><span class="p">);</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">pending_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* Rejected by the other end */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">CMD_NSC</span><span class="p">)</span>
			<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_control_transmit	-	send control packet</span>
<span class="cm"> *	@gsm: gsm mux</span>
<span class="cm"> *	@ctrl: frame to send</span>
<span class="cm"> *</span>
<span class="cm"> *	Send out a pending control command (called under control lock)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_control_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">gsm_data_alloc</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>	<span class="cm">/* command */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">gsm_data_queue</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_control_retransmit	-	retransmit a control frame</span>
<span class="cm"> *	@data: pointer to our gsm object</span>
<span class="cm"> *</span>
<span class="cm"> *	Called off the T2 timer expiry in order to retransmit control frames</span>
<span class="cm"> *	that have been lost in the system somewhere. The control_lock protects</span>
<span class="cm"> *	us from colliding with another sender or a receive completion event.</span>
<span class="cm"> *	In that situation the timer may still occur in a small window but</span>
<span class="cm"> *	gsm-&gt;pending_cmd will be NULL and we just let the timer expire.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_control_retransmit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">pending_cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">cretries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">cretries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">pending_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
			<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">gsm_control_transmit</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_control_send	-	send a control frame on DLCI 0</span>
<span class="cm"> *	@gsm: the GSM channel</span>
<span class="cm"> *	@command: command  to send including CR bit</span>
<span class="cm"> *	@data: bytes of data (must be kmalloced)</span>
<span class="cm"> *	@len: length of the block to send</span>
<span class="cm"> *</span>
<span class="cm"> *	Queue and dispatch a control command. Only one command can be</span>
<span class="cm"> *	active at a time. In theory more can be outstanding but the matching</span>
<span class="cm"> *	gets really complicated so for now stick to one outstanding.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="nf">gsm_control_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="n">ctrl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_control</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">pending_cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">pending_cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">clen</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">pending_cmd</span> <span class="o">=</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">cretries</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">n2</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
	<span class="n">gsm_control_transmit</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctrl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_control_wait	-	wait for a control to finish</span>
<span class="cm"> *	@gsm: GSM mux</span>
<span class="cm"> *	@control: control we are waiting on</span>
<span class="cm"> *</span>
<span class="cm"> *	Waits for the control to complete or time out. Frees any used</span>
<span class="cm"> *	resources and returns 0 for success, or an error if the remote</span>
<span class="cm"> *	rejected or ignored the request.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_control_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="n">control</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span> <span class="n">control</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">control</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">control</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	DLCI level handling: Needs krefs</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	State transitions and timers</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_close		-	a DLCI has closed</span>
<span class="cm"> *	@dlci: DLCI that closed</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform processing when moving a DLCI into closed state. If there</span>
<span class="cm"> *	is an attached tty this is hung up</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;DLCI %d goes closed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLCI_CLOSED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tty_struct</span>  <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tty_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
			<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfifo_reset</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
	<span class="cm">/* A DLCI 0 close is a MUX termination so we need to kick that</span>
<span class="cm">	   back to userspace somehow */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_open		-	a DLCI has opened</span>
<span class="cm"> *	@dlci: DLCI that opened</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform processing when moving a DLCI into open state.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Note that SABM UA .. SABM UA first UA lost can mean that we go</span>
<span class="cm">	   open -&gt; open */</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">);</span>
	<span class="cm">/* This will let a tty open continue */</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLCI_OPEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;DLCI %d goes open.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_t1		-	T1 timer expiry</span>
<span class="cm"> *	@dlci: DLCI that opened</span>
<span class="cm"> *</span>
<span class="cm"> *	The T1 timer handles retransmits of control frames (essentially of</span>
<span class="cm"> *	SABM and DISC). We resend the command until the retry count runs out</span>
<span class="cm"> *	in which case an opening port goes back to closed and a closing port</span>
<span class="cm"> *	is simply put into closed state (any further frames from the other</span>
<span class="cm"> *	end will get a DM response)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_t1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DLCI_OPENING</span>:
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">retries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm_command</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">SABM</span><span class="o">|</span><span class="n">PF</span><span class="p">);</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">gsm_dlci_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DLCI_CLOSING</span>:
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">retries</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm_command</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">DISC</span><span class="o">|</span><span class="n">PF</span><span class="p">);</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">gsm_dlci_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_begin_open	-	start channel open procedure</span>
<span class="cm"> *	@dlci: DLCI to open</span>
<span class="cm"> *</span>
<span class="cm"> *	Commence opening a DLCI from the Linux side. We issue SABM messages</span>
<span class="cm"> *	to the modem which should then reply with a UA, at which point we</span>
<span class="cm"> *	will move into open state. Opening is done asynchronously with retry</span>
<span class="cm"> *	running off timers and the responses.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_begin_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DLCI_OPEN</span> <span class="o">||</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DLCI_OPENING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">n2</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLCI_OPENING</span><span class="p">;</span>
	<span class="n">gsm_command</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">SABM</span><span class="o">|</span><span class="n">PF</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_begin_close	-	start channel open procedure</span>
<span class="cm"> *	@dlci: DLCI to open</span>
<span class="cm"> *</span>
<span class="cm"> *	Commence closing a DLCI from the Linux side. We issue DISC messages</span>
<span class="cm"> *	to the modem which should then reply with a UA, at which point we</span>
<span class="cm"> *	will move into closed state. Closing is done asynchronously with retry</span>
<span class="cm"> *	off timers. We may also receive a DM reply from the other end which</span>
<span class="cm"> *	indicates the channel was already closed.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_begin_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DLCI_CLOSED</span> <span class="o">||</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DLCI_CLOSING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">n2</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLCI_CLOSING</span><span class="p">;</span>
	<span class="n">gsm_command</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">DISC</span><span class="o">|</span><span class="n">PF</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_data		-	data arrived</span>
<span class="cm"> *	@dlci: channel</span>
<span class="cm"> *	@data: block of bytes received</span>
<span class="cm"> *	@len: length of received block</span>
<span class="cm"> *</span>
<span class="cm"> *	A UI or UIH frame has arrived which contains data for a channel</span>
<span class="cm"> *	other than the control channel. If the relevant virtual tty is</span>
<span class="cm"> *	open we shovel the bits down it, if not we drop them.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* krefs .. */</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">modem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">clen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%d bytes for tty %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span><span class="p">)</span>  <span class="p">{</span>
		<span class="cm">/* Unsupported types */</span>
		<span class="cm">/* Packetised interruptible data */</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Packetised uininterruptible voice/data */</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Asynchronous serial with line state in each frame */</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">while</span> <span class="p">(</span><span class="n">gsm_read_ea</span><span class="p">(</span><span class="o">&amp;</span><span class="n">modem</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">++</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">len</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">gsm_process_modem</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">dlci</span><span class="p">,</span> <span class="n">modem</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
		<span class="cm">/* Line state will go via DLCI 0 controls only */</span>
		<span class="k">case</span> <span class="mi">1</span>:
		<span class="nl">default:</span>
			<span class="n">tty_insert_flip_string</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_control	-	data arrived on control channel</span>
<span class="cm"> *	@dlci: channel</span>
<span class="cm"> *	@data: block of bytes received</span>
<span class="cm"> *	@len: length of received block</span>
<span class="cm"> *</span>
<span class="cm"> *	A UI or UIH frame has arrived which contains data for DLCI 0 the</span>
<span class="cm"> *	control channel. This should contain a command EA followed by</span>
<span class="cm"> *	control data bytes. The command EA contains a command/response bit</span>
<span class="cm"> *	and we divide up the work accordingly.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* See what command is involved */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm_read_ea</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">++</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">clen</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="o">++</span><span class="p">;</span>
			<span class="n">len</span><span class="o">--</span><span class="p">;</span>
			<span class="cm">/* FIXME: this is properly an EA */</span>
			<span class="n">clen</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Malformed command ? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clen</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">gsm_control_message</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
								<span class="n">data</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">gsm_control_response</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span>
								<span class="n">data</span><span class="p">,</span> <span class="n">clen</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Allocate/Free DLCI channels</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_alloc		-	allocate a DLCI</span>
<span class="cm"> *	@gsm: GSM mux</span>
<span class="cm"> *	@addr: address of the DLCI</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate and install a new DLCI object into the GSM mux.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: review locking races</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="nf">gsm_dlci_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">_fifo</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kfifo_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">_fifo</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb_list</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">);</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">gsm_dlci_t1</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dlci</span><span class="p">;</span>
	<span class="n">tty_port_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gsm_port_ops</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">gsm</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">adaption</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLCI_CLOSED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">gsm_dlci_data</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">gsm_dlci_command</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlci</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dlci</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_free		-	free DLCI</span>
<span class="cm"> *	@dlci: DLCI to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Free up a DLCI.</span>
<span class="cm"> *</span>
<span class="cm"> *	Can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_dlci</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">);</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfifo_free</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb_list</span><span class="p">)))</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlci_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlci_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">gsm_dlci_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_dlci_release		-	release DLCI</span>
<span class="cm"> *	@dlci: DLCI to destroy</span>
<span class="cm"> *</span>
<span class="cm"> *	Release a DLCI. Actual free is deferred until either</span>
<span class="cm"> *	mux is closed or tty is closed - whichever is last.</span>
<span class="cm"> *</span>
<span class="cm"> *	Can sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dlci_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_vhangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dlci_put</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	LAPBish link layer logic</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_queue		-	a GSM frame is ready to process</span>
<span class="cm"> *	@gsm: pointer to our gsm mux</span>
<span class="cm"> *</span>
<span class="cm"> *	At this point in time a frame has arrived and been demangled from</span>
<span class="cm"> *	the line encoding. All the differences between the encodings have</span>
<span class="cm"> *	been handled below us and the frame is unpacked into the structures.</span>
<span class="cm"> *	The fcs holds the header FCS but any data FCS must be added here.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">address</span><span class="p">;</span>
	<span class="cm">/* We have to sneak a look at the packet body to do the FCS.</span>
<span class="cm">	   A somewhat layering violation in the spec */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PF</span><span class="p">)</span> <span class="o">==</span> <span class="n">UI</span><span class="p">)</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add_block</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
		<span class="cm">/* WARNING: gsm-&gt;received_fcs is used for gsm-&gt;encoding = 0 only.</span>
<span class="cm">		            In this case it contain the last piece of data</span>
<span class="cm">		            required to generate final CRC */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">received_fcs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">!=</span> <span class="n">GOOD_FCS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">bad_fcs</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;BAD FCS %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">address</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">NUM_DLCI</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>

	<span class="n">cr</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* C/R bit */</span>

	<span class="n">gsm_print_packet</span><span class="p">(</span><span class="s">&quot;&lt;--&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">cr</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">cr</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">;</span>	<span class="cm">/* Flip so 1 always means command */</span>
	<span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">address</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SABM</span><span class="o">|</span><span class="n">PF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm_dlci_alloc</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span>
			<span class="n">gsm_response</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">DM</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">gsm_response</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">UA</span><span class="p">);</span>
			<span class="n">gsm_dlci_open</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DISC</span><span class="o">|</span><span class="n">PF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DLCI_CLOSED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm_response</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">DM</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Real close complete */</span>
		<span class="n">gsm_response</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">UA</span><span class="p">);</span>
		<span class="n">gsm_dlci_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UA</span>:
	<span class="k">case</span> <span class="n">UA</span><span class="o">|</span><span class="n">PF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DLCI_CLOSING</span>:
			<span class="n">gsm_dlci_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLCI_OPENING</span>:
			<span class="n">gsm_dlci_open</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DM</span>:	<span class="cm">/* DM can be valid unsolicited */</span>
	<span class="k">case</span> <span class="n">DM</span><span class="o">|</span><span class="n">PF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">gsm_dlci_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UI</span>:
	<span class="k">case</span> <span class="n">UI</span><span class="o">|</span><span class="n">PF</span>:
	<span class="k">case</span> <span class="n">UIH</span>:
	<span class="k">case</span> <span class="n">UIH</span><span class="o">|</span><span class="n">PF</span>:
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		if (cr)</span>
<span class="c">			goto invalid;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">DLCI_OPEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm_command</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">DM</span><span class="o">|</span><span class="n">PF</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">invalid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">invalid:</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">malformed</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	gsm0_receive	-	perform processing for non-transparency</span>
<span class="cm"> *	@gsm: gsm data for this ldisc instance</span>
<span class="cm"> *	@c: character</span>
<span class="cm"> *</span>
<span class="cm"> *	Receive bytes in gsm mode 0</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm0_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GSM_SEARCH</span>:	<span class="cm">/* SOF marker */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">GSM0_SOF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_ADDRESS</span><span class="p">;</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">INIT_FCS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_ADDRESS</span>:	<span class="cm">/* Address EA */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm_read_ea</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_CONTROL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_CONTROL</span>:	<span class="cm">/* Control Byte */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_LEN0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_LEN0</span>:		<span class="cm">/* Length EA */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm_read_ea</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mru</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">bad_size</span><span class="o">++</span><span class="p">;</span>
				<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_SEARCH</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
				<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_FCS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_DATA</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_LEN1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_LEN1</span>:
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">|=</span> <span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mru</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">bad_size</span><span class="o">++</span><span class="p">;</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_SEARCH</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_FCS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_DATA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_DATA</span>:		<span class="cm">/* Data */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_FCS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_FCS</span>:		<span class="cm">/* FCS follows the packet */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">received_fcs</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">gsm_queue</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_SSOF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_SSOF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">GSM0_SOF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_SEARCH</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm1_receive	-	perform processing for non-transparency</span>
<span class="cm"> *	@gsm: gsm data for this ldisc instance</span>
<span class="cm"> *	@c: character</span>
<span class="cm"> *</span>
<span class="cm"> *	Receive bytes in mode 1 (Advanced option)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm1_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">GSM1_SOF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* EOF is only valid in frame if we have got to the data state</span>
<span class="cm">		   and received at least one byte (the FCS) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">GSM_DATA</span> <span class="o">&amp;&amp;</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Extract the FCS */</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">]);</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
			<span class="n">gsm_queue</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span>  <span class="o">=</span> <span class="n">GSM_START</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Any partial frame was a runt so go back to start */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">GSM_START</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">malformed</span><span class="o">++</span><span class="p">;</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_START</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* A SOF in GSM_START means we are still reading idling or</span>
<span class="cm">		   framing bytes */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">GSM1_ESCAPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">escape</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Only an unescaped SOF gets us out of GSM search */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">GSM_SEARCH</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">escape</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">^=</span> <span class="n">GSM1_ESCAPE_BITS</span><span class="p">;</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">escape</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GSM_START</span>:		<span class="cm">/* First byte after SOF */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_ADDRESS</span><span class="p">;</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">INIT_FCS</span><span class="p">;</span>
		<span class="cm">/* Drop through */</span>
	<span class="k">case</span> <span class="n">GSM_ADDRESS</span>:	<span class="cm">/* Address continuation */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm_read_ea</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_CONTROL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_CONTROL</span>:	<span class="cm">/* Control Byte */</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span> <span class="o">=</span> <span class="n">gsm_fcs_add</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">fcs</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_DATA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_DATA</span>:		<span class="cm">/* Data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mru</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Allow one for the FCS */</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_OVERRUN</span><span class="p">;</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">bad_size</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSM_OVERRUN</span>:	<span class="cm">/* Over-long - eg a dropped SOF */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_error		-	handle tty error</span>
<span class="cm"> *	@gsm: ldisc data</span>
<span class="cm"> *	@data: byte received (may be invalid)</span>
<span class="cm"> *	@flag: error received</span>
<span class="cm"> *</span>
<span class="cm"> *	Handle an error in the receipt of data for a frame. Currently we just</span>
<span class="cm"> *	go back to hunting for a SOF.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: better diagnostics ?</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">GSM_SEARCH</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_cleanup_mux		-	generic GSM protocol cleanup</span>
<span class="cm"> *	@gsm: our mux</span>
<span class="cm"> *</span>
<span class="cm"> *	Clean up the bits of the mux which are the same for all framing</span>
<span class="cm"> *	protocols. Remove the mux from the mux table, stop all the timers</span>
<span class="cm"> *	and then shut down each device hanging up the channels as we go.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">gsm_cleanup_mux</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">gsm_msg</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="n">gc</span><span class="p">;</span>

	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm_mux_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_MUX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm_mux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">gsm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm_mux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm_mux_lock</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_MUX</span><span class="p">);</span>

	<span class="cm">/* In theory disconnecting DLCI 0 is sufficient but for some</span>
<span class="cm">	   modems this is apparently not the case. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gc</span> <span class="o">=</span> <span class="n">gsm_control_send</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_CLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="p">)</span>
			<span class="n">gsm_control_wait</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">gc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2_timer</span><span class="p">);</span>
	<span class="cm">/* Now we are sure T2 has stopped */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">gsm_dlci_begin_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span>
					<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DLCI_CLOSED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Free up any link layer users */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_DLCI</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">gsm_dlci_release</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="cm">/* Now wipe the queues */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">txq</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">;</span> <span class="n">txq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">txq</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">=</span> <span class="n">txq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gsm_cleanup_mux</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_activate_mux	-	generic GSM setup</span>
<span class="cm"> *	@gsm: our mux</span>
<span class="cm"> *</span>
<span class="cm"> *	Set up the bits of the mux which are the same for all framing</span>
<span class="cm"> *	protocols. Add the mux to the mux table so it can be opened and</span>
<span class="cm"> *	finally kick off connecting to DLCI 0 on the modem.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">gsm_activate_mux</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2_timer</span><span class="p">);</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">gsm_control_retransmit</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">gsm</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">control_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">receive</span> <span class="o">=</span> <span class="n">gsm0_receive</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">receive</span> <span class="o">=</span> <span class="n">gsm1_receive</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">gsm_error</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm_mux_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_MUX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm_mux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">gsm_mux</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gsm</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm_mux_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_MUX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm_dlci_alloc</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* Tty opens are now permissible */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gsm_activate_mux</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_free_mux		-	free up a mux</span>
<span class="cm"> *	@mux: mux to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Dispose of allocated resources for a dead mux</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gsm_free_mux</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gsm_free_mux</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_free_muxr		-	free up a mux</span>
<span class="cm"> *	@mux: mux to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Dispose of allocated resources for a dead mux</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_free_muxr</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_mux</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
	<span class="n">gsm_free_mux</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mux_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mux_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">gsm_free_muxr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsm_alloc_mux		-	allocate a mux</span>
<span class="cm"> *</span>
<span class="cm"> *	Creates a new mux ready for activation.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="nf">gsm_alloc_mux</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">MAX_MRU</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">MAX_MRU</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">txframe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>

	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">=</span> <span class="n">T1</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2</span> <span class="o">=</span> <span class="n">T2</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">n2</span> <span class="o">=</span> <span class="n">N2</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span> <span class="o">=</span> <span class="n">UIH</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>	<span class="cm">/* Default to encoding 1 so these should be 64 */</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Avoid early tty opens */</span>

	<span class="k">return</span> <span class="n">gsm</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gsm_alloc_mux</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_output		-	write to link</span>
<span class="cm"> *	@gsm: our mux</span>
<span class="cm"> *	@data: bytes to output</span>
<span class="cm"> *	@len: size</span>
<span class="cm"> *</span>
<span class="cm"> *	Write a block of data from the GSM mux to the data channel. This</span>
<span class="cm"> *	will eventually be serialized from above but at the moment isn&#39;t.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmld_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_write_room</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">print_hex_dump_bytes</span><span class="p">(</span><span class="s">&quot;gsmld_output: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span>
				     <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_attach_gsm	-	mode set up</span>
<span class="cm"> *	@tty: our tty structure</span>
<span class="cm"> *	@gsm: our mux</span>
<span class="cm"> *</span>
<span class="cm"> *	Set up the MUX for basic mode and commence connecting to the</span>
<span class="cm"> *	modem. Currently called from the line discipline set up but</span>
<span class="cm"> *	will need moving to an ioctl path.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmld_attach_gsm</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="cm">/* Base for this MUX */</span>

	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty_kref_get</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">gsmld_output</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span>  <span class="n">gsm_activate_mux</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Don&#39;t register device 0 - this is the control channel and not</span>
<span class="cm">		   a usable tty interface */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_DLCI</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">tty_register_device</span><span class="p">(</span><span class="n">gsm_tty_driver</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	gsmld_detach_gsm	-	stop doing 0710 mux</span>
<span class="cm"> *	@tty: tty attached to the mux</span>
<span class="cm"> *	@gsm: mux</span>
<span class="cm"> *</span>
<span class="cm"> *	Shutdown and then clean up the resources used by the line discipline</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmld_detach_gsm</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="cm">/* Base for this MUX */</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_DLCI</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">gsm_tty_driver</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">gsm_cleanup_mux</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
	<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmld_receive_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">print_hex_dump_bytes</span><span class="p">(</span><span class="s">&quot;gsmld_receive: &quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span>
				     <span class="n">cp</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="p">,</span> <span class="n">dp</span> <span class="o">=</span> <span class="n">cp</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">dp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="o">*</span><span class="n">f</span><span class="o">++</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TTY_NORMAL</span>:
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">receive</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TTY_OVERRUN</span>:
		<span class="k">case</span> <span class="n">TTY_BREAK</span>:
		<span class="k">case</span> <span class="n">TTY_PARITY</span>:
		<span class="k">case</span> <span class="n">TTY_FRAME</span>:
			<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">WARN_ONCE</span><span class="p">(</span><span class="s">&quot;%s: unknown flag %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">tty_name</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* FASYNC if needed ? */</span>
	<span class="cm">/* If clogged call tty_throttle(tty); */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_chars_in_buffer	-	report available bytes</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *</span>
<span class="cm"> *	Report the number of characters buffered to be delivered to user</span>
<span class="cm"> *	at this instant in time.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: gsm lock</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gsmld_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_flush_buffer	-	clean input queue</span>
<span class="cm"> *	@tty:	terminal device</span>
<span class="cm"> *</span>
<span class="cm"> *	Flush the input buffer. Called when the line discipline is</span>
<span class="cm"> *	being closed, when the tty layer wants the buffer flushed (eg</span>
<span class="cm"> *	at hangup).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmld_flush_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_close		-	close the ldisc for this tty</span>
<span class="cm"> *	@tty: device</span>
<span class="cm"> *</span>
<span class="cm"> *	Called from the terminal layer when this line discipline is</span>
<span class="cm"> *	being shut down, either because of a close or becsuse of a</span>
<span class="cm"> *	discipline change. The function will not be called while other</span>
<span class="cm"> *	ldisc methods are in progress.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmld_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>

	<span class="n">gsmld_detach_gsm</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">gsm</span><span class="p">);</span>

	<span class="n">gsmld_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="cm">/* Do other clean up here */</span>
	<span class="n">mux_put</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_open		-	open an ldisc</span>
<span class="cm"> *	@tty: terminal to open</span>
<span class="cm"> *</span>
<span class="cm"> *	Called when this line discipline is being attached to the</span>
<span class="cm"> *	terminal device. Can sleep. Called serialized so that no</span>
<span class="cm"> *	other events will occur in parallel. No further open will occur</span>
<span class="cm"> *	until a close.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmld_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Attach our ldisc data */</span>
	<span class="n">gsm</span> <span class="o">=</span> <span class="n">gsm_alloc_mux</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="n">gsm</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">receive_room</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>

	<span class="cm">/* Attach the initial passive connection */</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gsmld_attach_gsm</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">gsm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_write_wakeup	-	asynchronous I/O notifier</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *</span>
<span class="cm"> *	Required for the ptys, serial driver etc. since processes</span>
<span class="cm"> *	that attach themselves to the master and rely on ASYNC</span>
<span class="cm"> *	IO must be woken up</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmld_write_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Queue poll */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">gsm_data_kick</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">&lt;</span> <span class="n">TX_THRESH_LO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">gsm_dlci_data_sweep</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_read		-	read function for tty</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *	@file: file object</span>
<span class="cm"> *	@buf: userspace buffer pointer</span>
<span class="cm"> *	@nr: size of I/O</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform reads for the line discipline. We are guaranteed that the</span>
<span class="cm"> *	line discipline will not be closed under us but we may get multiple</span>
<span class="cm"> *	parallel readers and must handle this ourselves. We may also get</span>
<span class="cm"> *	a hangup. Always called in user context, may sleep.</span>
<span class="cm"> *</span>
<span class="cm"> *	This code must be sure never to sleep through a hangup.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gsmld_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_write		-	write function for tty</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *	@file: file object</span>
<span class="cm"> *	@buf: userspace buffer pointer</span>
<span class="cm"> *	@nr: size of I/O</span>
<span class="cm"> *</span>
<span class="cm"> *	Called when the owner of the device wants to send a frame</span>
<span class="cm"> *	itself (or some other control data). The data is transferred</span>
<span class="cm"> *	as-is and must be properly framed and checksummed as appropriate</span>
<span class="cm"> *	by userspace. Frames are either sent whole or not at all as this</span>
<span class="cm"> *	avoids pain user side.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gsmld_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">space</span> <span class="o">=</span> <span class="n">tty_write_room</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&gt;=</span> <span class="n">nr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	gsmld_poll		-	poll method for N_GSM0710</span>
<span class="cm"> *	@tty: terminal device</span>
<span class="cm"> *	@file: file accessing it</span>
<span class="cm"> *	@wait: poll table</span>
<span class="cm"> *</span>
<span class="cm"> *	Called when the line discipline is asked to poll() for data or</span>
<span class="cm"> *	for special events. This code is not serialized with respect to</span>
<span class="cm"> *	other events save open/close.</span>
<span class="cm"> *</span>
<span class="cm"> *	This code must be sure never to sleep through a hangup.</span>
<span class="cm"> *	Called without the kernel lock held - fine</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">gsmld_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
							<span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty_is_writelocked</span><span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tty_write_room</span><span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmld_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">gsm_config</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">need_close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Stuff we don&#39;t support yet - UI or I frame transport, windowing */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="cm">/* Check the MRU/MTU range looks sane */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">&gt;</span> <span class="n">MAX_MRU</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">MAX_MTU</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">n2</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">encapsulation</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>	<span class="cm">/* Basic, advanced, no I */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>	<span class="cm">/* UIH and UI only */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	See what is needed for reconfiguration</span>
<span class="cm">	 */</span>

	<span class="cm">/* Timing fields */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">!=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">)</span>
		<span class="n">need_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">t2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">t2</span> <span class="o">!=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2</span><span class="p">)</span>
		<span class="n">need_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">encapsulation</span> <span class="o">!=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">)</span>
		<span class="n">need_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">!=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">adaption</span><span class="p">)</span>
		<span class="n">need_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Requires care */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">!=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">)</span>
		<span class="n">need_close</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">!=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mru</span><span class="p">)</span>
		<span class="n">need_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">!=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span>
		<span class="n">need_restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Close down what is needed, restart and initiate the new</span>
<span class="cm">	 *	configuration</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_close</span> <span class="o">||</span> <span class="n">need_restart</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">gsm_dlci_begin_close</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="cm">/* This will timeout if the link is down due to N2 expiring */</span>
		<span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">,</span>
				<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">DLCI_CLOSED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_restart</span><span class="p">)</span>
		<span class="n">gsm_cleanup_mux</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>

	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mru</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">encapsulation</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">adaption</span><span class="p">;</span>
	<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">n2</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">n2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span> <span class="o">=</span> <span class="n">UIH</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span> <span class="o">=</span> <span class="n">UI</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">)</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">t2</span><span class="p">)</span>
		<span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">t2</span><span class="p">;</span>

	<span class="cm">/* FIXME: We need to separate activation/deactivation from adding</span>
<span class="cm">	   and removing from the mux array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_restart</span><span class="p">)</span>
		<span class="n">gsm_activate_mux</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">initiator</span> <span class="o">&amp;&amp;</span> <span class="n">need_close</span><span class="p">)</span>
		<span class="n">gsm_dlci_begin_open</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmld_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_config</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GSMIOC_GETCONF</span>:
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
		<span class="n">c</span><span class="p">.</span><span class="n">adaption</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">adaption</span><span class="p">;</span>
		<span class="n">c</span><span class="p">.</span><span class="n">encapsulation</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">;</span>
		<span class="n">c</span><span class="p">.</span><span class="n">initiator</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">initiator</span><span class="p">;</span>
		<span class="n">c</span><span class="p">.</span><span class="n">t1</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t1</span><span class="p">;</span>
		<span class="n">c</span><span class="p">.</span><span class="n">t2</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">t2</span><span class="p">;</span>
		<span class="n">c</span><span class="p">.</span><span class="n">t3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Not supported */</span>
		<span class="n">c</span><span class="p">.</span><span class="n">n2</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">n2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span> <span class="o">==</span> <span class="n">UIH</span><span class="p">)</span>
			<span class="n">c</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">c</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Ftype %d i %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">ftype</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
		<span class="n">c</span><span class="p">.</span><span class="n">mru</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mru</span><span class="p">;</span>
		<span class="n">c</span><span class="p">.</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
		<span class="n">c</span><span class="p">.</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMIOC_SETCONF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">gsmld_config</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">gsm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">n_tty_ioctl_helper</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Network interface</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_mux_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_mux_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">gsm_mux_net_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlci_net_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">prev_adaption</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">prev_data</span><span class="p">;</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="n">mux_net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">;</span>

	<span class="n">mux_net</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_mux_net</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
	<span class="n">dlci</span> <span class="o">=</span> <span class="n">mux_net</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
		<span class="n">dlci_net_free</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">muxnet_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="n">mux_net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux_net</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">muxnet_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="n">mux_net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux_net</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">net_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_mux_net_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="n">mux_net</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">mux_net</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">;</span>
	<span class="n">muxnet_get</span><span class="p">(</span><span class="n">mux_net</span><span class="p">);</span>

	<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">skb_list</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">STATS</span><span class="p">(</span><span class="n">net</span><span class="p">).</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">STATS</span><span class="p">(</span><span class="n">net</span><span class="p">).</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">gsm_dlci_data_kick</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="cm">/* And tell the kernel when the last transmit started. */</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">muxnet_put</span><span class="p">(</span><span class="n">mux_net</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called when a packet did not ack after watchdogtimeout */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_mux_net_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Tell syslog we are hosed. */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Update statistics */</span>
	<span class="n">STATS</span><span class="p">(</span><span class="n">net</span><span class="p">).</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_mux_rx_netchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in_buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="n">mux_net</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">muxnet_get</span><span class="p">(</span><span class="n">mux_net</span><span class="p">);</span>

	<span class="cm">/* Allocate an sk_buff */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We got no receive buffer. */</span>
		<span class="n">STATS</span><span class="p">(</span><span class="n">net</span><span class="p">).</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="n">muxnet_put</span><span class="p">(</span><span class="n">mux_net</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">in_buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">__constant_htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>

	<span class="cm">/* Ship it off to the kernel */</span>
	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* update out statistics */</span>
	<span class="n">STATS</span><span class="p">(</span><span class="n">net</span><span class="p">).</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">STATS</span><span class="p">(</span><span class="n">net</span><span class="p">).</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">muxnet_put</span><span class="p">(</span><span class="n">mux_net</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">gsm_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="n">mux_net</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">mux_net</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_mux_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">gsm_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">gsm_mux_net_open</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">gsm_mux_net_close</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">gsm_mux_net_start_xmit</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">gsm_mux_net_tx_timeout</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">gsm_mux_net_get_stats</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">gsm_change_mtu</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gsm_netdev_ops</span><span class="p">;</span>

	<span class="cm">/* fill in the other fields */</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">GSM_NET_TX_TIMEOUT</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IFF_POINTOPOINT</span> <span class="o">|</span> <span class="n">IFF_NOARP</span> <span class="o">|</span> <span class="n">IFF_MULTICAST</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ARPHRD_NONE</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* caller holds the dlci mutex */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_destroy_network</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="n">mux_net</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;destroy network interface&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mux_net</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">);</span>
	<span class="n">muxnet_put</span><span class="p">(</span><span class="n">mux_net</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* caller holds the dlci mutex */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_create_network</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_netconfig</span> <span class="o">*</span><span class="n">nc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">netname</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="n">mux_net</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* Already in a non tty mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">nc</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;create network interface&quot;</span><span class="p">);</span>

	<span class="n">netname</span> <span class="o">=</span> <span class="s">&quot;gsm%d&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">if_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="n">netname</span> <span class="o">=</span> <span class="n">nc</span><span class="o">-&gt;</span><span class="n">if_name</span><span class="p">;</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux_net</span><span class="p">),</span>
			<span class="n">netname</span><span class="p">,</span>
			<span class="n">gsm_mux_net_init</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;alloc_netdev failed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
	<span class="n">mux_net</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gsm_mux_net</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">mux_net</span><span class="o">-&gt;</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">dlci</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mux_net</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">if_name</span><span class="p">,</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span> <span class="cm">/* return net name */</span>

	<span class="cm">/* reconfigure dlci for network */</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">prev_adaption</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">prev_data</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">adaption</span> <span class="o">=</span> <span class="n">nc</span><span class="o">-&gt;</span><span class="n">adaption</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">gsm_mux_rx_netchar</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;register netdev&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;network register fail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="n">dlci_net_free</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>	<span class="cm">/* return network index */</span>
<span class="p">}</span>

<span class="cm">/* Line discipline for real tty */</span>
<span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="n">tty_ldisc_packet</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		 <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">magic</span>           <span class="o">=</span> <span class="n">TTY_LDISC_MAGIC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>            <span class="o">=</span> <span class="s">&quot;n_gsm&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>            <span class="o">=</span> <span class="n">gsmld_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>           <span class="o">=</span> <span class="n">gsmld_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_buffer</span>    <span class="o">=</span> <span class="n">gsmld_flush_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="n">gsmld_chars_in_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>            <span class="o">=</span> <span class="n">gsmld_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>           <span class="o">=</span> <span class="n">gsmld_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>           <span class="o">=</span> <span class="n">gsmld_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>            <span class="o">=</span> <span class="n">gsmld_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">receive_buf</span>     <span class="o">=</span> <span class="n">gsmld_receive_buf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_wakeup</span>    <span class="o">=</span> <span class="n">gsmld_write_wakeup</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Virtual tty side</span>
<span class="cm"> */</span>

<span class="cp">#define TX_SIZE		512</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_modem_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">,</span> <span class="n">u8</span> <span class="n">brk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">modembits</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">gsm_control</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">brk</span><span class="p">)</span>
		<span class="n">len</span><span class="o">++</span><span class="p">;</span>

	<span class="n">modembits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>		<span class="cm">/* Data bytes */</span>
	<span class="n">modembits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* DLCI, EA, 1 */</span>
	<span class="n">modembits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gsm_encode_modem</span><span class="p">(</span><span class="n">dlci</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">brk</span><span class="p">)</span>
		<span class="n">modembits</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">brk</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">EA</span><span class="p">;</span>	<span class="cm">/* Valid, EA */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">gsm_control_send</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">CMD_MSC</span><span class="p">,</span> <span class="n">modembits</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gsm_control_wait</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsm_carrier_raised</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_dlci</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="cm">/* Not yet open so no carrier info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">DLCI_OPEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_rx</span> <span class="o">&amp;</span> <span class="n">TIOCM_CD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsm_dtr_rts</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gsm_dlci</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">modem_tx</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">onoff</span><span class="p">)</span>
		<span class="n">modem_tx</span> <span class="o">|=</span> <span class="n">TIOCM_DTR</span> <span class="o">|</span> <span class="n">TIOCM_RTS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">modem_tx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TIOCM_DTR</span> <span class="o">|</span> <span class="n">TIOCM_RTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">modem_tx</span> <span class="o">!=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span> <span class="o">=</span> <span class="n">modem_tx</span><span class="p">;</span>
		<span class="n">gsmtty_modem_update</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="n">gsm_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">carrier_raised</span> <span class="o">=</span> <span class="n">gsm_carrier_raised</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr_rts</span> <span class="o">=</span> <span class="n">gsm_dtr_rts</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mux</span> <span class="o">=</span> <span class="n">line</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>

	<span class="n">line</span> <span class="o">=</span> <span class="n">line</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mux</span> <span class="o">&gt;=</span> <span class="n">MAX_MUX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="cm">/* FIXME: we need to lock gsm_mux for lifetimes of ttys eventually */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm_mux</span><span class="p">[</span><span class="n">mux</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EUNATCH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">line</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">line</span> <span class="o">&gt;</span> <span class="mi">61</span><span class="p">)</span>	<span class="cm">/* 62/63 reserved */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHRNG</span><span class="p">;</span>
	<span class="n">gsm</span> <span class="o">=</span> <span class="n">gsm_mux</span><span class="p">[</span><span class="n">mux</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dead</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EL2HLT</span><span class="p">;</span>
	<span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="n">line</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dlci</span> <span class="o">=</span> <span class="n">gsm_dlci_alloc</span><span class="p">(</span><span class="n">gsm</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">dlci</span><span class="p">;</span>
	<span class="n">dlci_get</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="n">dlci_get</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">mux_get</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">);</span>
	<span class="n">tty_port_tty_set</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>

	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* We could in theory open and close before we wait - eg if we get</span>
<span class="cm">	   a DM straight back. This is ok as that will have caused a hangup */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ASYNCB_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Start sending off SABM messages */</span>
	<span class="n">gsm_dlci_begin_open</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="cm">/* And wait for virtual carrier */</span>
	<span class="k">return</span> <span class="n">tty_port_block_til_ready</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmtty_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_mux</span> <span class="o">*</span><span class="n">gsm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlci</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">gsm_destroy_network</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">gsm</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">gsm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_port_close_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">gsm_dlci_begin_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="n">tty_port_close_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
	<span class="n">tty_port_tty_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">dlci_put</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="n">dlci_put</span><span class="p">(</span><span class="n">gsm</span><span class="o">-&gt;</span><span class="n">dlci</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">mux_put</span><span class="p">(</span><span class="n">gsm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmtty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="n">tty_port_hangup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">gsm_dlci_begin_close</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
								    <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="cm">/* Stuff the bytes into the fifo queue */</span>
	<span class="kt">int</span> <span class="n">sent</span> <span class="o">=</span> <span class="n">kfifo_in_locked</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* Need to kick the channel */</span>
	<span class="n">gsm_dlci_data_kick</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">TX_SIZE</span> <span class="o">-</span> <span class="n">kfifo_len</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kfifo_len</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmtty_flush_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="cm">/* Caution needed: If we implement reliable transport classes</span>
<span class="cm">	   then the data being transmitted can&#39;t simply be junked once</span>
<span class="cm">	   it has first hit the stack. Until then we can just blow it</span>
<span class="cm">	   away */</span>
	<span class="n">kfifo_reset</span><span class="p">(</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">fifo</span><span class="p">);</span>
	<span class="cm">/* Need to unhook this DLCI from the transmit queue logic */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmtty_wait_until_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The FIFO handles the queue so the kernel will do the right</span>
<span class="cm">	   thing waiting on chars_in_buffer before calling us. No work</span>
<span class="cm">	   to do here */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_tiocmget</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_rx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_tiocmset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">modem_tx</span> <span class="o">=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span><span class="p">;</span>

	<span class="n">modem_tx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">clear</span><span class="p">;</span>
	<span class="n">modem_tx</span> <span class="o">|=</span> <span class="n">set</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">modem_tx</span> <span class="o">!=</span> <span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span> <span class="o">=</span> <span class="n">modem_tx</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">gsmtty_modem_update</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gsm_netconfig</span> <span class="n">nc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GSMIOC_ENABLE_NET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nc</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nc</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">nc</span><span class="p">.</span><span class="n">if_name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="cm">/* return net interface index or error code */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">gsm_create_network</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nc</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nc</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GSMIOC_DISABLE_NET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">gsm_destroy_network</span><span class="p">(</span><span class="n">dlci</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmtty_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* For the moment its fixed. In actual fact the speed information</span>
<span class="cm">	   for the virtual channel can be propogated in both directions by</span>
<span class="cm">	   the RPN control message. This however rapidly gets nasty as we</span>
<span class="cm">	   then have to remap modem signals each way according to whether</span>
<span class="cm">	   our virtual cable is null modem etc .. */</span>
	<span class="n">tty_termios_copy_hw</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmtty_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TIOCM_DTR</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">throttled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Send an MSC with DTR cleared */</span>
	<span class="n">gsmtty_modem_update</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gsmtty_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">modem_tx</span> <span class="o">|=</span> <span class="n">TIOCM_DTR</span><span class="p">;</span>
	<span class="n">dlci</span><span class="o">-&gt;</span><span class="n">throttled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Send an MSC with DTR set */</span>
	<span class="n">gsmtty_modem_update</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gsmtty_break_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gsm_dlci</span> <span class="o">*</span><span class="n">dlci</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">encode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Off */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>	<span class="cm">/* &quot;On indefinitely&quot; - we can&#39;t encode this</span>
<span class="cm">				    properly */</span>
		<span class="n">encode</span> <span class="o">=</span> <span class="mh">0x0F</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">encode</span> <span class="o">=</span> <span class="n">state</span> <span class="o">/</span> <span class="mi">200</span><span class="p">;</span>	<span class="cm">/* mS to encoding */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">encode</span> <span class="o">&gt;</span> <span class="mh">0x0F</span><span class="p">)</span>
			<span class="n">encode</span> <span class="o">=</span> <span class="mh">0x0F</span><span class="p">;</span>	<span class="cm">/* Best effort */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">gsmtty_modem_update</span><span class="p">(</span><span class="n">dlci</span><span class="p">,</span> <span class="n">encode</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Virtual ttys for the demux */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="n">gsmtty_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>			<span class="o">=</span> <span class="n">gsmtty_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>			<span class="o">=</span> <span class="n">gsmtty_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>			<span class="o">=</span> <span class="n">gsmtty_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_room</span>		<span class="o">=</span> <span class="n">gsmtty_write_room</span><span class="p">,</span>
	<span class="p">.</span><span class="n">chars_in_buffer</span>	<span class="o">=</span> <span class="n">gsmtty_chars_in_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_buffer</span>		<span class="o">=</span> <span class="n">gsmtty_flush_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>			<span class="o">=</span> <span class="n">gsmtty_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">throttle</span>		<span class="o">=</span> <span class="n">gsmtty_throttle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unthrottle</span>		<span class="o">=</span> <span class="n">gsmtty_unthrottle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span>		<span class="o">=</span> <span class="n">gsmtty_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hangup</span>			<span class="o">=</span> <span class="n">gsmtty_hangup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wait_until_sent</span>	<span class="o">=</span> <span class="n">gsmtty_wait_until_sent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tiocmget</span>		<span class="o">=</span> <span class="n">gsmtty_tiocmget</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tiocmset</span>		<span class="o">=</span> <span class="n">gsmtty_tiocmset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">break_ctl</span>		<span class="o">=</span> <span class="n">gsmtty_break_ctl</span><span class="p">,</span>
<span class="p">};</span>



<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">gsm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Fill in our line protocol discipline, and register it */</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">tty_register_ldisc</span><span class="p">(</span><span class="n">N_GSM0710</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_ldisc_packet</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;n_gsm: can&#39;t register line discipline (err = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gsm_tty_driver</span> <span class="o">=</span> <span class="n">alloc_tty_driver</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gsm_tty_driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_unregister_ldisc</span><span class="p">(</span><span class="n">N_GSM0710</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;gsm_init: tty allocation failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">driver_name</span>	<span class="o">=</span> <span class="s">&quot;gsmtty&quot;</span><span class="p">;</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;gsmtty&quot;</span><span class="p">;</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">major</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Dynamic */</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">minor_start</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">type</span>		<span class="o">=</span> <span class="n">TTY_DRIVER_TYPE_SERIAL</span><span class="p">;</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">subtype</span>	<span class="o">=</span> <span class="n">SERIAL_TYPE_NORMAL</span><span class="p">;</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">flags</span>	<span class="o">=</span> <span class="n">TTY_DRIVER_REAL_RAW</span> <span class="o">|</span> <span class="n">TTY_DRIVER_DYNAMIC_DEV</span>
						<span class="o">|</span> <span class="n">TTY_DRIVER_HARDWARE_BREAK</span><span class="p">;</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span>	<span class="o">=</span> <span class="n">tty_std_termios</span><span class="p">;</span>
	<span class="cm">/* Fixme */</span>
	<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">.</span><span class="n">c_lflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ECHO</span><span class="p">;</span>
	<span class="n">tty_set_operations</span><span class="p">(</span><span class="n">gsm_tty_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gsmtty_ops</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gsm_mux_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_register_driver</span><span class="p">(</span><span class="n">gsm_tty_driver</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">gsm_tty_driver</span><span class="p">);</span>
		<span class="n">tty_unregister_ldisc</span><span class="p">(</span><span class="n">N_GSM0710</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;gsm_init: tty registration failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;gsm_init: loaded as %d,%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">gsm_tty_driver</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">gsm_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">tty_unregister_ldisc</span><span class="p">(</span><span class="n">N_GSM0710</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;n_gsm: can&#39;t unregister line discipline (err = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">status</span><span class="p">);</span>
	<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">gsm_tty_driver</span><span class="p">);</span>
	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">gsm_tty_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">gsm_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">gsm_exit</span><span class="p">);</span>


<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_LDISC</span><span class="p">(</span><span class="n">N_GSM0710</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
