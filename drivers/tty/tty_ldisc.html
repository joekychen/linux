<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › tty_ldisc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tty_ldisc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_driver.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *	This guards the refcounted line discipline lists. The lock</span>
<span class="cm"> *	must be taken with irqs off because there are hangup path</span>
<span class="cm"> *	callers who will do ldisc lookups and cannot sleep.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">tty_ldisc_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">tty_ldisc_wait</span><span class="p">);</span>
<span class="cm">/* Line disc dispatch table */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">tty_ldiscs</span><span class="p">[</span><span class="n">NR_LDISCS</span><span class="p">];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="nf">get_ldisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ld</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_ldisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">ld</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the last user, free the ldisc, and</span>
<span class="cm">	 * release the ldisc ops.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We really want an &quot;atomic_dec_and_lock_irqsave()&quot;,</span>
<span class="cm">	 * but we don&#39;t have it, so this does it by hand.</span>
<span class="cm">	 */</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">ldo</span> <span class="o">=</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>

		<span class="n">ldo</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">--</span><span class="p">;</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">ldo</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">wq_idle</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_register_ldisc	-	install a line discipline</span>
<span class="cm"> *	@disc: ldisc number</span>
<span class="cm"> *	@new_ldisc: pointer to the ldisc object</span>
<span class="cm"> *</span>
<span class="cm"> *	Installs a new line discipline into the kernel. The discipline</span>
<span class="cm"> *	is set up as unreferenced and then made available to the kernel</span>
<span class="cm"> *	from this point onwards.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		takes tty_ldisc_lock to guard against ldisc races</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_register_ldisc</span><span class="p">(</span><span class="kt">int</span> <span class="n">disc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">new_ldisc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disc</span> <span class="o">&lt;</span> <span class="n">N_TTY</span> <span class="o">||</span> <span class="n">disc</span> <span class="o">&gt;=</span> <span class="n">NR_LDISCS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty_ldiscs</span><span class="p">[</span><span class="n">disc</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ldisc</span><span class="p">;</span>
	<span class="n">new_ldisc</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">disc</span><span class="p">;</span>
	<span class="n">new_ldisc</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_register_ldisc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_unregister_ldisc	-	unload a line discipline</span>
<span class="cm"> *	@disc: ldisc number</span>
<span class="cm"> *	@new_ldisc: pointer to the ldisc object</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove a line discipline from the kernel providing it is not</span>
<span class="cm"> *	currently in use.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		takes tty_ldisc_lock to guard against ldisc races</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_unregister_ldisc</span><span class="p">(</span><span class="kt">int</span> <span class="n">disc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disc</span> <span class="o">&lt;</span> <span class="n">N_TTY</span> <span class="o">||</span> <span class="n">disc</span> <span class="o">&gt;=</span> <span class="n">NR_LDISCS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_ldiscs</span><span class="p">[</span><span class="n">disc</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tty_ldiscs</span><span class="p">[</span><span class="n">disc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_unregister_ldisc</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="nf">get_ldops</span><span class="p">(</span><span class="kt">int</span> <span class="n">disc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">ldops</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="n">ldops</span> <span class="o">=</span> <span class="n">tty_ldiscs</span><span class="p">[</span><span class="n">disc</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ldops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">ldops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ldops</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ldops</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_ldops</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">ldops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ldops</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">--</span><span class="p">;</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">ldops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_get		-	take a reference to an ldisc</span>
<span class="cm"> *	@disc: ldisc number</span>
<span class="cm"> *</span>
<span class="cm"> *	Takes a reference to a line discipline. Deals with refcounts and</span>
<span class="cm"> *	module locking counts. Returns NULL if the discipline is not available.</span>
<span class="cm"> *	Returns a pointer to the discipline and bumps the ref count if it is</span>
<span class="cm"> *	available</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		takes tty_ldisc_lock to guard against ldisc races</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="nf">tty_ldisc_get</span><span class="p">(</span><span class="kt">int</span> <span class="n">disc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">ldops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disc</span> <span class="o">&lt;</span> <span class="n">N_TTY</span> <span class="o">||</span> <span class="n">disc</span> <span class="o">&gt;=</span> <span class="n">NR_LDISCS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the ldisc ops - we may need to request them to be loaded</span>
<span class="cm">	 * dynamically and try again.</span>
<span class="cm">	 */</span>
	<span class="n">ldops</span> <span class="o">=</span> <span class="n">get_ldops</span><span class="p">(</span><span class="n">disc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ldops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;tty-ldisc-%d&quot;</span><span class="p">,</span> <span class="n">disc</span><span class="p">);</span>
		<span class="n">ldops</span> <span class="o">=</span> <span class="n">get_ldops</span><span class="p">(</span><span class="n">disc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ldops</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">ldops</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ld</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_ldisc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_ldops</span><span class="p">(</span><span class="n">ldops</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ldops</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">wq_idle</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ld</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">tty_ldiscs_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">NR_LDISCS</span><span class="p">)</span> <span class="o">?</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">tty_ldiscs_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">NR_LDISCS</span><span class="p">)</span> <span class="o">?</span> <span class="n">pos</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tty_ldiscs_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_ldiscs_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">loff_t</span> <span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="o">*</span><span class="n">ldops</span><span class="p">;</span>

	<span class="n">ldops</span> <span class="o">=</span> <span class="n">get_ldops</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ldops</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%-10s %2d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ldops</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?</span> <span class="n">ldops</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;???&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">put_ldops</span><span class="p">(</span><span class="n">ldops</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">tty_ldiscs_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">tty_ldiscs_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">tty_ldiscs_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">tty_ldiscs_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">tty_ldiscs_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_tty_ldiscs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_ldiscs_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tty_ldiscs_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proc_tty_ldiscs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_assign	-	set ldisc on a tty</span>
<span class="cm"> *	@tty: tty to assign</span>
<span class="cm"> *	@ld: line discipline</span>
<span class="cm"> *</span>
<span class="cm"> *	Install an instance of a line discipline into a tty structure. The</span>
<span class="cm"> *	ldisc must have a reference count above zero to ensure it remains.</span>
<span class="cm"> *	The tty instance refcount starts at zero.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		Caller must hold references</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tty_ldisc_assign</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span> <span class="o">=</span> <span class="n">ld</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_try		-	internal helper</span>
<span class="cm"> *	@tty: the tty</span>
<span class="cm"> *</span>
<span class="cm"> *	Make a single attempt to grab and bump the refcount on</span>
<span class="cm"> *	the tty ldisc. Return 0 on failure or 1 on success. This is</span>
<span class="cm"> *	used to implement both the waiting and non waiting versions</span>
<span class="cm"> *	of tty_ldisc_ref</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: takes tty_ldisc_lock</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="nf">tty_ldisc_try</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ld</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_LDISC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">ld</span> <span class="o">=</span> <span class="n">get_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ld</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_ref_wait	-	wait for the tty ldisc</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *</span>
<span class="cm"> *	Dereference the line discipline for the terminal and take a</span>
<span class="cm"> *	reference to it. If the line discipline is in flux then</span>
<span class="cm"> *	wait patiently until it changes.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Must not be called from an IRQ/timer context. The caller</span>
<span class="cm"> *	must also be careful not to hold other locks that will deadlock</span>
<span class="cm"> *	against a discipline change, such as an existing ldisc reference</span>
<span class="cm"> *	(which we check for)</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: call functions take tty_ldisc_lock</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="nf">tty_ldisc_ref_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>

	<span class="cm">/* wait_event is a macro */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">tty_ldisc_wait</span><span class="p">,</span> <span class="p">(</span><span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_try</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ld</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_ldisc_ref_wait</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_ref		-	get the tty ldisc</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *</span>
<span class="cm"> *	Dereference the line discipline for the terminal and take a</span>
<span class="cm"> *	reference to it. If the line discipline is in flux then</span>
<span class="cm"> *	return NULL. Can be called from IRQ and timer functions.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: called functions take tty_ldisc_lock</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="nf">tty_ldisc_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tty_ldisc_try</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_ldisc_ref</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_deref		-	free a tty ldisc reference</span>
<span class="cm"> *	@ld: reference to free up</span>
<span class="cm"> *</span>
<span class="cm"> *	Undoes the effect of tty_ldisc_ref or tty_ldisc_ref_wait. May</span>
<span class="cm"> *	be called in IRQ context.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: takes tty_ldisc_lock</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_ldisc_deref</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_ldisc</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_ldisc_deref</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tty_ldisc_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_ldisc</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_enable	-	allow ldisc use</span>
<span class="cm"> *	@tty: terminal to activate ldisc on</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the TTY_LDISC flag when the line discipline can be called</span>
<span class="cm"> *	again. Do necessary wakeups for existing sleepers. Clear the LDISC</span>
<span class="cm"> *	changing flag to indicate any ldisc change is now over.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: nobody should set the TTY_LDISC bit except via this function.</span>
<span class="cm"> *	Clearing directly is allowed.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_ldisc_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_LDISC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_LDISC_CHANGING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_ldisc_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_flush	-	flush line discipline queue</span>
<span class="cm"> *	@tty: tty</span>
<span class="cm"> *</span>
<span class="cm"> *	Flush the line discipline queue (if any) for this tty. If there</span>
<span class="cm"> *	is no line discipline active this is a no-op.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_ldisc_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flush_buffer</span><span class="p">)</span>
			<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tty_buffer_flush</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_ldisc_flush</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_set_termios_ldisc		-	set ldisc field</span>
<span class="cm"> *	@tty: tty structure</span>
<span class="cm"> *	@num: line discipline number</span>
<span class="cm"> *</span>
<span class="cm"> *	This is probably overkill for real world processors but</span>
<span class="cm"> *	they are not on hot paths so a little discipline won&#39;t do</span>
<span class="cm"> *	any harm.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: takes termios_mutex</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tty_set_termios_ldisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_line</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_open		-	open a line discipline</span>
<span class="cm"> *	@tty: tty we are opening the ldisc on</span>
<span class="cm"> *	@ld: discipline to open</span>
<span class="cm"> *</span>
<span class="cm"> *	A helper opening method. Also a convenient debugging and check</span>
<span class="cm"> *	point.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: always called with BTM already held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_ldisc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TTY_LDISC_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
                <span class="cm">/* BTM here locks versus a hangup event */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_LDISC_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_close		-	close a line discipline</span>
<span class="cm"> *	@tty: tty we are opening the ldisc on</span>
<span class="cm"> *	@ld: discipline to close</span>
<span class="cm"> *</span>
<span class="cm"> *	A helper close method. Also a convenient debugging and check</span>
<span class="cm"> *	point.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tty_ldisc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_LDISC_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_LDISC_OPEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
		<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_restore	-	helper for tty ldisc change</span>
<span class="cm"> *	@tty: tty to recover</span>
<span class="cm"> *	@old: previous ldisc</span>
<span class="cm"> *</span>
<span class="cm"> *	Restore the previous line discipline or N_TTY when a line discipline</span>
<span class="cm"> *	change fails due to an open error</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tty_ldisc_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">new_ldisc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/* There is an outstanding reference here so this is safe */</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">tty_ldisc_get</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">old</span><span class="p">));</span>
	<span class="n">tty_ldisc_assign</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
	<span class="n">tty_set_termios_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_ldisc_open</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_ldisc_put</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="cm">/* This driver is always present */</span>
		<span class="n">new_ldisc</span> <span class="o">=</span> <span class="n">tty_ldisc_get</span><span class="p">(</span><span class="n">N_TTY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_ldisc</span><span class="p">))</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;n_tty: get&quot;</span><span class="p">);</span>
		<span class="n">tty_ldisc_assign</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">new_ldisc</span><span class="p">);</span>
		<span class="n">tty_set_termios_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">N_TTY</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">tty_ldisc_open</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">new_ldisc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t open N_TTY ldisc for &quot;</span>
			      <span class="s">&quot;%s --- error %d.&quot;</span><span class="p">,</span>
			      <span class="n">tty_name</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">),</span> <span class="n">r</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_halt		-	shut down the line discipline</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *</span>
<span class="cm"> *	Shut down the line discipline and work queue for this tty device.</span>
<span class="cm"> *	The TTY_LDISC flag being cleared ensures no further references can</span>
<span class="cm"> *	be obtained while the delayed work queue halt ensures that no more</span>
<span class="cm"> *	data is fed to the ldisc.</span>
<span class="cm"> *</span>
<span class="cm"> *	You need to do a &#39;flush_scheduled_work()&#39; (outside the ldisc_mutex)</span>
<span class="cm"> *	in order to make sure any currently executing ldisc work is also</span>
<span class="cm"> *	flushed.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_ldisc_halt</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_LDISC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_flush_works	-	flush all works of a tty</span>
<span class="cm"> *	@tty: tty device to flush works for</span>
<span class="cm"> *</span>
<span class="cm"> *	Sync flush all works belonging to @tty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tty_ldisc_flush_works</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hangup_work</span><span class="p">);</span>
	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">SAK_work</span><span class="p">);</span>
	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_wait_idle	-	wait for the ldisc to become idle</span>
<span class="cm"> *	@tty: tty to wait for</span>
<span class="cm"> *	@timeout: for how long to wait at most</span>
<span class="cm"> *</span>
<span class="cm"> *	Wait for the line discipline to become idle. The discipline must</span>
<span class="cm"> *	have been halted for this to guarantee it remains idle.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_ldisc_wait_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="o">-&gt;</span><span class="n">wq_idle</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_set_ldisc		-	set line discipline</span>
<span class="cm"> *	@tty: the terminal to set</span>
<span class="cm"> *	@ldisc: the line discipline</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the discipline of a tty line. Must be called from a process</span>
<span class="cm"> *	context. The ldisc change logic has to protect itself against any</span>
<span class="cm"> *	overlapping ldisc change (including on the other end of pty pairs),</span>
<span class="cm"> *	the close of one side of a tty/pty pair, and eventually hangup.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: takes tty_ldisc_lock, termios_mutex</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_set_ldisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ldisc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">o_ldisc</span><span class="p">,</span> <span class="o">*</span><span class="n">new_ldisc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work</span><span class="p">,</span> <span class="n">o_work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">o_tty</span><span class="p">;</span>

	<span class="n">new_ldisc</span> <span class="o">=</span> <span class="n">tty_ldisc_get</span><span class="p">(</span><span class="n">ldisc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_ldisc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_ldisc</span><span class="p">);</span>

	<span class="n">tty_lock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 *	We need to look at the tty locking here for pty/tty pairs</span>
<span class="cm">	 *	when both sides try to change in parallel.</span>
<span class="cm">	 */</span>

	<span class="n">o_tty</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>	<span class="cm">/* o_tty is the pty side or NULL */</span>


	<span class="cm">/*</span>
<span class="cm">	 *	Check the no-op case</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">==</span> <span class="n">ldisc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="n">tty_ldisc_put</span><span class="p">(</span><span class="n">new_ldisc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Problem: What do we do if this blocks ?</span>
<span class="cm">	 *	We could deadlock here</span>
<span class="cm">	 */</span>

	<span class="n">tty_wait_until_sent</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">tty_lock</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	We could be midstream of another ldisc change which has</span>
<span class="cm">	 *	dropped the lock during processing. If so we need to wait.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_LDISC_CHANGING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">tty_ldisc_wait</span><span class="p">,</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_LDISC_CHANGING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">tty_lock</span><span class="p">();</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_LDISC_CHANGING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	No more input please, we are switching. The new ldisc</span>
<span class="cm">	 *	will update this value in the ldisc open function</span>
<span class="cm">	 */</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">receive_room</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">o_ldisc</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">;</span>

	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Make sure we don&#39;t change while someone holds a</span>
<span class="cm">	 *	reference to the line discipline. The TTY_LDISC bit</span>
<span class="cm">	 *	prevents anyone taking a reference once it is clear.</span>
<span class="cm">	 *	We need the lock to avoid racing reference takers.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	We must clear the TTY_LDISC bit here to avoid a livelock</span>
<span class="cm">	 *	with a userspace app continually trying to use the tty in</span>
<span class="cm">	 *	parallel to the change and re-referencing the tty.</span>
<span class="cm">	 */</span>

	<span class="n">work</span> <span class="o">=</span> <span class="n">tty_ldisc_halt</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_tty</span><span class="p">)</span>
		<span class="n">o_work</span> <span class="o">=</span> <span class="n">tty_ldisc_halt</span><span class="p">(</span><span class="n">o_tty</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for -&gt;hangup_work and -&gt;buf.work handlers to terminate.</span>
<span class="cm">	 * We must drop the mutex here in case a hangup is also in process.</span>
<span class="cm">	 */</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>

	<span class="n">tty_ldisc_flush_works</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_ldisc_wait_idle</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="n">tty_lock</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>

	<span class="cm">/* handle wait idle failure locked */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_ldisc_put</span><span class="p">(</span><span class="n">new_ldisc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">enable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_HUPPED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We were raced by the hangup method. It will have stomped</span>
<span class="cm">		   the ldisc data and closed the ldisc down */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_LDISC_CHANGING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
		<span class="n">tty_ldisc_put</span><span class="p">(</span><span class="n">new_ldisc</span><span class="p">);</span>
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Shutdown the current discipline. */</span>
	<span class="n">tty_ldisc_close</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">o_ldisc</span><span class="p">);</span>

	<span class="cm">/* Now set up the new line discipline. */</span>
	<span class="n">tty_ldisc_assign</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">new_ldisc</span><span class="p">);</span>
	<span class="n">tty_set_termios_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ldisc</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_ldisc_open</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">new_ldisc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Back to the old one or N_TTY if we can&#39;t */</span>
		<span class="n">tty_ldisc_put</span><span class="p">(</span><span class="n">new_ldisc</span><span class="p">);</span>
		<span class="n">tty_ldisc_restore</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">o_ldisc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* At this point we hold a reference to the new ldisc and a</span>
<span class="cm">	   a reference to the old ldisc. If we ended up flipping back</span>
<span class="cm">	   to the existing ldisc we have two references to it */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">!=</span> <span class="n">o_ldisc</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_ldisc</span><span class="p">)</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">tty_ldisc_put</span><span class="p">(</span><span class="n">o_ldisc</span><span class="p">);</span>

<span class="nl">enable:</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Allow ldisc referencing to occur again</span>
<span class="cm">	 */</span>

	<span class="n">tty_ldisc_enable</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_tty</span><span class="p">)</span>
		<span class="n">tty_ldisc_enable</span><span class="p">(</span><span class="n">o_tty</span><span class="p">);</span>

	<span class="cm">/* Restart the work queue in case no characters kick it off. Safe if</span>
<span class="cm">	   already running */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_work</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_reset_termios	-	reset terminal state</span>
<span class="cm"> *	@tty: tty to reset</span>
<span class="cm"> *</span>
<span class="cm"> *	Restore a terminal to the driver default state.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tty_reset_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>
	<span class="o">*</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_ispeed</span> <span class="o">=</span> <span class="n">tty_termios_input_baud_rate</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_ospeed</span> <span class="o">=</span> <span class="n">tty_termios_baud_rate</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_reinit	-	reinitialise the tty ldisc</span>
<span class="cm"> *	@tty: tty to reinit</span>
<span class="cm"> *	@ldisc: line discipline to reinitialize</span>
<span class="cm"> *</span>
<span class="cm"> *	Switch the tty to a line discipline and leave the ldisc</span>
<span class="cm"> *	state closed</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_ldisc_reinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ldisc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_get</span><span class="p">(</span><span class="n">ldisc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ld</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">tty_ldisc_close</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">);</span>
	<span class="n">tty_ldisc_put</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Switch the line discipline back</span>
<span class="cm">	 */</span>
	<span class="n">tty_ldisc_assign</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ld</span><span class="p">);</span>
	<span class="n">tty_set_termios_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ldisc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_hangup		-	hangup ldisc reset</span>
<span class="cm"> *	@tty: tty being hung up</span>
<span class="cm"> *</span>
<span class="cm"> *	Some tty devices reset their termios when they receive a hangup</span>
<span class="cm"> *	event. In that situation we must also switch back to N_TTY properly</span>
<span class="cm"> *	before we reset the termios data.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: We can take the ldisc mutex as the rest of the code is</span>
<span class="cm"> *	careful to allow for this.</span>
<span class="cm"> *</span>
<span class="cm"> *	In the pty pair case this occurs in the close() path of the</span>
<span class="cm"> *	tty itself so we must be careful about locking rules.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_ldisc_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_RESET_TERMIOS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME! What are the locking issues here? This may me overdoing</span>
<span class="cm">	 * things... This question is especially important now that we&#39;ve</span>
<span class="cm">	 * removed the irqlock.</span>
<span class="cm">	 */</span>
	<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We may have no line discipline at this point */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flush_buffer</span><span class="p">)</span>
			<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">tty_driver_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write_wakeup</span><span class="p">)</span>
			<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">hangup</span><span class="p">)</span>
			<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: Once we trust the LDISC code better we can wait here for</span>
<span class="cm">	 * ldisc completion and fix the driver call race</span>
<span class="cm">	 */</span>
	<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="n">POLLOUT</span><span class="p">);</span>
	<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Shutdown the current line discipline, and reset it to</span>
<span class="cm">	 * N_TTY if need be.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Avoid racing set_ldisc or tty_ldisc_release</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * this is like tty_ldisc_halt, but we need to give up</span>
<span class="cm">	 * the BTM before calling cancel_work_sync, which may</span>
<span class="cm">	 * need to wait for another function taking the BTM</span>
<span class="cm">	 */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_LDISC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
<span class="nl">retry:</span>
	<span class="n">tty_lock</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>

	<span class="cm">/* At this point we have a closed ldisc and we want to</span>
<span class="cm">	   reopen it. We could defer this to the next open but</span>
<span class="cm">	   it means auditing a lot of other paths so this is</span>
<span class="cm">	   a FIXME */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Not yet closed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">cur_n</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">],</span> <span class="n">tty_n</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
			<span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">tty_unlock</span><span class="p">();</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">tty_ldisc_wait_idle</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">timeout</span> <span class="o">=</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>
				<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_WARNING</span>
					<span class="s">&quot;%s: waiting (%s) for %s took too long, but we keep waiting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">get_task_comm</span><span class="p">(</span><span class="n">cur_n</span><span class="p">,</span> <span class="n">current</span><span class="p">),</span>
					<span class="n">tty_name</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">tty_n</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty_ldisc_reinit</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_line</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">tty_ldisc_open</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If the re-open fails or we reset then go to N_TTY. The</span>
<span class="cm">		   N_TTY open cannot fail */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset</span> <span class="o">||</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tty_ldisc_reinit</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">N_TTY</span><span class="p">));</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tty_ldisc_open</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">tty_ldisc_enable</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
		<span class="n">tty_reset_termios</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_setup			-	open line discipline</span>
<span class="cm"> *	@tty: tty being shut down</span>
<span class="cm"> *	@o_tty: pair tty for pty/tty pairs</span>
<span class="cm"> *</span>
<span class="cm"> *	Called during the initial open of a tty/pty pair in order to set up the</span>
<span class="cm"> *	line disciplines and bind them to the tty. This has no locking issues</span>
<span class="cm"> *	as the device isn&#39;t yet active.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_ldisc_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">o_tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_ldisc_open</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ld</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">o_tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_ldisc_open</span><span class="p">(</span><span class="n">o_tty</span><span class="p">,</span> <span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tty_ldisc_close</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ld</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tty_ldisc_enable</span><span class="p">(</span><span class="n">o_tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tty_ldisc_enable</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_release		-	release line discipline</span>
<span class="cm"> *	@tty: tty being shut down</span>
<span class="cm"> *	@o_tty: pair tty for pty/tty pairs</span>
<span class="cm"> *</span>
<span class="cm"> *	Called during the final close of a tty/pty pair in order to shut down</span>
<span class="cm"> *	the line discpline layer. On exit the ldisc assigned is N_TTY and the</span>
<span class="cm"> *	ldisc has not been opened.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_ldisc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">o_tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Prevent flush_to_ldisc() from rescheduling the work for later.  Then</span>
<span class="cm">	 * kill any delayed work. As this is the final close it does not</span>
<span class="cm">	 * race with the set_ldisc code path.</span>
<span class="cm">	 */</span>

	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="n">tty_ldisc_halt</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">tty_ldisc_flush_works</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">tty_lock</span><span class="p">();</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now kill off the ldisc</span>
<span class="cm">	 */</span>
	<span class="n">tty_ldisc_close</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">);</span>
	<span class="n">tty_ldisc_put</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">);</span>
	<span class="cm">/* Force an oops if we mess this up */</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Ensure the next open requests the N_TTY ldisc */</span>
	<span class="n">tty_set_termios_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">N_TTY</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>

	<span class="cm">/* This will need doing differently if we need to lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_tty</span><span class="p">)</span>
		<span class="n">tty_ldisc_release</span><span class="p">(</span><span class="n">o_tty</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* And the memory resources remaining (buffers, termios) will be</span>
<span class="cm">	   disposed of when the kref hits zero */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_init		-	ldisc setup for new tty</span>
<span class="cm"> *	@tty: tty being allocated</span>
<span class="cm"> *</span>
<span class="cm"> *	Set up the line discipline objects for a newly allocated tty. Note that</span>
<span class="cm"> *	the tty structure is not completely set up when this call is made.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_ldisc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_get</span><span class="p">(</span><span class="n">N_TTY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ld</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;n_tty: init_tty&quot;</span><span class="p">);</span>
	<span class="n">tty_ldisc_assign</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ld</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_ldisc_init		-	ldisc cleanup for new tty</span>
<span class="cm"> *	@tty: tty that was allocated recently</span>
<span class="cm"> *</span>
<span class="cm"> *	The tty structure must not becompletely set up (tty_ldisc_setup) when</span>
<span class="cm"> *      this call is made.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tty_ldisc_deinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="p">);</span>
	<span class="n">tty_ldisc_assign</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tty_ldisc_begin</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Setup the default TTY line discipline. */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">tty_register_ldisc</span><span class="p">(</span><span class="n">N_TTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_ldisc_N_TTY</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
