<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › synclink.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>synclink.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * $Id: synclink.c,v 4.38 2005/11/07 16:30:34 paulkf Exp $</span>
<span class="cm"> *</span>
<span class="cm"> * Device driver for Microgate SyncLink ISA and PCI</span>
<span class="cm"> * high speed multiprotocol serial adapters.</span>
<span class="cm"> *</span>
<span class="cm"> * written by Paul Fulghum for Microgate Corporation</span>
<span class="cm"> * paulkf@microgate.com</span>
<span class="cm"> *</span>
<span class="cm"> * Microgate and SyncLink are trademarks of Microgate Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Derived from serial.c written by Theodore Ts&#39;o and Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> * Original release 01/11/99</span>
<span class="cm"> *</span>
<span class="cm"> * This code is released under the GNU General Public License (GPL)</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is primarily intended for use in synchronous</span>
<span class="cm"> * HDLC mode. Asynchronous mode is also provided.</span>
<span class="cm"> *</span>
<span class="cm"> * When operating in synchronous mode, each call to mgsl_write()</span>
<span class="cm"> * contains exactly one complete HDLC frame. Calling mgsl_put_char</span>
<span class="cm"> * will start assembling an HDLC frame that will not be sent until</span>
<span class="cm"> * mgsl_flush_chars or mgsl_write is called.</span>
<span class="cm"> * </span>
<span class="cm"> * Synchronous receive data is reported as complete frames. To accomplish</span>
<span class="cm"> * this, the TTY flip buffer is bypassed (too small to hold largest</span>
<span class="cm"> * frame and may fragment frames) and the line discipline</span>
<span class="cm"> * receive entry point is called directly.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver has been tested with a slightly modified ppp.c driver</span>
<span class="cm"> * for synchronous PPP.</span>
<span class="cm"> *</span>
<span class="cm"> * 2000/02/16</span>
<span class="cm"> * Added interface for syncppp.c driver (an alternate synchronous PPP</span>
<span class="cm"> * implementation that also supports Cisco HDLC). Each device instance</span>
<span class="cm"> * registers as a tty device AND a network device (if dosyncppp option</span>
<span class="cm"> * is set for the device). The functionality is determined by which</span>
<span class="cm"> * device interface is opened.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<span class="cm"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,</span>
<span class="cm"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="cm"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED</span>
<span class="cm"> * OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#if defined(__i386__)</span>
<span class="cp">#  define BREAKPOINT() asm(&quot;   int $3&quot;);</span>
<span class="cp">#else</span>
<span class="cp">#  define BREAKPOINT() { }</span>
<span class="cp">#endif</span>

<span class="cp">#define MAX_ISA_DEVICES 10</span>
<span class="cp">#define MAX_PCI_DEVICES 10</span>
<span class="cp">#define MAX_TOTAL_DEVICES 20</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/synclink.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;asm/types.h&gt;</span>
<span class="cp">#include &lt;linux/termios.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/hdlc.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>

<span class="cp">#if defined(CONFIG_HDLC) || (defined(CONFIG_HDLC_MODULE) &amp;&amp; defined(CONFIG_SYNCLINK_MODULE))</span>
<span class="cp">#define SYNCLINK_GENERIC_HDLC 1</span>
<span class="cp">#else</span>
<span class="cp">#define SYNCLINK_GENERIC_HDLC 0</span>
<span class="cp">#endif</span>

<span class="cp">#define GET_USER(error,value,addr) error = get_user(value,addr)</span>
<span class="cp">#define COPY_FROM_USER(error,dest,src,size) error = copy_from_user(dest,src,size) ? -EFAULT : 0</span>
<span class="cp">#define PUT_USER(error,value,addr) error = put_user(value,addr)</span>
<span class="cp">#define COPY_TO_USER(error,dest,src,size) error = copy_to_user(dest,src,size) ? -EFAULT : 0</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#define RCLRVALUE 0xffff</span>

<span class="k">static</span> <span class="n">MGSL_PARAMS</span> <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MGSL_MODE_HDLC</span><span class="p">,</span>			<span class="cm">/* unsigned long mode */</span>
	<span class="mi">0</span><span class="p">,</span>				<span class="cm">/* unsigned char loopback; */</span>
	<span class="n">HDLC_FLAG_UNDERRUN_ABORT15</span><span class="p">,</span>	<span class="cm">/* unsigned short flags; */</span>
	<span class="n">HDLC_ENCODING_NRZI_SPACE</span><span class="p">,</span>	<span class="cm">/* unsigned char encoding; */</span>
	<span class="mi">0</span><span class="p">,</span>				<span class="cm">/* unsigned long clock_speed; */</span>
	<span class="mh">0xff</span><span class="p">,</span>				<span class="cm">/* unsigned char addr_filter; */</span>
	<span class="n">HDLC_CRC_16_CCITT</span><span class="p">,</span>		<span class="cm">/* unsigned short crc_type; */</span>
	<span class="n">HDLC_PREAMBLE_LENGTH_8BITS</span><span class="p">,</span>	<span class="cm">/* unsigned char preamble_length; */</span>
	<span class="n">HDLC_PREAMBLE_PATTERN_NONE</span><span class="p">,</span>	<span class="cm">/* unsigned char preamble; */</span>
	<span class="mi">9600</span><span class="p">,</span>				<span class="cm">/* unsigned long data_rate; */</span>
	<span class="mi">8</span><span class="p">,</span>				<span class="cm">/* unsigned char data_bits; */</span>
	<span class="mi">1</span><span class="p">,</span>				<span class="cm">/* unsigned char stop_bits; */</span>
	<span class="n">ASYNC_PARITY_NONE</span>		<span class="cm">/* unsigned char parity; */</span>
<span class="p">};</span>

<span class="cp">#define SHARED_MEM_ADDRESS_SIZE 0x40000</span>
<span class="cp">#define BUFFERLISTSIZE 4096</span>
<span class="cp">#define DMABUFFERSIZE 4096</span>
<span class="cp">#define MAXRXFRAMES 7</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_DMABUFFERENTRY</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phys_addr</span><span class="p">;</span>	<span class="cm">/* 32-bit flat physical address of data buffer */</span>
	<span class="k">volatile</span> <span class="n">u16</span> <span class="n">count</span><span class="p">;</span>	<span class="cm">/* buffer size/data count */</span>
	<span class="k">volatile</span> <span class="n">u16</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* Control/status field */</span>
	<span class="k">volatile</span> <span class="n">u16</span> <span class="n">rcc</span><span class="p">;</span>	<span class="cm">/* character count field */</span>
	<span class="n">u16</span> <span class="n">reserved</span><span class="p">;</span>	<span class="cm">/* padding required by 16C32 */</span>
	<span class="n">u32</span> <span class="n">link</span><span class="p">;</span>	<span class="cm">/* 32-bit flat link to next buffer entry */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">virt_addr</span><span class="p">;</span>	<span class="cm">/* virtual address of data buffer */</span>
	<span class="n">u32</span> <span class="n">phys_entry</span><span class="p">;</span>	<span class="cm">/* physical address of this buffer entry */</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_addr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">DMABUFFERENTRY</span><span class="p">,</span> <span class="o">*</span><span class="n">DMAPBUFFERENTRY</span><span class="p">;</span>

<span class="cm">/* The queue of BH actions to be performed */</span>

<span class="cp">#define BH_RECEIVE  1</span>
<span class="cp">#define BH_TRANSMIT 2</span>
<span class="cp">#define BH_STATUS   4</span>

<span class="cp">#define IO_PIN_SHUTDOWN_LIMIT 100</span>

<span class="k">struct</span>	<span class="n">_input_signal_events</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">ri_up</span><span class="p">;</span>	
	<span class="kt">int</span>	<span class="n">ri_down</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dsr_up</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dsr_down</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dcd_up</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dcd_down</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cts_up</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cts_down</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* transmit holding buffer definitions*/</span>
<span class="cp">#define MAX_TX_HOLDING_BUFFERS 5</span>
<span class="k">struct</span> <span class="n">tx_holding_buffer</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">buffer_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span>	<span class="n">buffer</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Device instance data structure</span>
<span class="cm"> */</span>
 
<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">magic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span>		<span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">line</span><span class="p">;</span>
	<span class="kt">int</span>                     <span class="n">hw_version</span><span class="p">;</span>
	
	<span class="k">struct</span> <span class="n">mgsl_icount</span>	<span class="n">icount</span><span class="p">;</span>
	
	<span class="kt">int</span>			<span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">x_char</span><span class="p">;</span>		<span class="cm">/* xon/xoff character */</span>
	<span class="n">u16</span>			<span class="n">read_status_mask</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">ignore_status_mask</span><span class="p">;</span>	
	<span class="kt">unsigned</span> <span class="kt">char</span> 		<span class="o">*</span><span class="n">xmit_buf</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">xmit_head</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">xmit_tail</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">xmit_cnt</span><span class="p">;</span>
	
	<span class="n">wait_queue_head_t</span>	<span class="n">status_event_wait_q</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">event_wait_q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">tx_timer</span><span class="p">;</span>	<span class="cm">/* HDLC transmit timeout timer */</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span>	<span class="o">*</span><span class="n">next_device</span><span class="p">;</span>	<span class="cm">/* device list link */</span>
	
	<span class="n">spinlock_t</span> <span class="n">irq_spinlock</span><span class="p">;</span>		<span class="cm">/* spinlock for synchronizing with ISR */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">task</span><span class="p">;</span>		<span class="cm">/* task structure for scheduling bh */</span>

	<span class="n">u32</span> <span class="n">EventMask</span><span class="p">;</span>			<span class="cm">/* event trigger mask */</span>
	<span class="n">u32</span> <span class="n">RecordedEvents</span><span class="p">;</span>		<span class="cm">/* pending events */</span>

	<span class="n">u32</span> <span class="n">max_frame_size</span><span class="p">;</span>		<span class="cm">/* as set by device config */</span>

	<span class="n">u32</span> <span class="n">pending_bh</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">bh_running</span><span class="p">;</span>		<span class="cm">/* Protection from multiple */</span>
	<span class="kt">int</span> <span class="n">isr_overflow</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bh_requested</span><span class="p">;</span>
	
	<span class="kt">int</span> <span class="n">dcd_chkcount</span><span class="p">;</span>		<span class="cm">/* check counts to prevent */</span>
	<span class="kt">int</span> <span class="n">cts_chkcount</span><span class="p">;</span>		<span class="cm">/* too many IRQs if a signal */</span>
	<span class="kt">int</span> <span class="n">dsr_chkcount</span><span class="p">;</span>		<span class="cm">/* is floating */</span>
	<span class="kt">int</span> <span class="n">ri_chkcount</span><span class="p">;</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer_list</span><span class="p">;</span>		<span class="cm">/* virtual address of Rx &amp; Tx buffer lists */</span>
	<span class="n">u32</span> <span class="n">buffer_list_phys</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">buffer_list_dma_addr</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_buffer_count</span><span class="p">;</span>	<span class="cm">/* count of total allocated Rx buffers */</span>
	<span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">rx_buffer_list</span><span class="p">;</span>	<span class="cm">/* list of receive buffer entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_rx_buffer</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">num_tx_dma_buffers</span><span class="p">;</span>		<span class="cm">/* number of tx dma frames required */</span>
 	<span class="kt">int</span> <span class="n">tx_dma_buffers_used</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_buffer_count</span><span class="p">;</span>	<span class="cm">/* count of total allocated Tx buffers */</span>
	<span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">tx_buffer_list</span><span class="p">;</span>	<span class="cm">/* list of transmit buffer entries */</span>
	<span class="kt">int</span> <span class="n">start_tx_dma_buffer</span><span class="p">;</span>	<span class="cm">/* tx dma buffer to start tx dma operation */</span>
	<span class="kt">int</span> <span class="n">current_tx_buffer</span><span class="p">;</span>          <span class="cm">/* next tx dma buffer to be loaded */</span>
	
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">intermediate_rxbuffer</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">num_tx_holding_buffers</span><span class="p">;</span>	<span class="cm">/* number of tx holding buffer allocated */</span>
	<span class="kt">int</span> <span class="n">get_tx_holding_index</span><span class="p">;</span>  	<span class="cm">/* next tx holding buffer for adapter to load */</span>
	<span class="kt">int</span> <span class="n">put_tx_holding_index</span><span class="p">;</span>  	<span class="cm">/* next tx holding buffer to store user request */</span>
	<span class="kt">int</span> <span class="n">tx_holding_count</span><span class="p">;</span>		<span class="cm">/* number of tx holding buffers waiting */</span>
	<span class="k">struct</span> <span class="n">tx_holding_buffer</span> <span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">MAX_TX_HOLDING_BUFFERS</span><span class="p">];</span>

	<span class="n">bool</span> <span class="n">rx_enabled</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_overflow</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rx_rcc_underrun</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">tx_enabled</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">tx_active</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idle_mode</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">cmr_value</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tcsr_value</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">device_name</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>		<span class="cm">/* device instance name */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bus_type</span><span class="p">;</span>	<span class="cm">/* expansion bus type (ISA,EISA,PCI) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bus</span><span class="p">;</span>		<span class="cm">/* expansion bus number (zero based) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">function</span><span class="p">;</span>		<span class="cm">/* PCI device number */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_base</span><span class="p">;</span>		<span class="cm">/* base I/O address of adapter */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_addr_size</span><span class="p">;</span>	<span class="cm">/* size of the I/O address range */</span>
	<span class="n">bool</span> <span class="n">io_addr_requested</span><span class="p">;</span>		<span class="cm">/* true if I/O address requested */</span>
	
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_level</span><span class="p">;</span>		<span class="cm">/* interrupt level */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">irq_requested</span><span class="p">;</span>		<span class="cm">/* true if IRQ requested */</span>
	
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dma_level</span><span class="p">;</span>		<span class="cm">/* DMA channel */</span>
	<span class="n">bool</span> <span class="n">dma_requested</span><span class="p">;</span>		<span class="cm">/* true if dma channel requested */</span>

	<span class="n">u16</span> <span class="n">mbre_bit</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">loopback_bits</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">usc_idle_mode</span><span class="p">;</span>

	<span class="n">MGSL_PARAMS</span> <span class="n">params</span><span class="p">;</span>		<span class="cm">/* communications parameters */</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">serial_signals</span><span class="p">;</span>	<span class="cm">/* current serial signal states */</span>

	<span class="n">bool</span> <span class="n">irq_occurred</span><span class="p">;</span>		<span class="cm">/* for diagnostics use */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">init_error</span><span class="p">;</span>	<span class="cm">/* Initialization startup error 		(DIAGS)	*/</span>
	<span class="kt">int</span>	<span class="n">fDiagnosticsmode</span><span class="p">;</span>	<span class="cm">/* Driver in Diagnostic mode?			(DIAGS)	*/</span>

	<span class="n">u32</span> <span class="n">last_mem_alloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">memory_base</span><span class="p">;</span>	<span class="cm">/* shared memory address (PCI only) */</span>
	<span class="n">u32</span> <span class="n">phys_memory_base</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">shared_mem_requested</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">lcr_base</span><span class="p">;</span>	<span class="cm">/* local config registers (PCI only) */</span>
	<span class="n">u32</span> <span class="n">phys_lcr_base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lcr_offset</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">lcr_mem_requested</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">misc_ctrl_value</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">flag_buf</span><span class="p">[</span><span class="n">MAX_ASYNC_BUFFER_SIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">char_buf</span><span class="p">[</span><span class="n">MAX_ASYNC_BUFFER_SIZE</span><span class="p">];</span>	
	<span class="n">bool</span> <span class="n">drop_rts_on_tx_done</span><span class="p">;</span>

	<span class="n">bool</span> <span class="n">loopmode_insert_requested</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">loopmode_send_done_requested</span><span class="p">;</span>
	
	<span class="k">struct</span>	<span class="n">_input_signal_events</span>	<span class="n">input_signal_events</span><span class="p">;</span>

	<span class="cm">/* generic HDLC device parts */</span>
	<span class="kt">int</span> <span class="n">netcount</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">netlock</span><span class="p">;</span>

<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cp">#define MGSL_MAGIC 0x5401</span>

<span class="cm">/*</span>
<span class="cm"> * The size of the serial xmit buffer is 1 page, or 4096 bytes</span>
<span class="cm"> */</span>
<span class="cp">#ifndef SERIAL_XMIT_SIZE</span>
<span class="cp">#define SERIAL_XMIT_SIZE 4096</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * These macros define the offsets used in calculating the</span>
<span class="cm"> * I/O address of the specified USC registers.</span>
<span class="cm"> */</span>


<span class="cp">#define DCPIN 2		</span><span class="cm">/* Bit 1 of I/O address */</span><span class="cp"></span>
<span class="cp">#define SDPIN 4		</span><span class="cm">/* Bit 2 of I/O address */</span><span class="cp"></span>

<span class="cp">#define DCAR 0		</span><span class="cm">/* DMA command/address register */</span><span class="cp"></span>
<span class="cp">#define CCAR SDPIN		</span><span class="cm">/* channel command/address register */</span><span class="cp"></span>
<span class="cp">#define DATAREG DCPIN + SDPIN	</span><span class="cm">/* serial data register */</span><span class="cp"></span>
<span class="cp">#define MSBONLY 0x41</span>
<span class="cp">#define LSBONLY 0x40</span>

<span class="cm">/*</span>
<span class="cm"> * These macros define the register address (ordinal number)</span>
<span class="cm"> * used for writing address/value pairs to the USC.</span>
<span class="cm"> */</span>

<span class="cp">#define CMR	0x02	</span><span class="cm">/* Channel mode Register */</span><span class="cp"></span>
<span class="cp">#define CCSR	0x04	</span><span class="cm">/* Channel Command/status Register */</span><span class="cp"></span>
<span class="cp">#define CCR	0x06	</span><span class="cm">/* Channel Control Register */</span><span class="cp"></span>
<span class="cp">#define PSR	0x08	</span><span class="cm">/* Port status Register */</span><span class="cp"></span>
<span class="cp">#define PCR	0x0a	</span><span class="cm">/* Port Control Register */</span><span class="cp"></span>
<span class="cp">#define TMDR	0x0c	</span><span class="cm">/* Test mode Data Register */</span><span class="cp"></span>
<span class="cp">#define TMCR	0x0e	</span><span class="cm">/* Test mode Control Register */</span><span class="cp"></span>
<span class="cp">#define CMCR	0x10	</span><span class="cm">/* Clock mode Control Register */</span><span class="cp"></span>
<span class="cp">#define HCR	0x12	</span><span class="cm">/* Hardware Configuration Register */</span><span class="cp"></span>
<span class="cp">#define IVR	0x14	</span><span class="cm">/* Interrupt Vector Register */</span><span class="cp"></span>
<span class="cp">#define IOCR	0x16	</span><span class="cm">/* Input/Output Control Register */</span><span class="cp"></span>
<span class="cp">#define ICR	0x18	</span><span class="cm">/* Interrupt Control Register */</span><span class="cp"></span>
<span class="cp">#define DCCR	0x1a	</span><span class="cm">/* Daisy Chain Control Register */</span><span class="cp"></span>
<span class="cp">#define MISR	0x1c	</span><span class="cm">/* Misc Interrupt status Register */</span><span class="cp"></span>
<span class="cp">#define SICR	0x1e	</span><span class="cm">/* status Interrupt Control Register */</span><span class="cp"></span>
<span class="cp">#define RDR	0x20	</span><span class="cm">/* Receive Data Register */</span><span class="cp"></span>
<span class="cp">#define RMR	0x22	</span><span class="cm">/* Receive mode Register */</span><span class="cp"></span>
<span class="cp">#define RCSR	0x24	</span><span class="cm">/* Receive Command/status Register */</span><span class="cp"></span>
<span class="cp">#define RICR	0x26	</span><span class="cm">/* Receive Interrupt Control Register */</span><span class="cp"></span>
<span class="cp">#define RSR	0x28	</span><span class="cm">/* Receive Sync Register */</span><span class="cp"></span>
<span class="cp">#define RCLR	0x2a	</span><span class="cm">/* Receive count Limit Register */</span><span class="cp"></span>
<span class="cp">#define RCCR	0x2c	</span><span class="cm">/* Receive Character count Register */</span><span class="cp"></span>
<span class="cp">#define TC0R	0x2e	</span><span class="cm">/* Time Constant 0 Register */</span><span class="cp"></span>
<span class="cp">#define TDR	0x30	</span><span class="cm">/* Transmit Data Register */</span><span class="cp"></span>
<span class="cp">#define TMR	0x32	</span><span class="cm">/* Transmit mode Register */</span><span class="cp"></span>
<span class="cp">#define TCSR	0x34	</span><span class="cm">/* Transmit Command/status Register */</span><span class="cp"></span>
<span class="cp">#define TICR	0x36	</span><span class="cm">/* Transmit Interrupt Control Register */</span><span class="cp"></span>
<span class="cp">#define TSR	0x38	</span><span class="cm">/* Transmit Sync Register */</span><span class="cp"></span>
<span class="cp">#define TCLR	0x3a	</span><span class="cm">/* Transmit count Limit Register */</span><span class="cp"></span>
<span class="cp">#define TCCR	0x3c	</span><span class="cm">/* Transmit Character count Register */</span><span class="cp"></span>
<span class="cp">#define TC1R	0x3e	</span><span class="cm">/* Time Constant 1 Register */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * MACRO DEFINITIONS FOR DMA REGISTERS</span>
<span class="cm"> */</span>

<span class="cp">#define DCR	0x06	</span><span class="cm">/* DMA Control Register (shared) */</span><span class="cp"></span>
<span class="cp">#define DACR	0x08	</span><span class="cm">/* DMA Array count Register (shared) */</span><span class="cp"></span>
<span class="cp">#define BDCR	0x12	</span><span class="cm">/* Burst/Dwell Control Register (shared) */</span><span class="cp"></span>
<span class="cp">#define DIVR	0x14	</span><span class="cm">/* DMA Interrupt Vector Register (shared) */</span><span class="cp">	</span>
<span class="cp">#define DICR	0x18	</span><span class="cm">/* DMA Interrupt Control Register (shared) */</span><span class="cp"></span>
<span class="cp">#define CDIR	0x1a	</span><span class="cm">/* Clear DMA Interrupt Register (shared) */</span><span class="cp"></span>
<span class="cp">#define SDIR	0x1c	</span><span class="cm">/* Set DMA Interrupt Register (shared) */</span><span class="cp"></span>

<span class="cp">#define TDMR	0x02	</span><span class="cm">/* Transmit DMA mode Register */</span><span class="cp"></span>
<span class="cp">#define TDIAR	0x1e	</span><span class="cm">/* Transmit DMA Interrupt Arm Register */</span><span class="cp"></span>
<span class="cp">#define TBCR	0x2a	</span><span class="cm">/* Transmit Byte count Register */</span><span class="cp"></span>
<span class="cp">#define TARL	0x2c	</span><span class="cm">/* Transmit Address Register (low) */</span><span class="cp"></span>
<span class="cp">#define TARU	0x2e	</span><span class="cm">/* Transmit Address Register (high) */</span><span class="cp"></span>
<span class="cp">#define NTBCR	0x3a	</span><span class="cm">/* Next Transmit Byte count Register */</span><span class="cp"></span>
<span class="cp">#define NTARL	0x3c	</span><span class="cm">/* Next Transmit Address Register (low) */</span><span class="cp"></span>
<span class="cp">#define NTARU	0x3e	</span><span class="cm">/* Next Transmit Address Register (high) */</span><span class="cp"></span>

<span class="cp">#define RDMR	0x82	</span><span class="cm">/* Receive DMA mode Register (non-shared) */</span><span class="cp"></span>
<span class="cp">#define RDIAR	0x9e	</span><span class="cm">/* Receive DMA Interrupt Arm Register */</span><span class="cp"></span>
<span class="cp">#define RBCR	0xaa	</span><span class="cm">/* Receive Byte count Register */</span><span class="cp"></span>
<span class="cp">#define RARL	0xac	</span><span class="cm">/* Receive Address Register (low) */</span><span class="cp"></span>
<span class="cp">#define RARU	0xae	</span><span class="cm">/* Receive Address Register (high) */</span><span class="cp"></span>
<span class="cp">#define NRBCR	0xba	</span><span class="cm">/* Next Receive Byte count Register */</span><span class="cp"></span>
<span class="cp">#define NRARL	0xbc	</span><span class="cm">/* Next Receive Address Register (low) */</span><span class="cp"></span>
<span class="cp">#define NRARU	0xbe	</span><span class="cm">/* Next Receive Address Register (high) */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * MACRO DEFINITIONS FOR MODEM STATUS BITS</span>
<span class="cm"> */</span>

<span class="cp">#define MODEMSTATUS_DTR 0x80</span>
<span class="cp">#define MODEMSTATUS_DSR 0x40</span>
<span class="cp">#define MODEMSTATUS_RTS 0x20</span>
<span class="cp">#define MODEMSTATUS_CTS 0x10</span>
<span class="cp">#define MODEMSTATUS_RI  0x04</span>
<span class="cp">#define MODEMSTATUS_DCD 0x01</span>


<span class="cm">/*</span>
<span class="cm"> * Channel Command/Address Register (CCAR) Command Codes</span>
<span class="cm"> */</span>

<span class="cp">#define RTCmd_Null			0x0000</span>
<span class="cp">#define RTCmd_ResetHighestIus		0x1000</span>
<span class="cp">#define RTCmd_TriggerChannelLoadDma	0x2000</span>
<span class="cp">#define RTCmd_TriggerRxDma		0x2800</span>
<span class="cp">#define RTCmd_TriggerTxDma		0x3000</span>
<span class="cp">#define RTCmd_TriggerRxAndTxDma		0x3800</span>
<span class="cp">#define RTCmd_PurgeRxFifo		0x4800</span>
<span class="cp">#define RTCmd_PurgeTxFifo		0x5000</span>
<span class="cp">#define RTCmd_PurgeRxAndTxFifo		0x5800</span>
<span class="cp">#define RTCmd_LoadRcc			0x6800</span>
<span class="cp">#define RTCmd_LoadTcc			0x7000</span>
<span class="cp">#define RTCmd_LoadRccAndTcc		0x7800</span>
<span class="cp">#define RTCmd_LoadTC0			0x8800</span>
<span class="cp">#define RTCmd_LoadTC1			0x9000</span>
<span class="cp">#define RTCmd_LoadTC0AndTC1		0x9800</span>
<span class="cp">#define RTCmd_SerialDataLSBFirst	0xa000</span>
<span class="cp">#define RTCmd_SerialDataMSBFirst	0xa800</span>
<span class="cp">#define RTCmd_SelectBigEndian		0xb000</span>
<span class="cp">#define RTCmd_SelectLittleEndian	0xb800</span>


<span class="cm">/*</span>
<span class="cm"> * DMA Command/Address Register (DCAR) Command Codes</span>
<span class="cm"> */</span>

<span class="cp">#define DmaCmd_Null			0x0000</span>
<span class="cp">#define DmaCmd_ResetTxChannel		0x1000</span>
<span class="cp">#define DmaCmd_ResetRxChannel		0x1200</span>
<span class="cp">#define DmaCmd_StartTxChannel		0x2000</span>
<span class="cp">#define DmaCmd_StartRxChannel		0x2200</span>
<span class="cp">#define DmaCmd_ContinueTxChannel	0x3000</span>
<span class="cp">#define DmaCmd_ContinueRxChannel	0x3200</span>
<span class="cp">#define DmaCmd_PauseTxChannel		0x4000</span>
<span class="cp">#define DmaCmd_PauseRxChannel		0x4200</span>
<span class="cp">#define DmaCmd_AbortTxChannel		0x5000</span>
<span class="cp">#define DmaCmd_AbortRxChannel		0x5200</span>
<span class="cp">#define DmaCmd_InitTxChannel		0x7000</span>
<span class="cp">#define DmaCmd_InitRxChannel		0x7200</span>
<span class="cp">#define DmaCmd_ResetHighestDmaIus	0x8000</span>
<span class="cp">#define DmaCmd_ResetAllChannels		0x9000</span>
<span class="cp">#define DmaCmd_StartAllChannels		0xa000</span>
<span class="cp">#define DmaCmd_ContinueAllChannels	0xb000</span>
<span class="cp">#define DmaCmd_PauseAllChannels		0xc000</span>
<span class="cp">#define DmaCmd_AbortAllChannels		0xd000</span>
<span class="cp">#define DmaCmd_InitAllChannels		0xf000</span>

<span class="cp">#define TCmd_Null			0x0000</span>
<span class="cp">#define TCmd_ClearTxCRC			0x2000</span>
<span class="cp">#define TCmd_SelectTicrTtsaData		0x4000</span>
<span class="cp">#define TCmd_SelectTicrTxFifostatus	0x5000</span>
<span class="cp">#define TCmd_SelectTicrIntLevel		0x6000</span>
<span class="cp">#define TCmd_SelectTicrdma_level		0x7000</span>
<span class="cp">#define TCmd_SendFrame			0x8000</span>
<span class="cp">#define TCmd_SendAbort			0x9000</span>
<span class="cp">#define TCmd_EnableDleInsertion		0xc000</span>
<span class="cp">#define TCmd_DisableDleInsertion	0xd000</span>
<span class="cp">#define TCmd_ClearEofEom		0xe000</span>
<span class="cp">#define TCmd_SetEofEom			0xf000</span>

<span class="cp">#define RCmd_Null			0x0000</span>
<span class="cp">#define RCmd_ClearRxCRC			0x2000</span>
<span class="cp">#define RCmd_EnterHuntmode		0x3000</span>
<span class="cp">#define RCmd_SelectRicrRtsaData		0x4000</span>
<span class="cp">#define RCmd_SelectRicrRxFifostatus	0x5000</span>
<span class="cp">#define RCmd_SelectRicrIntLevel		0x6000</span>
<span class="cp">#define RCmd_SelectRicrdma_level		0x7000</span>

<span class="cm">/*</span>
<span class="cm"> * Bits for enabling and disabling IRQs in Interrupt Control Register (ICR)</span>
<span class="cm"> */</span>
 
<span class="cp">#define RECEIVE_STATUS		BIT5</span>
<span class="cp">#define RECEIVE_DATA		BIT4</span>
<span class="cp">#define TRANSMIT_STATUS		BIT3</span>
<span class="cp">#define TRANSMIT_DATA		BIT2</span>
<span class="cp">#define IO_PIN			BIT1</span>
<span class="cp">#define MISC			BIT0</span>


<span class="cm">/*</span>
<span class="cm"> * Receive status Bits in Receive Command/status Register RCSR</span>
<span class="cm"> */</span>

<span class="cp">#define RXSTATUS_SHORT_FRAME		BIT8</span>
<span class="cp">#define RXSTATUS_CODE_VIOLATION		BIT8</span>
<span class="cp">#define RXSTATUS_EXITED_HUNT		BIT7</span>
<span class="cp">#define RXSTATUS_IDLE_RECEIVED		BIT6</span>
<span class="cp">#define RXSTATUS_BREAK_RECEIVED		BIT5</span>
<span class="cp">#define RXSTATUS_ABORT_RECEIVED		BIT5</span>
<span class="cp">#define RXSTATUS_RXBOUND		BIT4</span>
<span class="cp">#define RXSTATUS_CRC_ERROR		BIT3</span>
<span class="cp">#define RXSTATUS_FRAMING_ERROR		BIT3</span>
<span class="cp">#define RXSTATUS_ABORT			BIT2</span>
<span class="cp">#define RXSTATUS_PARITY_ERROR		BIT2</span>
<span class="cp">#define RXSTATUS_OVERRUN		BIT1</span>
<span class="cp">#define RXSTATUS_DATA_AVAILABLE		BIT0</span>
<span class="cp">#define RXSTATUS_ALL			0x01f6</span>
<span class="cp">#define usc_UnlatchRxstatusBits(a,b) usc_OutReg( (a), RCSR, (u16)((b) &amp; RXSTATUS_ALL) )</span>

<span class="cm">/*</span>
<span class="cm"> * Values for setting transmit idle mode in </span>
<span class="cm"> * Transmit Control/status Register (TCSR)</span>
<span class="cm"> */</span>
<span class="cp">#define IDLEMODE_FLAGS			0x0000</span>
<span class="cp">#define IDLEMODE_ALT_ONE_ZERO		0x0100</span>
<span class="cp">#define IDLEMODE_ZERO			0x0200</span>
<span class="cp">#define IDLEMODE_ONE			0x0300</span>
<span class="cp">#define IDLEMODE_ALT_MARK_SPACE		0x0500</span>
<span class="cp">#define IDLEMODE_SPACE			0x0600</span>
<span class="cp">#define IDLEMODE_MARK			0x0700</span>
<span class="cp">#define IDLEMODE_MASK			0x0700</span>

<span class="cm">/*</span>
<span class="cm"> * IUSC revision identifiers</span>
<span class="cm"> */</span>
<span class="cp">#define	IUSC_SL1660			0x4d44</span>
<span class="cp">#define IUSC_PRE_SL1660			0x4553</span>

<span class="cm">/*</span>
<span class="cm"> * Transmit status Bits in Transmit Command/status Register (TCSR)</span>
<span class="cm"> */</span>

<span class="cp">#define TCSR_PRESERVE			0x0F00</span>

<span class="cp">#define TCSR_UNDERWAIT			BIT11</span>
<span class="cp">#define TXSTATUS_PREAMBLE_SENT		BIT7</span>
<span class="cp">#define TXSTATUS_IDLE_SENT		BIT6</span>
<span class="cp">#define TXSTATUS_ABORT_SENT		BIT5</span>
<span class="cp">#define TXSTATUS_EOF_SENT		BIT4</span>
<span class="cp">#define TXSTATUS_EOM_SENT		BIT4</span>
<span class="cp">#define TXSTATUS_CRC_SENT		BIT3</span>
<span class="cp">#define TXSTATUS_ALL_SENT		BIT2</span>
<span class="cp">#define TXSTATUS_UNDERRUN		BIT1</span>
<span class="cp">#define TXSTATUS_FIFO_EMPTY		BIT0</span>
<span class="cp">#define TXSTATUS_ALL			0x00fa</span>
<span class="cp">#define usc_UnlatchTxstatusBits(a,b) usc_OutReg( (a), TCSR, (u16)((a)-&gt;tcsr_value + ((b) &amp; 0x00FF)) )</span>
				

<span class="cp">#define MISCSTATUS_RXC_LATCHED		BIT15</span>
<span class="cp">#define MISCSTATUS_RXC			BIT14</span>
<span class="cp">#define MISCSTATUS_TXC_LATCHED		BIT13</span>
<span class="cp">#define MISCSTATUS_TXC			BIT12</span>
<span class="cp">#define MISCSTATUS_RI_LATCHED		BIT11</span>
<span class="cp">#define MISCSTATUS_RI			BIT10</span>
<span class="cp">#define MISCSTATUS_DSR_LATCHED		BIT9</span>
<span class="cp">#define MISCSTATUS_DSR			BIT8</span>
<span class="cp">#define MISCSTATUS_DCD_LATCHED		BIT7</span>
<span class="cp">#define MISCSTATUS_DCD			BIT6</span>
<span class="cp">#define MISCSTATUS_CTS_LATCHED		BIT5</span>
<span class="cp">#define MISCSTATUS_CTS			BIT4</span>
<span class="cp">#define MISCSTATUS_RCC_UNDERRUN		BIT3</span>
<span class="cp">#define MISCSTATUS_DPLL_NO_SYNC		BIT2</span>
<span class="cp">#define MISCSTATUS_BRG1_ZERO		BIT1</span>
<span class="cp">#define MISCSTATUS_BRG0_ZERO		BIT0</span>

<span class="cp">#define usc_UnlatchIostatusBits(a,b) usc_OutReg((a),MISR,(u16)((b) &amp; 0xaaa0))</span>
<span class="cp">#define usc_UnlatchMiscstatusBits(a,b) usc_OutReg((a),MISR,(u16)((b) &amp; 0x000f))</span>

<span class="cp">#define SICR_RXC_ACTIVE			BIT15</span>
<span class="cp">#define SICR_RXC_INACTIVE		BIT14</span>
<span class="cp">#define SICR_RXC			(BIT15+BIT14)</span>
<span class="cp">#define SICR_TXC_ACTIVE			BIT13</span>
<span class="cp">#define SICR_TXC_INACTIVE		BIT12</span>
<span class="cp">#define SICR_TXC			(BIT13+BIT12)</span>
<span class="cp">#define SICR_RI_ACTIVE			BIT11</span>
<span class="cp">#define SICR_RI_INACTIVE		BIT10</span>
<span class="cp">#define SICR_RI				(BIT11+BIT10)</span>
<span class="cp">#define SICR_DSR_ACTIVE			BIT9</span>
<span class="cp">#define SICR_DSR_INACTIVE		BIT8</span>
<span class="cp">#define SICR_DSR			(BIT9+BIT8)</span>
<span class="cp">#define SICR_DCD_ACTIVE			BIT7</span>
<span class="cp">#define SICR_DCD_INACTIVE		BIT6</span>
<span class="cp">#define SICR_DCD			(BIT7+BIT6)</span>
<span class="cp">#define SICR_CTS_ACTIVE			BIT5</span>
<span class="cp">#define SICR_CTS_INACTIVE		BIT4</span>
<span class="cp">#define SICR_CTS			(BIT5+BIT4)</span>
<span class="cp">#define SICR_RCC_UNDERFLOW		BIT3</span>
<span class="cp">#define SICR_DPLL_NO_SYNC		BIT2</span>
<span class="cp">#define SICR_BRG1_ZERO			BIT1</span>
<span class="cp">#define SICR_BRG0_ZERO			BIT0</span>

<span class="kt">void</span> <span class="n">usc_DisableMasterIrqBit</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="kt">void</span> <span class="n">usc_EnableMasterIrqBit</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="kt">void</span> <span class="n">usc_EnableInterrupts</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">IrqMask</span> <span class="p">);</span>
<span class="kt">void</span> <span class="n">usc_DisableInterrupts</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">IrqMask</span> <span class="p">);</span>
<span class="kt">void</span> <span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">IrqMask</span> <span class="p">);</span>

<span class="cp">#define usc_EnableInterrupts( a, b ) \</span>
<span class="cp">	usc_OutReg( (a), ICR, (u16)((usc_InReg((a),ICR) &amp; 0xff00) + 0xc0 + (b)) )</span>

<span class="cp">#define usc_DisableInterrupts( a, b ) \</span>
<span class="cp">	usc_OutReg( (a), ICR, (u16)((usc_InReg((a),ICR) &amp; 0xff00) + 0x80 + (b)) )</span>

<span class="cp">#define usc_EnableMasterIrqBit(a) \</span>
<span class="cp">	usc_OutReg( (a), ICR, (u16)((usc_InReg((a),ICR) &amp; 0x0f00) + 0xb000) )</span>

<span class="cp">#define usc_DisableMasterIrqBit(a) \</span>
<span class="cp">	usc_OutReg( (a), ICR, (u16)(usc_InReg((a),ICR) &amp; 0x7f00) )</span>

<span class="cp">#define usc_ClearIrqPendingBits( a, b ) usc_OutReg( (a), DCCR, 0x40 + (b) )</span>

<span class="cm">/*</span>
<span class="cm"> * Transmit status Bits in Transmit Control status Register (TCSR)</span>
<span class="cm"> * and Transmit Interrupt Control Register (TICR) (except BIT2, BIT0)</span>
<span class="cm"> */</span>

<span class="cp">#define TXSTATUS_PREAMBLE_SENT	BIT7</span>
<span class="cp">#define TXSTATUS_IDLE_SENT	BIT6</span>
<span class="cp">#define TXSTATUS_ABORT_SENT	BIT5</span>
<span class="cp">#define TXSTATUS_EOF		BIT4</span>
<span class="cp">#define TXSTATUS_CRC_SENT	BIT3</span>
<span class="cp">#define TXSTATUS_ALL_SENT	BIT2</span>
<span class="cp">#define TXSTATUS_UNDERRUN	BIT1</span>
<span class="cp">#define TXSTATUS_FIFO_EMPTY	BIT0</span>

<span class="cp">#define DICR_MASTER		BIT15</span>
<span class="cp">#define DICR_TRANSMIT		BIT0</span>
<span class="cp">#define DICR_RECEIVE		BIT1</span>

<span class="cp">#define usc_EnableDmaInterrupts(a,b) \</span>
<span class="cp">	usc_OutDmaReg( (a), DICR, (u16)(usc_InDmaReg((a),DICR) | (b)) )</span>

<span class="cp">#define usc_DisableDmaInterrupts(a,b) \</span>
<span class="cp">	usc_OutDmaReg( (a), DICR, (u16)(usc_InDmaReg((a),DICR) &amp; ~(b)) )</span>

<span class="cp">#define usc_EnableStatusIrqs(a,b) \</span>
<span class="cp">	usc_OutReg( (a), SICR, (u16)(usc_InReg((a),SICR) | (b)) )</span>

<span class="cp">#define usc_DisablestatusIrqs(a,b) \</span>
<span class="cp">	usc_OutReg( (a), SICR, (u16)(usc_InReg((a),SICR) &amp; ~(b)) )</span>

<span class="cm">/* Transmit status Bits in Transmit Control status Register (TCSR) */</span>
<span class="cm">/* and Transmit Interrupt Control Register (TICR) (except BIT2, BIT0) */</span>


<span class="cp">#define DISABLE_UNCONDITIONAL    0</span>
<span class="cp">#define DISABLE_END_OF_FRAME     1</span>
<span class="cp">#define ENABLE_UNCONDITIONAL     2</span>
<span class="cp">#define ENABLE_AUTO_CTS          3</span>
<span class="cp">#define ENABLE_AUTO_DCD          3</span>
<span class="cp">#define usc_EnableTransmitter(a,b) \</span>
<span class="cp">	usc_OutReg( (a), TMR, (u16)((usc_InReg((a),TMR) &amp; 0xfffc) | (b)) )</span>
<span class="cp">#define usc_EnableReceiver(a,b) \</span>
<span class="cp">	usc_OutReg( (a), RMR, (u16)((usc_InReg((a),RMR) &amp; 0xfffc) | (b)) )</span>

<span class="k">static</span> <span class="n">u16</span>  <span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Port</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Port</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Value</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Cmd</span> <span class="p">);</span>

<span class="k">static</span> <span class="n">u16</span>  <span class="n">usc_InReg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Port</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_OutReg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Port</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Value</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_RTCmd</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Cmd</span> <span class="p">);</span>
<span class="kt">void</span> <span class="n">usc_RCmd</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Cmd</span> <span class="p">);</span>
<span class="kt">void</span> <span class="n">usc_TCmd</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Cmd</span> <span class="p">);</span>

<span class="cp">#define usc_TCmd(a,b) usc_OutReg((a), TCSR, (u16)((a)-&gt;tcsr_value + (b)))</span>
<span class="cp">#define usc_RCmd(a,b) usc_OutReg((a), RCSR, (b))</span>

<span class="cp">#define usc_SetTransmitSyncChars(a,s0,s1) usc_OutReg((a), TSR, (u16)(((u16)s0&lt;&lt;8)|(u16)s1))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_process_rxoverrun_sync</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_start_receiver</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_stop_receiver</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_start_transmitter</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_stop_transmitter</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_set_txidle</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_load_txfifo</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_enable_aux_clock</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u32</span> <span class="n">DataRate</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_enable_loopback</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span> <span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_get_serial_signals</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_set_serial_signals</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_reset</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_set_sync_mode</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_set_sdlc_mode</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_set_async_mode</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_enable_async_clock</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u32</span> <span class="n">DataRate</span> <span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_loopback_frame</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_tx_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">context</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_loopmode_cancel_transmit</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_loopmode_insert_request</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">usc_loopmode_active</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">usc_loopmode_send_done</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_ioctl_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
<span class="cp">#define dev_to_port(D) (dev_to_hdlc(D)-&gt;priv)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hdlcdev_tx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hdlcdev_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">hdlcdev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hdlcdev_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Defines a BUS descriptor value for the PCI adapter</span>
<span class="cm"> * local bus address ranges.</span>
<span class="cm"> */</span>

<span class="cp">#define BUS_DESCRIPTOR( WrHold, WrDly, RdDly, Nwdd, Nwad, Nxda, Nrdd, Nrad ) \</span>
<span class="cp">(0x00400020 + \</span>
<span class="cp">((WrHold) &lt;&lt; 30) + \</span>
<span class="cp">((WrDly)  &lt;&lt; 28) + \</span>
<span class="cp">((RdDly)  &lt;&lt; 26) + \</span>
<span class="cp">((Nwdd)   &lt;&lt; 20) + \</span>
<span class="cp">((Nwad)   &lt;&lt; 15) + \</span>
<span class="cp">((Nxda)   &lt;&lt; 13) + \</span>
<span class="cp">((Nrdd)   &lt;&lt; 11) + \</span>
<span class="cp">((Nrad)   &lt;&lt;  6) )</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_trace_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xmit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Adapter diagnostic routines</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">mgsl_register_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">mgsl_irq_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">mgsl_dma_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">mgsl_memory_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_adapter_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * device and resource management routines</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_claim_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_release_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mgsl_struct</span><span class="o">*</span> <span class="n">mgsl_allocate_device</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * DMA buffer manupulation functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_free_rx_frame_buffers</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">StartIndex</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">EndIndex</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">mgsl_get_rx_frame</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">mgsl_get_raw_rx_frame</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_reset_rx_dma_buffers</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_reset_tx_dma_buffers</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_free_tx_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_load_tx_dma_buffer</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">BufferSize</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_load_pci_memory</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">TargetPtr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">SourcePtr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">count</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * DMA and Shared Memory buffer allocation and formatting</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">mgsl_allocate_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_free_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">mgsl_alloc_frame_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">BufferList</span><span class="p">,</span><span class="kt">int</span> <span class="n">Buffercount</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_free_frame_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">BufferList</span><span class="p">,</span><span class="kt">int</span> <span class="n">Buffercount</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">mgsl_alloc_buffer_list_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_free_buffer_list_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_alloc_intermediate_rxbuffer_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_free_intermediate_rxbuffer_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_alloc_intermediate_txbuffer_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_free_intermediate_txbuffer_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">load_next_tx_holding_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">save_tx_buffer_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">BufferSize</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Bottom half interrupt handlers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_bh_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_bh_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_bh_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_bh_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handler routines and dispatch table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_null</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_transmit_data</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_receive_data</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_receive_status</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_transmit_status</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_io_pin</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_misc</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_receive_dma</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_isr_transmit_dma</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">isr_dispatch_func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="n">isr_dispatch_func</span> <span class="n">UscIsrTable</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="n">mgsl_isr_null</span><span class="p">,</span>
	<span class="n">mgsl_isr_misc</span><span class="p">,</span>
	<span class="n">mgsl_isr_io_pin</span><span class="p">,</span>
	<span class="n">mgsl_isr_transmit_data</span><span class="p">,</span>
	<span class="n">mgsl_isr_transmit_status</span><span class="p">,</span>
	<span class="n">mgsl_isr_receive_data</span><span class="p">,</span>
	<span class="n">mgsl_isr_receive_status</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ioctl call handlers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tiocmget</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tiocmset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mgsl_icount</span>
	<span class="n">__user</span> <span class="o">*</span><span class="n">user_icount</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_get_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="n">MGSL_PARAMS</span>  <span class="n">__user</span> <span class="o">*</span><span class="n">user_params</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_set_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="n">MGSL_PARAMS</span>  <span class="n">__user</span> <span class="o">*</span><span class="n">new_params</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_get_txidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">idle_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_set_txidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idle_mode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_txenable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_txabort</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_rxenable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_wait_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_loopmode_send_done</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="p">);</span>

<span class="cm">/* set non-zero on successful registration with PCI subsystem */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">pci_registered</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Global linked list of SyncLink devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">mgsl_device_list</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mgsl_device_count</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Set this param to non-zero to load eax with the</span>
<span class="cm"> * .text section address and breakpoint on module load.</span>
<span class="cm"> * This is useful for use with gdb and add-symbol-file command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">break_on_load</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Driver major number, defaults to zero to get auto</span>
<span class="cm"> * assigned major number. May be forced as module parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ttymajor</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Array of user specified options for ISA adapters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">io</span><span class="p">[</span><span class="n">MAX_ISA_DEVICES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">[</span><span class="n">MAX_ISA_DEVICES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dma</span><span class="p">[</span><span class="n">MAX_ISA_DEVICES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug_level</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">maxframe</span><span class="p">[</span><span class="n">MAX_TOTAL_DEVICES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">txdmabufs</span><span class="p">[</span><span class="n">MAX_TOTAL_DEVICES</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">txholdbufs</span><span class="p">[</span><span class="n">MAX_TOTAL_DEVICES</span><span class="p">];</span>
	
<span class="n">module_param</span><span class="p">(</span><span class="n">break_on_load</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ttymajor</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug_level</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">maxframe</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">txdmabufs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">txholdbufs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_name</span> <span class="o">=</span> <span class="s">&quot;SyncLink serial driver&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_version</span> <span class="o">=</span> <span class="s">&quot;$Revision: 4.38 $&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">synclink_init_one</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">synclink_remove_one</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">synclink_pci_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_MICROGATE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_MICROGATE_USC</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_MICROGATE</span><span class="p">,</span> <span class="mh">0x0210</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">},</span> <span class="cm">/* terminate list */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">synclink_pci_tbl</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">synclink_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;synclink&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">synclink_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">synclink_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">synclink_remove_one</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">serial_driver</span><span class="p">;</span>

<span class="cm">/* number of characters left in xmit buffer before we ask for more */</span>
<span class="cp">#define WAKEUP_CHARS 256</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_change_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mgsl_wait_until_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * 1st function defined in .text section. Calling this function in</span>
<span class="cm"> * init_module() followed by a breakpoint allows a remote debugger</span>
<span class="cm"> * (gdb) to get the .text address for the add-symbol-file command.</span>
<span class="cm"> * This allows remote debugging of dynamically loadable modules.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">mgsl_get_text_ptr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mgsl_get_text_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mgsl_paranoia_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">routine</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef MGSL_PARANOIA_CHECK</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">badmagic</span> <span class="o">=</span>
		<span class="s">&quot;Warning: bad magic number for mgsl struct (%s) in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">badinfo</span> <span class="o">=</span>
		<span class="s">&quot;Warning: null mgsl_struct for (%s) in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">badinfo</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">routine</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">MGSL_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">badmagic</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">routine</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * line discipline callback wrappers</span>
<span class="cm"> *</span>
<span class="cm"> * The wrappers maintain line discipline references</span>
<span class="cm"> * while calling into the line discipline.</span>
<span class="cm"> *</span>
<span class="cm"> * ldisc_receive_buf  - pass receive data to line discipline</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ldisc_receive_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">receive_buf</span><span class="p">)</span>
			<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">receive_buf</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* mgsl_stop()		throttle (stop) transmitter</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_stop&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;mgsl_stop(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>	
		
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span><span class="p">)</span>
	 	<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_stop() */</span>

<span class="cm">/* mgsl_start()		release (start) transmitter</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_start&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;mgsl_start(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>	
		
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span><span class="p">)</span>
	 	<span class="n">usc_start_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_start() */</span>

<span class="cm">/*</span>
<span class="cm"> * Bottom half work queue access functions</span>
<span class="cm"> */</span>

<span class="cm">/* mgsl_bh_action()	Return next bottom half action to perform.</span>
<span class="cm"> * Return Value:	BH action code or 0 if nothing to do.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_bh_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">&amp;</span> <span class="n">BH_RECEIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BH_RECEIVE</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BH_RECEIVE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">&amp;</span> <span class="n">BH_TRANSMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BH_TRANSMIT</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BH_TRANSMIT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">&amp;</span> <span class="n">BH_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BH_STATUS</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">BH_STATUS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Mark BH routine as complete */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bh_running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bh_requested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 	Perform bottom half processing of work items queued by ISR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_bh_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mgsl_struct</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">action</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_BH</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_bh_handler(%s) entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
	
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">bh_running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">while</span><span class="p">((</span><span class="n">action</span> <span class="o">=</span> <span class="n">mgsl_bh_action</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	
		<span class="cm">/* Process work item */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_BH</span> <span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_bh_handler() work item action=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">action</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
		
		<span class="k">case</span> <span class="n">BH_RECEIVE</span>:
			<span class="n">mgsl_bh_receive</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BH_TRANSMIT</span>:
			<span class="n">mgsl_bh_transmit</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BH_STATUS</span>:
			<span class="n">mgsl_bh_status</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* unknown work item ID */</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unknown work item ID=%08X!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_BH</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_bh_handler(%s) exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_bh_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">get_rx_frame</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">?</span> <span class="n">mgsl_get_rx_frame</span> <span class="o">:</span> <span class="n">mgsl_get_raw_rx_frame</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_BH</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_bh_receive(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
	
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_rcc_underrun</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">usc_start_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">get_rx_frame</span><span class="p">(</span><span class="n">info</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_bh_transmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_BH</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_bh_transmit() entry on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="cm">/* if transmitter idle and loopmode_send_done_requested</span>
<span class="cm">	 * then start echoing RxD to TxD</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
 	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">loopmode_send_done_requested</span> <span class="p">)</span>
 		<span class="n">usc_loopmode_send_done</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_bh_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_BH</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_bh_status() entry on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">ri_chkcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dsr_chkcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dcd_chkcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cts_chkcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mgsl_isr_receive_status()</span>
<span class="cm"> * </span>
<span class="cm"> *	Service a receive status interrupt. The type of status</span>
<span class="cm"> *	interrupt is indicated by the state of the RCSR.</span>
<span class="cm"> *	This is only used for HDLC mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_receive_status</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCSR</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_isr_receive_status status=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">status</span><span class="p">);</span>
			
 	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_ABORT_RECEIVED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopmode_insert_requested</span> <span class="o">&amp;&amp;</span>
 		<span class="n">usc_loopmode_active</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">)</span>
 	<span class="p">{</span>
		<span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxabort</span><span class="p">;</span>
	 	<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopmode_insert_requested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 
 		<span class="cm">/* clear CMR:13 to start echoing RxD to TxD */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT13</span><span class="p">;</span>
 		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">CMR</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span><span class="p">);</span>
 
		<span class="cm">/* disable received abort irq (no longer required) */</span>
	 	<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="p">,</span>
 			<span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RXSTATUS_ABORT_RECEIVED</span><span class="p">));</span>
 	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXSTATUS_EXITED_HUNT</span> <span class="o">+</span> <span class="n">RXSTATUS_IDLE_RECEIVED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_EXITED_HUNT</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">exithunt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_IDLE_RECEIVED</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxidle</span><span class="o">++</span><span class="p">;</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">event_wait_q</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_OVERRUN</span><span class="p">){</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxover</span><span class="o">++</span><span class="p">;</span>
		<span class="n">usc_process_rxoverrun_sync</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>
	<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">status</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_isr_receive_status() */</span>

<span class="cm">/* mgsl_isr_transmit_status()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Service a transmit status interrupt</span>
<span class="cm"> *	HDLC mode :end of transmit frame</span>
<span class="cm"> *	Async mode:all data is sent</span>
<span class="cm"> * 	transmit status is indicated by bits in the TCSR.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info	       pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_transmit_status</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCSR</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_isr_transmit_status status=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">status</span><span class="p">);</span>
	
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="p">);</span>
	<span class="n">usc_UnlatchTxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">status</span> <span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TXSTATUS_UNDERRUN</span> <span class="o">|</span> <span class="n">TXSTATUS_ABORT_SENT</span><span class="p">)</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* finished sending HDLC abort. This may leave	*/</span>
		<span class="cm">/* the TxFifo with data from the aborted frame	*/</span>
		<span class="cm">/* so purge the TxFifo. Also shutdown the DMA	*/</span>
		<span class="cm">/* channel in case there is data remaining in 	*/</span>
		<span class="cm">/* the DMA buffer				*/</span>
 		<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_ResetTxChannel</span> <span class="p">);</span>
 		<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeTxFifo</span> <span class="p">);</span>
	<span class="p">}</span>
 
	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">TXSTATUS_EOF_SENT</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txok</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">TXSTATUS_UNDERRUN</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txunder</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">TXSTATUS_ABORT_SENT</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txabort</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txunder</span><span class="o">++</span><span class="p">;</span>
			
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_timer</span><span class="p">);</span>	
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">drop_rts_on_tx_done</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">usc_get_serial_signals</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_RTS</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SerialSignal_RTS</span><span class="p">;</span>
			<span class="n">usc_set_serial_signals</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">drop_rts_on_tx_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="p">)</span>
		<span class="n">hdlcdev_tx_done</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">else</span> 
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">|=</span> <span class="n">BH_TRANSMIT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_isr_transmit_status() */</span>

<span class="cm">/* mgsl_isr_io_pin()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Service an Input/Output pin interrupt. The type of</span>
<span class="cm"> * 	interrupt is indicated by bits in the MISR</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		info	       pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_io_pin</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
 	<span class="k">struct</span>	<span class="n">mgsl_icount</span> <span class="o">*</span><span class="n">icount</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">MISR</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_isr_io_pin status=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">status</span><span class="p">);</span>
			
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">IO_PIN</span> <span class="p">);</span>
	<span class="n">usc_UnlatchIostatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">status</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MISCSTATUS_CTS_LATCHED</span> <span class="o">|</span> <span class="n">MISCSTATUS_DCD_LATCHED</span> <span class="o">|</span>
	              <span class="n">MISCSTATUS_DSR_LATCHED</span> <span class="o">|</span> <span class="n">MISCSTATUS_RI_LATCHED</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">icount</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>
		<span class="cm">/* update input line counters */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_RI_LATCHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ri_chkcount</span><span class="p">)</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">IO_PIN_SHUTDOWN_LIMIT</span><span class="p">)</span>
				<span class="n">usc_DisablestatusIrqs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">SICR_RI</span><span class="p">);</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rng</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_RI</span> <span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">.</span><span class="n">ri_up</span><span class="o">++</span><span class="p">;</span>	
			<span class="k">else</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">.</span><span class="n">ri_down</span><span class="o">++</span><span class="p">;</span>	
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DSR_LATCHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dsr_chkcount</span><span class="p">)</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">IO_PIN_SHUTDOWN_LIMIT</span><span class="p">)</span>
				<span class="n">usc_DisablestatusIrqs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">SICR_DSR</span><span class="p">);</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dsr</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DSR</span> <span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">.</span><span class="n">dsr_up</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">.</span><span class="n">dsr_down</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DCD_LATCHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dcd_chkcount</span><span class="p">)</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">IO_PIN_SHUTDOWN_LIMIT</span><span class="p">)</span>
				<span class="n">usc_DisablestatusIrqs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">SICR_DCD</span><span class="p">);</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dcd</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DCD</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">.</span><span class="n">dcd_up</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">.</span><span class="n">dcd_down</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DCD</span><span class="p">)</span>
					<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_CTS_LATCHED</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cts_chkcount</span><span class="p">)</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">IO_PIN_SHUTDOWN_LIMIT</span><span class="p">)</span>
				<span class="n">usc_DisablestatusIrqs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">SICR_CTS</span><span class="p">);</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">cts</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_CTS</span> <span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">.</span><span class="n">cts_up</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">.</span><span class="n">cts_down</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">status_event_wait_q</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">event_wait_q</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CHECK_CD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
		     <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DCD_LATCHED</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s CD now %s...&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DCD</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;on&quot;</span> <span class="o">:</span> <span class="s">&quot;off&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DCD</span><span class="p">)</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">open_wait</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;doing serial hangup...&quot;</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">)</span>
					<span class="n">tty_hangup</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CTS_FLOW</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
		     <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_CTS_LATCHED</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_CTS</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CTS tx start...&quot;</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">)</span>
						<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">usc_start_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">|=</span> <span class="n">BH_TRANSMIT</span><span class="p">;</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_CTS</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>
						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CTS tx stop...&quot;</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">)</span>
						<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">|=</span> <span class="n">BH_STATUS</span><span class="p">;</span>
	
	<span class="cm">/* for diagnostics set IRQ flag */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_TXC_LATCHED</span> <span class="p">){</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">SICR</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">SICR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SICR_TXC_ACTIVE</span><span class="o">+</span><span class="n">SICR_TXC_INACTIVE</span><span class="p">))</span> <span class="p">);</span>
		<span class="n">usc_UnlatchIostatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">MISCSTATUS_TXC_LATCHED</span> <span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_occurred</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_isr_io_pin() */</span>

<span class="cm">/* mgsl_isr_transmit_data()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Service a transmit data interrupt (async mode only).</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_transmit_data</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_isr_transmit_data xmit_cnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span><span class="p">);</span>
			
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_DATA</span> <span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="p">)</span>
		<span class="n">usc_load_txfifo</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">&lt;</span> <span class="n">WAKEUP_CHARS</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">|=</span> <span class="n">BH_TRANSMIT</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_isr_transmit_data() */</span>

<span class="cm">/* mgsl_isr_receive_data()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Service a receive data interrupt. This occurs</span>
<span class="cm"> * 	when operating in asynchronous interrupt transfer mode.</span>
<span class="cm"> *	The receive data FIFO is flushed to the receive data buffers. </span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info		pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_receive_data</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">Fifocount</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">DataByte</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>
 	<span class="k">struct</span>	<span class="n">mgsl_icount</span> <span class="o">*</span><span class="n">icount</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_isr_receive_data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>

	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span> <span class="p">);</span>
	
	<span class="cm">/* select FIFO status for RICR readback */</span>
	<span class="n">usc_RCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCmd_SelectRicrRxFifostatus</span> <span class="p">);</span>

	<span class="cm">/* clear the Wordstatus bit so that status readback */</span>
	<span class="cm">/* only reflects the status of this byte */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="o">+</span><span class="n">LSBONLY</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="o">+</span><span class="n">LSBONLY</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT3</span> <span class="p">));</span>

	<span class="cm">/* flush the receive FIFO */</span>

	<span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">Fifocount</span> <span class="o">=</span> <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">RICR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">))</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>

		<span class="cm">/* read one byte from RxFIFO */</span>
		<span class="n">outw</span><span class="p">(</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0780</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">RDR</span><span class="o">+</span><span class="n">LSBONLY</span><span class="p">),</span>
		      <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
		<span class="n">DataByte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>

		<span class="cm">/* get the status of the received byte */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RCSR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXSTATUS_FRAMING_ERROR</span> <span class="o">+</span> <span class="n">RXSTATUS_PARITY_ERROR</span> <span class="o">+</span>
				<span class="n">RXSTATUS_OVERRUN</span> <span class="o">+</span> <span class="n">RXSTATUS_BREAK_RECEIVED</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">RXSTATUS_ALL</span><span class="p">);</span>
		
		<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rx</span><span class="o">++</span><span class="p">;</span>
		
		<span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXSTATUS_FRAMING_ERROR</span> <span class="o">+</span> <span class="n">RXSTATUS_PARITY_ERROR</span> <span class="o">+</span>
				<span class="n">RXSTATUS_OVERRUN</span> <span class="o">+</span> <span class="n">RXSTATUS_BREAK_RECEIVED</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;rxerr=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">status</span><span class="p">);</span>					
			<span class="cm">/* update error statistics */</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_BREAK_RECEIVED</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RXSTATUS_FRAMING_ERROR</span> <span class="o">+</span> <span class="n">RXSTATUS_PARITY_ERROR</span><span class="p">);</span>
				<span class="n">icount</span><span class="o">-&gt;</span><span class="n">brk</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_PARITY_ERROR</span><span class="p">)</span> 
				<span class="n">icount</span><span class="o">-&gt;</span><span class="n">parity</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_FRAMING_ERROR</span><span class="p">)</span>
				<span class="n">icount</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_OVERRUN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* must issue purge fifo cmd before */</span>
				<span class="cm">/* 16C32 accepts more receive chars */</span>
				<span class="n">usc_RTCmd</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">RTCmd_PurgeRxFifo</span><span class="p">);</span>
				<span class="n">icount</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* discard char if tty control flags say so */</span>					
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
				
			<span class="n">status</span> <span class="o">&amp;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">read_status_mask</span><span class="p">;</span>
		
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_BREAK_RECEIVED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">flag</span> <span class="o">=</span> <span class="n">TTY_BREAK</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_SAK</span><span class="p">)</span>
					<span class="n">do_SAK</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_PARITY_ERROR</span><span class="p">)</span>
				<span class="n">flag</span> <span class="o">=</span> <span class="n">TTY_PARITY</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_FRAMING_ERROR</span><span class="p">)</span>
				<span class="n">flag</span> <span class="o">=</span> <span class="n">TTY_FRAME</span><span class="p">;</span>
		<span class="p">}</span>	<span class="cm">/* end of if (error) */</span>
		<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">DataByte</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_OVERRUN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Overrun is special, since it&#39;s</span>
<span class="cm">			 * reported immediately, and doesn&#39;t</span>
<span class="cm">			 * affect the current character</span>
<span class="cm">			 */</span>
			<span class="n">work</span> <span class="o">+=</span> <span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_OVERRUN</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):rx=%d brk=%d parity=%d frame=%d overrun=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">icount</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">,</span><span class="n">icount</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">,</span>
			<span class="n">icount</span><span class="o">-&gt;</span><span class="n">parity</span><span class="p">,</span><span class="n">icount</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">,</span><span class="n">icount</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="p">);</span>
	<span class="p">}</span>
			
	<span class="k">if</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
		<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* mgsl_isr_misc()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Service a miscellaneous interrupt source.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		info		pointer to device extension (instance data)</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_misc</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">MISR</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_isr_misc status=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">status</span><span class="p">);</span>
			
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_RCC_UNDERRUN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* turn off receiver and rx DMA */</span>
		<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DISABLE_UNCONDITIONAL</span><span class="p">);</span>
		<span class="n">usc_DmaCmd</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_ResetRxChannel</span><span class="p">);</span>
		<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RXSTATUS_ALL</span><span class="p">);</span>
		<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span><span class="p">);</span>
		<span class="n">usc_DisableInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span><span class="p">);</span>

		<span class="cm">/* schedule BH handler to restart receiver */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">|=</span> <span class="n">BH_RECEIVE</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_rcc_underrun</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">MISC</span> <span class="p">);</span>
	<span class="n">usc_UnlatchMiscstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">status</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_isr_misc() */</span>

<span class="cm">/* mgsl_isr_null()</span>
<span class="cm"> *</span>
<span class="cm"> * 	Services undefined interrupt vectors from the</span>
<span class="cm"> * 	USC. (hence this function SHOULD never be called)</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info		pointer to device extension (instance data)</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_null</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_isr_null() */</span>

<span class="cm">/* mgsl_isr_receive_dma()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Service a receive DMA channel interrupt.</span>
<span class="cm"> * 	For this driver there are two sources of receive DMA interrupts</span>
<span class="cm"> * 	as identified in the Receive DMA mode Register (RDMR):</span>
<span class="cm"> * </span>
<span class="cm"> * 	BIT3	EOA/EOL		End of List, all receive buffers in receive</span>
<span class="cm"> * 				buffer list have been filled (no more free buffers</span>
<span class="cm"> * 				available). The DMA controller has shut down.</span>
<span class="cm"> * </span>
<span class="cm"> * 	BIT2	EOB		End of Buffer. This interrupt occurs when a receive</span>
<span class="cm"> * 				DMA buffer is terminated in response to completion</span>
<span class="cm"> * 				of a good frame or a frame with errors. The status</span>
<span class="cm"> * 				of the frame is stored in the buffer entry in the</span>
<span class="cm"> * 				list of receive buffer entries.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info		pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_receive_dma</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	
	<span class="cm">/* clear interrupt pending and IUS bit for Rx DMA IRQ */</span>
	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CDIR</span><span class="p">,</span> <span class="n">BIT9</span><span class="o">+</span><span class="n">BIT1</span> <span class="p">);</span>

	<span class="cm">/* Read the receive DMA status to identify interrupt type. */</span>
	<span class="cm">/* This also clears the status bits. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDMR</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_isr_receive_dma(%s) status=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">status</span><span class="p">);</span>
			
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">|=</span> <span class="n">BH_RECEIVE</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">BIT3</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_overflow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">buf_overrun</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_isr_receive_dma() */</span>

<span class="cm">/* mgsl_isr_transmit_dma()</span>
<span class="cm"> *</span>
<span class="cm"> *	This function services a transmit DMA channel interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> *	For this driver there is one source of transmit DMA interrupts</span>
<span class="cm"> *	as identified in the Transmit DMA Mode Register (TDMR):</span>
<span class="cm"> *</span>
<span class="cm"> *     	BIT2  EOB       End of Buffer. This interrupt occurs when a</span>
<span class="cm"> *     			transmit DMA buffer has been emptied.</span>
<span class="cm"> *</span>
<span class="cm"> *     	The driver maintains enough transmit DMA buffers to hold at least</span>
<span class="cm"> *     	one max frame size transmit frame. When operating in a buffered</span>
<span class="cm"> *     	transmit mode, there may be enough transmit DMA buffers to hold at</span>
<span class="cm"> *     	least two or more max frame size frames. On an EOB condition,</span>
<span class="cm"> *     	determine if there are any queued transmit buffers and copy into</span>
<span class="cm"> *     	transmit DMA buffers if we have room.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info		pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_isr_transmit_dma</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* clear interrupt pending and IUS bit for Tx DMA IRQ */</span>
	<span class="n">usc_OutDmaReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">CDIR</span><span class="p">,</span> <span class="n">BIT8</span><span class="o">+</span><span class="n">BIT0</span> <span class="p">);</span>

	<span class="cm">/* Read the transmit DMA status to identify interrupt type. */</span>
	<span class="cm">/* This also clears the status bits. */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TDMR</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_isr_transmit_dma(%s) status=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">BIT2</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_dma_buffers_used</span><span class="p">;</span>

		<span class="cm">/* if there are transmit frames queued,</span>
<span class="cm">		 *  try to load the next one</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">load_next_tx_holding_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* if call returns non-zero value, we have</span>
<span class="cm">			 * at least one free tx holding buffer</span>
<span class="cm">			 */</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">|=</span> <span class="n">BH_TRANSMIT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_isr_transmit_dma() */</span>

<span class="cm">/* mgsl_interrupt()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Interrupt service routine entry point.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	irq		interrupt number that caused interrupt</span>
<span class="cm"> * 	dev_id		device ID supplied during interrupt registration</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value: None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">mgsl_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">UscVector</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">DmaVector</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s(%d):mgsl_interrupt(%d)entry.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* Read the interrupt vectors from hardware. */</span>
		<span class="n">UscVector</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IVR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">DmaVector</span> <span class="o">=</span> <span class="n">usc_InDmaReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">DIVR</span><span class="p">);</span>
		
		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):%s UscVector=%08X DmaVector=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">UscVector</span><span class="p">,</span><span class="n">DmaVector</span><span class="p">);</span>
			
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">UscVector</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">DmaVector</span> <span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
			
		<span class="cm">/* Dispatch interrupt vector */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">UscVector</span> <span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">UscIsrTable</span><span class="p">[</span><span class="n">UscVector</span><span class="p">])(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">DmaVector</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BIT10</span><span class="o">|</span><span class="n">BIT9</span><span class="p">))</span> <span class="o">==</span> <span class="n">BIT10</span><span class="p">)</span>
			<span class="n">mgsl_isr_transmit_dma</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mgsl_isr_receive_dma</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">isr_overflow</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s(%d):%s isr overflow irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">);</span>
			<span class="n">usc_DisableMasterIrqBit</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">usc_DisableDmaInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DICR_MASTER</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="cm">/* Request bottom half processing if there&#39;s something </span>
<span class="cm">	 * for it to do and the bh is not already running</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bh_running</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bh_requested</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):%s queueing bh task.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bh_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span> <span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s(%d):mgsl_interrupt(%d)exit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* end of mgsl_interrupt() */</span>

<span class="cm">/* startup()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Initialize and start device.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_startup(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* allocate a page of memory for a transmit buffer */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;%s(%d):%s can&#39;t allocate transmit buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">));</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_timer</span><span class="p">,</span> <span class="n">mgsl_tx_timeout</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="p">);</span>
	
	<span class="cm">/* Allocate and claim adapter resources */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">mgsl_claim_resources</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	
	<span class="cm">/* perform existence check and diagnostics */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">retval</span> <span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">mgsl_adapter_test</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span> <span class="n">retval</span> <span class="p">)</span> <span class="p">{</span>
  		<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">mgsl_release_resources</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
  		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
  	<span class="p">}</span>

	<span class="cm">/* program hardware for current parameters */</span>
	<span class="n">mgsl_change_params</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of startup() */</span>

<span class="cm">/* shutdown()</span>
<span class="cm"> *</span>
<span class="cm"> * Called by mgsl_close() and mgsl_hangup() to shutdown hardware</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_shutdown(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>

	<span class="cm">/* clear status wait queue because status changes */</span>
	<span class="cm">/* can&#39;t happen after shutting down the hardware */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">status_event_wait_q</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">event_wait_q</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_timer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">usc_DisableMasterIrqBit</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">usc_stop_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">usc_DisableInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span> <span class="o">+</span>
		<span class="n">TRANSMIT_DATA</span> <span class="o">+</span> <span class="n">TRANSMIT_STATUS</span> <span class="o">+</span> <span class="n">IO_PIN</span> <span class="o">+</span> <span class="n">MISC</span> <span class="p">);</span>
	<span class="n">usc_DisableDmaInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DICR_MASTER</span> <span class="o">+</span> <span class="n">DICR_TRANSMIT</span> <span class="o">+</span> <span class="n">DICR_RECEIVE</span><span class="p">);</span>
	
	<span class="cm">/* Disable DMAEN (Port 7, Bit 14) */</span>
	<span class="cm">/* This disconnects the DMA request signal from the ISA bus */</span>
	<span class="cm">/* on the ISA adapter. This has no effect for the PCI adapter */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT15</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT14</span><span class="p">));</span>
	
	<span class="cm">/* Disable INTEN (Port 6, Bit12) */</span>
	<span class="cm">/* This disconnects the IRQ request signal to the ISA bus */</span>
	<span class="cm">/* on the ISA adapter. This has no effect for the PCI adapter */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT13</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT12</span><span class="p">));</span>
	
 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">HUPCL</span><span class="p">)</span> <span class="p">{</span>
 		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SerialSignal_DTR</span> <span class="o">+</span> <span class="n">SerialSignal_RTS</span><span class="p">);</span>
		<span class="n">usc_set_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">mgsl_release_resources</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>	
	
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASYNC_INITIALIZED</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of shutdown() */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_program_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="n">usc_stop_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="o">||</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="p">)</span>
		<span class="n">usc_set_sync_mode</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usc_set_async_mode</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		
	<span class="n">usc_set_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dcd_chkcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cts_chkcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">ri_chkcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dsr_chkcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">usc_EnableStatusIrqs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">SICR_CTS</span><span class="o">+</span><span class="n">SICR_DSR</span><span class="o">+</span><span class="n">SICR_DCD</span><span class="o">+</span><span class="n">SICR_RI</span><span class="p">);</span>		
	<span class="n">usc_EnableInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IO_PIN</span><span class="p">);</span>
	<span class="n">usc_get_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CREAD</span><span class="p">)</span>
		<span class="n">usc_start_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Reconfigure adapter based on new parameters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_change_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">cflag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits_per_char</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_change_params(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			 
	<span class="n">cflag</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span><span class="p">;</span>

	<span class="cm">/* if B0 rate (hangup) specified then negate DTR and RTS */</span>
	<span class="cm">/* otherwise assert DTR and RTS */</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_RTS</span> <span class="o">+</span> <span class="n">SerialSignal_DTR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SerialSignal_RTS</span> <span class="o">+</span> <span class="n">SerialSignal_DTR</span><span class="p">);</span>
	
	<span class="cm">/* byte size and parity */</span>
	
	<span class="k">switch</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CSIZE</span><span class="p">)</span> <span class="p">{</span>
	      <span class="k">case</span> <span class="n">CS5</span>: <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_bits</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">CS6</span>: <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_bits</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">CS7</span>: <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_bits</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	      <span class="k">case</span> <span class="n">CS8</span>: <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	      <span class="cm">/* Never happens, but GCC is too dumb to figure it out */</span>
	      <span class="nl">default:</span>  <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_bits</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	      <span class="p">}</span>
	      
	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CSTOPB</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">stop_bits</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">stop_bits</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">parity</span> <span class="o">=</span> <span class="n">ASYNC_PARITY_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">PARENB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">PARODD</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">parity</span> <span class="o">=</span> <span class="n">ASYNC_PARITY_ODD</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">parity</span> <span class="o">=</span> <span class="n">ASYNC_PARITY_EVEN</span><span class="p">;</span>
<span class="cp">#ifdef CMSPAR</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CMSPAR</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">parity</span> <span class="o">=</span> <span class="n">ASYNC_PARITY_SPACE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* calculate number of jiffies to transmit a full</span>
<span class="cm">	 * FIFO (32 bytes) at specified data rate</span>
<span class="cm">	 */</span>
	<span class="n">bits_per_char</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_bits</span> <span class="o">+</span> 
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">stop_bits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* if port data rate is set to 460800 or less then</span>
<span class="cm">	 * allow tty settings to override, otherwise keep the</span>
<span class="cm">	 * current data rate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_rate</span> <span class="o">&lt;=</span> <span class="mi">460800</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_rate</span> <span class="o">=</span> <span class="n">tty_get_baud_rate</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_rate</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="o">*</span><span class="n">HZ</span><span class="o">*</span><span class="n">bits_per_char</span><span class="p">)</span> <span class="o">/</span> 
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_rate</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">+=</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">50</span><span class="p">;</span>		<span class="cm">/* Add .02 seconds of slop */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ASYNC_CTS_FLOW</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASYNC_CTS_FLOW</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CLOCAL</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASYNC_CHECK_CD</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ASYNC_CHECK_CD</span><span class="p">;</span>

	<span class="cm">/* process tty input control flags */</span>
	
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">=</span> <span class="n">RXSTATUS_OVERRUN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">I_INPCK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">))</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">|=</span> <span class="n">RXSTATUS_PARITY_ERROR</span> <span class="o">|</span> <span class="n">RXSTATUS_FRAMING_ERROR</span><span class="p">;</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">I_BRKINT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">)</span> <span class="o">||</span> <span class="n">I_PARMRK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">))</span>
 		<span class="n">info</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">|=</span> <span class="n">RXSTATUS_BREAK_RECEIVED</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">I_IGNPAR</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">))</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">|=</span> <span class="n">RXSTATUS_PARITY_ERROR</span> <span class="o">|</span> <span class="n">RXSTATUS_FRAMING_ERROR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">I_IGNBRK</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">|=</span> <span class="n">RXSTATUS_BREAK_RECEIVED</span><span class="p">;</span>
		<span class="cm">/* If ignoring parity and break indicators, ignore </span>
<span class="cm">		 * overruns too.  (For real raw support).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">I_IGNPAR</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">))</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">|=</span> <span class="n">RXSTATUS_OVERRUN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mgsl_program_hw</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_change_params() */</span>

<span class="cm">/* mgsl_put_char()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Add a character to the transmit buffer.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty information structure</span>
<span class="cm"> * 			ch	character to add to transmit buffer</span>
<span class="cm"> * 		</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_put_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s(%d):mgsl_put_char(%d) on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
	<span class="p">}</span>		
	
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_put_char&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_ASYNC</span> <span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">&lt;</span> <span class="n">SERIAL_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span> <span class="o">&amp;=</span> <span class="n">SERIAL_XMIT_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_put_char() */</span>

<span class="cm">/* mgsl_flush_chars()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Enable transmitter so remaining characters in the</span>
<span class="cm"> * 	transmit buffer are sent.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty information structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_flush_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
				
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_flush_chars() entry on %s xmit_cnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_flush_chars&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">||</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_flush_chars() entry on %s starting transmitter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* operating in synchronous (frame oriented) mode */</span>
			<span class="cm">/* copy data from circular xmit_buf to */</span>
			<span class="cm">/* transmit DMA buffer. */</span>
			<span class="n">mgsl_load_tx_dma_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
				 <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span><span class="p">);</span>
		<span class="p">}</span>
	 	<span class="n">usc_start_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_flush_chars() */</span>

<span class="cm">/* mgsl_write()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Send a block of data</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	tty		pointer to tty information structure</span>
<span class="cm"> * 	buf		pointer to buffer containing send data</span>
<span class="cm"> * 	count		size of send data in bytes</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value:	number of characters written</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">c</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_write(%s) count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_write&quot;</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* operating in synchronous (frame oriented) mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* transmitter is actively sending data -</span>
<span class="cm">			 * if we have multiple transmit dma and</span>
<span class="cm">			 * holding buffers, attempt to queue this</span>
<span class="cm">			 * frame for transmission at a later time.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_count</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span> <span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* no tx holding buffers available */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* queue transmit frame request */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">save_tx_buffer_request</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>

			<span class="cm">/* if we have sufficient tx dma buffers,</span>
<span class="cm">			 * load the next buffered tx request</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">load_next_tx_holding_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
	
		<span class="cm">/* if operating in HDLC LoopMode and the adapter  */</span>
		<span class="cm">/* has yet to be inserted into the loop, we can&#39;t */</span>
		<span class="cm">/* transmit					  */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_HDLC_LOOPMODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">usc_loopmode_active</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Send accumulated from send_char() calls */</span>
			<span class="cm">/* as frame and wait before accepting more data. */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			
			<span class="cm">/* copy data from circular xmit_buf to */</span>
			<span class="cm">/* transmit DMA buffer. */</span>
			<span class="n">mgsl_load_tx_dma_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_write(%s) sync xmit_cnt flushing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_write(%s) sync transmit accepted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">mgsl_load_tx_dma_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
				<span class="n">min</span><span class="p">(</span><span class="n">SERIAL_XMIT_SIZE</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				    <span class="n">SERIAL_XMIT_SIZE</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span> <span class="o">=</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span>
					   <span class="p">(</span><span class="n">SERIAL_XMIT_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">-=</span> <span class="n">c</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>	
	
 	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span><span class="p">)</span>
		 	<span class="n">usc_start_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
 	<span class="p">}</span>
<span class="nl">cleanup:</span>	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_write(%s) returning=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">ret</span><span class="p">);</span>
			
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_write() */</span>

<span class="cm">/* mgsl_write_room()</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the count of free bytes in transmit buffer</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">ret</span><span class="p">;</span>
				
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_write_room&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">SERIAL_XMIT_SIZE</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_write_room(%s)=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">ret</span> <span class="p">);</span>
			 
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* operating in synchronous (frame oriented) mode */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">HDLC_MAX_FRAME_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_write_room() */</span>

<span class="cm">/* mgsl_chars_in_buffer()</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the count of bytes in transmit buffer</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
			 
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_chars_in_buffer(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			 
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_chars_in_buffer&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_chars_in_buffer(%s)=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="p">);</span>
			 
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* operating in synchronous (frame oriented) mode */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="p">)</span>
			<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
			 
	<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* end of mgsl_chars_in_buffer() */</span>

<span class="cm">/* mgsl_flush_buffer()</span>
<span class="cm"> *</span>
<span class="cm"> *	Discard all data in the send buffer</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_flush_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_flush_buffer(%s) entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_flush_buffer&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
		
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span> 
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_timer</span><span class="p">);</span>	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* mgsl_send_xchar()</span>
<span class="cm"> *</span>
<span class="cm"> *	Send a high-priority XON/XOFF character</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> *			ch	character to send</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_send_xchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_send_xchar(%s,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">ch</span> <span class="p">);</span>
			 
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_send_xchar&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure transmit interrupts are on */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span><span class="p">)</span>
		 	<span class="n">usc_start_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>	<span class="cm">/* end of mgsl_send_xchar() */</span>

<span class="cm">/* mgsl_throttle()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Signal remote device to throttle send data (our receive data)</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_throttle(%s) entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_throttle&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">I_IXOFF</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span>
		<span class="n">mgsl_send_xchar</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">STOP_CHAR</span><span class="p">(</span><span class="n">tty</span><span class="p">));</span>
 
 	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SerialSignal_RTS</span><span class="p">;</span>
	 	<span class="n">usc_set_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>	<span class="cm">/* end of mgsl_throttle() */</span>

<span class="cm">/* mgsl_unthrottle()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Signal remote device to stop throttling send data (our receive data)</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_unthrottle(%s) entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_unthrottle&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">I_IXOFF</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">x_char</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mgsl_send_xchar</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">START_CHAR</span><span class="p">(</span><span class="n">tty</span><span class="p">));</span>
	<span class="p">}</span>
	
 	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_RTS</span><span class="p">;</span>
	 	<span class="n">usc_set_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_unthrottle() */</span>

<span class="cm">/* mgsl_get_stats()</span>
<span class="cm"> * </span>
<span class="cm"> * 	get the current serial parameters information</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:	info		pointer to device instance data</span>
<span class="cm"> * 		user_icount	pointer to buffer to hold returned stats</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mgsl_icount</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_icount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_get_params(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
			
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_icount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">COPY_TO_USER</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">user_icount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_icount</span><span class="p">));</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_get_stats() */</span>

<span class="cm">/* mgsl_get_params()</span>
<span class="cm"> * </span>
<span class="cm"> * 	get the current serial parameters information</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:	info		pointer to device instance data</span>
<span class="cm"> * 		user_params	pointer to buffer to hold returned params</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_get_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="n">MGSL_PARAMS</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_get_params(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
			
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">COPY_TO_USER</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="n">user_params</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MGSL_PARAMS</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_get_params(%s) user buffer copy failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_get_params() */</span>

<span class="cm">/* mgsl_set_params()</span>
<span class="cm"> * </span>
<span class="cm"> * 	set the serial parameters</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	info		pointer to device instance data</span>
<span class="cm"> * 	new_params	user buffer containing new serial params</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_set_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="n">MGSL_PARAMS</span> <span class="n">__user</span> <span class="o">*</span><span class="n">new_params</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">MGSL_PARAMS</span> <span class="n">tmp_params</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
 
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_set_params %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
	<span class="n">COPY_FROM_USER</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp_params</span><span class="p">,</span> <span class="n">new_params</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MGSL_PARAMS</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_set_params(%s) user buffer copy failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp_params</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MGSL_PARAMS</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
 	<span class="n">mgsl_change_params</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_set_params() */</span>

<span class="cm">/* mgsl_get_txidle()</span>
<span class="cm"> * </span>
<span class="cm"> * 	get the current transmit idle mode</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:	info		pointer to device instance data</span>
<span class="cm"> * 		idle_mode	pointer to buffer to hold returned idle mode</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_get_txidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">idle_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_get_txidle(%s)=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">idle_mode</span><span class="p">);</span>
			
	<span class="n">COPY_TO_USER</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="n">idle_mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">idle_mode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_get_txidle(%s) user buffer copy failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_get_txidle() */</span>

<span class="cm">/* mgsl_set_txidle()	service ioctl to set transmit idle mode</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:	 	info		pointer to device instance data</span>
<span class="cm"> * 			idle_mode	new idle mode</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_set_txidle</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idle_mode</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
 
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_set_txidle(%s,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">idle_mode</span> <span class="p">);</span>
			
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">idle_mode</span> <span class="o">=</span> <span class="n">idle_mode</span><span class="p">;</span>
	<span class="n">usc_set_txidle</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_set_txidle() */</span>

<span class="cm">/* mgsl_txenable()</span>
<span class="cm"> * </span>
<span class="cm"> * 	enable or disable the transmitter</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	info		pointer to device instance data</span>
<span class="cm"> * 	enable		1 = enable, 0 = disable</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_txenable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
 
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_txenable(%s,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
			
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">enable</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span> <span class="p">)</span> <span class="p">{</span>

			<span class="n">usc_start_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="cm">/*--------------------------------------------------</span>
<span class="cm">			 * if HDLC/SDLC Loop mode, attempt to insert the</span>
<span class="cm">			 * station in the &#39;loop&#39; by setting CMR:13. Upon</span>
<span class="cm">			 * receipt of the next GoAhead (RxAbort) sequence,</span>
<span class="cm">			 * the OnLoop indicator (CCSR:7) should go active</span>
<span class="cm">			 * to indicate that we are on the loop</span>
<span class="cm">			 *--------------------------------------------------*/</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_HDLC_LOOPMODE</span> <span class="p">)</span>
				<span class="n">usc_loopmode_insert_request</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span> <span class="p">)</span>
			<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_txenable() */</span>

<span class="cm">/* mgsl_txabort()	abort send HDLC frame</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:	 	info		pointer to device instance data</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_txabort</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
 
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_txabort(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
			
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_HDLC_LOOPMODE</span> <span class="p">)</span>
			<span class="n">usc_loopmode_cancel_transmit</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
		<span class="k">else</span>
			<span class="n">usc_TCmd</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">TCmd_SendAbort</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_txabort() */</span>

<span class="cm">/* mgsl_rxenable() 	enable or disable the receiver</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:	 	info		pointer to device instance data</span>
<span class="cm"> * 			enable		1 = enable, 0 = disable</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_rxenable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
 
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_rxenable(%s,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">enable</span><span class="p">);</span>
			
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">enable</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_enabled</span> <span class="p">)</span>
			<span class="n">usc_start_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_enabled</span> <span class="p">)</span>
			<span class="n">usc_stop_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_rxenable() */</span>

<span class="cm">/* mgsl_wait_event() 	wait for specified event to occur</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:	 	info	pointer to device instance data</span>
<span class="cm"> * 			mask	pointer to bitmask of events to wait for</span>
<span class="cm"> * Return Value:	0 	if successful and bit mask updated with</span>
<span class="cm"> *				of events triggerred,</span>
<span class="cm"> * 			otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_wait_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">mask_ptr</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgsl_icount</span> <span class="n">cprev</span><span class="p">,</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">events</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">_input_signal_events</span> <span class="n">oldsigs</span><span class="p">,</span> <span class="n">newsigs</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">COPY_FROM_USER</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>  <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
		 
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_wait_event(%s,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* return immediately if state matches requested events */</span>
	<span class="n">usc_get_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span><span class="p">;</span>
	<span class="n">events</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span>
		<span class="p">(</span> <span class="p">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DSR</span><span class="p">)</span> <span class="o">?</span> <span class="n">MgslEvent_DsrActive</span><span class="o">:</span><span class="n">MgslEvent_DsrInactive</span><span class="p">)</span> <span class="o">+</span>
 		  <span class="p">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DCD</span><span class="p">)</span> <span class="o">?</span> <span class="n">MgslEvent_DcdActive</span><span class="o">:</span><span class="n">MgslEvent_DcdInactive</span><span class="p">)</span> <span class="o">+</span>
		  <span class="p">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">SerialSignal_CTS</span><span class="p">)</span> <span class="o">?</span> <span class="n">MgslEvent_CtsActive</span><span class="o">:</span><span class="n">MgslEvent_CtsInactive</span><span class="p">)</span> <span class="o">+</span>
		  <span class="p">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">SerialSignal_RI</span><span class="p">)</span>  <span class="o">?</span> <span class="n">MgslEvent_RiActive</span> <span class="o">:</span><span class="n">MgslEvent_RiInactive</span><span class="p">)</span> <span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* save current irq counts */</span>
	<span class="n">cprev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>
	<span class="n">oldsigs</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">;</span>
	
	<span class="cm">/* enable hunt and idle irqs if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MgslEvent_ExitHuntMode</span> <span class="o">+</span> <span class="n">MgslEvent_IdleReceived</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">oldreg</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">RICR</span><span class="p">);</span>
		<span class="n">u16</span> <span class="n">newreg</span> <span class="o">=</span> <span class="n">oldreg</span> <span class="o">+</span>
			 <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MgslEvent_ExitHuntMode</span> <span class="o">?</span> <span class="n">RXSTATUS_EXITED_HUNT</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
			 <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MgslEvent_IdleReceived</span> <span class="o">?</span> <span class="n">RXSTATUS_IDLE_RECEIVED</span><span class="o">:</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldreg</span> <span class="o">!=</span> <span class="n">newreg</span><span class="p">)</span>
			<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="p">,</span> <span class="n">newreg</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">event_wait_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	

	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
			
		<span class="cm">/* get current irq counts */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">cnow</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>
		<span class="n">newsigs</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">input_signal_events</span><span class="p">;</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* if no change, wait aborted for some reason */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">dsr_up</span>   <span class="o">==</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">dsr_up</span>   <span class="o">&amp;&amp;</span>
		    <span class="n">newsigs</span><span class="p">.</span><span class="n">dsr_down</span> <span class="o">==</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">dsr_down</span> <span class="o">&amp;&amp;</span>
		    <span class="n">newsigs</span><span class="p">.</span><span class="n">dcd_up</span>   <span class="o">==</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">dcd_up</span>   <span class="o">&amp;&amp;</span>
		    <span class="n">newsigs</span><span class="p">.</span><span class="n">dcd_down</span> <span class="o">==</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">dcd_down</span> <span class="o">&amp;&amp;</span>
		    <span class="n">newsigs</span><span class="p">.</span><span class="n">cts_up</span>   <span class="o">==</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">cts_up</span>   <span class="o">&amp;&amp;</span>
		    <span class="n">newsigs</span><span class="p">.</span><span class="n">cts_down</span> <span class="o">==</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">cts_down</span> <span class="o">&amp;&amp;</span>
		    <span class="n">newsigs</span><span class="p">.</span><span class="n">ri_up</span>    <span class="o">==</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">ri_up</span>    <span class="o">&amp;&amp;</span>
		    <span class="n">newsigs</span><span class="p">.</span><span class="n">ri_down</span>  <span class="o">==</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">ri_down</span>  <span class="o">&amp;&amp;</span>
		    <span class="n">cnow</span><span class="p">.</span><span class="n">exithunt</span>    <span class="o">==</span> <span class="n">cprev</span><span class="p">.</span><span class="n">exithunt</span>   <span class="o">&amp;&amp;</span>
		    <span class="n">cnow</span><span class="p">.</span><span class="n">rxidle</span>      <span class="o">==</span> <span class="n">cprev</span><span class="p">.</span><span class="n">rxidle</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">events</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span>
			<span class="p">(</span> <span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">dsr_up</span>   <span class="o">!=</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">dsr_up</span>   <span class="o">?</span> <span class="n">MgslEvent_DsrActive</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>   <span class="o">+</span>
			<span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">dsr_down</span> <span class="o">!=</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">dsr_down</span> <span class="o">?</span> <span class="n">MgslEvent_DsrInactive</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">dcd_up</span>   <span class="o">!=</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">dcd_up</span>   <span class="o">?</span> <span class="n">MgslEvent_DcdActive</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>   <span class="o">+</span>
			<span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">dcd_down</span> <span class="o">!=</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">dcd_down</span> <span class="o">?</span> <span class="n">MgslEvent_DcdInactive</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">cts_up</span>   <span class="o">!=</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">cts_up</span>   <span class="o">?</span> <span class="n">MgslEvent_CtsActive</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>   <span class="o">+</span>
			<span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">cts_down</span> <span class="o">!=</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">cts_down</span> <span class="o">?</span> <span class="n">MgslEvent_CtsInactive</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">ri_up</span>    <span class="o">!=</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">ri_up</span>    <span class="o">?</span> <span class="n">MgslEvent_RiActive</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>    <span class="o">+</span>
			<span class="p">(</span><span class="n">newsigs</span><span class="p">.</span><span class="n">ri_down</span>  <span class="o">!=</span> <span class="n">oldsigs</span><span class="p">.</span><span class="n">ri_down</span>  <span class="o">?</span> <span class="n">MgslEvent_RiInactive</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>  <span class="o">+</span>
			<span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">exithunt</span>    <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">exithunt</span>   <span class="o">?</span> <span class="n">MgslEvent_ExitHuntMode</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
			  <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">rxidle</span>      <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">rxidle</span>     <span class="o">?</span> <span class="n">MgslEvent_IdleReceived</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		
		<span class="n">cprev</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">;</span>
		<span class="n">oldsigs</span> <span class="o">=</span> <span class="n">newsigs</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">event_wait_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MgslEvent_ExitHuntMode</span> <span class="o">+</span> <span class="n">MgslEvent_IdleReceived</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">event_wait_q</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* disable enable exit hunt mode/idle rcvd IRQs */</span>
			<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="p">,</span> <span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">RICR</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="o">~</span><span class="p">(</span><span class="n">RXSTATUS_EXITED_HUNT</span> <span class="o">+</span> <span class="n">RXSTATUS_IDLE_RECEIVED</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="n">PUT_USER</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">mask_ptr</span><span class="p">);</span>
		
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_wait_event() */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">modem_input_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgsl_icount</span> <span class="n">cprev</span><span class="p">,</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="cm">/* save current irq counts */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cprev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">status_event_wait_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* get new irq counts */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">cnow</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* if no change, wait aborted for some reason */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">rng</span> <span class="o">==</span> <span class="n">cprev</span><span class="p">.</span><span class="n">rng</span> <span class="o">&amp;&amp;</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dsr</span> <span class="o">==</span> <span class="n">cprev</span><span class="p">.</span><span class="n">dsr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cnow</span><span class="p">.</span><span class="n">dcd</span> <span class="o">==</span> <span class="n">cprev</span><span class="p">.</span><span class="n">dcd</span> <span class="o">&amp;&amp;</span> <span class="n">cnow</span><span class="p">.</span><span class="n">cts</span> <span class="o">==</span> <span class="n">cprev</span><span class="p">.</span><span class="n">cts</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* check for change in caller specified modem input */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_RNG</span> <span class="o">&amp;&amp;</span> <span class="n">cnow</span><span class="p">.</span><span class="n">rng</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">rng</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_DSR</span> <span class="o">&amp;&amp;</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dsr</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">dsr</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_CD</span>  <span class="o">&amp;&amp;</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dcd</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">dcd</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_CTS</span> <span class="o">&amp;&amp;</span> <span class="n">cnow</span><span class="p">.</span><span class="n">cts</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">cts</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cprev</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">status_event_wait_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* return the state of the serial control and status signals</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocmget</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
 	<span class="n">usc_get_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_RTS</span><span class="p">)</span> <span class="o">?</span> <span class="n">TIOCM_RTS</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DTR</span><span class="p">)</span> <span class="o">?</span> <span class="n">TIOCM_DTR</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DCD</span><span class="p">)</span> <span class="o">?</span> <span class="n">TIOCM_CAR</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_RI</span><span class="p">)</span>  <span class="o">?</span> <span class="n">TIOCM_RNG</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DSR</span><span class="p">)</span> <span class="o">?</span> <span class="n">TIOCM_DSR</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_CTS</span><span class="p">)</span> <span class="o">?</span> <span class="n">TIOCM_CTS</span><span class="o">:</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):%s tiocmget() value=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">result</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set modem control signals (DTR/RTS)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocmset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):%s tiocmset(%x,%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">set</span><span class="p">,</span> <span class="n">clear</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="n">TIOCM_RTS</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_RTS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="n">TIOCM_DTR</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_DTR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear</span> <span class="o">&amp;</span> <span class="n">TIOCM_RTS</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SerialSignal_RTS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear</span> <span class="o">&amp;</span> <span class="n">TIOCM_DTR</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SerialSignal_DTR</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
 	<span class="n">usc_set_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mgsl_break()		Set or clear transmit break condition</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		tty		pointer to tty instance data</span>
<span class="cm"> *			break_state	-1=set break condition, 0=clear</span>
<span class="cm"> * Return Value:	error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">break_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_break(%s,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">break_state</span><span class="p">);</span>
			 
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_break&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">break_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">IOCR</span><span class="p">,(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">IOCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT7</span><span class="p">));</span>
	<span class="k">else</span> 
		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">IOCR</span><span class="p">,(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">IOCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT7</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_break() */</span>

<span class="cm">/*</span>
<span class="cm"> * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)</span>
<span class="cm"> * Return: write counters to the user passed counter struct</span>
<span class="cm"> * NB: both 1-&gt;0 and 0-&gt;1 transitions are counted except for</span>
<span class="cm"> *     RI where only 0-&gt;1 is counted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msgl_get_icount</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">serial_icounter_struct</span> <span class="o">*</span><span class="n">icount</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgsl_icount</span> <span class="n">cnow</span><span class="p">;</span>	<span class="cm">/* kernel counter temps */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">cnow</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">cts</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">cts</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dsr</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dsr</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rng</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">rng</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dcd</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dcd</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rx</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">rx</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">tx</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">tx</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">overrun</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">overrun</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">parity</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">parity</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">brk</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">buf_overrun</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">buf_overrun</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mgsl_ioctl()	Service an IOCTL request</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	tty	pointer to tty instance data</span>
<span class="cm"> * 	cmd	IOCTL command code</span>
<span class="cm"> * 	arg	command argument/context</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_ioctl %s cmd=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">cmd</span> <span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_ioctl&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">TIOCGSERIAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">TIOCSSERIAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">TIOCMIWAIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TTY_IO_ERROR</span><span class="p">))</span>
		    <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mgsl_ioctl_common</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_ioctl_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MGSL_IOCGPARAMS</span>:
			<span class="k">return</span> <span class="n">mgsl_get_params</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCSPARAMS</span>:
			<span class="k">return</span> <span class="n">mgsl_set_params</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCGTXIDLE</span>:
			<span class="k">return</span> <span class="n">mgsl_get_txidle</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCSTXIDLE</span>:
			<span class="k">return</span> <span class="n">mgsl_set_txidle</span><span class="p">(</span><span class="n">info</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCTXENABLE</span>:
			<span class="k">return</span> <span class="n">mgsl_txenable</span><span class="p">(</span><span class="n">info</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCRXENABLE</span>:
			<span class="k">return</span> <span class="n">mgsl_rxenable</span><span class="p">(</span><span class="n">info</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCTXABORT</span>:
			<span class="k">return</span> <span class="n">mgsl_txabort</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCGSTATS</span>:
			<span class="k">return</span> <span class="n">mgsl_get_stats</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCWAITEVENT</span>:
			<span class="k">return</span> <span class="n">mgsl_wait_event</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MGSL_IOCLOOPTXDONE</span>:
			<span class="k">return</span> <span class="n">mgsl_loopmode_send_done</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="cm">/* Wait for modem input (DCD,RI,DSR,CTS) change</span>
<span class="cm">		 * as specified by mask in arg (TIOCM_RNG/DSR/CD/CTS)</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">TIOCMIWAIT</span>:
			<span class="k">return</span> <span class="n">modem_input_wait</span><span class="p">(</span><span class="n">info</span><span class="p">,(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* mgsl_set_termios()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Set new termios settings</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	tty		pointer to tty structure</span>
<span class="cm"> * 	termios		pointer to buffer to hold returned old termios</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value:		None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old_termios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_set_termios %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">);</span>
	
	<span class="n">mgsl_change_params</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Handle transition to B0 status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SerialSignal_RTS</span> <span class="o">+</span> <span class="n">SerialSignal_DTR</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	 	<span class="n">usc_set_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="cm">/* Handle transition away from B0 status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_DTR</span><span class="p">;</span>
 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="o">||</span> 
 		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_THROTTLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_RTS</span><span class="p">;</span>
 		<span class="p">}</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	 	<span class="n">usc_set_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="cm">/* Handle turning off CRTSCTS */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mgsl_start</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_set_termios() */</span>

<span class="cm">/* mgsl_close()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Called when port is closed. Wait for remaining data to be</span>
<span class="cm"> * 	sent. Disable port and free resources.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	tty	pointer to open tty structure</span>
<span class="cm"> * 	filp	pointer to open file object</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_close&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_close(%s) entry, count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_port_close_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>			 
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">)</span>
 		<span class="n">mgsl_wait_until_sent</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">mgsl_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">tty_ldisc_flush</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">shutdown</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">tty_port_close_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>	
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">cleanup:</span>			
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_close(%s) exit, count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
			<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
			
<span class="p">}</span>	<span class="cm">/* end of mgsl_close() */</span>

<span class="cm">/* mgsl_wait_until_sent()</span>
<span class="cm"> *</span>
<span class="cm"> *	Wait until the transmitter is empty.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	tty		pointer to tty info structure</span>
<span class="cm"> *	timeout		time to wait for send completion</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_wait_until_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">orig_jiffies</span><span class="p">,</span> <span class="n">char_time</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span> <span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_wait_until_sent(%s) entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
      
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_wait_until_sent&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	 
	<span class="n">orig_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
      
	<span class="cm">/* Set check interval to 1/5 of estimated time to</span>
<span class="cm">	 * send a character, and make it at least 1. The check</span>
<span class="cm">	 * interval should also be less than the timeout.</span>
<span class="cm">	 * Note: use tight timings here to satisfy the NIST-PCTS.</span>
<span class="cm">	 */</span> 

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_rate</span> <span class="p">)</span> <span class="p">{</span>
	       	<span class="n">char_time</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="o">/</span><span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">char_time</span><span class="p">)</span>
			<span class="n">char_time</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">char_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">char_time</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">char_time</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep_interruptible</span><span class="p">(</span><span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">char_time</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">orig_jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">TCSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TXSTATUS_ALL_SENT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep_interruptible</span><span class="p">(</span><span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">char_time</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">orig_jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
      
<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_wait_until_sent(%s) exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			 
<span class="p">}</span>	<span class="cm">/* end of mgsl_wait_until_sent() */</span>

<span class="cm">/* mgsl_hangup()</span>
<span class="cm"> *</span>
<span class="cm"> *	Called by tty_hangup() when a hangup is signaled.</span>
<span class="cm"> *	This is the same as to closing all open files for the port.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		tty	pointer to associated tty object</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_hangup(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			 
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_hangup&quot;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mgsl_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">shutdown</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ASYNC_NORMAL_ACTIVE</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">open_wait</span><span class="p">);</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_hangup() */</span>

<span class="cm">/*</span>
<span class="cm"> * carrier_raised()</span>
<span class="cm"> *</span>
<span class="cm"> *	Return true if carrier is raised</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">carrier_raised</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mgsl_struct</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
 	<span class="n">usc_get_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DCD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dtr_rts</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mgsl_struct</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_RTS</span> <span class="o">+</span> <span class="n">SerialSignal_DTR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">SerialSignal_RTS</span> <span class="o">+</span> <span class="n">SerialSignal_DTR</span><span class="p">);</span>
 	<span class="n">usc_set_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* block_til_ready()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Block the current process until the specified port</span>
<span class="cm"> * 	is ready to be opened.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	tty		pointer to tty info structure</span>
<span class="cm"> * 	filp		pointer to open file object</span>
<span class="cm"> * 	info		pointer to device instance data</span>
<span class="cm"> * 	</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">block_til_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="kt">int</span>		<span class="n">retval</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">do_clocal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">extra_count</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">dcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):block_til_ready on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span> <span class="o">||</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TTY_IO_ERROR</span><span class="p">)){</span>
		<span class="cm">/* nonblock mode is set or port is not enabled */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ASYNC_NORMAL_ACTIVE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CLOCAL</span><span class="p">)</span>
		<span class="n">do_clocal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Wait for carrier detect and the line to become</span>
<span class="cm">	 * free (i.e., not in use by the callout).  While we are in</span>
<span class="cm">	 * this loop, port-&gt;count is dropped by one, so that</span>
<span class="cm">	 * mgsl_close() knows when to free things.  We restore it upon</span>
<span class="cm">	 * exit, either normal or abnormal.</span>
<span class="cm">	 */</span>
	 
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):block_til_ready before block on %s count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span> <span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">extra_count</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">blocked_open</span><span class="o">++</span><span class="p">;</span>
	
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">)</span>
			<span class="n">tty_port_raise_dtr_rts</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
		
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">)){</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_HUP_NOTIFY</span><span class="p">)</span> <span class="o">?</span>
					<span class="o">-</span><span class="n">EAGAIN</span> <span class="o">:</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">dcd</span> <span class="o">=</span> <span class="n">tty_port_carrier_raised</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
		
 		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CLOSING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">do_clocal</span> <span class="o">||</span> <span class="n">dcd</span><span class="p">))</span>
 			<span class="k">break</span><span class="p">;</span>
			
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):block_til_ready blocking on %s count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span> <span class="p">);</span>
				 
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">tty_lock</span><span class="p">();</span>
	<span class="p">}</span>
	
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	
	<span class="cm">/* FIXME: Racy on hangup during close wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extra_count</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">blocked_open</span><span class="o">--</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):block_til_ready after blocking on %s count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span> <span class="p">);</span>
			 
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ASYNC_NORMAL_ACTIVE</span><span class="p">;</span>
		
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of block_til_ready() */</span>

<span class="cm">/* mgsl_open()</span>
<span class="cm"> *</span>
<span class="cm"> *	Called when a port is opened.  Init and enable port.</span>
<span class="cm"> *	Perform serial-specific initialization for the tty structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		tty	pointer to tty info structure</span>
<span class="cm"> *			filp	associated file pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span>	<span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> 			<span class="n">retval</span><span class="p">,</span> <span class="n">line</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* verify range of specified line number */</span>	
	<span class="n">line</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">line</span> <span class="o">&gt;=</span> <span class="n">mgsl_device_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_open with invalid line #%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">line</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* find the info structure for the specified line */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">mgsl_device_list</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">info</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">!=</span> <span class="n">line</span><span class="p">)</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next_device</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mgsl_paranoia_check</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;mgsl_open&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty</span><span class="p">;</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_open(%s), old ref count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>

	<span class="cm">/* If port is closing, signal caller to try again */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CLOSING</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CLOSING</span><span class="p">)</span>
			<span class="n">interruptible_sleep_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">close_wait</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_HUP_NOTIFY</span><span class="p">)</span> <span class="o">?</span>
			<span class="o">-</span><span class="n">EAGAIN</span> <span class="o">:</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">low_latency</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_LOW_LATENCY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 1st open on this device, init hardware */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">startup</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">block_til_ready</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):block_til_ready(%s) returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_open(%s) success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="nl">cleanup:</span>			
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* tty layer will release tty struct */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_open() */</span>

<span class="cm">/*</span>
<span class="cm"> * /proc fs routines....</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">line_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span>	<span class="n">stat_buf</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s:PCI io:%04X irq:%d mem:%08X lcr:%08X&quot;</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s:(E)ISA io:%04X irq:%d dma:%d&quot;</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">,</span> 
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* output current serial signal states */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
 	<span class="n">usc_get_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="n">stat_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stat_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_RTS</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">stat_buf</span><span class="p">,</span> <span class="s">&quot;|RTS&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_CTS</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">stat_buf</span><span class="p">,</span> <span class="s">&quot;|CTS&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DTR</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">stat_buf</span><span class="p">,</span> <span class="s">&quot;|DTR&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DSR</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">stat_buf</span><span class="p">,</span> <span class="s">&quot;|DSR&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DCD</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">stat_buf</span><span class="p">,</span> <span class="s">&quot;|CD&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_RI</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">stat_buf</span><span class="p">,</span> <span class="s">&quot;|RI&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; HDLC txok:%d rxok:%d&quot;</span><span class="p">,</span>
			      <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txok</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxok</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txunder</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; txunder:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txunder</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txabort</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; txabort:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txabort</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxshort</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; rxshort:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxshort</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxlong</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; rxlong:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxlong</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxover</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; rxover:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxover</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxcrc</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; rxcrc:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxcrc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; ASYNC tx:%d rx:%d&quot;</span><span class="p">,</span>
			      <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">frame</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; fe:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">frame</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">parity</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; pe:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">parity</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">brk</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; brk:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">brk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">overrun</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; oe:%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">overrun</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="cm">/* Append serial signal status to end */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat_buf</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;txactive=%d bh_req=%d bh_run=%d pending_bh=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	 <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bh_requested</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bh_running</span><span class="p">,</span>
	 <span class="n">info</span><span class="o">-&gt;</span><span class="n">pending_bh</span><span class="p">);</span>
	 
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">{</span>	
	<span class="n">u16</span> <span class="n">Tcsr</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCSR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Tdmr</span> <span class="o">=</span> <span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TDMR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Ticr</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TICR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Rscr</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCSR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Rdmr</span> <span class="o">=</span> <span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDMR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Ricr</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RICR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Icr</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">ICR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Dccr</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DCCR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Tmr</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TMR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Tccr</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCCR</span> <span class="p">);</span>
	<span class="n">u16</span> <span class="n">Ccar</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;tcsr=%04X tdmr=%04X ticr=%04X rcsr=%04X rdmr=%04X</span><span class="se">\n</span><span class="s">&quot;</span>
                        <span class="s">&quot;ricr=%04X icr =%04X dccr=%04X tmr=%04X tccr=%04X ccar=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	 		<span class="n">Tcsr</span><span class="p">,</span><span class="n">Tdmr</span><span class="p">,</span><span class="n">Ticr</span><span class="p">,</span><span class="n">Rscr</span><span class="p">,</span><span class="n">Rdmr</span><span class="p">,</span><span class="n">Ricr</span><span class="p">,</span><span class="n">Icr</span><span class="p">,</span><span class="n">Dccr</span><span class="p">,</span><span class="n">Tmr</span><span class="p">,</span><span class="n">Tccr</span><span class="p">,</span><span class="n">Ccar</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called to print information about devices */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;synclink driver:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_version</span><span class="p">);</span>
	
	<span class="n">info</span> <span class="o">=</span> <span class="n">mgsl_device_list</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span> <span class="n">info</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">line_info</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next_device</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mgsl_proc_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">mgsl_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">mgsl_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* mgsl_allocate_dma_buffers()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Allocate and format DMA buffers (ISA adapter)</span>
<span class="cm"> * 	or format shared memory buffers (PCI adapter).</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	0 if success, otherwise error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_allocate_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">BuffersPerFrame</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">last_mem_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Calculate the number of DMA buffers necessary to hold the */</span>
	<span class="cm">/* largest allowable frame size. Note: If the max frame size is */</span>
	<span class="cm">/* not an even multiple of the DMA buffer size then we need to */</span>
	<span class="cm">/* round the buffer count per frame up one. */</span>

	<span class="n">BuffersPerFrame</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="o">/</span><span class="n">DMABUFFERSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">%</span> <span class="n">DMABUFFERSIZE</span> <span class="p">)</span>
		<span class="n">BuffersPerFrame</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The PCI adapter has 256KBytes of shared memory to use.</span>
<span class="cm">		 * This is 64 PAGE_SIZE buffers.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The first page is used for padding at this time so the</span>
<span class="cm">		 * buffer list does not begin at offset 0 of the PCI</span>
<span class="cm">		 * adapter&#39;s shared memory.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The 2nd page is used for the buffer list. A 4K buffer</span>
<span class="cm">		 * list can hold 128 DMA_BUFFER structures at 32 bytes</span>
<span class="cm">		 * each.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This leaves 62 4K pages.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The next N pages are used for transmit frame(s). We</span>
<span class="cm">		 * reserve enough 4K page blocks to hold the required</span>
<span class="cm">		 * number of transmit dma buffers (num_tx_dma_buffers),</span>
<span class="cm">		 * each of MaxFrameSize size.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Of the remaining pages (62-N), determine how many can</span>
<span class="cm">		 * be used to receive full MaxFrameSize inbound frames</span>
<span class="cm">		 */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_dma_buffers</span> <span class="o">*</span> <span class="n">BuffersPerFrame</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="o">=</span> <span class="mi">62</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Calculate the number of PAGE_SIZE buffers needed for */</span>
		<span class="cm">/* receive and transmit DMA buffers. */</span>


		<span class="cm">/* Calculate the number of DMA buffers necessary to */</span>
		<span class="cm">/* hold 7 max size receive frames and one max size transmit frame. */</span>
		<span class="cm">/* The receive buffer count is bumped by one so we avoid an */</span>
		<span class="cm">/* End of List condition if all receive buffers are used when */</span>
		<span class="cm">/* using linked list DMA buffers. */</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_dma_buffers</span> <span class="o">*</span> <span class="n">BuffersPerFrame</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">BuffersPerFrame</span> <span class="o">*</span> <span class="n">MAXRXFRAMES</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">;</span>
		
		<span class="cm">/* </span>
<span class="cm">		 * limit total TxBuffers &amp; RxBuffers to 62 4K total </span>
<span class="cm">		 * (ala PCI Allocation) </span>
<span class="cm">		 */</span>
		
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">62</span> <span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="o">=</span> <span class="mi">62</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):Allocating %d TX and %d RX DMA buffers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">mgsl_alloc_buffer_list_memory</span><span class="p">(</span> <span class="n">info</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
		  <span class="n">mgsl_alloc_frame_memory</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> 
		  <span class="n">mgsl_alloc_frame_memory</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> 
		  <span class="n">mgsl_alloc_intermediate_rxbuffer_memory</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="o">||</span>
		  <span class="n">mgsl_alloc_intermediate_txbuffer_memory</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):Can&#39;t allocate DMA buffer memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">mgsl_reset_rx_dma_buffers</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
  	<span class="n">mgsl_reset_tx_dma_buffers</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_allocate_dma_buffers() */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_alloc_buffer_list_memory()</span>
<span class="cm"> * </span>
<span class="cm"> * Allocate a common DMA buffer for use as the</span>
<span class="cm"> * receive and transmit buffer lists.</span>
<span class="cm"> * </span>
<span class="cm"> * A buffer list is a set of buffer entries where each entry contains</span>
<span class="cm"> * a pointer to an actual buffer and a pointer to the next buffer entry</span>
<span class="cm"> * (plus some other info about the buffer).</span>
<span class="cm"> * </span>
<span class="cm"> * The buffer entries for a list are built to form a circular list so</span>
<span class="cm"> * that when the entire list has been traversed you start back at the</span>
<span class="cm"> * beginning.</span>
<span class="cm"> * </span>
<span class="cm"> * This function allocates memory for just the buffer entries.</span>
<span class="cm"> * The links (pointer to next entry) are filled in with the physical</span>
<span class="cm"> * address of the next entry so the adapter can navigate the list</span>
<span class="cm"> * using bus master DMA. The pointers to the actual buffers are filled</span>
<span class="cm"> * out later when the actual buffers are allocated.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	0 if success, otherwise error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_alloc_buffer_list_memory</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* PCI adapter uses shared memory. */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">last_mem_alloc</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_phys</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">last_mem_alloc</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">last_mem_alloc</span> <span class="o">+=</span> <span class="n">BUFFERLISTSIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* ISA adapter uses system memory. */</span>
		<span class="cm">/* The buffer lists are allocated as a common buffer that both */</span>
		<span class="cm">/* the processor and adapter can access. This allows the driver to */</span>
		<span class="cm">/* inspect portions of the buffer while other portions are being */</span>
		<span class="cm">/* updated by the adapter using Bus Master DMA. */</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">BUFFERLISTSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_dma_addr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_phys</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_dma_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We got the memory for the buffer entry lists. */</span>
	<span class="cm">/* Initialize the memory block to all zeros. */</span>
	<span class="n">memset</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BUFFERLISTSIZE</span> <span class="p">);</span>

	<span class="cm">/* Save virtual address pointers to the receive and */</span>
	<span class="cm">/* transmit buffer lists. (Receive 1st). These pointers will */</span>
	<span class="cm">/* be used by the processor to access the lists. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span> <span class="o">+=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the links for the buffer entry lists such that</span>
<span class="cm">	 * two circular lists are built. (Transmit and Receive).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: the links are physical addresses</span>
<span class="cm">	 * which are read by the adapter to determine the next</span>
<span class="cm">	 * buffer entry to use.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* calculate and store physical address of this buffer entry */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_entry</span> <span class="o">=</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_phys</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DMABUFFERENTRY</span><span class="p">));</span>

		<span class="cm">/* calculate and store physical address of */</span>
		<span class="cm">/* next entry in cirular list of entries */</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_phys</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DMABUFFERENTRY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* calculate and store physical address of this buffer entry */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_entry</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_phys</span> <span class="o">+</span>
			<span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DMABUFFERENTRY</span><span class="p">));</span>

		<span class="cm">/* calculate and store physical address of */</span>
		<span class="cm">/* next entry in cirular list of entries */</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_phys</span> <span class="o">+</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DMABUFFERENTRY</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DMABUFFERENTRY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_alloc_buffer_list_memory() */</span>

<span class="cm">/* Free DMA buffers allocated for use as the</span>
<span class="cm"> * receive and transmit buffer lists.</span>
<span class="cm"> * Warning:</span>
<span class="cm"> * </span>
<span class="cm"> * 	The data transfer buffers associated with the buffer list</span>
<span class="cm"> * 	MUST be freed before freeing the buffer list itself because</span>
<span class="cm"> * 	the buffer list contains the information necessary to free</span>
<span class="cm"> * 	the individual buffers!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_free_buffer_list_memory</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">!=</span> <span class="n">MGSL_BUS_TYPE_PCI</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">BUFFERLISTSIZE</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list_dma_addr</span><span class="p">);</span>
		
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_free_buffer_list_memory() */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_alloc_frame_memory()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Allocate the frame DMA buffers used by the specified buffer list.</span>
<span class="cm"> * 	Each DMA buffer will be one memory page in size. This is necessary</span>
<span class="cm"> * 	because memory can fragment enough that it may be impossible</span>
<span class="cm"> * 	contiguous pages.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> *	info		pointer to device instance data</span>
<span class="cm"> * 	BufferList	pointer to list of buffer entries</span>
<span class="cm"> * 	Buffercount	count of buffer entries in buffer list</span>
<span class="cm"> * </span>
<span class="cm"> * Return Value:	0 if success, otherwise -ENOMEM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_alloc_frame_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span><span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">BufferList</span><span class="p">,</span><span class="kt">int</span> <span class="n">Buffercount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phys_addr</span><span class="p">;</span>

	<span class="cm">/* Allocate page sized buffers for the receive buffer list */</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Buffercount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* PCI adapter uses shared memory buffers. */</span>
			<span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">last_mem_alloc</span><span class="p">;</span>
			<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">last_mem_alloc</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">last_mem_alloc</span> <span class="o">+=</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* ISA adapter uses system memory. */</span>
			<span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_addr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">DMABUFFERSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">phys_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">phys_addr</span> <span class="o">=</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_alloc_frame_memory() */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_free_frame_memory()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Free the buffers associated with</span>
<span class="cm"> * 	each buffer entry of a buffer list.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> *	info		pointer to device instance data</span>
<span class="cm"> * 	BufferList	pointer to list of buffer entries</span>
<span class="cm"> * 	Buffercount	count of buffer entries in buffer list</span>
<span class="cm"> * </span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_free_frame_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">BufferList</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Buffercount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">BufferList</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Buffercount</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_addr</span> <span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">!=</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
					<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">DMABUFFERSIZE</span><span class="p">,</span> <span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_addr</span><span class="p">,</span> <span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma_addr</span><span class="p">);</span>
				<span class="n">BufferList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">virt_addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_free_frame_memory() */</span>

<span class="cm">/* mgsl_free_dma_buffers()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Free DMA buffers</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_free_dma_buffers</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">mgsl_free_frame_memory</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="p">);</span>
	<span class="n">mgsl_free_frame_memory</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="p">);</span>
	<span class="n">mgsl_free_buffer_list_memory</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_free_dma_buffers() */</span>


<span class="cm">/*</span>
<span class="cm"> * mgsl_alloc_intermediate_rxbuffer_memory()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Allocate a buffer large enough to hold max_frame_size. This buffer</span>
<span class="cm"> *	is used to pass an assembled frame to the line discipline.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> *	info		pointer to device instance data</span>
<span class="cm"> * </span>
<span class="cm"> * Return Value:	0 if success, otherwise -ENOMEM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_alloc_intermediate_rxbuffer_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_alloc_intermediate_rxbuffer_memory() */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_free_intermediate_rxbuffer_memory()</span>
<span class="cm"> * </span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> *	info		pointer to device instance data</span>
<span class="cm"> * </span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_free_intermediate_rxbuffer_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_free_intermediate_rxbuffer_memory() */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_alloc_intermediate_txbuffer_memory()</span>
<span class="cm"> *</span>
<span class="cm"> * 	Allocate intermdiate transmit buffer(s) large enough to hold max_frame_size.</span>
<span class="cm"> * 	This buffer is used to load transmit frames into the adapter&#39;s dma transfer</span>
<span class="cm"> * 	buffers when there is sufficient space.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	info		pointer to device instance data</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	0 if success, otherwise -ENOMEM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_alloc_intermediate_txbuffer_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %s(%d)  allocating %d tx holding buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer</span> <span class="o">=</span>
			<span class="n">kmalloc</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer</span><span class="p">);</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_alloc_intermediate_txbuffer_memory() */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_free_intermediate_txbuffer_memory()</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	info		pointer to device instance data</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_free_intermediate_txbuffer_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">get_tx_holding_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">put_tx_holding_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_free_intermediate_txbuffer_memory() */</span>


<span class="cm">/*</span>
<span class="cm"> * load_next_tx_holding_buffer()</span>
<span class="cm"> *</span>
<span class="cm"> * attempts to load the next buffered tx request into the</span>
<span class="cm"> * tx dma buffers</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	info		pointer to device instance data</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	true if next buffered tx request loaded</span>
<span class="cm"> * 			into adapter&#39;s tx dma buffer,</span>
<span class="cm"> * 			false otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">load_next_tx_holding_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_count</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* determine if we have enough tx dma buffers</span>
<span class="cm">		 * to accommodate the next tx frame</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">tx_holding_buffer</span> <span class="o">*</span><span class="n">ptx</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">get_tx_holding_index</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">num_free</span> <span class="o">=</span> <span class="n">num_free_tx_dma_buffers</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">num_needed</span> <span class="o">=</span> <span class="n">ptx</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">/</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">ptx</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">%</span> <span class="n">DMABUFFERSIZE</span> <span class="p">)</span>
			<span class="o">++</span><span class="n">num_needed</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num_needed</span> <span class="o">&lt;=</span> <span class="n">num_free</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">=</span> <span class="n">ptx</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span>
			<span class="n">mgsl_load_tx_dma_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ptx</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span><span class="n">ptx</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">);</span>

			<span class="o">--</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_count</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span> <span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">get_tx_holding_index</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">get_tx_holding_index</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* restart transmit timer */</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5000</span><span class="p">));</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * save_tx_buffer_request()</span>
<span class="cm"> *</span>
<span class="cm"> * attempt to store transmit frame request for later transmission</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	info		pointer to device instance data</span>
<span class="cm"> * 	Buffer		pointer to buffer containing frame to load</span>
<span class="cm"> * 	BufferSize	size in bytes of frame in Buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	1 if able to store, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">save_tx_buffer_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">BufferSize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tx_holding_buffer</span> <span class="o">*</span><span class="n">ptx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_count</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	        <span class="cm">/* all buffers in use */</span>
	<span class="p">}</span>

	<span class="n">ptx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_buffers</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">put_tx_holding_index</span><span class="p">];</span>
	<span class="n">ptx</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">BufferSize</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span> <span class="n">ptx</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">);</span>

	<span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">put_tx_holding_index</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">put_tx_holding_index</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_claim_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_region</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_addr_size</span><span class="p">,</span><span class="s">&quot;synclink&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):I/O address conflict on device %s Addr=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_addr_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">,</span><span class="n">mgsl_interrupt</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_flags</span><span class="p">,</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Can&#39;t request interrupt on device %s IRQ=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span> <span class="p">);</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span><span class="p">,</span><span class="mh">0x40000</span><span class="p">,</span><span class="s">&quot;synclink&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mem addr conflict device %s Addr=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">shared_mem_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_offset</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="s">&quot;synclink&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):lcr mem addr conflict device %s Addr=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_offset</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_mem_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span><span class="p">,</span>
								<span class="mh">0x40000</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Can&#39;t map shared memory on device %s MemAddr=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span> <span class="p">);</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">mgsl_memory_test</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Failed shared memory test %s MemAddr=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span> <span class="p">);</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span><span class="p">,</span>
								<span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Can&#39;t map LCR memory on device %s MemAddr=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span> <span class="p">);</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_base</span> <span class="o">+=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_offset</span><span class="p">;</span>
		
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* claim DMA channel */</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
			<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Can&#39;t request DMA channel on device %s DMA=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span> <span class="p">);</span>
			<span class="n">mgsl_release_resources</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/* ISA adapter uses bus master DMA */</span>		
		<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">,</span><span class="n">DMA_MODE_CASCADE</span><span class="p">);</span>
		<span class="n">enable_dma</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">mgsl_allocate_dma_buffers</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Can&#39;t allocate DMA buffers on device %s DMA=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span> <span class="p">);</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
	<span class="p">}</span>	
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">errout:</span>
	<span class="n">mgsl_release_resources</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_claim_resources() */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_release_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_release_resources(%s) entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_requested</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_requested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_requested</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">disable_dma</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">);</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_requested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mgsl_free_dma_buffers</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">mgsl_free_intermediate_rxbuffer_memory</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
     	<span class="n">mgsl_free_intermediate_txbuffer_memory</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_addr_requested</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_addr_size</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_addr_requested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">shared_mem_requested</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span><span class="p">,</span><span class="mh">0x40000</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">shared_mem_requested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_mem_requested</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_offset</span><span class="p">,</span><span class="mi">128</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_mem_requested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span><span class="p">){</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_base</span><span class="p">){</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_base</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_offset</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_release_resources(%s) exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			
<span class="p">}</span>	<span class="cm">/* end of mgsl_release_resources() */</span>

<span class="cm">/* mgsl_add_device()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Add the specified device instance data structure to the</span>
<span class="cm"> * 	global linked list of devices and increment the device count.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_add_device</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">next_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">=</span> <span class="n">mgsl_device_count</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="s">&quot;ttySL%d&quot;</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">&lt;</span> <span class="n">MAX_TOTAL_DEVICES</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxframe</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">])</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">maxframe</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">txdmabufs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_dma_buffers</span> <span class="o">=</span> <span class="n">txdmabufs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_dma_buffers</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_dma_buffers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">txholdbufs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span> <span class="o">=</span> <span class="n">txholdbufs</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span> <span class="o">&gt;</span> <span class="n">MAX_TX_HOLDING_BUFFERS</span><span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span> <span class="o">=</span> <span class="n">MAX_TX_HOLDING_BUFFERS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mgsl_device_count</span><span class="o">++</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">mgsl_device_list</span> <span class="p">)</span>
		<span class="n">mgsl_device_list</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>	
		<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">current_dev</span> <span class="o">=</span> <span class="n">mgsl_device_list</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span> <span class="n">current_dev</span><span class="o">-&gt;</span><span class="n">next_device</span> <span class="p">)</span>
			<span class="n">current_dev</span> <span class="o">=</span> <span class="n">current_dev</span><span class="o">-&gt;</span><span class="n">next_device</span><span class="p">;</span>
		<span class="n">current_dev</span><span class="o">-&gt;</span><span class="n">next_device</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">&lt;</span> <span class="mi">4096</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">&gt;</span> <span class="mi">65535</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="mi">65535</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;SyncLink PCI v%d %s: IO=%04X IRQ=%d Mem=%08X,%08X MaxFrameSize=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span><span class="p">,</span>
		     	<span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;SyncLink ISA %s: IO=%04X IRQ=%d DMA=%d MaxFrameSize=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">,</span>
		     	<span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
	<span class="n">hdlcdev_init</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_add_device() */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="n">mgsl_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">carrier_raised</span> <span class="o">=</span> <span class="n">carrier_raised</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr_rts</span> <span class="o">=</span> <span class="n">dtr_rts</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* mgsl_allocate_device()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Allocate and initialize a device instance structure</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		none</span>
<span class="cm"> * Return Value:	pointer to mgsl_struct if success, otherwise NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mgsl_struct</span><span class="o">*</span> <span class="nf">mgsl_allocate_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	
	<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span><span class="p">),</span>
		 <span class="n">GFP_KERNEL</span><span class="p">);</span>
		 
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Error can&#39;t allocate device instance data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tty_port_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgsl_port_ops</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">MGSL_MAGIC</span><span class="p">;</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">mgsl_bh_handler</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">close_delay</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">closing_wait</span> <span class="o">=</span> <span class="mi">30</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">status_event_wait_q</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">event_wait_q</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">,</span><span class="o">&amp;</span><span class="n">default_params</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MGSL_PARAMS</span><span class="p">));</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">idle_mode</span> <span class="o">=</span> <span class="n">HDLC_TXIDLE_FLAGS</span><span class="p">;</span>		
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_dma_buffers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_holding_buffers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">info</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_allocate_device()*/</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="n">mgsl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">mgsl_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">mgsl_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">mgsl_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_char</span> <span class="o">=</span> <span class="n">mgsl_put_char</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_chars</span> <span class="o">=</span> <span class="n">mgsl_flush_chars</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_room</span> <span class="o">=</span> <span class="n">mgsl_write_room</span><span class="p">,</span>
	<span class="p">.</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="n">mgsl_chars_in_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_buffer</span> <span class="o">=</span> <span class="n">mgsl_flush_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span> <span class="n">mgsl_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">throttle</span> <span class="o">=</span> <span class="n">mgsl_throttle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unthrottle</span> <span class="o">=</span> <span class="n">mgsl_unthrottle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_xchar</span> <span class="o">=</span> <span class="n">mgsl_send_xchar</span><span class="p">,</span>
	<span class="p">.</span><span class="n">break_ctl</span> <span class="o">=</span> <span class="n">mgsl_break</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wait_until_sent</span> <span class="o">=</span> <span class="n">mgsl_wait_until_sent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span> <span class="o">=</span> <span class="n">mgsl_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">mgsl_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">mgsl_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hangup</span> <span class="o">=</span> <span class="n">mgsl_hangup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tiocmget</span> <span class="o">=</span> <span class="n">tiocmget</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tiocmset</span> <span class="o">=</span> <span class="n">tiocmset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_icount</span> <span class="o">=</span> <span class="n">msgl_get_icount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mgsl_proc_fops</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * perform tty device initialization</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_init_tty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">serial_driver</span> <span class="o">=</span> <span class="n">alloc_tty_driver</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serial_driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">driver_name</span> <span class="o">=</span> <span class="s">&quot;synclink&quot;</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ttySL&quot;</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">ttymajor</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">minor_start</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">TTY_DRIVER_TYPE_SERIAL</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">SERIAL_TYPE_NORMAL</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span> <span class="o">=</span> <span class="n">tty_std_termios</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">=</span>
		<span class="n">B9600</span> <span class="o">|</span> <span class="n">CS8</span> <span class="o">|</span> <span class="n">CREAD</span> <span class="o">|</span> <span class="n">HUPCL</span> <span class="o">|</span> <span class="n">CLOCAL</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">.</span><span class="n">c_ispeed</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">.</span><span class="n">c_ospeed</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
	<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">TTY_DRIVER_REAL_RAW</span><span class="p">;</span>
	<span class="n">tty_set_operations</span><span class="p">(</span><span class="n">serial_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mgsl_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">tty_register_driver</span><span class="p">(</span><span class="n">serial_driver</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):Couldn&#39;t register serial driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">serial_driver</span><span class="p">);</span>
		<span class="n">serial_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
			
 	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %s, tty major#%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">driver_name</span><span class="p">,</span> <span class="n">driver_version</span><span class="p">,</span>
		<span class="n">serial_driver</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* enumerate user specified ISA adapters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_enum_isa_devices</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		
	<span class="cm">/* Check for user specified ISA devices */</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="p">;(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_ISA_DEVICES</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">irq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ISA device specified io=%04X,irq=%d,dma=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">irq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
		
		<span class="n">info</span> <span class="o">=</span> <span class="n">mgsl_allocate_device</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* error allocating device instance data */</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ERROR</span> <span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;can&#39;t allocate device instance data.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="cm">/* Copy user configuration info to device instance data */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">irq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span> <span class="o">=</span> <span class="n">irq_canonicalize</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">dma</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">=</span> <span class="n">MGSL_BUS_TYPE_ISA</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_addr_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
		<span class="n">mgsl_add_device</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">synclink_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unloading %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">driver_version</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">serial_driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">serial_driver</span><span class="p">)))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d) failed to unregister tty driver err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">rc</span><span class="p">);</span>
		<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">serial_driver</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">mgsl_device_list</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
		<span class="n">hdlcdev_exit</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">mgsl_release_resources</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
		<span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">next_device</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_registered</span><span class="p">)</span>
		<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">synclink_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">synclink_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">break_on_load</span><span class="p">)</span> <span class="p">{</span>
	 	<span class="n">mgsl_get_text_ptr</span><span class="p">();</span>
  		<span class="n">BREAKPOINT</span><span class="p">();</span>
	<span class="p">}</span>

 	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">driver_version</span><span class="p">);</span>

	<span class="n">mgsl_enum_isa_devices</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">synclink_pci_driver</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:failed to register PCI driver, error=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">rc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pci_registered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">mgsl_init_tty</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">synclink_cleanup</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">synclink_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">synclink_cleanup</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">synclink_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">synclink_exit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * usc_RTCmd()</span>
<span class="cm"> *</span>
<span class="cm"> * Issue a USC Receive/Transmit command to the</span>
<span class="cm"> * Channel Command/Address Register (CCAR).</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *</span>
<span class="cm"> *    The command is encoded in the most significant 5 bits &lt;15..11&gt;</span>
<span class="cm"> *    of the CCAR value. Bits &lt;10..7&gt; of the CCAR must be preserved</span>
<span class="cm"> *    and Bits &lt;6..0&gt; must be written as zeros.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *    info   pointer to device information structure</span>
<span class="cm"> *    Cmd    command mask (use symbolic macros)</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *</span>
<span class="cm"> *    None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_RTCmd</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Cmd</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* output command to CCAR in bits &lt;15..11&gt; */</span>
	<span class="cm">/* preserve bits &lt;10..7&gt;, bits &lt;6..0&gt; must be zero */</span>

	<span class="n">outw</span><span class="p">(</span> <span class="n">Cmd</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">loopback_bits</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>

	<span class="cm">/* Read to flush write to CCAR */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
		<span class="n">inw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of usc_RTCmd() */</span>

<span class="cm">/*</span>
<span class="cm"> * usc_DmaCmd()</span>
<span class="cm"> *</span>
<span class="cm"> *    Issue a DMA command to the DMA Command/Address Register (DCAR).</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *    info   pointer to device information structure</span>
<span class="cm"> *    Cmd    DMA command mask (usc_DmaCmd_XX Macros)</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *</span>
<span class="cm"> *       None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_DmaCmd</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">Cmd</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* write command mask to DCAR */</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">Cmd</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mbre_bit</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>

	<span class="cm">/* Read to flush write to DCAR */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
		<span class="n">inw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of usc_DmaCmd() */</span>

<span class="cm">/*</span>
<span class="cm"> * usc_OutDmaReg()</span>
<span class="cm"> *</span>
<span class="cm"> *    Write a 16-bit value to a USC DMA register</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *    info      pointer to device info structure</span>
<span class="cm"> *    RegAddr   register address (number) for write</span>
<span class="cm"> *    RegValue  16-bit value to write to register</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *</span>
<span class="cm"> *    None</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_OutDmaReg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegAddr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegValue</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Note: The DCAR is located at the adapter base address */</span>
	<span class="cm">/* Note: must preserve state of BIT8 in DCAR */</span>

	<span class="n">outw</span><span class="p">(</span> <span class="n">RegAddr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mbre_bit</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">RegValue</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>

	<span class="cm">/* Read to flush write to DCAR */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
		<span class="n">inw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of usc_OutDmaReg() */</span>
 
<span class="cm">/*</span>
<span class="cm"> * usc_InDmaReg()</span>
<span class="cm"> *</span>
<span class="cm"> *    Read a 16-bit value from a DMA register</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *    info     pointer to device info structure</span>
<span class="cm"> *    RegAddr  register address (number) to read from</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *</span>
<span class="cm"> *    The 16-bit value read from register</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">usc_InDmaReg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegAddr</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Note: The DCAR is located at the adapter base address */</span>
	<span class="cm">/* Note: must preserve state of BIT8 in DCAR */</span>

	<span class="n">outw</span><span class="p">(</span> <span class="n">RegAddr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">mbre_bit</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of usc_InDmaReg() */</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * usc_OutReg()</span>
<span class="cm"> *</span>
<span class="cm"> *    Write a 16-bit value to a USC serial channel register </span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *    info      pointer to device info structure</span>
<span class="cm"> *    RegAddr   register address (number) to write to</span>
<span class="cm"> *    RegValue  16-bit value to write to register</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *</span>
<span class="cm"> *    None</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_OutReg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegAddr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegValue</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">RegAddr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">loopback_bits</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">RegValue</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>

	<span class="cm">/* Read to flush write to CCAR */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
		<span class="n">inw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of usc_OutReg() */</span>

<span class="cm">/*</span>
<span class="cm"> * usc_InReg()</span>
<span class="cm"> *</span>
<span class="cm"> *    Reads a 16-bit value from a USC serial channel register</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *    info       pointer to device extension</span>
<span class="cm"> *    RegAddr    register address (number) to read from</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:</span>
<span class="cm"> *</span>
<span class="cm"> *    16-bit value read from register</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">usc_InReg</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u16</span> <span class="n">RegAddr</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">RegAddr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">loopback_bits</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
	<span class="k">return</span> <span class="n">inw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of usc_InReg() */</span>

<span class="cm">/* usc_set_sdlc_mode()</span>
<span class="cm"> *</span>
<span class="cm"> *    Set up the adapter for SDLC DMA communications.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info    pointer to device instance data</span>
<span class="cm"> * Return Value: 	NONE</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_set_sdlc_mode</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">RegValue</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">PreSL1660</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * determine if the IUSC on the adapter is pre-SL1660. If</span>
<span class="cm">	 * not, take advantage of the UnderWait feature of more</span>
<span class="cm">	 * modern chips. If an underrun occurs and this bit is set,</span>
<span class="cm">	 * the transmitter will idle the programmed idle pattern</span>
<span class="cm">	 * until the driver has time to service the underrun. Otherwise,</span>
<span class="cm">	 * the dma controller may get the cycles previously requested</span>
<span class="cm">	 * and begin transmitting queued tx data.</span>
<span class="cm">	 */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">TMCR</span><span class="p">,</span><span class="mh">0x1f</span><span class="p">);</span>
	<span class="n">RegValue</span><span class="o">=</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">TMDR</span><span class="p">);</span>
	<span class="n">PreSL1660</span> <span class="o">=</span> <span class="p">(</span><span class="n">RegValue</span> <span class="o">==</span> <span class="n">IUSC_PRE_SL1660</span><span class="p">);</span>

 	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_HDLC_LOOPMODE</span> <span class="p">)</span>
 	<span class="p">{</span>
 	   <span class="cm">/*</span>
<span class="cm"> 	   ** Channel Mode Register (CMR)</span>
<span class="cm"> 	   **</span>
<span class="cm"> 	   ** &lt;15..14&gt;    10    Tx Sub Modes, Send Flag on Underrun</span>
<span class="cm"> 	   ** &lt;13&gt;        0     0 = Transmit Disabled (initially)</span>
<span class="cm"> 	   ** &lt;12&gt;        0     1 = Consecutive Idles share common 0</span>
<span class="cm"> 	   ** &lt;11..8&gt;     1110  Transmitter Mode = HDLC/SDLC Loop</span>
<span class="cm"> 	   ** &lt;7..4&gt;      0000  Rx Sub Modes, addr/ctrl field handling</span>
<span class="cm"> 	   ** &lt;3..0&gt;      0110  Receiver Mode = HDLC/SDLC</span>
<span class="cm"> 	   **</span>
<span class="cm"> 	   ** 1000 1110 0000 0110 = 0x8e06</span>
<span class="cm"> 	   */</span>
 	   <span class="n">RegValue</span> <span class="o">=</span> <span class="mh">0x8e06</span><span class="p">;</span>
 
 	   <span class="cm">/*--------------------------------------------------</span>
<span class="cm"> 	    * ignore user options for UnderRun Actions and</span>
<span class="cm"> 	    * preambles</span>
<span class="cm"> 	    *--------------------------------------------------*/</span>
 	<span class="p">}</span>
 	<span class="k">else</span>
 	<span class="p">{</span>	
		<span class="cm">/* Channel mode Register (CMR)</span>
<span class="cm">		 *</span>
<span class="cm">		 * &lt;15..14&gt;  00    Tx Sub modes, Underrun Action</span>
<span class="cm">		 * &lt;13&gt;      0     1 = Send Preamble before opening flag</span>
<span class="cm">		 * &lt;12&gt;      0     1 = Consecutive Idles share common 0</span>
<span class="cm">		 * &lt;11..8&gt;   0110  Transmitter mode = HDLC/SDLC</span>
<span class="cm">		 * &lt;7..4&gt;    0000  Rx Sub modes, addr/ctrl field handling</span>
<span class="cm">		 * &lt;3..0&gt;    0110  Receiver mode = HDLC/SDLC</span>
<span class="cm">		 *</span>
<span class="cm">		 * 0000 0110 0000 0110 = 0x0606</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RegValue</span> <span class="o">=</span> <span class="mh">0x0001</span><span class="p">;</span>		<span class="cm">/* Set Receive mode = external sync */</span>

			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">,</span>		<span class="cm">/* Set IOCR DCD is RxSync Detect Input */</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">BIT13</span><span class="o">|</span><span class="n">BIT12</span><span class="p">))</span> <span class="o">|</span> <span class="n">BIT12</span><span class="p">));</span>

			<span class="cm">/*</span>
<span class="cm">			 * TxSubMode:</span>
<span class="cm">			 * 	CMR &lt;15&gt;		0	Don&#39;t send CRC on Tx Underrun</span>
<span class="cm">			 * 	CMR &lt;14&gt;		x	undefined</span>
<span class="cm">			 * 	CMR &lt;13&gt;		0	Send preamble before openning sync</span>
<span class="cm">			 * 	CMR &lt;12&gt;		0	Send 8-bit syncs, 1=send Syncs per TxLength</span>
<span class="cm">			 *</span>
<span class="cm">			 * TxMode:</span>
<span class="cm">			 * 	CMR &lt;11-8)	0100	MonoSync</span>
<span class="cm">			 *</span>
<span class="cm">			 * 	0x00 0100 xxxx xxxx  04xx</span>
<span class="cm">			 */</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0400</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>

		<span class="n">RegValue</span> <span class="o">=</span> <span class="mh">0x0606</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_UNDERRUN_ABORT15</span> <span class="p">)</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT14</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_UNDERRUN_FLAG</span> <span class="p">)</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_UNDERRUN_CRC</span> <span class="p">)</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span> <span class="o">+</span> <span class="n">BIT14</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">preamble</span> <span class="o">!=</span> <span class="n">HDLC_PREAMBLE_PATTERN_NONE</span> <span class="p">)</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT13</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_SHARE_ZERO</span><span class="p">)</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT12</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">addr_filter</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* set up receive address filtering */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RSR</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">addr_filter</span> <span class="p">);</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CMR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span> <span class="o">=</span> <span class="n">RegValue</span><span class="p">;</span>

	<span class="cm">/* Receiver mode Register (RMR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..13&gt;  000    encoding</span>
<span class="cm">	 * &lt;12..11&gt;  00     FCS = 16bit CRC CCITT (x15 + x12 + x5 + 1)</span>
<span class="cm">	 * &lt;10&gt;      1      1 = Set CRC to all 1s (use for SDLC/HDLC)</span>
<span class="cm">	 * &lt;9&gt;       0      1 = Include Receive chars in CRC</span>
<span class="cm">	 * &lt;8&gt;       1      1 = Use Abort/PE bit as abort indicator</span>
<span class="cm">	 * &lt;7..6&gt;    00     Even parity</span>
<span class="cm">	 * &lt;5&gt;       0      parity disabled</span>
<span class="cm">	 * &lt;4..2&gt;    000    Receive Char Length = 8 bits</span>
<span class="cm">	 * &lt;1..0&gt;    00     Disable Receiver</span>
<span class="cm">	 *</span>
<span class="cm">	 * 0000 0101 0000 0000 = 0x0500</span>
<span class="cm">	 */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="mh">0x0500</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">encoding</span> <span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZB</span>:               <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT13</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZI_MARK</span>:          <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT14</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZI_SPACE</span>:	       <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT14</span> <span class="o">+</span> <span class="n">BIT13</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_MARK</span>:       <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_SPACE</span>:      <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span> <span class="o">+</span> <span class="n">BIT13</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_LEVEL</span>:      <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span> <span class="o">+</span> <span class="n">BIT14</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_DIFF_BIPHASE_LEVEL</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span> <span class="o">+</span> <span class="n">BIT14</span> <span class="o">+</span> <span class="n">BIT13</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">&amp;</span> <span class="n">HDLC_CRC_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HDLC_CRC_16_CCITT</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT9</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">&amp;</span> <span class="n">HDLC_CRC_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HDLC_CRC_32_CCITT</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="p">(</span> <span class="n">BIT12</span> <span class="o">|</span> <span class="n">BIT10</span> <span class="o">|</span> <span class="n">BIT9</span> <span class="p">);</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RMR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>

	<span class="cm">/* Set the Receive count Limit Register (RCLR) to 0xffff. */</span>
	<span class="cm">/* When an opening flag of an SDLC frame is recognized the */</span>
	<span class="cm">/* Receive Character count (RCC) is loaded with the value in */</span>
	<span class="cm">/* RCLR. The RCC is decremented for each received byte.  The */</span>
	<span class="cm">/* value of RCC is stored after the closing flag of the frame */</span>
	<span class="cm">/* allowing the frame size to be computed. */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCLR</span><span class="p">,</span> <span class="n">RCLRVALUE</span> <span class="p">);</span>

	<span class="n">usc_RCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCmd_SelectRicrdma_level</span> <span class="p">);</span>

	<span class="cm">/* Receive Interrupt Control Register (RICR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..8&gt;	?	RxFIFO DMA Request Level</span>
<span class="cm">	 * &lt;7&gt;		0	Exited Hunt IA (Interrupt Arm)</span>
<span class="cm">	 * &lt;6&gt;		0	Idle Received IA</span>
<span class="cm">	 * &lt;5&gt;		0	Break/Abort IA</span>
<span class="cm">	 * &lt;4&gt;		0	Rx Bound IA</span>
<span class="cm">	 * &lt;3&gt;		1	Queued status reflects oldest 2 bytes in FIFO</span>
<span class="cm">	 * &lt;2&gt;		0	Abort/PE IA</span>
<span class="cm">	 * &lt;1&gt;		1	Rx Overrun IA</span>
<span class="cm">	 * &lt;0&gt;		0	Select TC0 value for readback</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0000 0000 0000 1000 = 0x000a</span>
<span class="cm">	 */</span>

	<span class="cm">/* Carry over the Exit Hunt and Idle Received bits */</span>
	<span class="cm">/* in case they have been armed by usc_ArmEvents.   */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RICR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="mh">0x030a</span> <span class="o">|</span> <span class="n">RegValue</span><span class="p">)</span> <span class="p">);</span>
	<span class="k">else</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="mh">0x140a</span> <span class="o">|</span> <span class="n">RegValue</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* Unlatch all Rx status bits and clear Rx status IRQ Pending */</span>

	<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RXSTATUS_ALL</span> <span class="p">);</span>
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>

	<span class="cm">/* Transmit mode Register (TMR)</span>
<span class="cm">	 *	</span>
<span class="cm">	 * &lt;15..13&gt;	000	encoding</span>
<span class="cm">	 * &lt;12..11&gt;	00	FCS = 16bit CRC CCITT (x15 + x12 + x5 + 1)</span>
<span class="cm">	 * &lt;10&gt;		1	1 = Start CRC as all 1s (use for SDLC/HDLC)</span>
<span class="cm">	 * &lt;9&gt;		0	1 = Tx CRC Enabled</span>
<span class="cm">	 * &lt;8&gt;		0	1 = Append CRC to end of transmit frame</span>
<span class="cm">	 * &lt;7..6&gt;	00	Transmit parity Even</span>
<span class="cm">	 * &lt;5&gt;		0	Transmit parity Disabled</span>
<span class="cm">	 * &lt;4..2&gt;	000	Tx Char Length = 8 bits</span>
<span class="cm">	 * &lt;1..0&gt;	00	Disable Transmitter</span>
<span class="cm">	 *</span>
<span class="cm">	 * 	0000 0100 0000 0000 = 0x0400</span>
<span class="cm">	 */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="mh">0x0400</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">encoding</span> <span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZB</span>:               <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT13</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZI_MARK</span>:          <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT14</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZI_SPACE</span>:         <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT14</span> <span class="o">+</span> <span class="n">BIT13</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_MARK</span>:       <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_SPACE</span>:      <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span> <span class="o">+</span> <span class="n">BIT13</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_LEVEL</span>:      <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span> <span class="o">+</span> <span class="n">BIT14</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_ENCODING_DIFF_BIPHASE_LEVEL</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT15</span> <span class="o">+</span> <span class="n">BIT14</span> <span class="o">+</span> <span class="n">BIT13</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">&amp;</span> <span class="n">HDLC_CRC_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HDLC_CRC_16_CCITT</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT9</span> <span class="o">+</span> <span class="n">BIT8</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">&amp;</span> <span class="n">HDLC_CRC_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HDLC_CRC_32_CCITT</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="p">(</span> <span class="n">BIT12</span> <span class="o">|</span> <span class="n">BIT10</span> <span class="o">|</span> <span class="n">BIT9</span> <span class="o">|</span> <span class="n">BIT8</span><span class="p">);</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TMR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>

	<span class="n">usc_set_txidle</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>


	<span class="n">usc_TCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCmd_SelectTicrdma_level</span> <span class="p">);</span>

	<span class="cm">/* Transmit Interrupt Control Register (TICR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..8&gt;	?	Transmit FIFO DMA Level</span>
<span class="cm">	 * &lt;7&gt;		0	Present IA (Interrupt Arm)</span>
<span class="cm">	 * &lt;6&gt;		0	Idle Sent IA</span>
<span class="cm">	 * &lt;5&gt;		1	Abort Sent IA</span>
<span class="cm">	 * &lt;4&gt;		1	EOF/EOM Sent IA</span>
<span class="cm">	 * &lt;3&gt;		0	CRC Sent IA</span>
<span class="cm">	 * &lt;2&gt;		1	1 = Wait for SW Trigger to Start Frame</span>
<span class="cm">	 * &lt;1&gt;		1	Tx Underrun IA</span>
<span class="cm">	 * &lt;0&gt;		0	TC0 constant on read back</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0000 0000 0011 0110 = 0x0036</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TICR</span><span class="p">,</span> <span class="mh">0x0736</span> <span class="p">);</span>
	<span class="k">else</span>								
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TICR</span><span class="p">,</span> <span class="mh">0x1436</span> <span class="p">);</span>

	<span class="n">usc_UnlatchTxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TXSTATUS_ALL</span> <span class="p">);</span>
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	** Transmit Command/Status Register (TCSR)</span>
<span class="cm">	**</span>
<span class="cm">	** &lt;15..12&gt;	0000	TCmd</span>
<span class="cm">	** &lt;11&gt; 	0/1	UnderWait</span>
<span class="cm">	** &lt;10..08&gt;	000	TxIdle</span>
<span class="cm">	** &lt;7&gt;		x	PreSent</span>
<span class="cm">	** &lt;6&gt;         	x	IdleSent</span>
<span class="cm">	** &lt;5&gt;         	x	AbortSent</span>
<span class="cm">	** &lt;4&gt;         	x	EOF/EOM Sent</span>
<span class="cm">	** &lt;3&gt;         	x	CRC Sent</span>
<span class="cm">	** &lt;2&gt;         	x	All Sent</span>
<span class="cm">	** &lt;1&gt;         	x	TxUnder</span>
<span class="cm">	** &lt;0&gt;         	x	TxEmpty</span>
<span class="cm">	** </span>
<span class="cm">	** 0000 0000 0000 0000 = 0x0000</span>
<span class="cm">	*/</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcsr_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">PreSL1660</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcsr_value</span> <span class="o">|=</span> <span class="n">TCSR_UNDERWAIT</span><span class="p">;</span>
		
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCSR</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tcsr_value</span> <span class="p">);</span>

	<span class="cm">/* Clock mode Control Register (CMCR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	00	counter 1 Source = Disabled</span>
<span class="cm">	 * &lt;13..12&gt; 	00	counter 0 Source = Disabled</span>
<span class="cm">	 * &lt;11..10&gt; 	11	BRG1 Input is TxC Pin</span>
<span class="cm">	 * &lt;9..8&gt;	11	BRG0 Input is TxC Pin</span>
<span class="cm">	 * &lt;7..6&gt;	01	DPLL Input is BRG1 Output</span>
<span class="cm">	 * &lt;5..3&gt;	XXX	TxCLK comes from Port 0</span>
<span class="cm">	 * &lt;2..0&gt;   	XXX	RxCLK comes from Port 1</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0000 1111 0111 0111 = 0x0f77</span>
<span class="cm">	 */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="mh">0x0f40</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_RXC_DPLL</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0003</span><span class="p">;</span>	<span class="cm">/* RxCLK from DPLL */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_RXC_BRG</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0004</span><span class="p">;</span>	<span class="cm">/* RxCLK from BRG0 */</span>
 	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_RXC_TXCPIN</span><span class="p">)</span>
 		<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0006</span><span class="p">;</span>	<span class="cm">/* RxCLK from TXC Input */</span>
	<span class="k">else</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0007</span><span class="p">;</span>	<span class="cm">/* RxCLK from Port1 */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_TXC_DPLL</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0018</span><span class="p">;</span>	<span class="cm">/* TxCLK from DPLL */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_TXC_BRG</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0020</span><span class="p">;</span>	<span class="cm">/* TxCLK from BRG0 */</span>
 	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_TXC_RXCPIN</span><span class="p">)</span>
 		<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0038</span><span class="p">;</span>	<span class="cm">/* RxCLK from TXC Input */</span>
	<span class="k">else</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="mh">0x0030</span><span class="p">;</span>	<span class="cm">/* TxCLK from Port0 */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CMCR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>


	<span class="cm">/* Hardware Configuration Register (HCR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	00	CTR0 Divisor:00=32,01=16,10=8,11=4</span>
<span class="cm">	 * &lt;13&gt;		0	CTR1DSel:0=CTR0Div determines CTR0Div</span>
<span class="cm">	 * &lt;12&gt;		0	CVOK:0=report code violation in biphase</span>
<span class="cm">	 * &lt;11..10&gt;	00	DPLL Divisor:00=32,01=16,10=8,11=4</span>
<span class="cm">	 * &lt;9..8&gt;	XX	DPLL mode:00=disable,01=NRZ,10=Biphase,11=Biphase Level</span>
<span class="cm">	 * &lt;7..6&gt;	00	reserved</span>
<span class="cm">	 * &lt;5&gt;		0	BRG1 mode:0=continuous,1=single cycle</span>
<span class="cm">	 * &lt;4&gt;		X	BRG1 Enable</span>
<span class="cm">	 * &lt;3..2&gt;	00	reserved</span>
<span class="cm">	 * &lt;1&gt;		0	BRG0 mode:0=continuous,1=single cycle</span>
<span class="cm">	 * &lt;0&gt;		0	BRG0 Enable</span>
<span class="cm">	 */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HDLC_FLAG_RXC_DPLL</span> <span class="o">+</span> <span class="n">HDLC_FLAG_TXC_DPLL</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">XtalSpeed</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">DpllDivisor</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">Tc</span><span class="p">;</span>

		<span class="cm">/*  DPLL is enabled. Use BRG1 to provide continuous reference clock  */</span>
		<span class="cm">/*  for DPLL. DPLL mode in HCR is dependent on the encoding used. */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
			<span class="n">XtalSpeed</span> <span class="o">=</span> <span class="mi">11059200</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">XtalSpeed</span> <span class="o">=</span> <span class="mi">14745600</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_DPLL_DIV16</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">DpllDivisor</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT10</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_DPLL_DIV8</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">DpllDivisor</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT11</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">DpllDivisor</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

		<span class="cm">/*  Tc = (Xtal/Speed) - 1 */</span>
		<span class="cm">/*  If twice the remainder of (Xtal/Speed) is greater than Speed */</span>
		<span class="cm">/*  then rounding up gives a more precise time constant. Instead */</span>
		<span class="cm">/*  of rounding up and then subtracting 1 we just don&#39;t subtract */</span>
		<span class="cm">/*  the one in this case. */</span>

 		<span class="cm">/*--------------------------------------------------</span>
<span class="cm"> 		 * ejz: for DPLL mode, application should use the</span>
<span class="cm"> 		 * same clock speed as the partner system, even </span>
<span class="cm"> 		 * though clocking is derived from the input RxData.</span>
<span class="cm"> 		 * In case the user uses a 0 for the clock speed,</span>
<span class="cm"> 		 * default to 0xffffffff and don&#39;t try to divide by</span>
<span class="cm"> 		 * zero</span>
<span class="cm"> 		 *--------------------------------------------------*/</span>
 		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span> <span class="p">)</span>
 		<span class="p">{</span>
			<span class="n">Tc</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">XtalSpeed</span><span class="o">/</span><span class="n">DpllDivisor</span><span class="p">)</span><span class="o">/</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">((((</span><span class="n">XtalSpeed</span><span class="o">/</span><span class="n">DpllDivisor</span><span class="p">)</span> <span class="o">%</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
			       <span class="o">/</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span><span class="p">)</span> <span class="p">)</span>
				<span class="n">Tc</span><span class="o">--</span><span class="p">;</span>
 		<span class="p">}</span>
 		<span class="k">else</span>
 			<span class="n">Tc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 				  

		<span class="cm">/* Write 16-bit Time Constant for BRG1 */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC1R</span><span class="p">,</span> <span class="n">Tc</span> <span class="p">);</span>

		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT4</span><span class="p">;</span>		<span class="cm">/* enable BRG1 */</span>

		<span class="k">switch</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">encoding</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZ</span>:
		<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZB</span>:
		<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZI_MARK</span>:
		<span class="k">case</span> <span class="n">HDLC_ENCODING_NRZI_SPACE</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT8</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_MARK</span>:
		<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_SPACE</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT9</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HDLC_ENCODING_BIPHASE_LEVEL</span>:
		<span class="k">case</span> <span class="n">HDLC_ENCODING_DIFF_BIPHASE_LEVEL</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT9</span> <span class="o">+</span> <span class="n">BIT8</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>


	<span class="cm">/* Channel Control/status Register (CCSR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15&gt;		X	RCC FIFO Overflow status (RO)</span>
<span class="cm">	 * &lt;14&gt;		X	RCC FIFO Not Empty status (RO)</span>
<span class="cm">	 * &lt;13&gt;		0	1 = Clear RCC FIFO (WO)</span>
<span class="cm">	 * &lt;12&gt;		X	DPLL Sync (RW)</span>
<span class="cm">	 * &lt;11&gt;		X	DPLL 2 Missed Clocks status (RO)</span>
<span class="cm">	 * &lt;10&gt;		X	DPLL 1 Missed Clock status (RO)</span>
<span class="cm">	 * &lt;9..8&gt;	00	DPLL Resync on rising and falling edges (RW)</span>
<span class="cm">	 * &lt;7&gt;		X	SDLC Loop On status (RO)</span>
<span class="cm">	 * &lt;6&gt;		X	SDLC Loop Send status (RO)</span>
<span class="cm">	 * &lt;5&gt;		1	Bypass counters for TxClk and RxClk (RW)</span>
<span class="cm">	 * &lt;4..2&gt;   	000	Last Char of SDLC frame has 8 bits (RW)</span>
<span class="cm">	 * &lt;1..0&gt;   	00	reserved</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0000 0000 0010 0000 = 0x0020</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCSR</span><span class="p">,</span> <span class="mh">0x1020</span> <span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_AUTO_CTS</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">SICR</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">SICR</span><span class="p">)</span> <span class="o">|</span> <span class="n">SICR_CTS_INACTIVE</span><span class="p">)</span> <span class="p">);</span>
	<span class="p">}</span>
	

	<span class="cm">/* enable Master Interrupt Enable bit (MIE) */</span>
	<span class="n">usc_EnableMasterIrqBit</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_STATUS</span> <span class="o">+</span> <span class="n">RECEIVE_DATA</span> <span class="o">+</span>
				<span class="n">TRANSMIT_STATUS</span> <span class="o">+</span> <span class="n">TRANSMIT_DATA</span> <span class="o">+</span> <span class="n">MISC</span><span class="p">);</span>

	<span class="cm">/* arm RCC underflow interrupt */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">SICR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">SICR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT3</span><span class="p">));</span>
	<span class="n">usc_EnableInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">MISC</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mbre_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span> 			<span class="cm">/* clear Master Bus Enable (DCAR) */</span>
	<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_ResetAllChannels</span> <span class="p">);</span>	<span class="cm">/* disable both DMA channels */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mbre_bit</span> <span class="o">=</span> <span class="n">BIT8</span><span class="p">;</span>
	<span class="n">outw</span><span class="p">(</span> <span class="n">BIT8</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>			<span class="cm">/* set Master Bus Enable (DCAR) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_ISA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable DMAEN (Port 7, Bit 14) */</span>
		<span class="cm">/* This connects the DMA request signal to the ISA bus */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT14</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* DMA Control Register (DCR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	10	Priority mode = Alternating Tx/Rx</span>
<span class="cm">	 *		01	Rx has priority</span>
<span class="cm">	 *		00	Tx has priority</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;13&gt;		1	Enable Priority Preempt per DCR&lt;15..14&gt;</span>
<span class="cm">	 *			(WARNING DCR&lt;11..10&gt; must be 00 when this is 1)</span>
<span class="cm">	 *		0	Choose activate channel per DCR&lt;11..10&gt;</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;12&gt;		0	Little Endian for Array/List</span>
<span class="cm">	 * &lt;11..10&gt;	00	Both Channels can use each bus grant</span>
<span class="cm">	 * &lt;9..6&gt;	0000	reserved</span>
<span class="cm">	 * &lt;5&gt;		0	7 CLK - Minimum Bus Re-request Interval</span>
<span class="cm">	 * &lt;4&gt;		0	1 = drive D/C and S/D pins</span>
<span class="cm">	 * &lt;3&gt;		1	1 = Add one wait state to all DMA cycles.</span>
<span class="cm">	 * &lt;2&gt;		0	1 = Strobe /UAS on every transfer.</span>
<span class="cm">	 * &lt;1..0&gt;	11	Addr incrementing only affects LS24 bits</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0110 0000 0000 1011 = 0x600b</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* PCI adapter does not need DMA wait state */</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DCR</span><span class="p">,</span> <span class="mh">0xa00b</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DCR</span><span class="p">,</span> <span class="mh">0x800b</span> <span class="p">);</span>


	<span class="cm">/* Receive DMA mode Register (RDMR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	11	DMA mode = Linked List Buffer mode</span>
<span class="cm">	 * &lt;13&gt;		1	RSBinA/L = store Rx status Block in Arrary/List entry</span>
<span class="cm">	 * &lt;12&gt;		1	Clear count of List Entry after fetching</span>
<span class="cm">	 * &lt;11..10&gt;	00	Address mode = Increment</span>
<span class="cm">	 * &lt;9&gt;		1	Terminate Buffer on RxBound</span>
<span class="cm">	 * &lt;8&gt;		0	Bus Width = 16bits</span>
<span class="cm">	 * &lt;7..0&gt;	?	status Bits (write as 0s)</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1111 0010 0000 0000 = 0xf200</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDMR</span><span class="p">,</span> <span class="mh">0xf200</span> <span class="p">);</span>


	<span class="cm">/* Transmit DMA mode Register (TDMR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	11	DMA mode = Linked List Buffer mode</span>
<span class="cm">	 * &lt;13&gt;		1	TCBinA/L = fetch Tx Control Block from List entry</span>
<span class="cm">	 * &lt;12&gt;		1	Clear count of List Entry after fetching</span>
<span class="cm">	 * &lt;11..10&gt;	00	Address mode = Increment</span>
<span class="cm">	 * &lt;9&gt;		1	Terminate Buffer on end of frame</span>
<span class="cm">	 * &lt;8&gt;		0	Bus Width = 16bits</span>
<span class="cm">	 * &lt;7..0&gt;	?	status Bits (Read Only so write as 0)</span>
<span class="cm">	 *</span>
<span class="cm">	 *	1111 0010 0000 0000 = 0xf200</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TDMR</span><span class="p">,</span> <span class="mh">0xf200</span> <span class="p">);</span>


	<span class="cm">/* DMA Interrupt Control Register (DICR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15&gt;		1	DMA Interrupt Enable</span>
<span class="cm">	 * &lt;14&gt;		0	1 = Disable IEO from USC</span>
<span class="cm">	 * &lt;13&gt;		0	1 = Don&#39;t provide vector during IntAck</span>
<span class="cm">	 * &lt;12&gt;		1	1 = Include status in Vector</span>
<span class="cm">	 * &lt;10..2&gt;	0	reserved, Must be 0s</span>
<span class="cm">	 * &lt;1&gt;		0	1 = Rx DMA Interrupt Enabled</span>
<span class="cm">	 * &lt;0&gt;		0	1 = Tx DMA Interrupt Enabled</span>
<span class="cm">	 *</span>
<span class="cm">	 *	1001 0000 0000 0000 = 0x9000</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DICR</span><span class="p">,</span> <span class="mh">0x9000</span> <span class="p">);</span>

	<span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDMR</span> <span class="p">);</span>		<span class="cm">/* clear pending receive DMA IRQ bits */</span>
	<span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TDMR</span> <span class="p">);</span>		<span class="cm">/* clear pending transmit DMA IRQ bits */</span>
	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CDIR</span><span class="p">,</span> <span class="mh">0x0303</span> <span class="p">);</span>	<span class="cm">/* clear IUS and Pending for Tx and Rx */</span>

	<span class="cm">/* Channel Control Register (CCR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	10	Use 32-bit Tx Control Blocks (TCBs)</span>
<span class="cm">	 * &lt;13&gt;		0	Trigger Tx on SW Command Disabled</span>
<span class="cm">	 * &lt;12&gt;		0	Flag Preamble Disabled</span>
<span class="cm">	 * &lt;11..10&gt;	00	Preamble Length</span>
<span class="cm">	 * &lt;9..8&gt;	00	Preamble Pattern</span>
<span class="cm">	 * &lt;7..6&gt;	10	Use 32-bit Rx status Blocks (RSBs)</span>
<span class="cm">	 * &lt;5&gt;		0	Trigger Rx on SW Command Disabled</span>
<span class="cm">	 * &lt;4..0&gt;	0	reserved</span>
<span class="cm">	 *</span>
<span class="cm">	 *	1000 0000 1000 0000 = 0x8080</span>
<span class="cm">	 */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="mh">0x8080</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">preamble_length</span> <span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HDLC_PREAMBLE_LENGTH_16BITS</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT10</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_PREAMBLE_LENGTH_32BITS</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT11</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_PREAMBLE_LENGTH_64BITS</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT11</span> <span class="o">+</span> <span class="n">BIT10</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">preamble</span> <span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HDLC_PREAMBLE_PATTERN_FLAGS</span>: <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT8</span> <span class="o">+</span> <span class="n">BIT12</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_PREAMBLE_PATTERN_ONES</span>:  <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT8</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_PREAMBLE_PATTERN_10</span>:    <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT9</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_PREAMBLE_PATTERN_01</span>:    <span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT9</span> <span class="o">+</span> <span class="n">BIT8</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * Burst/Dwell Control Register</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..8&gt;	0x20	Maximum number of transfers per bus grant</span>
<span class="cm">	 * &lt;7..0&gt;	0x00	Maximum number of clock cycles per bus grant</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* don&#39;t limit bus occupancy on PCI adapter */</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">BDCR</span><span class="p">,</span> <span class="mh">0x0000</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">BDCR</span><span class="p">,</span> <span class="mh">0x2000</span> <span class="p">);</span>

	<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">usc_stop_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	
<span class="p">}</span>	<span class="cm">/* end of usc_set_sdlc_mode() */</span>

<span class="cm">/* usc_enable_loopback()</span>
<span class="cm"> *</span>
<span class="cm"> * Set the 16C32 for internal loopback mode.</span>
<span class="cm"> * The TxCLK and RxCLK signals are generated from the BRG0 and</span>
<span class="cm"> * the TxD is looped back to the RxD internally.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> *			enable	1 = enable loopback, 0 = disable</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_enable_loopback</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* blank external TXD output */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">IOCR</span><span class="p">,</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">IOCR</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">BIT7</span><span class="o">+</span><span class="n">BIT6</span><span class="p">));</span>
	
		<span class="cm">/* Clock mode Control Register (CMCR)</span>
<span class="cm">		 *</span>
<span class="cm">		 * &lt;15..14&gt;	00	counter 1 Disabled</span>
<span class="cm">		 * &lt;13..12&gt; 	00	counter 0 Disabled</span>
<span class="cm">		 * &lt;11..10&gt; 	11	BRG1 Input is TxC Pin</span>
<span class="cm">		 * &lt;9..8&gt;	11	BRG0 Input is TxC Pin</span>
<span class="cm">		 * &lt;7..6&gt;	01	DPLL Input is BRG1 Output</span>
<span class="cm">		 * &lt;5..3&gt;	100	TxCLK comes from BRG0</span>
<span class="cm">		 * &lt;2..0&gt;   	100	RxCLK comes from BRG0</span>
<span class="cm">		 *</span>
<span class="cm">		 * 0000 1111 0110 0100 = 0x0f64</span>
<span class="cm">		 */</span>

		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CMCR</span><span class="p">,</span> <span class="mh">0x0f64</span> <span class="p">);</span>

		<span class="cm">/* Write 16-bit Time Constant for BRG0 */</span>
		<span class="cm">/* use clock speed if available, otherwise use 8 for diagnostics */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span><span class="p">)</span>
				<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="mi">11059200</span><span class="o">/</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="mi">14745600</span><span class="o">/</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="mi">8</span><span class="p">);</span>

		<span class="cm">/* Hardware Configuration Register (HCR) Clear Bit 1, BRG0</span>
<span class="cm">		   mode = Continuous Set Bit 0 to enable BRG0.  */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT1</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT0</span><span class="p">)</span> <span class="p">);</span>

		<span class="cm">/* Input/Output Control Reg, &lt;2..0&gt; = 100, Drive RxC pin with BRG0 */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0004</span><span class="p">));</span>

		<span class="cm">/* set Internal Data loopback mode */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopback_bits</span> <span class="o">=</span> <span class="mh">0x300</span><span class="p">;</span>
		<span class="n">outw</span><span class="p">(</span> <span class="mh">0x0300</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* enable external TXD output */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">IOCR</span><span class="p">,</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">IOCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">BIT7</span><span class="o">+</span><span class="n">BIT6</span><span class="p">));</span>
	
		<span class="cm">/* clear Internal Data loopback mode */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopback_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
	<span class="p">}</span>
	
<span class="p">}</span>	<span class="cm">/* end of usc_enable_loopback() */</span>

<span class="cm">/* usc_enable_aux_clock()</span>
<span class="cm"> *</span>
<span class="cm"> * Enabled the AUX clock output at the specified frequency.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	info		pointer to device extension</span>
<span class="cm"> *	data_rate	data rate of clock in bits per second</span>
<span class="cm"> *			A data rate of 0 disables the AUX clock.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_enable_aux_clock</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data_rate</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">XtalSpeed</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">Tc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">data_rate</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
			<span class="n">XtalSpeed</span> <span class="o">=</span> <span class="mi">11059200</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">XtalSpeed</span> <span class="o">=</span> <span class="mi">14745600</span><span class="p">;</span>


		<span class="cm">/* Tc = (Xtal/Speed) - 1 */</span>
		<span class="cm">/* If twice the remainder of (Xtal/Speed) is greater than Speed */</span>
		<span class="cm">/* then rounding up gives a more precise time constant. Instead */</span>
		<span class="cm">/* of rounding up and then subtracting 1 we just don&#39;t subtract */</span>
		<span class="cm">/* the one in this case. */</span>


		<span class="n">Tc</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">XtalSpeed</span><span class="o">/</span><span class="n">data_rate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(((</span><span class="n">XtalSpeed</span> <span class="o">%</span> <span class="n">data_rate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">data_rate</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">Tc</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* Write 16-bit Time Constant for BRG0 */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span><span class="p">,</span> <span class="n">Tc</span> <span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Hardware Configuration Register (HCR)</span>
<span class="cm">		 * Clear Bit 1, BRG0 mode = Continuous</span>
<span class="cm">		 * Set Bit 0 to enable BRG0.</span>
<span class="cm">		 */</span>

		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT1</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT0</span><span class="p">)</span> <span class="p">);</span>

		<span class="cm">/* Input/Output Control Reg, &lt;2..0&gt; = 100, Drive RxC pin with BRG0 */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0004</span><span class="p">)</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* data rate == 0 so turn off BRG0 */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT0</span><span class="p">)</span> <span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of usc_enable_aux_clock() */</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * usc_process_rxoverrun_sync()</span>
<span class="cm"> *</span>
<span class="cm"> *		This function processes a receive overrun by resetting the</span>
<span class="cm"> *		receive DMA buffers and issuing a Purge Rx FIFO command</span>
<span class="cm"> *		to allow the receiver to continue receiving.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *</span>
<span class="cm"> *	info		pointer to device extension</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value: None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_process_rxoverrun_sync</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frame_start_index</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">start_of_frame_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">end_of_frame_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">reprogram_dma</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">buffer_list</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">phys_addr</span><span class="p">;</span>

	<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_PauseRxChannel</span> <span class="p">);</span>
	<span class="n">usc_RCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCmd_EnterHuntmode</span> <span class="p">);</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeRxFifo</span> <span class="p">);</span>

	<span class="cm">/* CurrentRxBuffer points to the 1st buffer of the next */</span>
	<span class="cm">/* possibly available receive frame. */</span>
	
	<span class="n">frame_start_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">=</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">current_rx_buffer</span><span class="p">;</span>

	<span class="cm">/* Search for an unfinished string of buffers. This means */</span>
	<span class="cm">/* that a receive frame started (at least one buffer with */</span>
	<span class="cm">/* count set to zero) but there is no terminiting buffer */</span>
	<span class="cm">/* (status set to non-zero). */</span>

	<span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">buffer_list</span><span class="p">[</span><span class="n">end_index</span><span class="p">].</span><span class="n">count</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Count field has been reset to zero by 16C32. */</span>
		<span class="cm">/* This buffer is currently in use. */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">start_of_frame_found</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">start_of_frame_found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">frame_start_index</span> <span class="o">=</span> <span class="n">end_index</span><span class="p">;</span>
			<span class="n">end_of_frame_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">buffer_list</span><span class="p">[</span><span class="n">end_index</span><span class="p">].</span><span class="n">status</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="cm">/* Status field has been set by 16C32. */</span>
			<span class="cm">/* This is the last buffer of a received frame. */</span>

			<span class="cm">/* We want to leave the buffers for this frame intact. */</span>
			<span class="cm">/* Move on to next possible frame. */</span>

			<span class="n">start_of_frame_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">end_of_frame_found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

  		<span class="cm">/* advance to next buffer entry in linked list */</span>
  		<span class="n">end_index</span><span class="o">++</span><span class="p">;</span>
  		<span class="k">if</span> <span class="p">(</span> <span class="n">end_index</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="p">)</span>
  			<span class="n">end_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">start_index</span> <span class="o">==</span> <span class="n">end_index</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="cm">/* The entire list has been searched with all Counts == 0 and */</span>
			<span class="cm">/* all Status == 0. The receive buffers are */</span>
			<span class="cm">/* completely screwed, reset all receive buffers! */</span>
			<span class="n">mgsl_reset_rx_dma_buffers</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
			<span class="n">frame_start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">start_of_frame_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">reprogram_dma</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">start_of_frame_found</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">end_of_frame_found</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* There is an unfinished string of receive DMA buffers */</span>
		<span class="cm">/* as a result of the receiver overrun. */</span>

		<span class="cm">/* Reset the buffers for the unfinished frame */</span>
		<span class="cm">/* and reprogram the receive DMA controller to start */</span>
		<span class="cm">/* at the 1st buffer of unfinished frame. */</span>

		<span class="n">start_index</span> <span class="o">=</span> <span class="n">frame_start_index</span><span class="p">;</span>

		<span class="k">do</span>
		<span class="p">{</span>
			<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">start_index</span><span class="o">++</span><span class="p">].</span><span class="n">count</span><span class="p">))</span> <span class="o">=</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>

  			<span class="cm">/* Adjust index for wrap around. */</span>
  			<span class="k">if</span> <span class="p">(</span> <span class="n">start_index</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="p">)</span>
  				<span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">start_index</span> <span class="o">!=</span> <span class="n">end_index</span> <span class="p">);</span>

		<span class="n">reprogram_dma</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">reprogram_dma</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">RXSTATUS_ALL</span><span class="p">);</span>
		<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span><span class="o">|</span><span class="n">RECEIVE_STATUS</span><span class="p">);</span>
		<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span><span class="o">|</span><span class="n">RECEIVE_STATUS</span><span class="p">);</span>
		
		<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DISABLE_UNCONDITIONAL</span><span class="p">);</span>
		
		<span class="cm">/* This empties the receive FIFO and loads the RCC with RCLR */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCSR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">CCSR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT13</span><span class="p">)</span> <span class="p">);</span>

		<span class="cm">/* program 16C32 with physical address of 1st DMA buffer entry */</span>
		<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">frame_start_index</span><span class="p">].</span><span class="n">phys_entry</span><span class="p">;</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NRARL</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">phys_addr</span> <span class="p">);</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NRARU</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">);</span>

		<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RXSTATUS_ALL</span> <span class="p">);</span>
		<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>
		<span class="n">usc_EnableInterrupts</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>

		<span class="cm">/* 1. Arm End of Buffer (EOB) Receive DMA Interrupt (BIT2 of RDIAR) */</span>
		<span class="cm">/* 2. Enable Receive DMA Interrupts (BIT1 of DICR) */</span>

		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDIAR</span><span class="p">,</span> <span class="n">BIT3</span> <span class="o">+</span> <span class="n">BIT2</span> <span class="p">);</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DICR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InDmaReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DICR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT1</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_InitRxChannel</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_AUTO_DCD</span> <span class="p">)</span>
			<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_AUTO_DCD</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_UNCONDITIONAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/* This empties the receive FIFO and loads the RCC with RCLR */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCSR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">CCSR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT13</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeRxFifo</span> <span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of usc_process_rxoverrun_sync() */</span>

<span class="cm">/* usc_stop_receiver()</span>
<span class="cm"> *</span>
<span class="cm"> *	Disable USC receiver</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_stop_receiver</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):usc_stop_receiver(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			 
	<span class="cm">/* Disable receive DMA channel. */</span>
	<span class="cm">/* This also disables receive DMA channel interrupts */</span>
	<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_ResetRxChannel</span> <span class="p">);</span>

	<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RXSTATUS_ALL</span> <span class="p">);</span>
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>
	<span class="n">usc_DisableInterrupts</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>

	<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DISABLE_UNCONDITIONAL</span><span class="p">);</span>

	<span class="cm">/* This empties the receive FIFO and loads the RCC with RCLR */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCSR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">CCSR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT13</span><span class="p">)</span> <span class="p">);</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeRxFifo</span> <span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_overflow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_rcc_underrun</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of stop_receiver() */</span>

<span class="cm">/* usc_start_receiver()</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable the USC receiver </span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_start_receiver</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phys_addr</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):usc_start_receiver(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>

	<span class="n">mgsl_reset_rx_dma_buffers</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="n">usc_stop_receiver</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCSR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">CCSR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT13</span><span class="p">)</span> <span class="p">);</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeRxFifo</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* DMA mode Transfers */</span>
		<span class="cm">/* Program the DMA controller. */</span>
		<span class="cm">/* Enable the DMA controller end of buffer interrupt. */</span>

		<span class="cm">/* program 16C32 with physical address of 1st DMA buffer entry */</span>
		<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_entry</span><span class="p">;</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NRARL</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">phys_addr</span> <span class="p">);</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NRARU</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">);</span>

		<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RXSTATUS_ALL</span> <span class="p">);</span>
		<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>
		<span class="n">usc_EnableInterrupts</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>

		<span class="cm">/* 1. Arm End of Buffer (EOB) Receive DMA Interrupt (BIT2 of RDIAR) */</span>
		<span class="cm">/* 2. Enable Receive DMA Interrupts (BIT1 of DICR) */</span>

		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDIAR</span><span class="p">,</span> <span class="n">BIT3</span> <span class="o">+</span> <span class="n">BIT2</span> <span class="p">);</span>
		<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DICR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InDmaReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DICR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT1</span><span class="p">)</span> <span class="p">);</span>
		<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_InitRxChannel</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_AUTO_DCD</span> <span class="p">)</span>
			<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_AUTO_DCD</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_UNCONDITIONAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RXSTATUS_ALL</span><span class="p">);</span>
		<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span><span class="p">);</span>
		<span class="n">usc_EnableInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_DATA</span><span class="p">);</span>

		<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeRxFifo</span> <span class="p">);</span>
		<span class="n">usc_RCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCmd_EnterHuntmode</span> <span class="p">);</span>

		<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_UNCONDITIONAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCSR</span><span class="p">,</span> <span class="mh">0x1020</span> <span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of usc_start_receiver() */</span>

<span class="cm">/* usc_start_transmitter()</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable the USC transmitter and send a transmit frame if</span>
<span class="cm"> *	one is loaded in the DMA buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_start_transmitter</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">FrameSize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):usc_start_transmitter(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			 
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* If auto RTS enabled and RTS is inactive, then assert */</span>
		<span class="cm">/* RTS and set a flag indicating that the driver should */</span>
		<span class="cm">/* negate RTS when the transmission completes. */</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">drop_rts_on_tx_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_AUTO_RTS</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">usc_get_serial_signals</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_RTS</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_RTS</span><span class="p">;</span>
				<span class="n">usc_set_serial_signals</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">drop_rts_on_tx_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>


		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_ASYNC</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">usc_UnlatchTxstatusBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TXSTATUS_ALL</span><span class="p">);</span>
				<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="o">+</span> <span class="n">TRANSMIT_DATA</span><span class="p">);</span>
				<span class="n">usc_EnableInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_DATA</span><span class="p">);</span>
				<span class="n">usc_load_txfifo</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Disable transmit DMA controller while programming. */</span>
			<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_ResetTxChannel</span> <span class="p">);</span>
			
			<span class="cm">/* Transmit DMA buffer is loaded, so program USC */</span>
			<span class="cm">/* to send the frame contained in the buffers.	 */</span>

			<span class="n">FrameSize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">start_tx_dma_buffer</span><span class="p">].</span><span class="n">rcc</span><span class="p">;</span>

			<span class="cm">/* if operating in Raw sync mode, reset the rcc component</span>
<span class="cm">			 * of the tx dma buffer entry, otherwise, the serial controller</span>
<span class="cm">			 * will send a closing sync char after this count.</span>
<span class="cm">			 */</span>
	    		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">start_tx_dma_buffer</span><span class="p">].</span><span class="n">rcc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* Program the Transmit Character Length Register (TCLR) */</span>
			<span class="cm">/* and clear FIFO (TCC is loaded with TCLR on FIFO clear) */</span>
			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCLR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">FrameSize</span> <span class="p">);</span>

			<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeTxFifo</span> <span class="p">);</span>

			<span class="cm">/* Program the address of the 1st DMA Buffer Entry in linked list */</span>
			<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">start_tx_dma_buffer</span><span class="p">].</span><span class="n">phys_entry</span><span class="p">;</span>
			<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NTARL</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">phys_addr</span> <span class="p">);</span>
			<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NTARU</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">);</span>

			<span class="n">usc_UnlatchTxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TXSTATUS_ALL</span> <span class="p">);</span>
			<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="p">);</span>
			<span class="n">usc_EnableInterrupts</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="o">&amp;&amp;</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_tx_dma_buffers</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
			   <span class="cm">/* When running external sync mode, attempt to &#39;stream&#39; transmit  */</span>
			   <span class="cm">/* by filling tx dma buffers as they become available. To do this */</span>
			   <span class="cm">/* we need to enable Tx DMA EOB Status interrupts :               */</span>
			   <span class="cm">/*                                                                */</span>
			   <span class="cm">/* 1. Arm End of Buffer (EOB) Transmit DMA Interrupt (BIT2 of TDIAR) */</span>
			   <span class="cm">/* 2. Enable Transmit DMA Interrupts (BIT0 of DICR) */</span>

			   <span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TDIAR</span><span class="p">,</span> <span class="n">BIT2</span><span class="o">|</span><span class="n">BIT3</span> <span class="p">);</span>
			   <span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DICR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InDmaReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DICR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT0</span><span class="p">)</span> <span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Initialize Transmit DMA Channel */</span>
			<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_InitTxChannel</span> <span class="p">);</span>
			
			<span class="n">usc_TCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCmd_SendFrame</span> <span class="p">);</span>
			
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span>
					<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5000</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_AUTO_CTS</span> <span class="p">)</span>
			<span class="n">usc_EnableTransmitter</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_AUTO_CTS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">usc_EnableTransmitter</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_UNCONDITIONAL</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of usc_start_transmitter() */</span>

<span class="cm">/* usc_stop_transmitter()</span>
<span class="cm"> *</span>
<span class="cm"> *	Stops the transmitter and DMA</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device isntance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_stop_transmitter</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_ISR</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):usc_stop_transmitter(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			 
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_timer</span><span class="p">);</span>	
			 
	<span class="n">usc_UnlatchTxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TXSTATUS_ALL</span> <span class="p">);</span>
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="o">+</span> <span class="n">TRANSMIT_DATA</span> <span class="p">);</span>
	<span class="n">usc_DisableInterrupts</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="o">+</span> <span class="n">TRANSMIT_DATA</span> <span class="p">);</span>

	<span class="n">usc_EnableTransmitter</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">DISABLE_UNCONDITIONAL</span><span class="p">);</span>
	<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_ResetTxChannel</span> <span class="p">);</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeTxFifo</span> <span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_enabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of usc_stop_transmitter() */</span>

<span class="cm">/* usc_load_txfifo()</span>
<span class="cm"> *</span>
<span class="cm"> *	Fill the transmit FIFO until the FIFO is full or</span>
<span class="cm"> *	there is no more data to load.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device extension (instance data)</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_load_txfifo</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">Fifocount</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">TwoBytes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> 
		
	<span class="cm">/* Select transmit FIFO status readback in TICR */</span>
	<span class="n">usc_TCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCmd_SelectTicrTxFifostatus</span> <span class="p">);</span>

	<span class="cm">/* load the Transmit FIFO until FIFOs full or all data sent */</span>

	<span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">Fifocount</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TICR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* there is more space in the transmit FIFO and */</span>
		<span class="cm">/* there is more data in transmit buffer */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Fifocount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="p">)</span> <span class="p">{</span>
 			<span class="cm">/* write a 16-bit word from transmit buffer to 16C32 */</span>
				
			<span class="n">TwoBytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span><span class="o">++</span><span class="p">];</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SERIAL_XMIT_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">TwoBytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span><span class="o">++</span><span class="p">];</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SERIAL_XMIT_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			
			<span class="n">outw</span><span class="p">(</span> <span class="o">*</span><span class="p">((</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">TwoBytes</span><span class="p">),</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">DATAREG</span><span class="p">);</span>
				
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* only 1 byte left to transmit or 1 FIFO slot left */</span>
			
			<span class="n">outw</span><span class="p">(</span> <span class="p">(</span><span class="n">inw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0780</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">TDR</span><span class="o">+</span><span class="n">LSBONLY</span><span class="p">),</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">x_char</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* transmit pending high priority char */</span>
				<span class="n">outw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">x_char</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">outw</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_buf</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span><span class="o">++</span><span class="p">],</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SERIAL_XMIT_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of usc_load_txfifo() */</span>

<span class="cm">/* usc_reset()</span>
<span class="cm"> *</span>
<span class="cm"> *	Reset the adapter to a known state and prepare it for further use.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_reset</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">readval</span><span class="p">;</span>

		<span class="cm">/* Set BIT30 of Misc Control Register */</span>
		<span class="cm">/* (Local Control Register 0x50) to force reset of USC. */</span>

		<span class="k">volatile</span> <span class="n">u32</span> <span class="o">*</span><span class="n">MiscCtrl</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_base</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">);</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">LCR0BRDR</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_base</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">);</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">misc_ctrl_value</span> <span class="o">|=</span> <span class="n">BIT30</span><span class="p">;</span>
		<span class="o">*</span><span class="n">MiscCtrl</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">misc_ctrl_value</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Force at least 170ns delay before clearing </span>
<span class="cm">		 * reset bit. Each read from LCR takes at least </span>
<span class="cm">		 * 30ns so 10 times for 300ns to be safe.</span>
<span class="cm">		 */</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">readval</span> <span class="o">=</span> <span class="o">*</span><span class="n">MiscCtrl</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">misc_ctrl_value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT30</span><span class="p">;</span>
		<span class="o">*</span><span class="n">MiscCtrl</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">misc_ctrl_value</span><span class="p">;</span>

		<span class="o">*</span><span class="n">LCR0BRDR</span> <span class="o">=</span> <span class="n">BUS_DESCRIPTOR</span><span class="p">(</span>
			<span class="mi">1</span><span class="p">,</span>		<span class="c1">// Write Strobe Hold (0-3)</span>
			<span class="mi">2</span><span class="p">,</span>		<span class="c1">// Write Strobe Delay (0-3)</span>
			<span class="mi">2</span><span class="p">,</span>		<span class="c1">// Read Strobe Delay  (0-3)</span>
			<span class="mi">0</span><span class="p">,</span>		<span class="c1">// NWDD (Write data-data) (0-3)</span>
			<span class="mi">4</span><span class="p">,</span>		<span class="c1">// NWAD (Write Addr-data) (0-31)</span>
			<span class="mi">0</span><span class="p">,</span>		<span class="c1">// NXDA (Read/Write Data-Addr) (0-3)</span>
			<span class="mi">0</span><span class="p">,</span>		<span class="c1">// NRDD (Read Data-Data) (0-3)</span>
			<span class="mi">5</span>		<span class="c1">// NRAD (Read Addr-Data) (0-31)</span>
			<span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* do HW reset */</span>
		<span class="n">outb</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="mi">8</span> <span class="p">);</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">mbre_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopback_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Program the Bus Configuration Register (BCR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15&gt;		0	Don&#39;t use separate address</span>
<span class="cm">	 * &lt;14..6&gt;	0	reserved</span>
<span class="cm">	 * &lt;5..4&gt;	00	IAckmode = Default, don&#39;t care</span>
<span class="cm">	 * &lt;3&gt;		1	Bus Request Totem Pole output</span>
<span class="cm">	 * &lt;2&gt;		1	Use 16 Bit data bus</span>
<span class="cm">	 * &lt;1&gt;		0	IRQ Totem Pole output</span>
<span class="cm">	 * &lt;0&gt;		0	Don&#39;t Shift Right Addr</span>
<span class="cm">	 *</span>
<span class="cm">	 * 0000 0000 0000 1100 = 0x000c</span>
<span class="cm">	 *</span>
<span class="cm">	 * By writing to io_base + SDPIN the Wait/Ack pin is</span>
<span class="cm">	 * programmed to work as a Wait pin.</span>
<span class="cm">	 */</span>
	
	<span class="n">outw</span><span class="p">(</span> <span class="mh">0x000c</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">SDPIN</span> <span class="p">);</span>


	<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span> <span class="p">);</span>

	<span class="cm">/* select little endian byte ordering */</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_SelectLittleEndian</span> <span class="p">);</span>


	<span class="cm">/* Port Control Register (PCR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	11	Port 7 is Output (~DMAEN, Bit 14 : 0 = Enabled)</span>
<span class="cm">	 * &lt;13..12&gt;	11	Port 6 is Output (~INTEN, Bit 12 : 0 = Enabled)</span>
<span class="cm">	 * &lt;11..10&gt; 	00	Port 5 is Input (No Connect, Don&#39;t Care)</span>
<span class="cm">	 * &lt;9..8&gt; 	00	Port 4 is Input (No Connect, Don&#39;t Care)</span>
<span class="cm">	 * &lt;7..6&gt;	11	Port 3 is Output (~RTS, Bit 6 : 0 = Enabled )</span>
<span class="cm">	 * &lt;5..4&gt;	11	Port 2 is Output (~DTR, Bit 4 : 0 = Enabled )</span>
<span class="cm">	 * &lt;3..2&gt;	01	Port 1 is Input (Dedicated RxC)</span>
<span class="cm">	 * &lt;1..0&gt;	01	Port 0 is Input (Dedicated TxC)</span>
<span class="cm">	 *</span>
<span class="cm">	 *	1111 0000 1111 0101 = 0xf0f5</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">,</span> <span class="mh">0xf0f5</span> <span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * Input/Output Control Register</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	00	CTS is active low input</span>
<span class="cm">	 * &lt;13..12&gt;	00	DCD is active low input</span>
<span class="cm">	 * &lt;11..10&gt;	00	TxREQ pin is input (DSR)</span>
<span class="cm">	 * &lt;9..8&gt;	00	RxREQ pin is input (RI)</span>
<span class="cm">	 * &lt;7..6&gt;	00	TxD is output (Transmit Data)</span>
<span class="cm">	 * &lt;5..3&gt;	000	TxC Pin in Input (14.7456MHz Clock)</span>
<span class="cm">	 * &lt;2..0&gt;	100	RxC is Output (drive with BRG0)</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0000 0000 0000 0100 = 0x0004</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">,</span> <span class="mh">0x0004</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of usc_reset() */</span>

<span class="cm">/* usc_set_async_mode()</span>
<span class="cm"> *</span>
<span class="cm"> *	Program adapter for asynchronous communications.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info		pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_set_async_mode</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">RegValue</span><span class="p">;</span>

	<span class="cm">/* disable interrupts while programming USC */</span>
	<span class="n">usc_DisableMasterIrqBit</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="n">outw</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="p">);</span> 			<span class="cm">/* clear Master Bus Enable (DCAR) */</span>
	<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_ResetAllChannels</span> <span class="p">);</span>	<span class="cm">/* disable both DMA channels */</span>

	<span class="n">usc_loopback_frame</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="cm">/* Channel mode Register (CMR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	00	Tx Sub modes, 00 = 1 Stop Bit</span>
<span class="cm">	 * &lt;13..12&gt;	00	              00 = 16X Clock</span>
<span class="cm">	 * &lt;11..8&gt;	0000	Transmitter mode = Asynchronous</span>
<span class="cm">	 * &lt;7..6&gt;	00	reserved?</span>
<span class="cm">	 * &lt;5..4&gt;	00	Rx Sub modes, 00 = 16X Clock</span>
<span class="cm">	 * &lt;3..0&gt;	0000	Receiver mode = Asynchronous</span>
<span class="cm">	 *</span>
<span class="cm">	 * 0000 0000 0000 0000 = 0x0</span>
<span class="cm">	 */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">stop_bits</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT14</span><span class="p">;</span>
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CMR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>

	
	<span class="cm">/* Receiver mode Register (RMR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..13&gt;	000	encoding = None</span>
<span class="cm">	 * &lt;12..08&gt;	00000	reserved (Sync Only)</span>
<span class="cm">	 * &lt;7..6&gt;   	00	Even parity</span>
<span class="cm">	 * &lt;5&gt;		0	parity disabled</span>
<span class="cm">	 * &lt;4..2&gt;	000	Receive Char Length = 8 bits</span>
<span class="cm">	 * &lt;1..0&gt;	00	Disable Receiver</span>
<span class="cm">	 *</span>
<span class="cm">	 * 0000 0000 0000 0000 = 0x0</span>
<span class="cm">	 */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_bits</span> <span class="o">!=</span> <span class="mi">8</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT4</span><span class="o">+</span><span class="n">BIT3</span><span class="o">+</span><span class="n">BIT2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">parity</span> <span class="o">!=</span> <span class="n">ASYNC_PARITY_NONE</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT5</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">parity</span> <span class="o">!=</span> <span class="n">ASYNC_PARITY_ODD</span> <span class="p">)</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RMR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>


	<span class="cm">/* Set IRQ trigger level */</span>

	<span class="n">usc_RCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCmd_SelectRicrIntLevel</span> <span class="p">);</span>

	
	<span class="cm">/* Receive Interrupt Control Register (RICR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..8&gt;	?		RxFIFO IRQ Request Level</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: For async mode the receive FIFO level must be set</span>
<span class="cm">	 * to 0 to avoid the situation where the FIFO contains fewer bytes</span>
<span class="cm">	 * than the trigger level and no more data is expected.</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;7&gt;		0		Exited Hunt IA (Interrupt Arm)</span>
<span class="cm">	 * &lt;6&gt;		0		Idle Received IA</span>
<span class="cm">	 * &lt;5&gt;		0		Break/Abort IA</span>
<span class="cm">	 * &lt;4&gt;		0		Rx Bound IA</span>
<span class="cm">	 * &lt;3&gt;		0		Queued status reflects oldest byte in FIFO</span>
<span class="cm">	 * &lt;2&gt;		0		Abort/PE IA</span>
<span class="cm">	 * &lt;1&gt;		0		Rx Overrun IA</span>
<span class="cm">	 * &lt;0&gt;		0		Select TC0 value for readback</span>
<span class="cm">	 *</span>
<span class="cm">	 * 0000 0000 0100 0000 = 0x0000 + (FIFOLEVEL in MSB)</span>
<span class="cm">	 */</span>
	
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="p">,</span> <span class="mh">0x0000</span> <span class="p">);</span>

	<span class="n">usc_UnlatchRxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RXSTATUS_ALL</span> <span class="p">);</span>
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>

	
	<span class="cm">/* Transmit mode Register (TMR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..13&gt;	000	encoding = None</span>
<span class="cm">	 * &lt;12..08&gt;	00000	reserved (Sync Only)</span>
<span class="cm">	 * &lt;7..6&gt;	00	Transmit parity Even</span>
<span class="cm">	 * &lt;5&gt;		0	Transmit parity Disabled</span>
<span class="cm">	 * &lt;4..2&gt;	000	Tx Char Length = 8 bits</span>
<span class="cm">	 * &lt;1..0&gt;	00	Disable Transmitter</span>
<span class="cm">	 *</span>
<span class="cm">	 * 0000 0000 0000 0000 = 0x0</span>
<span class="cm">	 */</span>

	<span class="n">RegValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_bits</span> <span class="o">!=</span> <span class="mi">8</span> <span class="p">)</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT4</span><span class="o">+</span><span class="n">BIT3</span><span class="o">+</span><span class="n">BIT2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">parity</span> <span class="o">!=</span> <span class="n">ASYNC_PARITY_NONE</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT5</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">parity</span> <span class="o">!=</span> <span class="n">ASYNC_PARITY_ODD</span> <span class="p">)</span>
			<span class="n">RegValue</span> <span class="o">|=</span> <span class="n">BIT6</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TMR</span><span class="p">,</span> <span class="n">RegValue</span> <span class="p">);</span>

	<span class="n">usc_set_txidle</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>


	<span class="cm">/* Set IRQ trigger level */</span>

	<span class="n">usc_TCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCmd_SelectTicrIntLevel</span> <span class="p">);</span>

	
	<span class="cm">/* Transmit Interrupt Control Register (TICR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..8&gt;	?	Transmit FIFO IRQ Level</span>
<span class="cm">	 * &lt;7&gt;		0	Present IA (Interrupt Arm)</span>
<span class="cm">	 * &lt;6&gt;		1	Idle Sent IA</span>
<span class="cm">	 * &lt;5&gt;		0	Abort Sent IA</span>
<span class="cm">	 * &lt;4&gt;		0	EOF/EOM Sent IA</span>
<span class="cm">	 * &lt;3&gt;		0	CRC Sent IA</span>
<span class="cm">	 * &lt;2&gt;		0	1 = Wait for SW Trigger to Start Frame</span>
<span class="cm">	 * &lt;1&gt;		0	Tx Underrun IA</span>
<span class="cm">	 * &lt;0&gt;		0	TC0 constant on read back</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0000 0000 0100 0000 = 0x0040</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TICR</span><span class="p">,</span> <span class="mh">0x1f40</span> <span class="p">);</span>

	<span class="n">usc_UnlatchTxstatusBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TXSTATUS_ALL</span> <span class="p">);</span>
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="p">);</span>

	<span class="n">usc_enable_async_clock</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">data_rate</span> <span class="p">);</span>

	
	<span class="cm">/* Channel Control/status Register (CCSR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15&gt;		X	RCC FIFO Overflow status (RO)</span>
<span class="cm">	 * &lt;14&gt;		X	RCC FIFO Not Empty status (RO)</span>
<span class="cm">	 * &lt;13&gt;		0	1 = Clear RCC FIFO (WO)</span>
<span class="cm">	 * &lt;12&gt;		X	DPLL in Sync status (RO)</span>
<span class="cm">	 * &lt;11&gt;		X	DPLL 2 Missed Clocks status (RO)</span>
<span class="cm">	 * &lt;10&gt;		X	DPLL 1 Missed Clock status (RO)</span>
<span class="cm">	 * &lt;9..8&gt;	00	DPLL Resync on rising and falling edges (RW)</span>
<span class="cm">	 * &lt;7&gt;		X	SDLC Loop On status (RO)</span>
<span class="cm">	 * &lt;6&gt;		X	SDLC Loop Send status (RO)</span>
<span class="cm">	 * &lt;5&gt;		1	Bypass counters for TxClk and RxClk (RW)</span>
<span class="cm">	 * &lt;4..2&gt;   	000	Last Char of SDLC frame has 8 bits (RW)</span>
<span class="cm">	 * &lt;1..0&gt;   	00	reserved</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0000 0000 0010 0000 = 0x0020</span>
<span class="cm">	 */</span>
	
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCSR</span><span class="p">,</span> <span class="mh">0x0020</span> <span class="p">);</span>

	<span class="n">usc_DisableInterrupts</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="o">+</span> <span class="n">TRANSMIT_DATA</span> <span class="o">+</span>
			      <span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>

	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TRANSMIT_STATUS</span> <span class="o">+</span> <span class="n">TRANSMIT_DATA</span> <span class="o">+</span>
				<span class="n">RECEIVE_DATA</span> <span class="o">+</span> <span class="n">RECEIVE_STATUS</span> <span class="p">);</span>

	<span class="n">usc_EnableMasterIrqBit</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_ISA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable INTEN (Port 6, Bit12) */</span>
		<span class="cm">/* This connects the IRQ request signal to the ISA bus */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT13</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT12</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">loopback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopback_bits</span> <span class="o">=</span> <span class="mh">0x300</span><span class="p">;</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x0300</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">CCAR</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of usc_set_async_mode() */</span>

<span class="cm">/* usc_loopback_frame()</span>
<span class="cm"> *</span>
<span class="cm"> *	Loop back a small (2 byte) dummy SDLC frame.</span>
<span class="cm"> *	Interrupts and DMA are NOT used. The purpose of this is to</span>
<span class="cm"> *	clear any &#39;stale&#39; status info left over from running in	async mode.</span>
<span class="cm"> *</span>
<span class="cm"> *	The 16C32 shows the strange behaviour of marking the 1st</span>
<span class="cm"> *	received SDLC frame with a CRC error even when there is no</span>
<span class="cm"> *	CRC error. To get around this a small dummy from of 2 bytes</span>
<span class="cm"> *	is looped back when switching from async to sync mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info		pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_loopback_frame</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">oldmode</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">MGSL_MODE_HDLC</span><span class="p">;</span>
	
	<span class="n">usc_DisableMasterIrqBit</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="n">usc_set_sdlc_mode</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="n">usc_enable_loopback</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>

	<span class="cm">/* Write 16-bit Time Constant for BRG0 */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
	
	<span class="cm">/* Channel Control Register (CCR)</span>
<span class="cm">	 *</span>
<span class="cm">	 * &lt;15..14&gt;	00	Don&#39;t use 32-bit Tx Control Blocks (TCBs)</span>
<span class="cm">	 * &lt;13&gt;		0	Trigger Tx on SW Command Disabled</span>
<span class="cm">	 * &lt;12&gt;		0	Flag Preamble Disabled</span>
<span class="cm">	 * &lt;11..10&gt;	00	Preamble Length = 8-Bits</span>
<span class="cm">	 * &lt;9..8&gt;	01	Preamble Pattern = flags</span>
<span class="cm">	 * &lt;7..6&gt;	10	Don&#39;t use 32-bit Rx status Blocks (RSBs)</span>
<span class="cm">	 * &lt;5&gt;		0	Trigger Rx on SW Command Disabled</span>
<span class="cm">	 * &lt;4..0&gt;	0	reserved</span>
<span class="cm">	 *</span>
<span class="cm">	 *	0000 0001 0000 0000 = 0x0100</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCR</span><span class="p">,</span> <span class="mh">0x0100</span> <span class="p">);</span>

	<span class="cm">/* SETUP RECEIVER */</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeRxFifo</span> <span class="p">);</span>
	<span class="n">usc_EnableReceiver</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_UNCONDITIONAL</span><span class="p">);</span>

	<span class="cm">/* SETUP TRANSMITTER */</span>
	<span class="cm">/* Program the Transmit Character Length Register (TCLR) */</span>
	<span class="cm">/* and clear FIFO (TCC is loaded with TCLR on FIFO clear) */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCLR</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeTxFifo</span> <span class="p">);</span>

	<span class="cm">/* unlatch Tx status bits, and start transmit channel. */</span>
	<span class="n">usc_UnlatchTxstatusBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">TXSTATUS_ALL</span><span class="p">);</span>
	<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="n">DATAREG</span><span class="p">);</span>

	<span class="cm">/* ENABLE TRANSMITTER */</span>
	<span class="n">usc_TCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCmd_SendFrame</span> <span class="p">);</span>
	<span class="n">usc_EnableTransmitter</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">ENABLE_UNCONDITIONAL</span><span class="p">);</span>
							
	<span class="cm">/* WAIT FOR RECEIVE COMPLETE */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCSR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BIT8</span> <span class="o">+</span> <span class="n">BIT4</span> <span class="o">+</span> <span class="n">BIT3</span> <span class="o">+</span> <span class="n">BIT1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* clear Internal Data loopback mode */</span>
	<span class="n">usc_enable_loopback</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">usc_EnableMasterIrqBit</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">oldmode</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of usc_loopback_frame() */</span>

<span class="cm">/* usc_set_sync_mode()	Programs the USC for SDLC communications.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to adapter info structure</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_set_sync_mode</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">usc_loopback_frame</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="n">usc_set_sdlc_mode</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_ISA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable INTEN (Port 6, Bit12) */</span>
		<span class="cm">/* This connects the IRQ request signal to the ISA bus */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT13</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT12</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">usc_enable_aux_clock</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">loopback</span><span class="p">)</span>
		<span class="n">usc_enable_loopback</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_set_sync_mode() */</span>

<span class="cm">/* usc_set_txidle()	Set the HDLC idle mode for the transmitter.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_set_txidle</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">IDLEMODE_FLAGS</span><span class="p">;</span>

	<span class="cm">/* Map API idle mode to USC register bits */</span>

	<span class="k">switch</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">idle_mode</span> <span class="p">){</span>
	<span class="k">case</span> <span class="n">HDLC_TXIDLE_FLAGS</span>:			<span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">IDLEMODE_FLAGS</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_TXIDLE_ALT_ZEROS_ONES</span>:	<span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">IDLEMODE_ALT_ONE_ZERO</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_TXIDLE_ZEROS</span>:			<span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">IDLEMODE_ZERO</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_TXIDLE_ONES</span>:			<span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">IDLEMODE_ONE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_TXIDLE_ALT_MARK_SPACE</span>:	<span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">IDLEMODE_ALT_MARK_SPACE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_TXIDLE_SPACE</span>:			<span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">IDLEMODE_SPACE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HDLC_TXIDLE_MARK</span>:			<span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">IDLEMODE_MARK</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">usc_idle_mode</span> <span class="o">=</span> <span class="n">usc_idle_mode</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>usc<em>OutReg(info, TCSR, usc</em>idle_mode);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcsr_value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IDLEMODE_MASK</span><span class="p">;</span>	<span class="cm">/* clear idle mode bits */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcsr_value</span> <span class="o">+=</span> <span class="n">usc_idle_mode</span><span class="p">;</span>
	<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TCSR</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tcsr_value</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if SyncLink WAN adapter is running in external sync mode, the</span>
<span class="cm">	 * transmitter has been set to Monosync in order to try to mimic</span>
<span class="cm">	 * a true raw outbound bit stream. Monosync still sends an open/close</span>
<span class="cm">	 * sync char at the start/end of a frame. Try to match those sync</span>
<span class="cm">	 * patterns to the idle mode set here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">syncpat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">switch</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">idle_mode</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">HDLC_TXIDLE_FLAGS</span>:
			<span class="n">syncpat</span> <span class="o">=</span> <span class="mh">0x7e</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HDLC_TXIDLE_ALT_ZEROS_ONES</span>:
			<span class="n">syncpat</span> <span class="o">=</span> <span class="mh">0x55</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HDLC_TXIDLE_ZEROS</span>:
		<span class="k">case</span> <span class="n">HDLC_TXIDLE_SPACE</span>:
			<span class="n">syncpat</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HDLC_TXIDLE_ONES</span>:
		<span class="k">case</span> <span class="n">HDLC_TXIDLE_MARK</span>:
			<span class="n">syncpat</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">HDLC_TXIDLE_ALT_MARK_SPACE</span>:
			<span class="n">syncpat</span> <span class="o">=</span> <span class="mh">0xaa</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">usc_SetTransmitSyncChars</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">syncpat</span><span class="p">,</span><span class="n">syncpat</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of usc_set_txidle() */</span>

<span class="cm">/* usc_get_serial_signals()</span>
<span class="cm"> *</span>
<span class="cm"> *	Query the adapter for the state of the V24 status (input) signals.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_get_serial_signals</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* clear all serial signals except DTR and RTS */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;=</span> <span class="n">SerialSignal_DTR</span> <span class="o">+</span> <span class="n">SerialSignal_RTS</span><span class="p">;</span>

	<span class="cm">/* Read the Misc Interrupt status Register (MISR) to get */</span>
	<span class="cm">/* the V24 status signals. */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">MISR</span> <span class="p">);</span>

	<span class="cm">/* set serial signal bits to reflect MISR */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_CTS</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_CTS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DCD</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_DCD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_RI</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_RI</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">MISCSTATUS_DSR</span> <span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_DSR</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of usc_get_serial_signals() */</span>

<span class="cm">/* usc_set_serial_signals()</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the state of DTR and RTS based on contents of</span>
<span class="cm"> *	serial_signals member of device extension.</span>
<span class="cm"> *	</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_set_serial_signals</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">Control</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">V24Out</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span><span class="p">;</span>

	<span class="cm">/* get the current value of the Port Control Register (PCR) */</span>

	<span class="n">Control</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">PCR</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">V24Out</span> <span class="o">&amp;</span> <span class="n">SerialSignal_RTS</span> <span class="p">)</span>
		<span class="n">Control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BIT6</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">Control</span> <span class="o">|=</span> <span class="n">BIT6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">V24Out</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DTR</span> <span class="p">)</span>
		<span class="n">Control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BIT4</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">Control</span> <span class="o">|=</span> <span class="n">BIT4</span><span class="p">;</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">,</span> <span class="n">Control</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of usc_set_serial_signals() */</span>

<span class="cm">/* usc_enable_async_clock()</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable the async clock at the specified frequency.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info		pointer to device instance data</span>
<span class="cm"> *			data_rate	data rate of clock in bps</span>
<span class="cm"> *					0 disables the AUX clock.</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_enable_async_clock</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data_rate</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">data_rate</span> <span class="p">)</span>	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clock mode Control Register (CMCR)</span>
<span class="cm">		 * </span>
<span class="cm">		 * &lt;15..14&gt;     00      counter 1 Disabled</span>
<span class="cm">		 * &lt;13..12&gt;     00      counter 0 Disabled</span>
<span class="cm">		 * &lt;11..10&gt;     11      BRG1 Input is TxC Pin</span>
<span class="cm">		 * &lt;9..8&gt;       11      BRG0 Input is TxC Pin</span>
<span class="cm">		 * &lt;7..6&gt;       01      DPLL Input is BRG1 Output</span>
<span class="cm">		 * &lt;5..3&gt;       100     TxCLK comes from BRG0</span>
<span class="cm">		 * &lt;2..0&gt;       100     RxCLK comes from BRG0</span>
<span class="cm">		 *</span>
<span class="cm">		 * 0000 1111 0110 0100 = 0x0f64</span>
<span class="cm">		 */</span>
		
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CMCR</span><span class="p">,</span> <span class="mh">0x0f64</span> <span class="p">);</span>


		<span class="cm">/*</span>
<span class="cm">		 * Write 16-bit Time Constant for BRG0</span>
<span class="cm">		 * Time Constant = (ClkSpeed / data_rate) - 1</span>
<span class="cm">		 * ClkSpeed = 921600 (ISA), 691200 (PCI)</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="mi">691200</span><span class="o">/</span><span class="n">data_rate</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">else</span>
			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="mi">921600</span><span class="o">/</span><span class="n">data_rate</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">);</span>

		
		<span class="cm">/*</span>
<span class="cm">		 * Hardware Configuration Register (HCR)</span>
<span class="cm">		 * Clear Bit 1, BRG0 mode = Continuous</span>
<span class="cm">		 * Set Bit 0 to enable BRG0.</span>
<span class="cm">		 */</span>

		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT1</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT0</span><span class="p">)</span> <span class="p">);</span>


		<span class="cm">/* Input/Output Control Reg, &lt;2..0&gt; = 100, Drive RxC pin with BRG0 */</span>

		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IOCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfff8</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0004</span><span class="p">)</span> <span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* data rate == 0 so turn off BRG0 */</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">HCR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT0</span><span class="p">)</span> <span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>	<span class="cm">/* end of usc_enable_async_clock() */</span>

<span class="cm">/*</span>
<span class="cm"> * Buffer Structures:</span>
<span class="cm"> *</span>
<span class="cm"> * Normal memory access uses virtual addresses that can make discontiguous</span>
<span class="cm"> * physical memory pages appear to be contiguous in the virtual address</span>
<span class="cm"> * space (the processors memory mapping handles the conversions).</span>
<span class="cm"> *</span>
<span class="cm"> * DMA transfers require physically contiguous memory. This is because</span>
<span class="cm"> * the DMA system controller and DMA bus masters deal with memory using</span>
<span class="cm"> * only physical addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * This causes a problem under Windows NT when large DMA buffers are</span>
<span class="cm"> * needed. Fragmentation of the nonpaged pool prevents allocations of</span>
<span class="cm"> * physically contiguous buffers larger than the PAGE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * However the 16C32 supports Bus Master Scatter/Gather DMA which</span>
<span class="cm"> * allows DMA transfers to physically discontiguous buffers. Information</span>
<span class="cm"> * about each data transfer buffer is contained in a memory structure</span>
<span class="cm"> * called a &#39;buffer entry&#39;. A list of buffer entries is maintained</span>
<span class="cm"> * to track and control the use of the data transfer buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * To support this strategy we will allocate sufficient PAGE_SIZE</span>
<span class="cm"> * contiguous memory buffers to allow for the total required buffer</span>
<span class="cm"> * space.</span>
<span class="cm"> *</span>
<span class="cm"> * The 16C32 accesses the list of buffer entries using Bus Master</span>
<span class="cm"> * DMA. Control information is read from the buffer entries by the</span>
<span class="cm"> * 16C32 to control data transfers. status information is written to</span>
<span class="cm"> * the buffer entries by the 16C32 to indicate the status of completed</span>
<span class="cm"> * transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * The CPU writes control information to the buffer entries to control</span>
<span class="cm"> * the 16C32 and reads status information from the buffer entries to</span>
<span class="cm"> * determine information about received and transmitted frames.</span>
<span class="cm"> *</span>
<span class="cm"> * Because the CPU and 16C32 (adapter) both need simultaneous access</span>
<span class="cm"> * to the buffer entries, the buffer entry memory is allocated with</span>
<span class="cm"> * HalAllocateCommonBuffer(). This restricts the size of the buffer</span>
<span class="cm"> * entry list to PAGE_SIZE.</span>
<span class="cm"> *</span>
<span class="cm"> * The actual data buffers on the other hand will only be accessed</span>
<span class="cm"> * by the CPU or the adapter but not by both simultaneously. This allows</span>
<span class="cm"> * Scatter/Gather packet based DMA procedures for using physically</span>
<span class="cm"> * discontiguous pages.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_reset_tx_dma_buffers()</span>
<span class="cm"> *</span>
<span class="cm"> * 	Set the count for all transmit buffers to 0 to indicate the</span>
<span class="cm"> * 	buffer is available for use and set the current buffer to the</span>
<span class="cm"> * 	first buffer. This effectively makes all buffers free and</span>
<span class="cm"> * 	discards any data in buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_reset_tx_dma_buffers</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">current_tx_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">start_tx_dma_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_dma_buffers_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">get_tx_holding_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">put_tx_holding_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_holding_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_reset_tx_dma_buffers() */</span>

<span class="cm">/*</span>
<span class="cm"> * num_free_tx_dma_buffers()</span>
<span class="cm"> *</span>
<span class="cm"> * 	returns the number of free tx dma buffers available</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	number of free tx dma buffers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">num_free_tx_dma_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_dma_buffers_used</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_reset_rx_dma_buffers()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Set the count for all receive buffers to DMABUFFERSIZE</span>
<span class="cm"> * 	and set the current buffer to the first buffer. This effectively</span>
<span class="cm"> * 	makes all buffers free and discards any data in buffers.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_reset_rx_dma_buffers</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">))</span> <span class="o">=</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><pre><code>info-&gt;rx_buffer_list[i].count = DMABUFFERSIZE;
info-&gt;rx_buffer_list[i].status = 0;
</code></pre></td><td class="code"><div class="highlight"><pre>	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">current_rx_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_reset_rx_dma_buffers() */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_free_rx_frame_buffers()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Free the receive buffers used by a received SDLC</span>
<span class="cm"> * 	frame such that the buffers can be reused.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	info			pointer to device instance data</span>
<span class="cm"> * 	StartIndex		index of 1st receive buffer of frame</span>
<span class="cm"> * 	EndIndex		index of last receive buffer of frame</span>
<span class="cm"> * </span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_free_rx_frame_buffers</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">StartIndex</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">EndIndex</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">Done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">pBufEntry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Index</span><span class="p">;</span>

	<span class="cm">/* Starting with 1st buffer entry of the frame clear the status */</span>
	<span class="cm">/* field and set the count field to DMA Buffer Size. */</span>

	<span class="n">Index</span> <span class="o">=</span> <span class="n">StartIndex</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">Done</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">pBufEntry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">Index</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">Index</span> <span class="o">==</span> <span class="n">EndIndex</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is the last buffer of the frame! */</span>
			<span class="n">Done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* reset current buffer for reuse */</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><pre><code>pBufEntry-&gt;status = 0;
pBufEntry-&gt;count = DMABUFFERSIZE;
</code></pre></td><td class="code"><div class="highlight"><pre>		<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pBufEntry</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="o">=</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>

		<span class="cm">/* advance to next buffer entry in linked list */</span>
		<span class="n">Index</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">Index</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="p">)</span>
			<span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set current buffer to next buffer after last buffer of frame */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">current_rx_buffer</span> <span class="o">=</span> <span class="n">Index</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of free_rx_frame_buffers() */</span>

<span class="cm">/* mgsl_get_rx_frame()</span>
<span class="cm"> * </span>
<span class="cm"> * 	This function attempts to return a received SDLC frame from the</span>
<span class="cm"> * 	receive DMA buffers. Only frames received without errors are returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:	 	info	pointer to device extension</span>
<span class="cm"> * Return Value:	true if frame returned, otherwise false</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mgsl_get_rx_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">StartIndex</span><span class="p">,</span> <span class="n">EndIndex</span><span class="p">;</span>	<span class="cm">/* index of 1st and last buffers of Rx frame */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">pBufEntry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">framesize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ReturnCode</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">return_frame</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * current_rx_buffer points to the 1st buffer of the next available</span>
<span class="cm">	 * receive frame. To find the last buffer of the frame look for</span>
<span class="cm">	 * a non-zero status field in the buffer entries. (The status</span>
<span class="cm">	 * field is set by the 16C32 after completing a receive frame.</span>
<span class="cm">	 */</span>

	<span class="n">StartIndex</span> <span class="o">=</span> <span class="n">EndIndex</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">current_rx_buffer</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">].</span><span class="n">status</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the count field of the buffer entry is non-zero then</span>
<span class="cm">		 * this buffer has not been used. (The 16C32 clears the count</span>
<span class="cm">		 * field when it starts using the buffer.) If an unused buffer</span>
<span class="cm">		 * is encountered then there are no frames available.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">].</span><span class="n">count</span> <span class="p">)</span>
			<span class="k">goto</span> <span class="n">Cleanup</span><span class="p">;</span>

		<span class="cm">/* advance to next buffer entry in linked list */</span>
		<span class="n">EndIndex</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">EndIndex</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="p">)</span>
			<span class="n">EndIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* if entire list searched then no frame available */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">EndIndex</span> <span class="o">==</span> <span class="n">StartIndex</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If this occurs then something bad happened,</span>
<span class="cm">			 * all buffers have been &#39;used&#39; but none mark</span>
<span class="cm">			 * the end of a frame. Reset buffers and receiver.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_enabled</span> <span class="p">){</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">usc_start_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">Cleanup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/* check status of receive frame */</span>
	
	<span class="n">status</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">].</span><span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXSTATUS_SHORT_FRAME</span> <span class="o">+</span> <span class="n">RXSTATUS_OVERRUN</span> <span class="o">+</span>
			<span class="n">RXSTATUS_CRC_ERROR</span> <span class="o">+</span> <span class="n">RXSTATUS_ABORT</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_SHORT_FRAME</span> <span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxshort</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_ABORT</span> <span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxabort</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_OVERRUN</span> <span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxover</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxcrc</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">&amp;</span> <span class="n">HDLC_CRC_RETURN_EX</span> <span class="p">)</span>
				<span class="n">return_frame</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">framesize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
		<span class="p">{</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">return_frame</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">return_frame</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* receive frame has no errors, get frame size.</span>
<span class="cm">		 * The frame size is the starting value of the RCC (which was</span>
<span class="cm">		 * set to 0xffff) minus the ending value of the RCC (decremented</span>
<span class="cm">		 * once for each receive character) minus 2 for the 16-bit CRC.</span>
<span class="cm">		 */</span>

		<span class="n">framesize</span> <span class="o">=</span> <span class="n">RCLRVALUE</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">].</span><span class="n">rcc</span><span class="p">;</span>

		<span class="cm">/* adjust frame size for CRC if any */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">==</span> <span class="n">HDLC_CRC_16_CCITT</span> <span class="p">)</span>
			<span class="n">framesize</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">==</span> <span class="n">HDLC_CRC_32_CCITT</span> <span class="p">)</span>
			<span class="n">framesize</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>		
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_BH</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_get_rx_frame(%s) status=%04X size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">status</span><span class="p">,</span><span class="n">framesize</span><span class="p">);</span>
			
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_DATA</span> <span class="p">)</span>
		<span class="n">mgsl_trace_block</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">StartIndex</span><span class="p">].</span><span class="n">virt_addr</span><span class="p">,</span>
			<span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">framesize</span><span class="p">,</span> <span class="n">DMABUFFERSIZE</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">framesize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">&amp;</span> <span class="n">HDLC_CRC_RETURN_EX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">((</span><span class="n">framesize</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">)</span> <span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">framesize</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxlong</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* copy dma buffer(s) to contiguous intermediate buffer */</span>
			<span class="kt">int</span> <span class="n">copy_count</span> <span class="o">=</span> <span class="n">framesize</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">StartIndex</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptmp</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_CRC_ERROR</span><span class="p">))</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxok</span><span class="o">++</span><span class="p">;</span>
			
			<span class="k">while</span><span class="p">(</span><span class="n">copy_count</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">partial_count</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">copy_count</span> <span class="o">&gt;</span> <span class="n">DMABUFFERSIZE</span> <span class="p">)</span>
					<span class="n">partial_count</span> <span class="o">=</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">partial_count</span> <span class="o">=</span> <span class="n">copy_count</span><span class="p">;</span>
			
				<span class="n">pBufEntry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
				<span class="n">memcpy</span><span class="p">(</span> <span class="n">ptmp</span><span class="p">,</span> <span class="n">pBufEntry</span><span class="o">-&gt;</span><span class="n">virt_addr</span><span class="p">,</span> <span class="n">partial_count</span> <span class="p">);</span>
				<span class="n">ptmp</span> <span class="o">+=</span> <span class="n">partial_count</span><span class="p">;</span>
				<span class="n">copy_count</span> <span class="o">-=</span> <span class="n">partial_count</span><span class="p">;</span>
				
				<span class="k">if</span> <span class="p">(</span> <span class="o">++</span><span class="n">index</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="p">)</span>
					<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">&amp;</span> <span class="n">HDLC_CRC_RETURN_EX</span> <span class="p">)</span> <span class="p">{</span>
				<span class="o">++</span><span class="n">framesize</span><span class="p">;</span>
				<span class="o">*</span><span class="n">ptmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_CRC_ERROR</span> <span class="o">?</span>
						<span class="n">RX_CRC_ERROR</span> <span class="o">:</span>
						<span class="n">RX_OK</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_DATA</span> <span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_get_rx_frame(%s) rx frame status=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span>
						<span class="o">*</span><span class="n">ptmp</span><span class="p">);</span>
			<span class="p">}</span>

<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="p">)</span>
				<span class="n">hdlcdev_rx</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span><span class="p">,</span><span class="n">framesize</span><span class="p">);</span>
			<span class="k">else</span>
<span class="cp">#endif</span>
				<span class="n">ldisc_receive_buf</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">flag_buf</span><span class="p">,</span> <span class="n">framesize</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Free the buffers used by this frame. */</span>
	<span class="n">mgsl_free_rx_frame_buffers</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">StartIndex</span><span class="p">,</span> <span class="n">EndIndex</span> <span class="p">);</span>

	<span class="n">ReturnCode</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">Cleanup:</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_overflow</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The receiver needs to restarted because of </span>
<span class="cm">		 * a receive overflow (buffer or FIFO). If the </span>
<span class="cm">		 * receive buffers are now empty, then restart receiver.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">].</span><span class="n">status</span> <span class="o">&amp;&amp;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">].</span><span class="n">count</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">usc_start_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ReturnCode</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_get_rx_frame() */</span>

<span class="cm">/* mgsl_get_raw_rx_frame()</span>
<span class="cm"> *</span>
<span class="cm"> *     	This function attempts to return a received frame from the</span>
<span class="cm"> *	receive DMA buffers when running in external loop mode. In this mode,</span>
<span class="cm"> *	we will return at most one DMABUFFERSIZE frame to the application.</span>
<span class="cm"> *	The USC receiver is triggering off of DCD going active to start a new</span>
<span class="cm"> *	frame, and DCD going inactive to terminate the frame (similar to</span>
<span class="cm"> *	processing a closing flag character).</span>
<span class="cm"> *</span>
<span class="cm"> *	In this routine, we will return DMABUFFERSIZE &quot;chunks&quot; at a time.</span>
<span class="cm"> *	If DCD goes inactive, the last Rx DMA Buffer will have a non-zero</span>
<span class="cm"> * 	status field and the RCC field will indicate the length of the</span>
<span class="cm"> *	entire received frame. We take this RCC field and get the modulus</span>
<span class="cm"> *	of RCC and DMABUFFERSIZE to determine if number of bytes in the</span>
<span class="cm"> *	last Rx DMA buffer and return that last portion of the frame.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:	 	info	pointer to device extension</span>
<span class="cm"> * Return Value:	true if frame returned, otherwise false</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mgsl_get_raw_rx_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">CurrentIndex</span><span class="p">,</span> <span class="n">NextIndex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">pBufEntry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">framesize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ReturnCode</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm"> 	 * current_rx_buffer points to the 1st buffer of the next available</span>
<span class="cm">	 * receive frame. The status field is set by the 16C32 after</span>
<span class="cm">	 * completing a receive frame. If the status field of this buffer</span>
<span class="cm">	 * is zero, either the USC is still filling this buffer or this</span>
<span class="cm">	 * is one of a series of buffers making up a received frame.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the count field of this buffer is zero, the USC is either</span>
<span class="cm">	 * using this buffer or has used this buffer. Look at the count</span>
<span class="cm">	 * field of the next buffer. If that next buffer&#39;s count is</span>
<span class="cm">	 * non-zero, the USC is still actively using the current buffer.</span>
<span class="cm">	 * Otherwise, if the next buffer&#39;s count field is zero, the</span>
<span class="cm">	 * current buffer is complete and the USC is using the next</span>
<span class="cm">	 * buffer.</span>
<span class="cm">	 */</span>
	<span class="n">CurrentIndex</span> <span class="o">=</span> <span class="n">NextIndex</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">current_rx_buffer</span><span class="p">;</span>
	<span class="o">++</span><span class="n">NextIndex</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">NextIndex</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_count</span> <span class="p">)</span>
		<span class="n">NextIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">].</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">].</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">NextIndex</span><span class="p">].</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">	 	 * Either the status field of this dma buffer is non-zero</span>
<span class="cm">		 * (indicating the last buffer of a receive frame) or the next</span>
<span class="cm">	 	 * buffer is marked as in use -- implying this buffer is complete</span>
<span class="cm">		 * and an intermediate buffer for this received frame.</span>
<span class="cm">	 	 */</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">].</span><span class="n">status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXSTATUS_SHORT_FRAME</span> <span class="o">+</span> <span class="n">RXSTATUS_OVERRUN</span> <span class="o">+</span>
				<span class="n">RXSTATUS_CRC_ERROR</span> <span class="o">+</span> <span class="n">RXSTATUS_ABORT</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_SHORT_FRAME</span> <span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxshort</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_ABORT</span> <span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxabort</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="n">RXSTATUS_OVERRUN</span> <span class="p">)</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxover</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxcrc</span><span class="o">++</span><span class="p">;</span>
			<span class="n">framesize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * A receive frame is available, get frame size and status.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The frame size is the starting value of the RCC (which was</span>
<span class="cm">			 * set to 0xffff) minus the ending value of the RCC (decremented</span>
<span class="cm">			 * once for each receive character) minus 2 or 4 for the 16-bit</span>
<span class="cm">			 * or 32-bit CRC.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If the status field is zero, this is an intermediate buffer.</span>
<span class="cm">			 * It&#39;s size is 4K.</span>
<span class="cm">			 *</span>
<span class="cm">			 * If the DMA Buffer Entry&#39;s Status field is non-zero, the</span>
<span class="cm">			 * receive operation completed normally (ie: DCD dropped). The</span>
<span class="cm">			 * RCC field is valid and holds the received frame size.</span>
<span class="cm">			 * It is possible that the RCC field will be zero on a DMA buffer</span>
<span class="cm">			 * entry with a non-zero status. This can occur if the total</span>
<span class="cm">			 * frame size (number of bytes between the time DCD goes active</span>
<span class="cm">			 * to the time DCD goes inactive) exceeds 65535 bytes. In this</span>
<span class="cm">			 * case the 16C32 has underrun on the RCC count and appears to</span>
<span class="cm">			 * stop updating this counter to let us know the actual received</span>
<span class="cm">			 * frame size. If this happens (non-zero status and zero RCC),</span>
<span class="cm">			 * simply return the entire RxDMA Buffer</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * In the event that the final RxDMA Buffer is</span>
<span class="cm">				 * terminated with a non-zero status and the RCC</span>
<span class="cm">				 * field is zero, we interpret this as the RCC</span>
<span class="cm">				 * having underflowed (received frame &gt; 65535 bytes).</span>
<span class="cm">				 *</span>
<span class="cm">				 * Signal the event to the user by passing back</span>
<span class="cm">				 * a status of RxStatus_CrcError returning the full</span>
<span class="cm">				 * buffer and let the app figure out what data is</span>
<span class="cm">				 * actually valid</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">].</span><span class="n">rcc</span> <span class="p">)</span>
					<span class="n">framesize</span> <span class="o">=</span> <span class="n">RCLRVALUE</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">].</span><span class="n">rcc</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">framesize</span> <span class="o">=</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">framesize</span> <span class="o">=</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">framesize</span> <span class="o">&gt;</span> <span class="n">DMABUFFERSIZE</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if running in raw sync mode, ISR handler for</span>
<span class="cm">			 * End Of Buffer events terminates all buffers at 4K.</span>
<span class="cm">			 * If this frame size is said to be &gt;4K, get the</span>
<span class="cm">			 * actual number of bytes of the frame in this buffer.</span>
<span class="cm">			 */</span>
			<span class="n">framesize</span> <span class="o">=</span> <span class="n">framesize</span> <span class="o">%</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_BH</span> <span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d):mgsl_get_raw_rx_frame(%s) status=%04X size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span><span class="n">status</span><span class="p">,</span><span class="n">framesize</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_DATA</span> <span class="p">)</span>
			<span class="n">mgsl_trace_block</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">].</span><span class="n">virt_addr</span><span class="p">,</span>
				<span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">framesize</span><span class="p">,</span> <span class="n">DMABUFFERSIZE</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">framesize</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* copy dma buffer(s) to contiguous intermediate buffer */</span>
			<span class="cm">/* NOTE: we never copy more than DMABUFFERSIZE bytes	*/</span>

			<span class="n">pBufEntry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">]);</span>
			<span class="n">memcpy</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span><span class="p">,</span> <span class="n">pBufEntry</span><span class="o">-&gt;</span><span class="n">virt_addr</span><span class="p">,</span> <span class="n">framesize</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rxok</span><span class="o">++</span><span class="p">;</span>

			<span class="n">ldisc_receive_buf</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">intermediate_rxbuffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">flag_buf</span><span class="p">,</span> <span class="n">framesize</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Free the buffers used by this frame. */</span>
		<span class="n">mgsl_free_rx_frame_buffers</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CurrentIndex</span><span class="p">,</span> <span class="n">CurrentIndex</span> <span class="p">);</span>

		<span class="n">ReturnCode</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_overflow</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The receiver needs to restarted because of</span>
<span class="cm">		 * a receive overflow (buffer or FIFO). If the</span>
<span class="cm">		 * receive buffers are now empty, then restart receiver.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">].</span><span class="n">status</span> <span class="o">&amp;&amp;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="n">CurrentIndex</span><span class="p">].</span><span class="n">count</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">usc_start_receiver</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ReturnCode</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_get_raw_rx_frame() */</span>

<span class="cm">/* mgsl_load_tx_dma_buffer()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Load the transmit DMA buffer with the specified data.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	info		pointer to device extension</span>
<span class="cm"> * 	Buffer		pointer to buffer containing frame to load</span>
<span class="cm"> * 	BufferSize	size in bytes of frame in Buffer</span>
<span class="cm"> * </span>
<span class="cm"> * Return Value: 	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_load_tx_dma_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">BufferSize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">Copycount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DMABUFFERENTRY</span> <span class="o">*</span><span class="n">pBufEntry</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_DATA</span> <span class="p">)</span>
		<span class="n">mgsl_trace_block</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">BufferSize</span><span class="p">,</span> <span class="n">DMABUFFERSIZE</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_HDLC_LOOPMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set CMR:13 to start transmit when</span>
<span class="cm">		 * next GoAhead (abort) is received</span>
<span class="cm">		 */</span>
	 	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span> <span class="o">|=</span> <span class="n">BIT13</span><span class="p">;</span>			  
	<span class="p">}</span>
		
	<span class="cm">/* begin loading the frame in the next available tx dma</span>
<span class="cm">	 * buffer, remember it&#39;s starting location for setting</span>
<span class="cm">	 * up tx dma operation</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">current_tx_buffer</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">start_tx_dma_buffer</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Setup the status and RCC (Frame Size) fields of the 1st */</span>
	<span class="cm">/* buffer entry in the transmit DMA buffer list. */</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span> <span class="o">&amp;</span> <span class="mh">0xf000</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rcc</span>    <span class="o">=</span> <span class="n">BufferSize</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span>  <span class="o">=</span> <span class="n">BufferSize</span><span class="p">;</span>

	<span class="cm">/* Copy frame data from 1st source buffer to the DMA buffers. */</span>
	<span class="cm">/* The frame data may span multiple DMA buffers. */</span>

	<span class="k">while</span><span class="p">(</span> <span class="n">BufferSize</span> <span class="p">){</span>
		<span class="cm">/* Get a pointer to next DMA buffer entry. */</span>
		<span class="n">pBufEntry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
			
		<span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_count</span> <span class="p">)</span>
			<span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Calculate the number of bytes that can be copied from */</span>
		<span class="cm">/* the source buffer to this DMA buffer. */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">BufferSize</span> <span class="o">&gt;</span> <span class="n">DMABUFFERSIZE</span> <span class="p">)</span>
			<span class="n">Copycount</span> <span class="o">=</span> <span class="n">DMABUFFERSIZE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">Copycount</span> <span class="o">=</span> <span class="n">BufferSize</span><span class="p">;</span>

		<span class="cm">/* Actually copy data from source buffer to DMA buffer. */</span>
		<span class="cm">/* Also set the data count for this individual DMA buffer. */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
			<span class="n">mgsl_load_pci_memory</span><span class="p">(</span><span class="n">pBufEntry</span><span class="o">-&gt;</span><span class="n">virt_addr</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">,</span><span class="n">Copycount</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pBufEntry</span><span class="o">-&gt;</span><span class="n">virt_addr</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">,</span> <span class="n">Copycount</span><span class="p">);</span>

		<span class="n">pBufEntry</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">Copycount</span><span class="p">;</span>

		<span class="cm">/* Advance source pointer and reduce remaining data count. */</span>
		<span class="n">Buffer</span> <span class="o">+=</span> <span class="n">Copycount</span><span class="p">;</span>
		<span class="n">BufferSize</span> <span class="o">-=</span> <span class="n">Copycount</span><span class="p">;</span>

		<span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_dma_buffers_used</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remember next available tx dma buffer */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">current_tx_buffer</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_load_tx_dma_buffer() */</span>

<span class="cm">/*</span>
<span class="cm"> * mgsl_register_test()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Performs a register test of the 16C32.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:		true if test passed, otherwise false</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mgsl_register_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">BitPatterns</span><span class="p">[]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="mh">0xaaaa</span><span class="p">,</span> <span class="mh">0x5555</span><span class="p">,</span> <span class="mh">0x1234</span><span class="p">,</span> <span class="mh">0x6969</span><span class="p">,</span> <span class="mh">0x9696</span><span class="p">,</span> <span class="mh">0x0f0f</span> <span class="p">};</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Patterncount</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">BitPatterns</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">usc_reset</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* Verify the reset state of some registers. */</span>

	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">SICR</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		  <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">IVR</span>  <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		  <span class="p">(</span><span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DIVR</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">){</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="p">){</span>
		<span class="cm">/* Write bit patterns to various registers but do it out of */</span>
		<span class="cm">/* sync, then read back and verify values. */</span>

		<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Patterncount</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span><span class="p">,</span> <span class="n">BitPatterns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC1R</span><span class="p">,</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">]</span> <span class="p">);</span>
			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCLR</span><span class="p">,</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">]</span> <span class="p">);</span>
			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCLR</span><span class="p">,</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">]</span> <span class="p">);</span>
			<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RSR</span><span class="p">,</span>  <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">]</span> <span class="p">);</span>
			<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TBCR</span><span class="p">,</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">]</span> <span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC0R</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">BitPatterns</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">||</span>
				  <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TC1R</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">])</span> <span class="o">||</span>
				  <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCLR</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">])</span> <span class="o">||</span>
				  <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RCLR</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">])</span> <span class="o">||</span>
				  <span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RSR</span> <span class="p">)</span>  <span class="o">!=</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">])</span> <span class="o">||</span>
				  <span class="p">(</span><span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TBCR</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">BitPatterns</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">%</span><span class="n">Patterncount</span><span class="p">])</span> <span class="p">){</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">usc_reset</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_register_test() */</span>

<span class="cm">/* mgsl_irq_test() 	Perform interrupt test of the 16C32.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	true if test passed, otherwise false</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mgsl_irq_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">EndTime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">usc_reset</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup 16C32 to interrupt on TxC pin (14MHz clock) transition. </span>
<span class="cm">	 * The ISR sets irq_occurred to true.</span>
<span class="cm">	 */</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_occurred</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Enable INTEN gate for ISA adapter (Port 6, Bit12) */</span>
	<span class="cm">/* Enable INTEN (Port 6, Bit12) */</span>
	<span class="cm">/* This connects the IRQ request signal to the ISA bus */</span>
	<span class="cm">/* on the ISA adapter. This has no effect for the PCI adapter */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PCR</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT13</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BIT12</span><span class="p">)</span> <span class="p">);</span>

	<span class="n">usc_EnableMasterIrqBit</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">usc_EnableInterrupts</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IO_PIN</span><span class="p">);</span>
	<span class="n">usc_ClearIrqPendingBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">IO_PIN</span><span class="p">);</span>
	
	<span class="n">usc_UnlatchIostatusBits</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">MISCSTATUS_TXC_LATCHED</span><span class="p">);</span>
	<span class="n">usc_EnableStatusIrqs</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">SICR_TXC_ACTIVE</span> <span class="o">+</span> <span class="n">SICR_TXC_INACTIVE</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">EndTime</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span> <span class="n">EndTime</span><span class="o">--</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_occurred</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">usc_reset</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_occurred</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_irq_test() */</span>

<span class="cm">/* mgsl_dma_test()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Perform a DMA test of the 16C32. A small frame is</span>
<span class="cm"> * 	transmitted via DMA from a transmit buffer to a receive buffer</span>
<span class="cm"> * 	using single buffer DMA mode.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	true if test passed, otherwise false</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mgsl_dma_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">FifoLevel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">FrameSize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">TmpPtr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">EndTime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">MGSL_PARAMS</span> <span class="n">tmp_params</span><span class="p">;</span>

	<span class="cm">/* save current port options */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_params</span><span class="p">,</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MGSL_PARAMS</span><span class="p">));</span>
	<span class="cm">/* load default port options */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">,</span><span class="o">&amp;</span><span class="n">default_params</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MGSL_PARAMS</span><span class="p">));</span>
	
<span class="cp">#define TESTFRAMESIZE 40</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="cm">/* setup 16C32 for SDLC DMA transfer mode */</span>

	<span class="n">usc_reset</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">usc_set_sdlc_mode</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">usc_enable_loopback</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="cm">/* Reprogram the RDMR so that the 16C32 does NOT clear the count</span>
<span class="cm">	 * field of the buffer entry after fetching buffer address. This</span>
<span class="cm">	 * way we can detect a DMA failure for a DMA read (which should be</span>
<span class="cm">	 * non-destructive to system memory) before we try and write to</span>
<span class="cm">	 * memory (where a failure could corrupt system memory).</span>
<span class="cm">	 */</span>

	<span class="cm">/* Receive DMA mode Register (RDMR)</span>
<span class="cm">	 * </span>
<span class="cm">	 * &lt;15..14&gt;	11	DMA mode = Linked List Buffer mode</span>
<span class="cm">	 * &lt;13&gt;		1	RSBinA/L = store Rx status Block in List entry</span>
<span class="cm">	 * &lt;12&gt;		0	1 = Clear count of List Entry after fetching</span>
<span class="cm">	 * &lt;11..10&gt;	00	Address mode = Increment</span>
<span class="cm">	 * &lt;9&gt;		1	Terminate Buffer on RxBound</span>
<span class="cm">	 * &lt;8&gt;		0	Bus Width = 16bits</span>
<span class="cm">	 * &lt;7..0&gt;		?	status Bits (write as 0s)</span>
<span class="cm">	 * </span>
<span class="cm">	 * 1110 0010 0000 0000 = 0xe200</span>
<span class="cm">	 */</span>

	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDMR</span><span class="p">,</span> <span class="mh">0xe200</span> <span class="p">);</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>


	<span class="cm">/* SETUP TRANSMIT AND RECEIVE DMA BUFFERS */</span>

	<span class="n">FrameSize</span> <span class="o">=</span> <span class="n">TESTFRAMESIZE</span><span class="p">;</span>

	<span class="cm">/* setup 1st transmit buffer entry: */</span>
	<span class="cm">/* with frame size and transmit control word */</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span>  <span class="o">=</span> <span class="n">FrameSize</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rcc</span>    <span class="o">=</span> <span class="n">FrameSize</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mh">0x4000</span><span class="p">;</span>

	<span class="cm">/* build a transmit frame in 1st transmit DMA buffer */</span>

	<span class="n">TmpPtr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">virt_addr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FrameSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
		<span class="o">*</span><span class="n">TmpPtr</span><span class="o">++</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* setup 1st receive buffer entry: */</span>
	<span class="cm">/* clear status, set max receive buffer size */</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="n">FrameSize</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* zero out the 1st receive buffer */</span>

	<span class="n">memset</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">virt_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FrameSize</span> <span class="o">+</span> <span class="mi">4</span> <span class="p">);</span>

	<span class="cm">/* Set count field of next buffer entries to prevent */</span>
	<span class="cm">/* 16C32 from using buffers after the 1st one. */</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	

	<span class="cm">/***************************/</span>
	<span class="cm">/* Program 16C32 receiver. */</span>
	<span class="cm">/***************************/</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* setup DMA transfers */</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeRxFifo</span> <span class="p">);</span>

	<span class="cm">/* program 16C32 receiver with physical address of 1st DMA buffer entry */</span>
	<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_entry</span><span class="p">;</span>
	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NRARL</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">phys_addr</span> <span class="p">);</span>
	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NRARU</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)(</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* Clear the Rx DMA status bits (read RDMR) and start channel */</span>
	<span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDMR</span> <span class="p">);</span>
	<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_InitRxChannel</span> <span class="p">);</span>

	<span class="cm">/* Enable Receiver (RMR &lt;1..0&gt; = 10) */</span>
	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RMR</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">RMR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffc</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0002</span><span class="p">)</span> <span class="p">);</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>


	<span class="cm">/*************************************************************/</span>
	<span class="cm">/* WAIT FOR RECEIVER TO DMA ALL PARAMETERS FROM BUFFER ENTRY */</span>
	<span class="cm">/*************************************************************/</span>

	<span class="cm">/* Wait 100ms for interrupt. */</span>
	<span class="n">EndTime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">EndTime</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usc_InDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RDMR</span> <span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BIT4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BIT5</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* INITG (BIT 4) is inactive (no entry read in progress) AND */</span>
			<span class="cm">/* BUSY  (BIT 5) is active (channel still active). */</span>
			<span class="cm">/* This means the buffer entry read has completed. */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/******************************/</span>
	<span class="cm">/* Program 16C32 transmitter. */</span>
	<span class="cm">/******************************/</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Program the Transmit Character Length Register (TCLR) */</span>
	<span class="cm">/* and clear FIFO (TCC is loaded with TCLR on FIFO clear) */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCLR</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="p">);</span>
	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeTxFifo</span> <span class="p">);</span>

	<span class="cm">/* Program the address of the 1st DMA Buffer Entry in linked list */</span>

	<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">phys_entry</span><span class="p">;</span>
	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NTARL</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">phys_addr</span> <span class="p">);</span>
	<span class="n">usc_OutDmaReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">NTARU</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)(</span><span class="n">phys_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">);</span>

	<span class="cm">/* unlatch Tx status bits, and start transmit channel. */</span>

	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCSR</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)((</span> <span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TCSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f00</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xfa</span><span class="p">)</span> <span class="p">);</span>
	<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_InitTxChannel</span> <span class="p">);</span>

	<span class="cm">/* wait for DMA controller to fill transmit FIFO */</span>

	<span class="n">usc_TCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCmd_SelectTicrTxFifostatus</span> <span class="p">);</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>


	<span class="cm">/**********************************/</span>
	<span class="cm">/* WAIT FOR TRANSMIT FIFO TO FILL */</span>
	<span class="cm">/**********************************/</span>
	
	<span class="cm">/* Wait 100ms */</span>
	<span class="n">EndTime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">EndTime</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">FifoLevel</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TICR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			
		<span class="k">if</span> <span class="p">(</span> <span class="n">FifoLevel</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">FrameSize</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* This frame is smaller than the entire transmit FIFO */</span>
				<span class="cm">/* so wait for the entire frame to be loaded. */</span>
				<span class="k">if</span> <span class="p">(</span> <span class="n">FifoLevel</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">FrameSize</span><span class="p">)</span> <span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Enable 16C32 transmitter. */</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		
		<span class="cm">/* Transmit mode Register (TMR), &lt;1..0&gt; = 10, Enable Transmitter */</span>
		<span class="n">usc_TCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCmd_SendFrame</span> <span class="p">);</span>
		<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TMR</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)((</span><span class="n">usc_InReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">TMR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffc</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x0002</span><span class="p">)</span> <span class="p">);</span>
		
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

						
		<span class="cm">/******************************/</span>
		<span class="cm">/* WAIT FOR TRANSMIT COMPLETE */</span>
		<span class="cm">/******************************/</span>

		<span class="cm">/* Wait 100ms */</span>
		<span class="n">EndTime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="cm">/* While timer not expired wait for transmit complete */</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCSR</span> <span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BIT6</span><span class="o">+</span><span class="n">BIT5</span><span class="o">+</span><span class="n">BIT4</span><span class="o">+</span><span class="n">BIT2</span><span class="o">+</span><span class="n">BIT1</span><span class="p">))</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">EndTime</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">TCSR</span> <span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="p">){</span>
		<span class="cm">/* CHECK FOR TRANSMIT ERRORS */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BIT5</span> <span class="o">+</span> <span class="n">BIT1</span><span class="p">)</span> <span class="p">)</span> 
			<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* WAIT FOR RECEIVE COMPLETE */</span>

		<span class="cm">/* Wait 100ms */</span>
		<span class="n">EndTime</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="cm">/* Wait for 16C32 to write receive status to buffer entry. */</span>
		<span class="n">status</span><span class="o">=</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">status</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">EndTime</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">status</span><span class="o">=</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* CHECK FOR RECEIVE ERRORS */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BIT8</span> <span class="o">+</span> <span class="n">BIT3</span> <span class="o">+</span> <span class="n">BIT1</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* receive error has occurred */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">memcmp</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">virt_addr</span> <span class="p">,</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">rx_buffer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">virt_addr</span><span class="p">,</span> <span class="n">FrameSize</span> <span class="p">)</span> <span class="p">){</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">usc_reset</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* restore current port options */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tmp_params</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MGSL_PARAMS</span><span class="p">));</span>
	
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_dma_test() */</span>

<span class="cm">/* mgsl_adapter_test()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Perform the register, IRQ, and DMA tests for the 16C32.</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	0 if success, otherwise -ENODEV</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_adapter_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Testing device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">mgsl_register_test</span><span class="p">(</span> <span class="n">info</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">init_error</span> <span class="o">=</span> <span class="n">DiagStatus_AddressFailure</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Register test failure for device %s Addr=%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">mgsl_irq_test</span><span class="p">(</span> <span class="n">info</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">init_error</span> <span class="o">=</span> <span class="n">DiagStatus_IrqFailure</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):Interrupt test failure for device %s IRQ=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">mgsl_dma_test</span><span class="p">(</span> <span class="n">info</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">init_error</span> <span class="o">=</span> <span class="n">DiagStatus_DmaFailure</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):DMA test failure for device %s DMA=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):device %s passed diagnostics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span> <span class="p">);</span>
			
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* end of mgsl_adapter_test() */</span>

<span class="cm">/* mgsl_memory_test()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Test the shared memory on a PCI adapter.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:		info	pointer to device instance data</span>
<span class="cm"> * Return Value:	true if test passed, otherwise false</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mgsl_memory_test</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">BitPatterns</span><span class="p">[]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x55555555</span><span class="p">,</span> <span class="mh">0xaaaaaaaa</span><span class="p">,</span> <span class="mh">0x66666666</span><span class="p">,</span> <span class="mh">0x99999999</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0x12345678</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Patterncount</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">BitPatterns</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">TestLimit</span> <span class="o">=</span> <span class="n">SHARED_MEM_ADDRESS_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">TestAddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">!=</span> <span class="n">MGSL_BUS_TYPE_PCI</span> <span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">TestAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span><span class="p">;</span>

	<span class="cm">/* Test data lines with test pattern at one location. */</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Patterncount</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">TestAddr</span> <span class="o">=</span> <span class="n">BitPatterns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">TestAddr</span> <span class="o">!=</span> <span class="n">BitPatterns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Test address lines with incrementing pattern over */</span>
	<span class="cm">/* entire address range. */</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TestLimit</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">TestAddr</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">TestAddr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TestAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TestLimit</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">TestAddr</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">TestAddr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">memory_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SHARED_MEM_ADDRESS_SIZE</span> <span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="p">}</span>	<span class="cm">/* End Of mgsl_memory_test() */</span>


<span class="cm">/* mgsl_load_pci_memory()</span>
<span class="cm"> * </span>
<span class="cm"> * 	Load a large block of data into the PCI shared memory.</span>
<span class="cm"> * 	Use this instead of memcpy() or memmove() to move data</span>
<span class="cm"> * 	into the PCI shared memory.</span>
<span class="cm"> * </span>
<span class="cm"> * Notes:</span>
<span class="cm"> * </span>
<span class="cm"> * 	This function prevents the PCI9050 interface chip from hogging</span>
<span class="cm"> * 	the adapter local bus, which can starve the 16C32 by preventing</span>
<span class="cm"> * 	16C32 bus master cycles.</span>
<span class="cm"> * </span>
<span class="cm"> * 	The PCI9050 documentation says that the 9050 will always release</span>
<span class="cm"> * 	control of the local bus after completing the current read</span>
<span class="cm"> * 	or write operation.</span>
<span class="cm"> * </span>
<span class="cm"> * 	It appears that as long as the PCI9050 write FIFO is full, the</span>
<span class="cm"> * 	PCI9050 treats all of the writes as a single burst transaction</span>
<span class="cm"> * 	and will not release the bus. This causes DMA latency problems</span>
<span class="cm"> * 	at high speeds when copying large data blocks to the shared</span>
<span class="cm"> * 	memory.</span>
<span class="cm"> * </span>
<span class="cm"> * 	This function in effect, breaks the a large shared memory write</span>
<span class="cm"> * 	into multiple transations by interleaving a shared memory read</span>
<span class="cm"> * 	which will flush the write FIFO and &#39;complete&#39; the write</span>
<span class="cm"> * 	transation. This allows any pending DMA request to gain control</span>
<span class="cm"> * 	of the local bus in a timely fasion.</span>
<span class="cm"> * </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> * </span>
<span class="cm"> * 	TargetPtr	pointer to target address in PCI shared memory</span>
<span class="cm"> * 	SourcePtr	pointer to source buffer for data</span>
<span class="cm"> * 	count		count in bytes of data to copy</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_load_pci_memory</span><span class="p">(</span> <span class="kt">char</span><span class="o">*</span> <span class="n">TargetPtr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">SourcePtr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">count</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* 16 32-bit writes @ 60ns each = 960ns max latency on local bus */</span>
<span class="cp">#define PCI_LOAD_INTERVAL 64</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">Intervalcount</span> <span class="o">=</span> <span class="n">count</span> <span class="o">/</span> <span class="n">PCI_LOAD_INTERVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">Index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Dummy</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="n">Index</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">Index</span> <span class="o">&lt;</span> <span class="n">Intervalcount</span> <span class="p">;</span> <span class="n">Index</span><span class="o">++</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">TargetPtr</span><span class="p">,</span> <span class="n">SourcePtr</span><span class="p">,</span> <span class="n">PCI_LOAD_INTERVAL</span><span class="p">);</span>
		<span class="n">Dummy</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">TargetPtr</span><span class="p">);</span>
		<span class="n">TargetPtr</span> <span class="o">+=</span> <span class="n">PCI_LOAD_INTERVAL</span><span class="p">;</span>
		<span class="n">SourcePtr</span> <span class="o">+=</span> <span class="n">PCI_LOAD_INTERVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span> <span class="n">TargetPtr</span><span class="p">,</span> <span class="n">SourcePtr</span><span class="p">,</span> <span class="n">count</span> <span class="o">%</span> <span class="n">PCI_LOAD_INTERVAL</span> <span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* End Of mgsl_load_pci_memory() */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_trace_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xmit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">linecount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xmit</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s tx data:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s rx data:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
		
	<span class="k">while</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
			<span class="n">linecount</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">linecount</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">linecount</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02X &quot;</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">for</span><span class="p">(;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">17</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;   &quot;</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">linecount</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="mo">040</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="mo">0176</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		
		<span class="n">data</span>  <span class="o">+=</span> <span class="n">linecount</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">linecount</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>	<span class="cm">/* end of mgsl_trace_block() */</span>

<span class="cm">/* mgsl_tx_timeout()</span>
<span class="cm"> * </span>
<span class="cm"> * 	called when HDLC frame times out</span>
<span class="cm"> * 	update stats and do tx completion processing</span>
<span class="cm"> * 	</span>
<span class="cm"> * Arguments:	context		pointer to device instance data</span>
<span class="cm"> * Return Value:	None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mgsl_tx_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span><span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span> <span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span> <span class="s">&quot;%s(%d):mgsl_tx_timeout(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">device_name</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_HDLC</span> <span class="o">||</span>
	    <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MGSL_MODE_RAW</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">txtimeout</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_head</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_HDLC_LOOPMODE</span> <span class="p">)</span>
		<span class="n">usc_loopmode_cancel_transmit</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="p">)</span>
		<span class="n">hdlcdev_tx_done</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">mgsl_bh_transmit</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	
<span class="p">}</span>	<span class="cm">/* end of mgsl_tx_timeout() */</span>

<span class="cm">/* signal that there are no more frames to send, so that</span>
<span class="cm"> * line is &#39;released&#39; by echoing RxD to TxD when current</span>
<span class="cm"> * transmission is complete (or immediately if no tx in progress).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mgsl_loopmode_send_done</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HDLC_FLAG_HDLC_LOOPMODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopmode_send_done_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">usc_loopmode_send_done</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* release the line by echoing RxD to TxD</span>
<span class="cm"> * upon completion of a transmit frame</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_loopmode_send_done</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
 	<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopmode_send_done_requested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
 	<span class="cm">/* clear CMR:13 to 0 to start echoing RxData to TxData */</span>
 	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT13</span><span class="p">;</span>			  
 	<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">CMR</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* abort a transmit in progress while in HDLC LoopMode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_loopmode_cancel_transmit</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
 	<span class="cm">/* reset tx dma channel and purge TxFifo */</span>
 	<span class="n">usc_RTCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RTCmd_PurgeTxFifo</span> <span class="p">);</span>
 	<span class="n">usc_DmaCmd</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">DmaCmd_ResetTxChannel</span> <span class="p">);</span>
  	<span class="n">usc_loopmode_send_done</span><span class="p">(</span> <span class="n">info</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* for HDLC/SDLC LoopMode, setting CMR:13 after the transmitter is enabled</span>
<span class="cm"> * is an Insert Into Loop action. Upon receipt of a GoAhead sequence (RxAbort)</span>
<span class="cm"> * we must clear CMR:13 to begin repeating TxData to RxData</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">usc_loopmode_insert_request</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span> <span class="p">)</span>
<span class="p">{</span>
 	<span class="n">info</span><span class="o">-&gt;</span><span class="n">loopmode_insert_requested</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 
 	<span class="cm">/* enable RxAbort irq. On next RxAbort, clear CMR:13 to</span>
<span class="cm"> 	 * begin repeating TxData on RxData (complete insertion)</span>
<span class="cm">	 */</span>
 	<span class="n">usc_OutReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RICR</span><span class="p">,</span> 
		<span class="p">(</span><span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">RICR</span> <span class="p">)</span> <span class="o">|</span> <span class="n">RXSTATUS_ABORT_RECEIVED</span> <span class="p">)</span> <span class="p">);</span>
		
	<span class="cm">/* set CMR:13 to insert into loop on next GoAhead (RxAbort) */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span> <span class="o">|=</span> <span class="n">BIT13</span><span class="p">;</span>
 	<span class="n">usc_OutReg</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">CMR</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cmr_value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* return 1 if station is inserted into the loop, otherwise 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usc_loopmode_active</span><span class="p">(</span> <span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="k">return</span> <span class="n">usc_InReg</span><span class="p">(</span> <span class="n">info</span><span class="p">,</span> <span class="n">CCSR</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">BIT7</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if SYNCLINK_GENERIC_HDLC</span>

<span class="cm">/**</span>
<span class="cm"> * called by generic HDLC layer when protocol selected (PPP, frame relay, etc.)</span>
<span class="cm"> * set encoding and frame check sequence (FCS) options</span>
<span class="cm"> *</span>
<span class="cm"> * dev       pointer to network device structure</span>
<span class="cm"> * encoding  serial encoding setting</span>
<span class="cm"> * parity    FCS setting</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hdlcdev_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">encoding</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">parity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev_to_port</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">new_encoding</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">new_crctype</span><span class="p">;</span>

	<span class="cm">/* return error if TTY interface open */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="n">ENCODING_NRZ</span>:        <span class="n">new_encoding</span> <span class="o">=</span> <span class="n">HDLC_ENCODING_NRZ</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ENCODING_NRZI</span>:       <span class="n">new_encoding</span> <span class="o">=</span> <span class="n">HDLC_ENCODING_NRZI_SPACE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ENCODING_FM_MARK</span>:    <span class="n">new_encoding</span> <span class="o">=</span> <span class="n">HDLC_ENCODING_BIPHASE_MARK</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ENCODING_FM_SPACE</span>:   <span class="n">new_encoding</span> <span class="o">=</span> <span class="n">HDLC_ENCODING_BIPHASE_SPACE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ENCODING_MANCHESTER</span>: <span class="n">new_encoding</span> <span class="o">=</span> <span class="n">HDLC_ENCODING_BIPHASE_LEVEL</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">parity</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="n">PARITY_NONE</span>:            <span class="n">new_crctype</span> <span class="o">=</span> <span class="n">HDLC_CRC_NONE</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PARITY_CRC16_PR1_CCITT</span>: <span class="n">new_crctype</span> <span class="o">=</span> <span class="n">HDLC_CRC_16_CCITT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PARITY_CRC32_PR1_CCITT</span>: <span class="n">new_crctype</span> <span class="o">=</span> <span class="n">HDLC_CRC_32_CCITT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">new_encoding</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">crc_type</span> <span class="o">=</span> <span class="n">new_crctype</span><span class="p">;</span>

	<span class="cm">/* if network interface up, reprogram hardware */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="p">)</span>
		<span class="n">mgsl_program_hw</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * called by generic HDLC layer to send frame</span>
<span class="cm"> *</span>
<span class="cm"> * skb  socket buffer containing HDLC frame</span>
<span class="cm"> * dev  pointer to network device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">hdlcdev_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev_to_port</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s:hdlc_xmit(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* stop sending until this frame completes */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* copy data to device buffers */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">xmit_cnt</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">mgsl_load_tx_dma_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* update network statistics */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* done with socket buffer, so free it */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* save start time for transmit timeout detection */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* start hardware transmitter if necessary */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tx_active</span><span class="p">)</span>
	 	<span class="n">usc_start_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * called by network layer when interface enabled</span>
<span class="cm"> * claim resources and initialize hardware</span>
<span class="cm"> *</span>
<span class="cm"> * dev  pointer to network device structure</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hdlcdev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev_to_port</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:hdlcdev_open(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* generic HDLC layer open processing */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">hdlc_open</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* arbitrate between network and tty opens */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: hdlc_open returning busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* claim resources and init adapter */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">startup</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* assert DTR and RTS, apply hardware settings */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">|=</span> <span class="n">SerialSignal_RTS</span> <span class="o">+</span> <span class="n">SerialSignal_DTR</span><span class="p">;</span>
	<span class="n">mgsl_program_hw</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* enable network layer transmit */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* inform generic HDLC layer of current DCD status */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">usc_get_serial_signals</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">serial_signals</span> <span class="o">&amp;</span> <span class="n">SerialSignal_DCD</span><span class="p">)</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * called by network layer when interface is disabled</span>
<span class="cm"> * shutdown hardware and release resources</span>
<span class="cm"> *</span>
<span class="cm"> * dev  pointer to network device structure</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hdlcdev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev_to_port</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:hdlcdev_close(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* shutdown adapter and release resources */</span>
	<span class="n">shutdown</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="n">hdlc_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * called by network layer to process IOCTL call to network device</span>
<span class="cm"> *</span>
<span class="cm"> * dev  pointer to network device structure</span>
<span class="cm"> * ifr  pointer to network interface request structure</span>
<span class="cm"> * cmd  IOCTL command code</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hdlcdev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sync_serial_settings</span><span class="p">);</span>
	<span class="n">sync_serial_settings</span> <span class="n">new_line</span><span class="p">;</span>
	<span class="n">sync_serial_settings</span> <span class="n">__user</span> <span class="o">*</span><span class="n">line</span> <span class="o">=</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_settings</span><span class="p">.</span><span class="n">ifs_ifsu</span><span class="p">.</span><span class="n">sync</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev_to_port</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s:hdlcdev_ioctl(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* return error if TTY interface open */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">SIOCWANDEV</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hdlc_ioctl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_settings</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IF_GET_IFACE</span>: <span class="cm">/* return current sync_serial_settings */</span>

		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_settings</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">IF_IFACE_SYNC_SERIAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_settings</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_settings</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span> <span class="cm">/* data size wanted */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_RXC_DPLL</span> <span class="o">|</span>
					      <span class="n">HDLC_FLAG_RXC_BRG</span>    <span class="o">|</span> <span class="n">HDLC_FLAG_RXC_TXCPIN</span> <span class="o">|</span>
					      <span class="n">HDLC_FLAG_TXC_TXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_DPLL</span> <span class="o">|</span>
					      <span class="n">HDLC_FLAG_TXC_BRG</span>    <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_RXCPIN</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">flags</span><span class="p">){</span>
		<span class="k">case</span> <span class="p">(</span><span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_TXCPIN</span><span class="p">)</span>: <span class="n">new_line</span><span class="p">.</span><span class="n">clock_type</span> <span class="o">=</span> <span class="n">CLOCK_EXT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="p">(</span><span class="n">HDLC_FLAG_RXC_BRG</span>    <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_BRG</span><span class="p">)</span>:    <span class="n">new_line</span><span class="p">.</span><span class="n">clock_type</span> <span class="o">=</span> <span class="n">CLOCK_INT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="p">(</span><span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_BRG</span><span class="p">)</span>:    <span class="n">new_line</span><span class="p">.</span><span class="n">clock_type</span> <span class="o">=</span> <span class="n">CLOCK_TXINT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="p">(</span><span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_RXCPIN</span><span class="p">)</span>: <span class="n">new_line</span><span class="p">.</span><span class="n">clock_type</span> <span class="o">=</span> <span class="n">CLOCK_TXFROMRX</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="n">new_line</span><span class="p">.</span><span class="n">clock_type</span> <span class="o">=</span> <span class="n">CLOCK_DEFAULT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">new_line</span><span class="p">.</span><span class="n">clock_rate</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span><span class="p">;</span>
		<span class="n">new_line</span><span class="p">.</span><span class="n">loopback</span>   <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">loopback</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_line</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IF_IFACE_SYNC_SERIAL</span>: <span class="cm">/* set sync_serial_settings */</span>

		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_line</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">new_line</span><span class="p">.</span><span class="n">clock_type</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">case</span> <span class="n">CLOCK_EXT</span>:      <span class="n">flags</span> <span class="o">=</span> <span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_TXCPIN</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CLOCK_TXFROMRX</span>: <span class="n">flags</span> <span class="o">=</span> <span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_RXCPIN</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CLOCK_INT</span>:      <span class="n">flags</span> <span class="o">=</span> <span class="n">HDLC_FLAG_RXC_BRG</span>    <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_BRG</span><span class="p">;</span>    <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CLOCK_TXINT</span>:    <span class="n">flags</span> <span class="o">=</span> <span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_BRG</span><span class="p">;</span>    <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CLOCK_DEFAULT</span>:  <span class="n">flags</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span>
					     <span class="p">(</span><span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_RXC_DPLL</span> <span class="o">|</span>
					      <span class="n">HDLC_FLAG_RXC_BRG</span>    <span class="o">|</span> <span class="n">HDLC_FLAG_RXC_TXCPIN</span> <span class="o">|</span>
					      <span class="n">HDLC_FLAG_TXC_TXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_DPLL</span> <span class="o">|</span>
					      <span class="n">HDLC_FLAG_TXC_BRG</span>    <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_RXCPIN</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_line</span><span class="p">.</span><span class="n">loopback</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_line</span><span class="p">.</span><span class="n">loopback</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HDLC_FLAG_RXC_RXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_RXC_DPLL</span> <span class="o">|</span>
					<span class="n">HDLC_FLAG_RXC_BRG</span>    <span class="o">|</span> <span class="n">HDLC_FLAG_RXC_TXCPIN</span> <span class="o">|</span>
					<span class="n">HDLC_FLAG_TXC_TXCPIN</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_DPLL</span> <span class="o">|</span>
					<span class="n">HDLC_FLAG_TXC_BRG</span>    <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_RXCPIN</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">loopback</span> <span class="o">=</span> <span class="n">new_line</span><span class="p">.</span><span class="n">loopback</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HDLC_FLAG_RXC_BRG</span> <span class="o">|</span> <span class="n">HDLC_FLAG_TXC_BRG</span><span class="p">))</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span> <span class="o">=</span> <span class="n">new_line</span><span class="p">.</span><span class="n">clock_rate</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">clock_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* if network interface up, reprogram hardware */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netcount</span><span class="p">)</span>
			<span class="n">mgsl_program_hw</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">hdlc_ioctl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * called by network layer when transmit timeout is detected</span>
<span class="cm"> *</span>
<span class="cm"> * dev  pointer to network device structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hdlcdev_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev_to_port</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;hdlcdev_tx_timeout(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">usc_stop_transmitter</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * called by device driver when transmit completes</span>
<span class="cm"> * reenable network layer transmit if stopped</span>
<span class="cm"> *</span>
<span class="cm"> * info  pointer to device instance information</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hdlcdev_tx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * called by device driver when frame received</span>
<span class="cm"> * pass frame to network layer</span>
<span class="cm"> *</span>
<span class="cm"> * info  pointer to device instance information</span>
<span class="cm"> * buf   pointer to buffer contianing frame data</span>
<span class="cm"> * size  count of data bytes in buf</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hdlcdev_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_level</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;hdlcdev_rx(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;%s: can&#39;t alloc skb, dropping packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">hdlc_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">hdlcdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>       <span class="o">=</span> <span class="n">hdlcdev_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>       <span class="o">=</span> <span class="n">hdlcdev_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span> <span class="o">=</span> <span class="n">hdlc_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">hdlc_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>   <span class="o">=</span> <span class="n">hdlcdev_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> <span class="o">=</span> <span class="n">hdlcdev_tx_timeout</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * called by device driver when adding device instance</span>
<span class="cm"> * do generic HDLC initialization</span>
<span class="cm"> *</span>
<span class="cm"> * info  pointer to device instance information</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hdlcdev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">hdlc_device</span> <span class="o">*</span><span class="n">hdlc</span><span class="p">;</span>

	<span class="cm">/* allocate and initialize network and HDLC layer objects */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_hdlcdev</span><span class="p">(</span><span class="n">info</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s:hdlc device allocation failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* for network layer reporting purposes only */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span>       <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span>       <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma_level</span><span class="p">;</span>

	<span class="cm">/* network layer callbacks and settings */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">hdlcdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span>   <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

	<span class="cm">/* generic HDLC layer callbacks and settings */</span>
	<span class="n">hdlc</span>         <span class="o">=</span> <span class="n">dev_to_hdlc</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">hdlc</span><span class="o">-&gt;</span><span class="n">attach</span> <span class="o">=</span> <span class="n">hdlcdev_attach</span><span class="p">;</span>
	<span class="n">hdlc</span><span class="o">-&gt;</span><span class="n">xmit</span>   <span class="o">=</span> <span class="n">hdlcdev_xmit</span><span class="p">;</span>

	<span class="cm">/* register objects with HDLC layer */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">register_hdlc_device</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s:unable to register hdlc device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * called by device driver when removing device instance</span>
<span class="cm"> * do generic HDLC cleanup</span>
<span class="cm"> *</span>
<span class="cm"> * info  pointer to device instance information</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hdlcdev_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_hdlc_device</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_HDLC */</span><span class="cp"></span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">synclink_init_one</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mgsl_struct</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;error enabling pci device %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">info</span> <span class="o">=</span> <span class="n">mgsl_allocate_device</span><span class="p">()))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;can&#39;t allocate device instance data.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

        <span class="cm">/* Copy user configuration info to device instance data */</span>
		
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_level</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_memory_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
				
        <span class="cm">/* Because veremap only works on page boundaries we must map</span>
<span class="cm">	 * a larger area than is actually implemented for the LCR</span>
<span class="cm">	 * memory range. We map a full page starting at the page boundary.</span>
<span class="cm">	 */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">lcr_offset</span>    <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">phys_lcr_base</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
				
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">=</span> <span class="n">MGSL_BUS_TYPE_PCI</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">io_addr_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq_flags</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="mh">0x0210</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Version 1 PCI9030 based universal PCI adapter */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">misc_ctrl_value</span> <span class="o">=</span> <span class="mh">0x007c4080</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Version 0 PCI9050 based 5V PCI adapter</span>
<span class="cm">		 * A PCI9050 bug prevents reading LCR registers if </span>
<span class="cm">		 * LCR base address bit 7 is set. Maintain shadow</span>
<span class="cm">		 * value so we can write to LCR misc control reg.</span>
<span class="cm">		 */</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">misc_ctrl_value</span> <span class="o">=</span> <span class="mh">0x087e4546</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
				
	<span class="n">mgsl_add_device</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">synclink_remove_one</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
