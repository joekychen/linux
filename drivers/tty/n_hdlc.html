<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › n_hdlc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>n_hdlc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* generic HDLC line discipline for Linux</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Paul Fulghum paulkf@microgate.com</span>
<span class="cm"> * for Microgate Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Microgate and SyncLink are registered trademarks of Microgate Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * Adapted from ppp.c, written by Michael Callahan &lt;callahan@maths.ox.ac.uk&gt;,</span>
<span class="cm"> *	Al Longyear &lt;longyear@netcom.com&gt;,</span>
<span class="cm"> *	Paul Mackerras &lt;Paul.Mackerras@cs.anu.edu.au&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Original release 01/11/99</span>
<span class="cm"> *</span>
<span class="cm"> * This code is released under the GNU General Public License (GPL)</span>
<span class="cm"> *</span>
<span class="cm"> * This module implements the tty line discipline N_HDLC for use with</span>
<span class="cm"> * tty device drivers that support bit-synchronous HDLC communications.</span>
<span class="cm"> *</span>
<span class="cm"> * All HDLC data is frame oriented which means:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. tty write calls represent one complete transmit frame of data</span>
<span class="cm"> *    The device driver should accept the complete frame or none of </span>
<span class="cm"> *    the frame (busy) in the write method. Each write call should have</span>
<span class="cm"> *    a byte count in the range of 2-65535 bytes (2 is min HDLC frame</span>
<span class="cm"> *    with 1 addr byte and 1 ctrl byte). The max byte count of 65535</span>
<span class="cm"> *    should include any crc bytes required. For example, when using</span>
<span class="cm"> *    CCITT CRC32, 4 crc bytes are required, so the maximum size frame</span>
<span class="cm"> *    the application may transmit is limited to 65531 bytes. For CCITT</span>
<span class="cm"> *    CRC16, the maximum application frame size would be 65533.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 2. receive callbacks from the device driver represents</span>
<span class="cm"> *    one received frame. The device driver should bypass</span>
<span class="cm"> *    the tty flip buffer and call the line discipline receive</span>
<span class="cm"> *    callback directly to avoid fragmenting or concatenating</span>
<span class="cm"> *    multiple frames into a single receive callback.</span>
<span class="cm"> *</span>
<span class="cm"> *    The HDLC line discipline queues the receive frames in separate</span>
<span class="cm"> *    buffers so complete receive frames can be returned by the</span>
<span class="cm"> *    tty read calls.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. tty read calls returns an entire frame of data or nothing.</span>
<span class="cm"> *    </span>
<span class="cm"> * 4. all send and receive data is considered raw. No processing</span>
<span class="cm"> *    or translation is performed by the line discipline, regardless</span>
<span class="cm"> *    of the tty flags</span>
<span class="cm"> *</span>
<span class="cm"> * 5. When line discipline is queried for the amount of receive</span>
<span class="cm"> *    data available (FIOC), 0 is returned if no data available,</span>
<span class="cm"> *    otherwise the count of the next available frame is returned.</span>
<span class="cm"> *    (instead of the sum of all received frame counts).</span>
<span class="cm"> *</span>
<span class="cm"> * These conventions allow the standard tty programming interface</span>
<span class="cm"> * to be used for synchronous HDLC applications when used with</span>
<span class="cm"> * this line discipline (or another line discipline that is frame</span>
<span class="cm"> * oriented such as N_PPP).</span>
<span class="cm"> *</span>
<span class="cm"> * The SyncLink driver (synclink.c) implements both asynchronous</span>
<span class="cm"> * (using standard line discipline N_TTY) and synchronous HDLC</span>
<span class="cm"> * (using N_HDLC) communications, with the latter using the above</span>
<span class="cm"> * conventions.</span>
<span class="cm"> *</span>
<span class="cm"> * This implementation is very basic and does not maintain</span>
<span class="cm"> * any statistics. The main point is to enforce the raw data</span>
<span class="cm"> * and frame orientation of HDLC communications.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<span class="cm"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,</span>
<span class="cm"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="cm"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="cm"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED</span>
<span class="cm"> * OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#define HDLC_MAGIC 0x239e</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>

<span class="cp">#undef VERSION</span>
<span class="cp">#define VERSION(major,minor,patch) (((((major)&lt;&lt;8)+(minor))&lt;&lt;8)+(patch))</span>

<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;	</span><span class="cm">/* used in new tty drivers */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/signal.h&gt;	</span><span class="cm">/* used in new tty drivers */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/if.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/termios.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Buffers for individual HDLC frames</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_HDLC_FRAME_SIZE 65535 </span>
<span class="cp">#define DEFAULT_RX_BUF_COUNT 10</span>
<span class="cp">#define MAX_RX_BUF_COUNT 60</span>
<span class="cp">#define DEFAULT_TX_BUF_COUNT 3</span>

<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="kt">int</span>		  <span class="n">count</span><span class="p">;</span>
	<span class="kt">char</span>		  <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define	N_HDLC_BUF_SIZE	(sizeof(struct n_hdlc_buf) + maxframe)</span>

<span class="k">struct</span> <span class="n">n_hdlc_buf_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="kt">int</span>		  <span class="n">count</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	  <span class="n">spinlock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct n_hdlc - per device instance data structure</span>
<span class="cm"> * @magic - magic value for structure</span>
<span class="cm"> * @flags - miscellaneous control flags</span>
<span class="cm"> * @tty - ptr to TTY structure</span>
<span class="cm"> * @backup_tty - TTY to use if tty gets closed</span>
<span class="cm"> * @tbusy - reentrancy flag for tx wakeup code</span>
<span class="cm"> * @woke_up - FIXME: describe this field</span>
<span class="cm"> * @tbuf - currently transmitting tx buffer</span>
<span class="cm"> * @tx_buf_list - list of pending transmit frame buffers</span>
<span class="cm"> * @rx_buf_list - list of received frame buffers</span>
<span class="cm"> * @tx_free_buf_list - list unused transmit frame buffers</span>
<span class="cm"> * @rx_free_buf_list - list unused received frame buffers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">magic</span><span class="p">;</span>
	<span class="n">__u32</span>			<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span>	<span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span>	<span class="o">*</span><span class="n">backup_tty</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">tbusy</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">woke_up</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span>	<span class="o">*</span><span class="n">tbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf_list</span>	<span class="n">tx_buf_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf_list</span>	<span class="n">rx_buf_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf_list</span>	<span class="n">tx_free_buf_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf_list</span>	<span class="n">rx_free_buf_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * HDLC buffer list manipulation functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">n_hdlc_buf_list_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">n_hdlc_buf_list</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">n_hdlc_buf_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">n_hdlc_buf_list</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>

<span class="cm">/* Local functions */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc_alloc</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* debug level can be set by insmod for debugging purposes */</span>
<span class="cp">#define DEBUG_LEVEL_INFO	1</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debuglevel</span><span class="p">;</span>

<span class="cm">/* max frame size for memory allocations */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">maxframe</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>

<span class="cm">/* TTY callbacks */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">n_hdlc_tty_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			   <span class="n">__u8</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">n_hdlc_tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">n_hdlc_tty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n_hdlc_tty_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				    <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">n_hdlc_tty_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">n_hdlc_tty_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">n_hdlc_tty_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">n_hdlc_tty_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>

<span class="cp">#define bset(p,b)	((p)[(b) &gt;&gt; 5] |= (1 &lt;&lt; ((b) &amp; 0x1f)))</span>

<span class="cp">#define tty2n_hdlc(tty)	((struct n_hdlc *) ((tty)-&gt;disc_data))</span>
<span class="cp">#define n_hdlc2tty(n_hdlc)	((n_hdlc)-&gt;tty)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">buf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">)))</span>
		<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_free_buf_list</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">buf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">)))</span>
		<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_free_buf_list</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
 	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_free_buf_list</span><span class="p">,</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbuf</span><span class="p">);</span>
		<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="n">n_hdlc_ldisc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">magic</span>		<span class="o">=</span> <span class="n">TTY_LDISC_MAGIC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;hdlc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">n_hdlc_tty_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">n_hdlc_tty_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">n_hdlc_tty_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">n_hdlc_tty_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">n_hdlc_tty_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">n_hdlc_tty_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">receive_buf</span>	<span class="o">=</span> <span class="n">n_hdlc_tty_receive</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_wakeup</span>	<span class="o">=</span> <span class="n">n_hdlc_tty_wakeup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_buffer</span>   <span class="o">=</span> <span class="n">flush_rx_queue</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_release - release an n_hdlc per device line discipline info structure</span>
<span class="cm"> * @n_hdlc - per device line discipline info structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">n_hdlc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">n_hdlc2tty</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_release() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		
	<span class="cm">/* Ensure that the n_hdlcd process is not hanging on select()/poll() */</span>
	<span class="n">wake_up_interruptible</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">==</span> <span class="n">n_hdlc</span><span class="p">)</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* Break the tty-&gt;n_hdlc link */</span>

	<span class="cm">/* Release transmit and receive buffers */</span>
	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_free_buf_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_free_buf_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">n_hdlc</span><span class="p">);</span>
	
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_release() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_tty_close - line discipline close</span>
<span class="cm"> * @tty - pointer to tty info structure</span>
<span class="cm"> *</span>
<span class="cm"> * Called when the line discipline is changed to something</span>
<span class="cm"> * else, the tty is closed, or the tty detects a hangup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">n_hdlc_tty_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span> <span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_close() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">HDLC_MAGIC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_WARNING</span><span class="s">&quot;n_hdlc: trying to close unopened tty!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#if defined(TTY_NO_WRITE_SPLIT)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_NO_WRITE_SPLIT</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span> <span class="o">==</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">backup_tty</span><span class="p">)</span>
			<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">backup_tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">backup_tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">backup_tty</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">n_hdlc_release</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_close() success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_tty_close() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_tty_open - called when line discipline changed to n_hdlc</span>
<span class="cm"> * @tty - pointer to tty info structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if success, otherwise error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">n_hdlc_tty_open</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span> <span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_open() called (device=%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		
	<span class="cm">/* There should not be an existing table for this slot. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span><span class="s">&quot;n_hdlc_tty_open:tty already associated!</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">n_hdlc_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_hdlc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;n_hdlc_alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
	<span class="p">}</span>
		
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="n">n_hdlc</span><span class="p">;</span>
	<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span>    <span class="o">=</span> <span class="n">tty</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">receive_room</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>
	
<span class="cp">#if defined(TTY_NO_WRITE_SPLIT)</span>
	<span class="cm">/* change tty_io write() to not split large writes into 8K chunks */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_NO_WRITE_SPLIT</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#endif</span>
	
	<span class="cm">/* flush receive data from driver */</span>
	<span class="n">tty_driver_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_open() success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of n_tty_hdlc_open() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_send_frames - send frames on pending send buffer list</span>
<span class="cm"> * @n_hdlc - pointer to ldisc instance data</span>
<span class="cm"> * @tty - pointer to tty instance data</span>
<span class="cm"> *</span>
<span class="cm"> * Send frames on pending send buffer list until the driver does not accept a</span>
<span class="cm"> * frame (busy) this function is called after adding a frame to the send buffer</span>
<span class="cm"> * list and by the tty wakeup callback.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">n_hdlc_send_frames</span><span class="p">(</span><span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">actual</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">tbuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_send_frames() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
 <span class="nl">check_again:</span>
		
 	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbusy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">woke_up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbusy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">woke_up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* get current transmit buffer or get new transmit */</span>
	<span class="cm">/* buffer from list of pending transmit buffers */</span>
		
	<span class="n">tbuf</span> <span class="o">=</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbuf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbuf</span><span class="p">)</span>
		<span class="n">tbuf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">);</span>
		
	<span class="k">while</span> <span class="p">(</span><span class="n">tbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)sending frame %p, count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">tbuf</span><span class="p">,</span><span class="n">tbuf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
			
		<span class="cm">/* Send the next block of data to device */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">actual</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">tbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">tbuf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

		<span class="cm">/* rollback was possible and has been done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">actual</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbuf</span> <span class="o">=</span> <span class="n">tbuf</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* if transmit error, throw frame away by */</span>
		<span class="cm">/* pretending it was accepted by driver */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">actual</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">actual</span> <span class="o">=</span> <span class="n">tbuf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">actual</span> <span class="o">==</span> <span class="n">tbuf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)frame %p completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">tbuf</span><span class="p">);</span>
					
			<span class="cm">/* free current transmit buffer */</span>
			<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_free_buf_list</span><span class="p">,</span> <span class="n">tbuf</span><span class="p">);</span>
			
			<span class="cm">/* this tx buffer is done */</span>
			<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			
			<span class="cm">/* wait up sleeping writers */</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">);</span>
	
			<span class="cm">/* get next pending transmit buffer */</span>
			<span class="n">tbuf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)frame %p pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">tbuf</span><span class="p">);</span>
					
			<span class="cm">/* buffer not accepted by driver */</span>
			<span class="cm">/* set this buffer as pending buffer */</span>
			<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbuf</span> <span class="o">=</span> <span class="n">tbuf</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tbuf</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="cm">/* Clear the re-entry flag */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tbusy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span> 
	
        <span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">woke_up</span><span class="p">)</span>
	  <span class="k">goto</span> <span class="n">check_again</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_send_frames() exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_send_frames() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_tty_wakeup - Callback for transmit wakeup</span>
<span class="cm"> * @tty	- pointer to associated tty instance data</span>
<span class="cm"> *</span>
<span class="cm"> * Called when low level device driver can accept more send data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">n_hdlc_tty_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_wakeup() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_hdlc</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">n_hdlc_send_frames</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
		
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_tty_wakeup() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_tty_receive - Called by tty driver when receive data is available</span>
<span class="cm"> * @tty	- pointer to tty instance data</span>
<span class="cm"> * @data - pointer to received data</span>
<span class="cm"> * @flags - pointer to flags for data</span>
<span class="cm"> * @count - count of received data in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Called by tty low level driver when receive data is available. Data is</span>
<span class="cm"> * interpreted as one HDLC frame.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">n_hdlc_tty_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">const</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span> <span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_receive() called count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		
	<span class="cm">/* This can happen if stuff comes in on the backup tty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_hdlc</span> <span class="o">||</span> <span class="n">tty</span> <span class="o">!=</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
		
	<span class="cm">/* verify line is using HDLC discipline */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">HDLC_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d) line not using HDLC discipline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">count</span><span class="o">&gt;</span><span class="n">maxframe</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d) rx count&gt;maxframesize, data discarded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get a free HDLC buffer */</span>	
	<span class="n">buf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_free_buf_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no buffers in free list, attempt to allocate another rx buffer */</span>
		<span class="cm">/* unless the maximum count has been reached */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">MAX_RX_BUF_COUNT</span><span class="p">)</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">N_HDLC_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d) no more rx buffers, data discarded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
		
	<span class="cm">/* copy received data to HDLC buffer */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/* add HDLC buffer to list of received frames */</span>
	<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	
	<span class="cm">/* wake up any blocked reads and perform async signalling */</span>
	<span class="n">wake_up_interruptible</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">fasync</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kill_fasync</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">fasync</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>

<span class="p">}</span>	<span class="cm">/* end of n_hdlc_tty_receive() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_tty_read - Called to retrieve one frame of data (if available)</span>
<span class="cm"> * @tty - pointer to tty instance data</span>
<span class="cm"> * @file - pointer to open file object</span>
<span class="cm"> * @buf - pointer to returned data buffer</span>
<span class="cm"> * @nr - size of returned data buffer</span>
<span class="cm"> * 	</span>
<span class="cm"> * Returns the number of bytes returned or error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">n_hdlc_tty_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			   <span class="n">__u8</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_read() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		
	<span class="cm">/* Validate the pointers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_hdlc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* verify user access to buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s(%d) n_hdlc_tty_read() can&#39;t verify user &quot;</span>
		<span class="s">&quot;buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_OTHER_CLOSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="n">rbuf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rbuf</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rbuf</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* too large for caller&#39;s buffer */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">rbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">rbuf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">rbuf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_free_buf_list</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span>
			    <span class="n">DEFAULT_RX_BUF_COUNT</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">rbuf</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_free_buf_list</span><span class="p">,</span> <span class="n">rbuf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
			
		<span class="cm">/* no data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">schedule</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_tty_read() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_tty_write - write a single frame of data to device</span>
<span class="cm"> * @tty	- pointer to associated tty device instance data</span>
<span class="cm"> * @file - pointer to file object data</span>
<span class="cm"> * @data - pointer to transmit data (one frame)</span>
<span class="cm"> * @count - size of transmit frame in bytes</span>
<span class="cm"> * 		</span>
<span class="cm"> * Returns the number of bytes written (or error code).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">n_hdlc_tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span> <span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">tbuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_write() called count=%Zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
		
	<span class="cm">/* Verify pointers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_hdlc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">HDLC_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* verify frame size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">maxframe</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&amp;</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;n_hdlc_tty_write: truncating user packet &quot;</span>
				<span class="s">&quot;from %lu to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">count</span><span class="p">,</span>
				<span class="n">maxframe</span> <span class="p">);</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">maxframe</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	
		<span class="n">tbuf</span> <span class="o">=</span> <span class="n">n_hdlc_buf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_free_buf_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tbuf</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">schedule</span><span class="p">();</span>
			
		<span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span> <span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_hdlc</span> <span class="o">||</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">HDLC_MAGIC</span> <span class="o">||</span> 
		    <span class="n">tty</span> <span class="o">!=</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;n_hdlc_tty_write: %p invalid after wait!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n_hdlc</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
			
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>		
		<span class="cm">/* Retrieve the user&#39;s buffer */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

		<span class="cm">/* Send the data */</span>
		<span class="n">tbuf</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">error</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">,</span><span class="n">tbuf</span><span class="p">);</span>
		<span class="n">n_hdlc_send_frames</span><span class="p">(</span><span class="n">n_hdlc</span><span class="p">,</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_tty_write() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_tty_ioctl - process IOCTL system call for the tty device.</span>
<span class="cm"> * @tty - pointer to tty instance data</span>
<span class="cm"> * @file - pointer to open file object for device</span>
<span class="cm"> * @cmd - IOCTL command code</span>
<span class="cm"> * @arg - argument for IOCTL call (cmd dependent)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns command dependent result.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">n_hdlc_tty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span> <span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_ioctl() called %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="n">cmd</span><span class="p">);</span>
		
	<span class="cm">/* Verify the status of the device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_hdlc</span> <span class="o">||</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">HDLC_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FIONREAD</span>:
		<span class="cm">/* report count of read data available */</span>
		<span class="cm">/* in next available frame (if any) */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">.</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TIOCOUTQ</span>:
		<span class="cm">/* get the pending tx byte count in the driver */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">tty_chars_in_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="cm">/* add size of next output frame in queue */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">.</span><span class="n">spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCFLSH</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TCIOFLUSH</span>:
		<span class="k">case</span> <span class="n">TCOFLUSH</span>:
			<span class="n">flush_tx_queue</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* fall through to default */</span>

	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">n_tty_ioctl_helper</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_tty_ioctl() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_tty_poll - TTY callback for poll system call</span>
<span class="cm"> * @tty - pointer to tty instance data</span>
<span class="cm"> * @filp - pointer to open file object for device</span>
<span class="cm"> * @poll_table - wait queue for operations</span>
<span class="cm"> * </span>
<span class="cm"> * Determine which operations (read/write) will not block and return info</span>
<span class="cm"> * to caller.</span>
<span class="cm"> * Returns a bit mask containing info on which ops will not block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">n_hdlc_tty_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
				    <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">tty2n_hdlc</span> <span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_tty_poll() called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">);</span>
		
	<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span> <span class="o">&amp;&amp;</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">HDLC_MAGIC</span> <span class="o">&amp;&amp;</span> <span class="n">tty</span> <span class="o">==</span> <span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* queue current process into any wait queue that */</span>
		<span class="cm">/* may awaken in the future (read and write) */</span>

		<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
		<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

		<span class="cm">/* set bits for operations that won&#39;t block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>	<span class="cm">/* readable */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_OTHER_CLOSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty_is_writelocked</span><span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_free_buf_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>	<span class="cm">/* writable */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_tty_poll() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_alloc - allocate an n_hdlc instance data structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to newly created structure if success, otherwise %NULL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="nf">n_hdlc_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc</span> <span class="o">*</span><span class="n">n_hdlc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">n_hdlc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_hdlc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">n_hdlc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">n_hdlc</span><span class="p">));</span>

	<span class="n">n_hdlc_buf_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_free_buf_list</span><span class="p">);</span>
	<span class="n">n_hdlc_buf_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_free_buf_list</span><span class="p">);</span>
	<span class="n">n_hdlc_buf_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_buf_list</span><span class="p">);</span>
	<span class="n">n_hdlc_buf_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_buf_list</span><span class="p">);</span>
	
	<span class="cm">/* allocate free rx buffer list */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">DEFAULT_RX_BUF_COUNT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">N_HDLC_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span>
			<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">rx_free_buf_list</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_alloc(), kalloc() failed for rx buffer %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="cm">/* allocate free tx buffer list */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">DEFAULT_TX_BUF_COUNT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">N_HDLC_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span>
			<span class="n">n_hdlc_buf_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">tx_free_buf_list</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">debuglevel</span> <span class="o">&gt;=</span> <span class="n">DEBUG_LEVEL_INFO</span><span class="p">)</span>	
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(%d)n_hdlc_alloc(), kalloc() failed for tx buffer %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">__FILE__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="cm">/* Initialize the control block */</span>
	<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">magic</span>  <span class="o">=</span> <span class="n">HDLC_MAGIC</span><span class="p">;</span>
	<span class="n">n_hdlc</span><span class="o">-&gt;</span><span class="n">flags</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="n">n_hdlc</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_alloc() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_buf_list_init - initialize specified HDLC buffer list</span>
<span class="cm"> * @list - pointer to buffer list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">n_hdlc_buf_list_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">n_hdlc_buf_list</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">list</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_buf_list_init() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_buf_put - add specified HDLC buffer to tail of specified list</span>
<span class="cm"> * @list - pointer to buffer list</span>
<span class="cm"> * @buf	- pointer to buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">n_hdlc_buf_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">n_hdlc_buf_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_buf_put() */</span>

<span class="cm">/**</span>
<span class="cm"> * n_hdlc_buf_get - remove and return an HDLC buffer from list</span>
<span class="cm"> * @list - pointer to HDLC buffer list</span>
<span class="cm"> * </span>
<span class="cm"> * Remove and return an HDLC buffer from the head of the specified HDLC buffer</span>
<span class="cm"> * list.</span>
<span class="cm"> * Returns a pointer to HDLC buffer if available, otherwise %NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">n_hdlc_buf</span><span class="o">*</span> <span class="nf">n_hdlc_buf_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">n_hdlc_buf_list</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">n_hdlc_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="n">buf</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
		<span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
		<span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of n_hdlc_buf_get() */</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">hdlc_banner</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span>
	<span class="n">KERN_INFO</span> <span class="s">&quot;HDLC line discipline maxframe=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">hdlc_register_ok</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span>
	<span class="n">KERN_INFO</span> <span class="s">&quot;N_HDLC line discipline registered.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">hdlc_register_fail</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span>
	<span class="n">KERN_ERR</span> <span class="s">&quot;error registering line discipline: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">hdlc_init_fail</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span>
	<span class="n">KERN_INFO</span> <span class="s">&quot;N_HDLC: init failure %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">n_hdlc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* range check maxframe arg */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxframe</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">)</span>
		<span class="n">maxframe</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maxframe</span> <span class="o">&gt;</span> <span class="mi">65535</span><span class="p">)</span>
		<span class="n">maxframe</span> <span class="o">=</span> <span class="mi">65535</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">hdlc_banner</span><span class="p">,</span> <span class="n">maxframe</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">tty_register_ldisc</span><span class="p">(</span><span class="n">N_HDLC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_hdlc_ldisc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">hdlc_register_ok</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">hdlc_register_fail</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">hdlc_init_fail</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	
<span class="p">}</span>	<span class="cm">/* end of init_module() */</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">hdlc_unregister_ok</span><span class="p">[]</span> <span class="n">__exitdata</span> <span class="o">=</span>
	<span class="n">KERN_INFO</span> <span class="s">&quot;N_HDLC: line discipline unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">hdlc_unregister_fail</span><span class="p">[]</span> <span class="n">__exitdata</span> <span class="o">=</span>
	<span class="n">KERN_ERR</span> <span class="s">&quot;N_HDLC: can&#39;t unregister line discipline (err = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">n_hdlc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Release tty registration of line discipline */</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">tty_unregister_ldisc</span><span class="p">(</span><span class="n">N_HDLC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">hdlc_unregister_fail</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">hdlc_unregister_ok</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">n_hdlc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">n_hdlc_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Paul Fulghum paulkf@microgate.com&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debuglevel</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">maxframe</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_LDISC</span><span class="p">(</span><span class="n">N_HDLC</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
