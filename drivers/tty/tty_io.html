<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › tty_io.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tty_io.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * &#39;tty_io.c&#39; gives an orthogonal feeling to tty&#39;s, be they consoles</span>
<span class="cm"> * or rs-channels. It also implements echoing, cooked mode etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Kill-line thanks to John T Kohl, who also corrected VMIN = VTIME = 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Modified by Theodore Ts&#39;o, 9/14/92, to dynamically allocate the</span>
<span class="cm"> * tty_struct and tty_queue structures.  Previously there was an array</span>
<span class="cm"> * of 256 tty_struct&#39;s which was statically allocated, and the</span>
<span class="cm"> * tty_queue structures were allocated at boot time.  Both are now</span>
<span class="cm"> * dynamically allocated only when the tty is open.</span>
<span class="cm"> *</span>
<span class="cm"> * Also restructured routines so that there is more of a separation</span>
<span class="cm"> * between the high-level tty routines (tty_io.c and tty_ioctl.c) and</span>
<span class="cm"> * the low-level tty routines (serial.c, pty.c, console.c).  This</span>
<span class="cm"> * makes for cleaner and more compact code.  -TYT, 9/17/92</span>
<span class="cm"> *</span>
<span class="cm"> * Modified by Fred N. van Kempen, 01/29/93, to add line disciplines</span>
<span class="cm"> * which can be dynamically activated and de-activated by the line</span>
<span class="cm"> * discipline handling modules (like SLIP).</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: pay no attention to the line discipline code (yet); its</span>
<span class="cm"> * interface is still subject to change in this version...</span>
<span class="cm"> * -- TYT, 1/31/92</span>
<span class="cm"> *</span>
<span class="cm"> * Added functionality to the OPOST tty handling.  No delays, but all</span>
<span class="cm"> * other bits should be there.</span>
<span class="cm"> *	-- Nick Holloway &lt;alfie@dcs.warwick.ac.uk&gt;, 27th May 1993.</span>
<span class="cm"> *</span>
<span class="cm"> * Rewrote canonical mode and added more termios flags.</span>
<span class="cm"> * 	-- julian@uhunix.uhcc.hawaii.edu (J. Cowley), 13Jan94</span>
<span class="cm"> *</span>
<span class="cm"> * Reorganized FASYNC support so mouse code can share it.</span>
<span class="cm"> *	-- ctm@ardi.com, 9Sep95</span>
<span class="cm"> *</span>
<span class="cm"> * New TIOCLINUX variants added.</span>
<span class="cm"> *	-- mj@k332.feld.cvut.cz, 19-Nov-95</span>
<span class="cm"> *</span>
<span class="cm"> * Restrict vt switching via ioctl()</span>
<span class="cm"> *      -- grif@cs.ucr.edu, 5-Dec-95</span>
<span class="cm"> *</span>
<span class="cm"> * Move console and virtual terminal code to more appropriate files,</span>
<span class="cm"> * implement CONFIG_VT and generalize console device interface.</span>
<span class="cm"> *	-- Marko Kohtala &lt;Marko.Kohtala@hut.fi&gt;, March 97</span>
<span class="cm"> *</span>
<span class="cm"> * Rewrote tty_init_dev and tty_release_dev to eliminate races.</span>
<span class="cm"> *	-- Bill Hawes &lt;whawes@star.net&gt;, June 97</span>
<span class="cm"> *</span>
<span class="cm"> * Added devfs support.</span>
<span class="cm"> *      -- C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;, 13-Jan-1998</span>
<span class="cm"> *</span>
<span class="cm"> * Added support for a Unix98-style ptmx device.</span>
<span class="cm"> *      -- C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;, 14-Jan-1998</span>
<span class="cm"> *</span>
<span class="cm"> * Reduced memory usage for older ARM systems</span>
<span class="cm"> *      -- Russell King &lt;rmk@arm.linux.org.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Move do_SAK() into process context.  Less stack use in devfs functions.</span>
<span class="cm"> * alloc_tty_struct() always uses kmalloc()</span>
<span class="cm"> *			 -- Andrew Morton &lt;andrewm@uow.edu.eu&gt; 17Mar01</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_driver.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/devpts_fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/kd.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cp">#include &lt;linux/kbd_kern.h&gt;</span>
<span class="cp">#include &lt;linux/vt_kern.h&gt;</span>
<span class="cp">#include &lt;linux/selection.h&gt;</span>

<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>

<span class="cp">#undef TTY_DEBUG_HANGUP</span>

<span class="cp">#define TTY_PARANOIA_CHECK 1</span>
<span class="cp">#define CHECK_TTY_COUNT 1</span>

<span class="k">struct</span> <span class="n">ktermios</span> <span class="n">tty_std_termios</span> <span class="o">=</span> <span class="p">{</span>	<span class="cm">/* for the benefit of tty drivers  */</span>
	<span class="p">.</span><span class="n">c_iflag</span> <span class="o">=</span> <span class="n">ICRNL</span> <span class="o">|</span> <span class="n">IXON</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_oflag</span> <span class="o">=</span> <span class="n">OPOST</span> <span class="o">|</span> <span class="n">ONLCR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_cflag</span> <span class="o">=</span> <span class="n">B38400</span> <span class="o">|</span> <span class="n">CS8</span> <span class="o">|</span> <span class="n">CREAD</span> <span class="o">|</span> <span class="n">HUPCL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_lflag</span> <span class="o">=</span> <span class="n">ISIG</span> <span class="o">|</span> <span class="n">ICANON</span> <span class="o">|</span> <span class="n">ECHO</span> <span class="o">|</span> <span class="n">ECHOE</span> <span class="o">|</span> <span class="n">ECHOK</span> <span class="o">|</span>
		   <span class="n">ECHOCTL</span> <span class="o">|</span> <span class="n">ECHOKE</span> <span class="o">|</span> <span class="n">IEXTEN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_cc</span> <span class="o">=</span> <span class="n">INIT_C_CC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_ispeed</span> <span class="o">=</span> <span class="mi">38400</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_ospeed</span> <span class="o">=</span> <span class="mi">38400</span>
<span class="p">};</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_std_termios</span><span class="p">);</span>

<span class="cm">/* This list gets poked at by procfs and various bits of boot up code. This</span>
<span class="cm">   could do with some rationalisation such as pulling the tty proc function</span>
<span class="cm">   into this file */</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tty_drivers</span><span class="p">);</span>			<span class="cm">/* linked list of tty drivers */</span>

<span class="cm">/* Mutex to protect creating and releasing a tty. This is shared with</span>
<span class="cm">   vt.c for deeply disgusting hack reasons */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">tty_mutex</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_mutex</span><span class="p">);</span>

<span class="cm">/* Spinlock to protect the tty-&gt;tty_files list */</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">tty_files_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">tty_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">redirected_tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span>
							<span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tty_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tty_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">tty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">tty_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define tty_compat_ioctl NULL</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__tty_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tty_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">release_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__proc_set_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">proc_set_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	alloc_tty_struct	-	allocate a tty object</span>
<span class="cm"> *</span>
<span class="cm"> *	Return a new empty tty structure. The data fields have not</span>
<span class="cm"> *	been initialized in any way but has been zeroed</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">alloc_tty_struct</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	free_tty_struct		-	free a disused tty</span>
<span class="cm"> *	@tty: tty struct to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Free the write buffers, tty queue and tty memory itself.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none. Must be called after tty is definitely unused</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">free_tty_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_buf</span><span class="p">);</span>
	<span class="n">tty_buffer_free_all</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">file_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">tty_file_private</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tty_alloc_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_file_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">priv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Associate a new file with the tty structure */</span>
<span class="kt">void</span> <span class="nf">tty_add_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_file_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">tty_files</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tty_free_file - free file-&gt;private_data</span>
<span class="cm"> *</span>
<span class="cm"> * This shall be used only for fail path handling when tty_add_file was not</span>
<span class="cm"> * called yet.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tty_free_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_file_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Delete file from its tty */</span>
<span class="kt">void</span> <span class="nf">tty_del_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_file_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
	<span class="n">tty_free_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#define TTY_NUMBER(tty) ((tty)-&gt;index + (tty)-&gt;driver-&gt;name_base)</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_name	-	return tty naming</span>
<span class="cm"> *	@tty: tty structure</span>
<span class="cm"> *	@buf: buffer for output</span>
<span class="cm"> *</span>
<span class="cm"> *	Convert a tty structure into a name. The name reflects the kernel</span>
<span class="cm"> *	naming policy and if udev is in use may not reflect user space</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none</span>
<span class="cm"> */</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">tty_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span> <span class="cm">/* Hmm.  NULL pointer.  That&#39;s fun. */</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;NULL tty&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_name</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">tty_paranoia_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">routine</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef TTY_PARANOIA_CHECK</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;null TTY for (%d:%d) in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">imajor</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">routine</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">TTY_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;bad magic number for tty struct (%d:%d) in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">imajor</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">routine</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_tty_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">routine</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CHECK_TTY_COUNT</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">tty_files</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TTY_DRIVER_TYPE_PTY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">PTY_TYPE_SLAVE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">&amp;&amp;</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">!=</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Warning: dev (%s) tty-&gt;count(%d) &quot;</span>
				    <span class="s">&quot;!= #fd&#39;s(%d) in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">routine</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	get_tty_driver		-	find device of a tty</span>
<span class="cm"> *	@dev_t: device identifier</span>
<span class="cm"> *	@index: returns the index of the tty</span>
<span class="cm"> *</span>
<span class="cm"> *	This routine returns a tty driver structure, given a device number</span>
<span class="cm"> *	and also passes back the index number.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: caller must hold tty_mutex</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">get_tty_driver</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_drivers</span><span class="p">,</span> <span class="n">tty_drivers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_t</span> <span class="n">base</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">||</span> <span class="n">device</span> <span class="o">&gt;=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">device</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">tty_driver_kref_get</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CONSOLE_POLL</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_find_polling_driver	-	find device of a polled tty</span>
<span class="cm"> *	@name: name string to match</span>
<span class="cm"> *	@line: pointer to resulting tty line nr</span>
<span class="cm"> *</span>
<span class="cm"> *	This routine returns a tty driver structure, given a name</span>
<span class="cm"> *	and the condition that the tty driver is capable of polled</span>
<span class="cm"> *	operation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">tty_find_polling_driver</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tty_line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">stp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">str</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span> <span class="n">str</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">str</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">str</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">str</span> <span class="o">-</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">tty_line</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="cm">/* Search through the tty devices to look for a match */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_drivers</span><span class="p">,</span> <span class="n">tty_drivers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">stp</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">stp</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
			<span class="n">stp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">stp</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="n">stp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tty_line</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tty_line</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span>
		    <span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll_init</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll_init</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tty_line</span><span class="p">,</span> <span class="n">stp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">tty_driver_kref_get</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="o">*</span><span class="n">line</span> <span class="o">=</span> <span class="n">tty_line</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_find_polling_driver</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_check_change	-	check for POSIX terminal changes</span>
<span class="cm"> *	@tty: tty to check</span>
<span class="cm"> *</span>
<span class="cm"> *	If we try to write to, or set the state of, a terminal and we&#39;re</span>
<span class="cm"> *	not in the foreground, send a SIGTTOU.  If the signal is blocked or</span>
<span class="cm"> *	ignored, go ahead and perform the operation.  (POSIX 7.2)</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: ctrl_lock</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_check_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;tty_check_change: tty-&gt;pgrp == NULL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_pgrp</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ignored</span><span class="p">(</span><span class="n">SIGTTOU</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_current_pgrp_orphaned</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kill_pgrp</span><span class="p">(</span><span class="n">task_pgrp</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">SIGTTOU</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_SIGPENDING</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_check_change</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hung_up_tty_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hung_up_tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No kernel lock held - none needed ;) */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hung_up_tty_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span> <span class="o">|</span> <span class="n">POLLRDNORM</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">hung_up_tty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">TIOCSPGRP</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOTTY</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">hung_up_tty_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cmd</span> <span class="o">==</span> <span class="n">TIOCSPGRP</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOTTY</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">tty_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tty_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">tty_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">tty_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">tty_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">tty_compat_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tty_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">tty_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span>		<span class="o">=</span> <span class="n">tty_fasync</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">console_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">tty_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">redirected_tty_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">tty_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">tty_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">tty_compat_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">tty_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">tty_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span>		<span class="o">=</span> <span class="n">tty_fasync</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">hung_up_tty_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">hung_up_tty_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">hung_up_tty_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">hung_up_tty_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">hung_up_tty_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">hung_up_tty_compat_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">tty_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">redirect_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">redirect</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_wakeup	-	request more data</span>
<span class="cm"> *	@tty: terminal</span>
<span class="cm"> *</span>
<span class="cm"> *	Internal and external helper for wakeups of tty. This function</span>
<span class="cm"> *	informs the line discipline if present that the driver is ready</span>
<span class="cm"> *	to receive more output data.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write_wakeup</span><span class="p">)</span>
				<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
			<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="n">POLLOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_wakeup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__tty_hangup		-	actual handler for hangup events</span>
<span class="cm"> *	@work: tty device</span>
<span class="cm"> *</span>
<span class="cm"> *	This can be called by the &quot;eventd&quot; kernel thread.  That is process</span>
<span class="cm"> *	synchronous but doesn&#39;t hold any locks, so we need to make sure we</span>
<span class="cm"> *	have the appropriate locks for what we&#39;re doing.</span>
<span class="cm"> *</span>
<span class="cm"> *	The hangup event clears any pending redirections onto the hung up</span>
<span class="cm"> *	device. It ensures future writes will error and it does the needed</span>
<span class="cm"> *	line discipline hangup and signal delivery. The tty object itself</span>
<span class="cm"> *	remains intact.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		BTM</span>
<span class="cm"> *		  redirect lock for undoing redirection</span>
<span class="cm"> *		  file list lock for manipulating list of ttys</span>
<span class="cm"> *		  tty_ldisc_lock from called functions</span>
<span class="cm"> *		  termios_mutex resetting termios data</span>
<span class="cm"> *		  tasklist_lock to walk task list for hangup event</span>
<span class="cm"> *		    -&gt;siglock to protect -&gt;signal/-&gt;sighand</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__tty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">cons_filp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_file_private</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span>    <span class="n">closecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>


	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">redirect</span> <span class="o">&amp;&amp;</span> <span class="n">file_tty</span><span class="p">(</span><span class="n">redirect</span><span class="p">)</span> <span class="o">==</span> <span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">redirect</span><span class="p">;</span>
		<span class="n">redirect</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>

	<span class="n">tty_lock</span><span class="p">();</span>

	<span class="cm">/* some functions below drop BTM, so we need this bit */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_HUPPING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* inuse_filps is protected by the single tty lock,</span>
<span class="cm">	   this really needs to change if we want to flush the</span>
<span class="cm">	   workqueue with the lock held */</span>
	<span class="n">check_tty_count</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="s">&quot;tty_hangup&quot;</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
	<span class="cm">/* This breaks for file handles being sent over AF_UNIX sockets ? */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">tty_files</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">filp</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="n">redirected_tty_write</span><span class="p">)</span>
			<span class="n">cons_filp</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">!=</span> <span class="n">tty_write</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">closecount</span><span class="o">++</span><span class="p">;</span>
		<span class="n">__tty_fasync</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* can&#39;t block */</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hung_up_tty_fops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * it drops BTM and thus races with reopen</span>
<span class="cm">	 * we protect the race by TTY_HUPPING</span>
<span class="cm">	 */</span>
	<span class="n">tty_ldisc_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_each_pid_task</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">==</span> <span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="cm">/* We defer the dereferences outside fo</span>
<span class="cm">				   the tasklist lock */</span>
				<span class="n">refs</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">leader</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="n">__group_send_sig_info</span><span class="p">(</span><span class="n">SIGCONT</span><span class="p">,</span> <span class="n">SEND_SIG_PRIV</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="n">put_pid</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty_old_pgrp</span><span class="p">);</span>  <span class="cm">/* A noop */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">)</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty_old_pgrp</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="p">}</span> <span class="n">while_each_pid_task</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_THROTTLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_PUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Account for the p-&gt;signal references we killed */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">refs</span><span class="o">--</span><span class="p">)</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If one of the devices matches a console pointer, we</span>
<span class="cm">	 * cannot just call hangup() because that will cause</span>
<span class="cm">	 * tty-&gt;count and state-&gt;count to go out of sync.</span>
<span class="cm">	 * So we just call close() the right number of times.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cons_filp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">closecount</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
				<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">cons_filp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">hangup</span><span class="p">)</span>
		<span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">hangup</span><span class="p">)(</span><span class="n">tty</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to have driver/ldisc interactions beyond</span>
<span class="cm">	 * the ones we did here. The driver layer expects no</span>
<span class="cm">	 * calls after -&gt;hangup() from the ldisc side. However we</span>
<span class="cm">	 * can&#39;t yet guarantee all that.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_HUPPED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_HUPPING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">tty_ldisc_enable</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">tty_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_tty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span><span class="p">,</span> <span class="n">hangup_work</span><span class="p">);</span>

	<span class="n">__tty_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_hangup		-	trigger a hangup event</span>
<span class="cm"> *	@tty: tty to hangup</span>
<span class="cm"> *</span>
<span class="cm"> *	A carrier loss (virtual or otherwise) has occurred on this like</span>
<span class="cm"> *	schedule a hangup sequence to run after this event.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef TTY_DEBUG_HANGUP</span>
	<span class="kt">char</span>	<span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s hangup...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tty_name</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hangup_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_hangup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_vhangup		-	process vhangup</span>
<span class="cm"> *	@tty: tty to hangup</span>
<span class="cm"> *</span>
<span class="cm"> *	The user has asked via system call for the terminal to be hung up.</span>
<span class="cm"> *	We do this synchronously so that when the syscall returns the process</span>
<span class="cm"> *	is complete. That guarantee is necessary for security reasons.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_vhangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef TTY_DEBUG_HANGUP</span>
	<span class="kt">char</span>	<span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s vhangup...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tty_name</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">__tty_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_vhangup</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	tty_vhangup_self	-	process vhangup for own ctty</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform a vhangup on the current controlling tty</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_vhangup_self</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">get_current_tty</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_vhangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_hung_up_p		-	was tty hung up</span>
<span class="cm"> *	@filp: file pointer of tty</span>
<span class="cm"> *</span>
<span class="cm"> *	Return true if the tty has been subject to a vhangup or a carrier</span>
<span class="cm"> *	loss</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_hung_up_p</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">hung_up_tty_fops</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">session_clear_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">session</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">do_each_pid_task</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_clear_tty</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_pid_task</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	disassociate_ctty	-	disconnect controlling tty</span>
<span class="cm"> *	@on_exit: true if exiting so need to &quot;hang up&quot; the session</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is typically called only by the session leader, when</span>
<span class="cm"> *	it wants to disassociate itself from its controlling tty.</span>
<span class="cm"> *</span>
<span class="cm"> *	It performs the following functions:</span>
<span class="cm"> * 	(1)  Sends a SIGHUP and SIGCONT to the foreground process group</span>
<span class="cm"> * 	(2)  Clears the tty from being controlling the session</span>
<span class="cm"> * 	(3)  Clears the controlling tty for all processes in the</span>
<span class="cm"> * 		session group.</span>
<span class="cm"> *</span>
<span class="cm"> *	The argument on_exit is set to 1 if called when a process is</span>
<span class="cm"> *	exiting; it is 0 if called by the ioctl TIOCNOTTY.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		BTM is taken for hysterical raisins, and held when</span>
<span class="cm"> *		  called from no_tty().</span>
<span class="cm"> *		  tty_mutex is taken to protect tty</span>
<span class="cm"> *		  -&gt;siglock is taken to protect -&gt;signal/-&gt;sighand</span>
<span class="cm"> *		  tasklist_lock is taken to walk process list for sessions</span>
<span class="cm"> *		    -&gt;siglock is taken to protect -&gt;signal/-&gt;sighand</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">disassociate_ctty</span><span class="p">(</span><span class="kt">int</span> <span class="n">on_exit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">leader</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">get_current_tty</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">tty_pgrp</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">on_exit</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TTY_DRIVER_TYPE_PTY</span><span class="p">)</span>
				<span class="n">tty_vhangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty_pgrp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kill_pgrp</span><span class="p">(</span><span class="n">tty_pgrp</span><span class="p">,</span> <span class="n">SIGHUP</span><span class="p">,</span> <span class="n">on_exit</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on_exit</span><span class="p">)</span>
				<span class="n">kill_pgrp</span><span class="p">(</span><span class="n">tty_pgrp</span><span class="p">,</span> <span class="n">SIGCONT</span><span class="p">,</span> <span class="n">on_exit</span><span class="p">);</span>
			<span class="n">put_pid</span><span class="p">(</span><span class="n">tty_pgrp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">on_exit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">old_pgrp</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">old_pgrp</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty_old_pgrp</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty_old_pgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_pgrp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kill_pgrp</span><span class="p">(</span><span class="n">old_pgrp</span><span class="p">,</span> <span class="n">SIGHUP</span><span class="p">,</span> <span class="n">on_exit</span><span class="p">);</span>
			<span class="n">kill_pgrp</span><span class="p">(</span><span class="n">old_pgrp</span><span class="p">,</span> <span class="n">SIGCONT</span><span class="p">,</span> <span class="n">on_exit</span><span class="p">);</span>
			<span class="n">put_pid</span><span class="p">(</span><span class="n">old_pgrp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty_old_pgrp</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty_old_pgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">get_current_tty</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef TTY_DEBUG_HANGUP</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;error attempted to write to tty [0x%p]&quot;</span>
		       <span class="s">&quot; = NULL&quot;</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* Now clear signal-&gt;tty under the lock */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">session_clear_tty</span><span class="p">(</span><span class="n">task_session</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *	no_tty	- Ensure the current process does not have a controlling tty</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">no_tty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FIXME: Review locking here. The tty_lock never covered any race</span>
<span class="cm">	   between a new association and proc_clear_tty but possible we need</span>
<span class="cm">	   to protect against this anyway */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">disassociate_ctty</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">proc_clear_tty</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	stop_tty	-	propagate flow control</span>
<span class="cm"> *	@tty: tty to stop</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform flow control to the driver. For PTY/TTY pairs we</span>
<span class="cm"> *	must also propagate the TIOCKPKT status. May be called</span>
<span class="cm"> *	on an already stopped device and will not re-call the driver</span>
<span class="cm"> *	method.</span>
<span class="cm"> *</span>
<span class="cm"> *	This functionality is used by both the line disciplines for</span>
<span class="cm"> *	halting incoming flow and by the driver. It may therefore be</span>
<span class="cm"> *	called from any context, may be under the tty atomic_write_lock</span>
<span class="cm"> *	but not always.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		Uses the tty control lock internally</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">stop_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">&amp;&amp;</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TIOCPKT_START</span><span class="p">;</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_status</span> <span class="o">|=</span> <span class="n">TIOCPKT_STOP</span><span class="p">;</span>
		<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
		<span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">stop_tty</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	start_tty	-	propagate flow control</span>
<span class="cm"> *	@tty: tty to start</span>
<span class="cm"> *</span>
<span class="cm"> *	Start a tty that has been stopped if at all possible. Perform</span>
<span class="cm"> *	any necessary wakeups and propagate the TIOCPKT status. If this</span>
<span class="cm"> *	is the tty was previous stopped and is being started then the</span>
<span class="cm"> *	driver start method is invoked and the line discipline woken.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		ctrl_lock</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">start_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">||</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">flow_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">&amp;&amp;</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TIOCPKT_STOP</span><span class="p">;</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_status</span> <span class="o">|=</span> <span class="n">TIOCPKT_START</span><span class="p">;</span>
		<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span>
		<span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)(</span><span class="n">tty</span><span class="p">);</span>
	<span class="cm">/* If we have a running line discipline it may need kicking */</span>
	<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">start_tty</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_read	-	read method for tty device files</span>
<span class="cm"> *	@file: pointer to tty file</span>
<span class="cm"> *	@buf: user buffer</span>
<span class="cm"> *	@count: size of user buffer</span>
<span class="cm"> *	@ppos: unused</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform the read system call function on this terminal device. Checks</span>
<span class="cm"> *	for hung up devices before calling the line discipline method.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		Locks the line discipline internally while needed. Multiple</span>
<span class="cm"> *	read calls may be outstanding in parallel.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">tty_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">file_tty</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_paranoia_check</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="s">&quot;tty_read&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span> <span class="o">||</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* We want to wait for the line discipline to sort out in this</span>
<span class="cm">	   situation */</span>
	<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref_wait</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tty_write_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">atomic_write_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">atomic_write_lock</span><span class="p">);</span>
	<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="n">POLLOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tty_write_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ndelay</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">atomic_write_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">atomic_write_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndelay</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">atomic_write_lock</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Split writes up in sane blocksizes to avoid</span>
<span class="cm"> * denial-of-service type attacks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">do_tty_write</span><span class="p">(</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">),</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">,</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chunk</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tty_write_lock</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NDELAY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We chunk up writes into a temporary buffer. This</span>
<span class="cm">	 * simplifies low-level drivers immensely, since they</span>
<span class="cm">	 * don&#39;t have locking issues and user mode accesses.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But if TTY_NO_WRITE_SPLIT is set, we should use a</span>
<span class="cm">	 * big chunk-size..</span>
<span class="cm">	 *</span>
<span class="cm">	 * The default chunk-size is 2kB, because the NTTY</span>
<span class="cm">	 * layer has problems with bigger chunks. It will</span>
<span class="cm">	 * claim to be able to handle more characters than</span>
<span class="cm">	 * it actually does.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME: This can probably go away now except that 64K chunks</span>
<span class="cm">	 * are too likely to fail unless switched to vmalloc...</span>
<span class="cm">	 */</span>
	<span class="n">chunk</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_NO_WRITE_SPLIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="p">)</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/* write_buf/write_cnt is protected by the atomic_write_lock mutex */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_cnt</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf_chunk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">)</span>
			<span class="n">chunk</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

		<span class="n">buf_chunk</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf_chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_buf</span><span class="p">);</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_cnt</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_buf</span> <span class="o">=</span> <span class="n">buf_chunk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do the write .. */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">chunk</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">written</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">written</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">tty_write_unlock</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tty_write_message - write a message to a certain tty, not just the console.</span>
<span class="cm"> * @tty: the destination tty_struct</span>
<span class="cm"> * @msg: the message to write</span>
<span class="cm"> *</span>
<span class="cm"> * This is used for messages that need to be redirected to a specific tty.</span>
<span class="cm"> * We don&#39;t put it into the syslog queue right now maybe in the future if</span>
<span class="cm"> * really needed.</span>
<span class="cm"> *</span>
<span class="cm"> * We must still hold the BTM and test the CLOSING flag for the moment.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_write_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">atomic_write_lock</span><span class="p">);</span>
		<span class="n">tty_lock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tty_unlock</span><span class="p">();</span>
			<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="n">tty_write_unlock</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	tty_write		-	write method for tty device file</span>
<span class="cm"> *	@file: tty file pointer</span>
<span class="cm"> *	@buf: user data to write</span>
<span class="cm"> *	@count: bytes to write</span>
<span class="cm"> *	@ppos: unused</span>
<span class="cm"> *</span>
<span class="cm"> *	Write data to a tty device via the line discipline.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		Locks the line discipline as required</span>
<span class="cm"> *		Writes to the tty driver are serialized by the atomic_write_lock</span>
<span class="cm"> *	and are then processed in chunks to the device. The line discipline</span>
<span class="cm"> *	write method will not be invoked in parallel for each device.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">file_tty</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
 	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_paranoia_check</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="s">&quot;tty_write&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span> <span class="o">||</span> <span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="cm">/* Short term debug to catch buggy drivers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write_room</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;tty driver %s lacks a write_room method.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref_wait</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_tty_write</span><span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">,</span> <span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">redirected_tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">redirect</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_file</span><span class="p">(</span><span class="n">redirect</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">redirect</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">ssize_t</span> <span class="n">res</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">vfs_write</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">);</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">tty_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">ptychar</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;pqrstuvwxyzabcde&quot;</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	pty_line_name	-	generate name for a pty</span>
<span class="cm"> *	@driver: the tty driver in use</span>
<span class="cm"> *	@index: the minor number</span>
<span class="cm"> *	@p: output buffer of at least 6 bytes</span>
<span class="cm"> *</span>
<span class="cm"> *	Generate a name from a driver reference and write it to the output</span>
<span class="cm"> *	buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pty_line_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name_base</span><span class="p">;</span>
	<span class="cm">/* -&gt;name is initialized to &quot;ttyp&quot;, but &quot;tty&quot; is expected */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%s%c%x&quot;</span><span class="p">,</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">PTY_TYPE_SLAVE</span> <span class="o">?</span> <span class="s">&quot;tty&quot;</span> <span class="o">:</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">ptychar</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">],</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_line_name	-	generate name for a tty</span>
<span class="cm"> *	@driver: the tty driver in use</span>
<span class="cm"> *	@index: the minor number</span>
<span class="cm"> *	@p: output buffer of at least 7 bytes</span>
<span class="cm"> *</span>
<span class="cm"> *	Generate a name from a driver reference and write it to the output</span>
<span class="cm"> *	buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tty_line_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%s%d&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name_base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_driver_lookup_tty() - find an existing tty, if any</span>
<span class="cm"> *	@driver: the driver for the tty</span>
<span class="cm"> *	@idx:	 the minor number</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the tty, if found or ERR_PTR() otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: tty_mutex must be held. If tty is found, the mutex must</span>
<span class="cm"> *	be held until the &#39;fast-open&#39; is also done. Will change once we</span>
<span class="cm"> *	have refcounting in the driver and per driver locking</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">tty_driver_lookup_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_init_termios	-  helper for termios setup</span>
<span class="cm"> *	@tty: the tty to set up</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialise the termios structures for this tty. Thus runs under</span>
<span class="cm"> *	the tty_mutex currently so we can be relaxed about ordering.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_init_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span><span class="p">));</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_locked</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Compatibility until drivers always set this */</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_ispeed</span> <span class="o">=</span> <span class="n">tty_termios_input_baud_rate</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_ospeed</span> <span class="o">=</span> <span class="n">tty_termios_baud_rate</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_init_termios</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">tty_standard_install</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">tty_init_termios</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tty_driver_kref_get</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span><span class="p">[</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">tty</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_standard_install</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_driver_install_tty() - install a tty entry in the driver</span>
<span class="cm"> *	@driver: the driver for the tty</span>
<span class="cm"> *	@tty: the tty</span>
<span class="cm"> *</span>
<span class="cm"> *	Install a tty object into the driver tables. The tty-&gt;index field</span>
<span class="cm"> *	will be set by the time this is called. This method is responsible</span>
<span class="cm"> *	for ensuring any need additional structures are allocated and</span>
<span class="cm"> *	configured.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: tty_mutex for now</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_driver_install_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">install</span> <span class="o">?</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">install</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">tty</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">tty_standard_install</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_driver_remove_tty() - remove a tty from the driver tables</span>
<span class="cm"> *	@driver: the driver for the tty</span>
<span class="cm"> *	@idx:	 the minor number</span>
<span class="cm"> *</span>
<span class="cm"> *	Remvoe a tty object from the driver tables. The tty-&gt;index field</span>
<span class="cm"> *	will be set by the time this is called.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: tty_mutex for now</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tty_driver_remove_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span><span class="p">[</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 	tty_reopen()	- fast re-open of an open tty</span>
<span class="cm"> * 	@tty	- the tty to open</span>
<span class="cm"> *</span>
<span class="cm"> *	Return 0 on success, -errno on error.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: tty_mutex must be held from the time the tty was found</span>
<span class="cm"> *		 till this open completes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_reopen</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_HUPPING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_LDISC_CHANGING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TTY_DRIVER_TYPE_PTY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">PTY_TYPE_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * special case for PTY masters: only one open permitted,</span>
<span class="cm">		 * and the slave side open count is incremented as well.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_LDISC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_init_dev		-	initialise a tty device</span>
<span class="cm"> *	@driver: tty driver we are opening a device on</span>
<span class="cm"> *	@idx: device index</span>
<span class="cm"> *	@ret_tty: returned tty structure</span>
<span class="cm"> *</span>
<span class="cm"> *	Prepare a tty device. This may not be a &quot;new&quot; clean device but</span>
<span class="cm"> *	could also be an active device. The pty drivers require special</span>
<span class="cm"> *	handling because of this.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		The function is called under the tty_mutex, which</span>
<span class="cm"> *	protects us from the tty struct or driver itself going away.</span>
<span class="cm"> *</span>
<span class="cm"> *	On exit the tty device has the line discipline attached and</span>
<span class="cm"> *	a reference count of 1. If a pair was created for pty/tty use</span>
<span class="cm"> *	and the other was a pty master then it too has a reference count of 1.</span>
<span class="cm"> *</span>
<span class="cm"> * WSH 06/09/97: Rewritten to remove races and properly clean up after a</span>
<span class="cm"> * failed open.  The new code protects the open with a mutex, so it&#39;s</span>
<span class="cm"> * really quite straightforward.  The mutex locking can probably be</span>
<span class="cm"> * relaxed for the (most common) case of reopening a tty.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">tty_init_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First time open is complex, especially for PTY devices.</span>
<span class="cm">	 * This code guarantees that either everything succeeds and the</span>
<span class="cm">	 * TTY is ready for operation, or else the table slots are vacated</span>
<span class="cm">	 * and the allocated memory released.  (Except that the termios</span>
<span class="cm">	 * and locked termios may be retained.)</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">alloc_tty_struct</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_module_put</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">initialize_tty_struct</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_driver_install_tty</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_deinit_tty</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Structures all installed ... call the ldisc open routines.</span>
<span class="cm">	 * If we fail here just call release_tty to clean up.  No need</span>
<span class="cm">	 * to decrement the use counts, as release_tty doesn&#39;t care.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_ldisc_setup</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_release_tty</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tty</span><span class="p">;</span>

<span class="nl">err_deinit_tty:</span>
	<span class="n">deinitialize_tty_struct</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">free_tty_struct</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="nl">err_module_put:</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>

	<span class="cm">/* call the tty release_tty routine to clean out this slot */</span>
<span class="nl">err_release_tty:</span>
	<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;tty_init_dev: ldisc open failed, &quot;</span>
				 <span class="s">&quot;clearing slot %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">release_tty</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tty_free_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="cm">/* Kill this flag and push into drivers for locking etc */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_RESET_TERMIOS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: Locking on -&gt;termios array */</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">;</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_free_termios</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tty_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tty_driver_remove_tty</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
	<span class="n">tty_free_termios</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_shutdown</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	release_one_tty		-	release tty structure memory</span>
<span class="cm"> *	@kref: kref of tty we are obliterating</span>
<span class="cm"> *</span>
<span class="cm"> *	Releases memory associated with a tty structure, and clears out the</span>
<span class="cm"> *	driver table slots. This function is called when a device is no longer</span>
<span class="cm"> *	in use. It also gets called when setup of a device fails.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		tty_mutex - sometimes only</span>
<span class="cm"> *		takes the file list lock internally when working on the list</span>
<span class="cm"> *	of ttys that the driver keeps.</span>
<span class="cm"> *</span>
<span class="cm"> *	This method gets called from a work queue so that the driver private</span>
<span class="cm"> *	cleanup ops can sleep (needed for USB at least)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_one_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span><span class="p">,</span> <span class="n">hangup_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">)</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">cleanup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tty_driver_kref_put</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">tty_files</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_files_lock</span><span class="p">);</span>

	<span class="n">put_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
	<span class="n">free_tty_struct</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_release_one_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tty_shutdown</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="cm">/* The hangup queue is now free so we can reuse it rather than</span>
<span class="cm">	   waste a chunk of memory for each port */</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hangup_work</span><span class="p">,</span> <span class="n">release_one_tty</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hangup_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_kref_put		-	release a tty kref</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *</span>
<span class="cm"> *	Release a reference to a tty device and if need be let the kref</span>
<span class="cm"> *	layer destruct the object for us</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_kref_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">queue_release_one_tty</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_kref_put</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	release_tty		-	release tty structure memory</span>
<span class="cm"> *</span>
<span class="cm"> *	Release both @tty and a possible linked partner (think pty pair),</span>
<span class="cm"> *	and decrement the refcount of the backing module.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		tty_mutex - sometimes only</span>
<span class="cm"> *		takes the file list lock internally when working on the list</span>
<span class="cm"> *	of ttys that the driver keeps.</span>
<span class="cm"> *		FIXME: should we require tty_mutex is held here ??</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This should always be true but check for the moment */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_release_checks - check a tty before real release</span>
<span class="cm"> *	@tty: tty to check</span>
<span class="cm"> *	@o_tty: link of @tty (if any)</span>
<span class="cm"> *	@idx: index of the tty</span>
<span class="cm"> *</span>
<span class="cm"> *	Performs some paranoid checking before true release of the @tty.</span>
<span class="cm"> *	This is a no-op unless TTY_PARANOIA_CHECK is defined.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_release_checks</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">o_tty</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef TTY_PARANOIA_CHECK</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: bad idx when trying to free (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* not much to check for devpts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_DEVPTS_MEM</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: driver.table[%d] not tty for (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">!=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: driver.termios[%d] not termios for (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_tty</span> <span class="o">!=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">ttys</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: other-&gt;table[%d] not o_tty for (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">!=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: other-&gt;termios[%d] not o_termios for (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">!=</span> <span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: bad pty pointers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_release		-	vfs callback for close</span>
<span class="cm"> *	@inode: inode of tty</span>
<span class="cm"> *	@filp: file pointer for handle to tty</span>
<span class="cm"> *</span>
<span class="cm"> *	Called the last time each file handle is closed that references</span>
<span class="cm"> *	this tty. There may however be several such references.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		Takes bkl. See tty_release_dev</span>
<span class="cm"> *</span>
<span class="cm"> * Even releasing the tty structures is a tricky business.. We have</span>
<span class="cm"> * to be very careful that the structures are all released at the</span>
<span class="cm"> * same time, as interrupts might otherwise get the wrong pointers.</span>
<span class="cm"> *</span>
<span class="cm"> * WSH 09/09/97: rewritten to avoid some nasty race conditions that could</span>
<span class="cm"> * lead to double frees or releasing memory still in use.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">file_tty</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">o_tty</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">pty_master</span><span class="p">,</span> <span class="n">tty_closing</span><span class="p">,</span> <span class="n">o_tty_closing</span><span class="p">,</span> <span class="n">do_sleep</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">devpts</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">idx</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_paranoia_check</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">__func__</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tty_lock</span><span class="p">();</span>
	<span class="n">check_tty_count</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">__tty_fasync</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">pty_master</span> <span class="o">=</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TTY_DRIVER_TYPE_PTY</span> <span class="o">&amp;&amp;</span>
		      <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">PTY_TYPE_MASTER</span><span class="p">);</span>
	<span class="n">devpts</span> <span class="o">=</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_DEVPTS_MEM</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">o_tty</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_release_checks</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">o_tty</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef TTY_DEBUG_HANGUP</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: %s (tty count=%d)...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">tty_name</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">),</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>

	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sanity check: if tty-&gt;count is going to zero, there shouldn&#39;t be</span>
<span class="cm">	 * any waiters on tty-&gt;read_wait or tty-&gt;write_wait.  We test the</span>
<span class="cm">	 * wait queues and kick everyone out _before_ actually starting to</span>
<span class="cm">	 * close.  This ensures that we won&#39;t block while releasing the tty</span>
<span class="cm">	 * structure.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The test for the o_tty closing is necessary, since the master and</span>
<span class="cm">	 * slave sides may close in any order.  If the slave side closes out</span>
<span class="cm">	 * first, its count will be one, since the master side holds an open.</span>
<span class="cm">	 * Thus this test wouldn&#39;t be triggered at the time the slave closes,</span>
<span class="cm">	 * so we do it now.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that it&#39;s possible for the tty to be opened again while we&#39;re</span>
<span class="cm">	 * flushing out waiters.  By recalculating the closing flags before</span>
<span class="cm">	 * each iteration we avoid any problems.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Guard against races with tty-&gt;count changes elsewhere and</span>
<span class="cm">		   opens on /dev/tty */</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
		<span class="n">tty_lock</span><span class="p">();</span>
		<span class="n">tty_closing</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">o_tty_closing</span> <span class="o">=</span> <span class="n">o_tty</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">pty_master</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
		<span class="n">do_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tty_closing</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wake_up_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">);</span>
				<span class="n">do_sleep</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wake_up_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="n">POLLOUT</span><span class="p">);</span>
				<span class="n">do_sleep</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_tty_closing</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wake_up_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">);</span>
				<span class="n">do_sleep</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wake_up_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">,</span> <span class="n">POLLOUT</span><span class="p">);</span>
				<span class="n">do_sleep</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_sleep</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: %s: read/write wait queue active!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">tty_name</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The closing flags are now consistent with the open counts on</span>
<span class="cm">	 * both sides, and we&#39;ve completed the last operation that could</span>
<span class="cm">	 * block, so it&#39;s safe to proceed with closing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pty_master</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: bad pty slave count (%d) for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">tty_name</span><span class="p">(</span><span class="n">o_tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
			<span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: bad tty-&gt;count (%d) for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">tty_name</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ve decremented tty-&gt;count, so we need to remove this file</span>
<span class="cm">	 * descriptor off the tty-&gt;tty_files list; this serves two</span>
<span class="cm">	 * purposes:</span>
<span class="cm">	 *  - check_tty_count sees the correct number of file descriptors</span>
<span class="cm">	 *    associated with this tty.</span>
<span class="cm">	 *  - do_tty_hangup no longer sees this file descriptor as</span>
<span class="cm">	 *    something that needs to be handled for hangups.</span>
<span class="cm">	 */</span>
	<span class="n">tty_del_file</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perform some housekeeping before deciding whether to return.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Set the TTY_CLOSING flag if this was the last open.  In the</span>
<span class="cm">	 * case of a pty we may have to wait around for the other side</span>
<span class="cm">	 * to close, and TTY_CLOSING makes sure we can&#39;t be reopened.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_closing</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_tty_closing</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If _either_ side is closing, make sure there aren&#39;t any</span>
<span class="cm">	 * processes that still think tty or o_tty is their controlling</span>
<span class="cm">	 * tty.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_closing</span> <span class="o">||</span> <span class="n">o_tty_closing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">session_clear_tty</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_tty</span><span class="p">)</span>
			<span class="n">session_clear_tty</span><span class="p">(</span><span class="n">o_tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>

	<span class="cm">/* check whether both sides are closing ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty_closing</span> <span class="o">||</span> <span class="p">(</span><span class="n">o_tty</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_tty_closing</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef TTY_DEBUG_HANGUP</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: freeing tty structure...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ask the line discipline code to release its structures</span>
<span class="cm">	 */</span>
	<span class="n">tty_ldisc_release</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">o_tty</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The release_tty function takes care of the details of clearing</span>
<span class="cm">	 * the slots and preserving the termios structure.</span>
<span class="cm">	 */</span>
	<span class="n">release_tty</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="cm">/* Make this pty number available for reallocation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devpts</span><span class="p">)</span>
		<span class="n">devpts_kill_index</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_open_current_tty - get tty of current task for open</span>
<span class="cm"> *	@device: device number</span>
<span class="cm"> *	@filp: file pointer to tty</span>
<span class="cm"> *	@return: tty of the current task iff @device is /dev/tty</span>
<span class="cm"> *</span>
<span class="cm"> *	We cannot return driver and index like for the other nodes because</span>
<span class="cm"> *	devpts will not work then. It expects inodes to be from devpts FS.</span>
<span class="cm"> *</span>
<span class="cm"> *	We need to move to returning a refcounted object from all the lookup</span>
<span class="cm"> *	paths including this one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">tty_open_current_tty</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">!=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">get_current_tty</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENXIO</span><span class="p">);</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span> <span class="cm">/* Don&#39;t let /dev/tty block */</span>
	<span class="cm">/* noctty = 1; */</span>
	<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="cm">/* FIXME: we put a reference and return a TTY! */</span>
	<span class="cm">/* This is only safe because the caller holds tty_mutex */</span>
	<span class="k">return</span> <span class="n">tty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_lookup_driver - lookup a tty driver for a given device file</span>
<span class="cm"> *	@device: device number</span>
<span class="cm"> *	@filp: file pointer to tty</span>
<span class="cm"> *	@noctty: set if the device should not become a controlling tty</span>
<span class="cm"> *	@index: index for the device in the @return driver</span>
<span class="cm"> *	@return: driver for this inode (with increased refcount)</span>
<span class="cm"> *</span>
<span class="cm"> * 	If @return is not erroneous, the caller is responsible to decrement the</span>
<span class="cm"> * 	refcount by tty_driver_kref_put.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: tty_mutex protects get_tty_driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">tty_lookup_driver</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">noctty</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_VT</span>
	<span class="k">case</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTY_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>: <span class="p">{</span>
		<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">console_driver</span><span class="p">;</span>
		<span class="n">driver</span> <span class="o">=</span> <span class="n">tty_driver_kref_get</span><span class="p">(</span><span class="n">console_driver</span><span class="p">);</span>
		<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">fg_console</span><span class="p">;</span>
		<span class="o">*</span><span class="n">noctty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">console_driver</span> <span class="o">=</span> <span class="n">console_device</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">console_driver</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">driver</span> <span class="o">=</span> <span class="n">tty_driver_kref_get</span><span class="p">(</span><span class="n">console_driver</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Don&#39;t let /dev/console block */</span>
				<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
				<span class="o">*</span><span class="n">noctty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">driver</span> <span class="o">=</span> <span class="n">get_tty_driver</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">driver</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_open		-	open a tty device</span>
<span class="cm"> *	@inode: inode of device file</span>
<span class="cm"> *	@filp: file pointer to tty</span>
<span class="cm"> *</span>
<span class="cm"> *	tty_open and tty_release keep up the tty count that contains the</span>
<span class="cm"> *	number of opens done on a tty. We cannot use the inode-count, as</span>
<span class="cm"> *	different inodes might point to the same tty.</span>
<span class="cm"> *</span>
<span class="cm"> *	Open-counting is needed for pty masters, as well as for keeping</span>
<span class="cm"> *	track of serial lines: DTR is dropped when the last close happens.</span>
<span class="cm"> *	(This is not done solely through tty-&gt;count, now.  - Ted 1/27/92)</span>
<span class="cm"> *</span>
<span class="cm"> *	The termios state of a pty is reset on first open so that</span>
<span class="cm"> *	settings don&#39;t persist across reuse.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: tty_mutex protects tty, tty_lookup_driver and tty_init_dev.</span>
<span class="cm"> *		 tty-&gt;count should protect the rest.</span>
<span class="cm"> *		 -&gt;siglock protects -&gt;signal/-&gt;sighand</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">noctty</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">device</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">saved_flags</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">;</span>

	<span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>

<span class="nl">retry_open:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_alloc_file</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">noctty</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NOCTTY</span><span class="p">;</span>
	<span class="n">index</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="n">tty_lock</span><span class="p">();</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_open_current_tty</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">driver</span> <span class="o">=</span> <span class="n">tty_lookup_driver</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">noctty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">driver</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* check whether we&#39;re reopening an existing tty */</span>
		<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_driver_lookup_tty</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_reopen</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="n">tty</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_init_dev</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="p">)</span>
		<span class="n">tty_driver_kref_put</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_file</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tty_add_file</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>

	<span class="n">check_tty_count</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TTY_DRIVER_TYPE_PTY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">PTY_TYPE_MASTER</span><span class="p">)</span>
		<span class="n">noctty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef TTY_DEBUG_HANGUP</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: opening %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">=</span> <span class="n">saved_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_EXCLUSIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
						<span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef TTY_DEBUG_HANGUP</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: error %d in opening %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">retval</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">tty_unlock</span><span class="p">();</span> <span class="cm">/* need to call tty_release without BTM */</span>
		<span class="n">tty_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

		<span class="n">schedule</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * Need to reset f_op in case a hangup happened.</span>
<span class="cm">		 */</span>
		<span class="n">tty_lock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">hung_up_tty_fops</span><span class="p">)</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tty_fops</span><span class="p">;</span>
		<span class="n">tty_unlock</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">retry_open</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tty_unlock</span><span class="p">();</span>


	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="n">tty_lock</span><span class="p">();</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">noctty</span> <span class="o">&amp;&amp;</span>
	    <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">leader</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">__proc_set_tty</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_unlock:</span>
	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="cm">/* after locks to avoid deadlock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">driver</span><span class="p">))</span>
		<span class="n">tty_driver_kref_put</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
<span class="nl">err_file:</span>
	<span class="n">tty_free_file</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/**</span>
<span class="cm"> *	tty_poll	-	check tty status</span>
<span class="cm"> *	@filp: file being polled</span>
<span class="cm"> *	@wait: poll wait structures to update</span>
<span class="cm"> *</span>
<span class="cm"> *	Call the line discipline polling method to obtain the poll</span>
<span class="cm"> *	status of the device.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: locks called line discipline but ldisc poll method</span>
<span class="cm"> *	may be re-entered freely by other callers.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tty_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">file_tty</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_paranoia_check</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="s">&quot;tty_poll&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref_wait</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)(</span><span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__tty_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">file_tty</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_paranoia_check</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="s">&quot;tty_fasync&quot;</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">fasync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">))</span>
			<span class="n">tty</span><span class="o">-&gt;</span><span class="n">minimum_to_wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pid</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">;</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_PGID</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pid</span> <span class="o">=</span> <span class="n">task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">PIDTYPE_PID</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">get_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">__f_setown</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">fasync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">))</span>
			<span class="n">tty</span><span class="o">-&gt;</span><span class="n">minimum_to_wake</span> <span class="o">=</span> <span class="n">N_TTY_BUF_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">tty_lock</span><span class="p">();</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__tty_fasync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">on</span><span class="p">);</span>
	<span class="n">tty_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tiocsti			-	fake input character</span>
<span class="cm"> *	@tty: tty to fake input into</span>
<span class="cm"> *	@p: pointer to character</span>
<span class="cm"> *</span>
<span class="cm"> *	Fake input to a tty device. Does the necessary locking and</span>
<span class="cm"> *	input management.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: does not honour flow control ??</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		Called functions take tty_ldisc_lock</span>
<span class="cm"> *		current-&gt;signal-&gt;tty check is safe without locks</span>
<span class="cm"> *</span>
<span class="cm"> *	FIXME: may race normal receive processing</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocsti</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">ch</span><span class="p">,</span> <span class="n">mbz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">tty</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">tty_audit_tiocsti</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
	<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref_wait</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">receive_buf</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbz</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tiocgwinsz		-	implement window query ioctl</span>
<span class="cm"> *	@tty; tty</span>
<span class="cm"> *	@arg: user buffer for result</span>
<span class="cm"> *</span>
<span class="cm"> *	Copies the kernel idea of the window size into the user buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: tty-&gt;termios_mutex is taken to ensure the winsize data</span>
<span class="cm"> *		is consistent.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocgwinsz</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">winsize</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">winsize</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_do_resize		-	resize event</span>
<span class="cm"> *	@tty: tty being resized</span>
<span class="cm"> *	@rows: rows (character)</span>
<span class="cm"> *	@cols: cols (character)</span>
<span class="cm"> *</span>
<span class="cm"> *	Update the termios variables and send the necessary signals to</span>
<span class="cm"> *	peform a terminal resize correctly</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_do_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">winsize</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Lock the tty */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">winsize</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ws</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="cm">/* Get the PID values and reference them so we can</span>
<span class="cm">	   avoid holding the tty ctrl lock while sending signals */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pgrp</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgrp</span><span class="p">)</span>
		<span class="n">kill_pgrp</span><span class="p">(</span><span class="n">pgrp</span><span class="p">,</span> <span class="n">SIGWINCH</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">pgrp</span><span class="p">);</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">winsize</span> <span class="o">=</span> <span class="o">*</span><span class="n">ws</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tiocswinsz		-	implement window size set ioctl</span>
<span class="cm"> *	@tty; tty side of tty</span>
<span class="cm"> *	@arg: user buffer for result</span>
<span class="cm"> *</span>
<span class="cm"> *	Copies the user idea of the window size to the kernel. Traditionally</span>
<span class="cm"> *	this is just advisory information but for the Linux console it</span>
<span class="cm"> *	actually has driver level meaning and triggers a VC resize.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		Driver dependent. The default do_resize method takes the</span>
<span class="cm"> *	tty termios mutex and ctrl_lock. The console takes its own lock</span>
<span class="cm"> *	then calls into the default method.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocswinsz</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">winsize</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">winsize</span> <span class="n">tmp_ws</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_ws</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">resize</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">resize</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_ws</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">tty_do_resize</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_ws</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tioccons	-	allow admin to move logical console</span>
<span class="cm"> *	@file: the file to become console</span>
<span class="cm"> *</span>
<span class="cm"> *	Allow the administrator to move the redirected console device</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: uses redirect_lock to guard the redirect information</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tioccons</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="n">redirected_tty_write</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">redirect</span><span class="p">;</span>
		<span class="n">redirect</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">redirect</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">get_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">redirect</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">redirect_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	fionbio		-	non blocking ioctl</span>
<span class="cm"> *	@file: file to set blocking value</span>
<span class="cm"> *	@p: user parameter</span>
<span class="cm"> *</span>
<span class="cm"> *	Historical tty interfaces had a blocking control ioctl before</span>
<span class="cm"> *	the generic functionality existed. This piece of history is preserved</span>
<span class="cm"> *	in the expected tty API of posix OS&#39;s.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none, the open file handle ensures it won&#39;t go away.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fionbio</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nonblock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">nonblock</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nonblock</span><span class="p">)</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">O_NONBLOCK</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tiocsctty	-	set controlling tty</span>
<span class="cm"> *	@tty: tty structure</span>
<span class="cm"> *	@arg: user argument</span>
<span class="cm"> *</span>
<span class="cm"> *	This ioctl is used to manage job control. It permits a session</span>
<span class="cm"> *	leader to set this tty as the controlling tty for the session.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		Takes tty_mutex() to protect tty instance</span>
<span class="cm"> *		Takes tasklist_lock internally to walk sessions</span>
<span class="cm"> *		Takes -&gt;siglock() when updating signal-&gt;tty</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocsctty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">leader</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">task_session</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The process must be a session leader and</span>
<span class="cm">	 * not have a controlling tty already.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">leader</span> <span class="o">||</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This tty is already the controlling</span>
<span class="cm">		 * tty for another session group!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Steal it away</span>
<span class="cm">			 */</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
			<span class="n">session_clear_tty</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">proc_set_tty</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_get_pgrp	-	return a ref counted pgrp pid</span>
<span class="cm"> *	@tty: tty to read</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a refcounted instance of the pid struct for the process</span>
<span class="cm"> *	group controlling the tty.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="nf">tty_get_pgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pgrp</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pgrp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_get_pgrp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	tiocgpgrp		-	get process group</span>
<span class="cm"> *	@tty: tty passed by user</span>
<span class="cm"> *	@real_tty: tty side of the tty passed by the user if a pty else the tty</span>
<span class="cm"> *	@p: returned pid</span>
<span class="cm"> *</span>
<span class="cm"> *	Obtain the process group of the tty. If there is no process group</span>
<span class="cm"> *	return an error.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none. Reference to current-&gt;signal-&gt;tty is safe.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocgpgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">real_tty</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * (tty == real_tty) is a cheap way of</span>
<span class="cm">	 * testing if the tty is NOT a master pty.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span> <span class="o">==</span> <span class="n">real_tty</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">real_tty</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">tty_get_pgrp</span><span class="p">(</span><span class="n">real_tty</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span>  <span class="n">put_user</span><span class="p">(</span><span class="n">pid_vnr</span><span class="p">(</span><span class="n">pid</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tiocspgrp		-	attempt to set process group</span>
<span class="cm"> *	@tty: tty passed by user</span>
<span class="cm"> *	@real_tty: tty side device matching tty passed by user</span>
<span class="cm"> *	@p: pid pointer</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the process group of the tty to the session passed. Only</span>
<span class="cm"> *	permitted where the tty session is our session.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: RCU, ctrl lock</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocspgrp</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">real_tty</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pgrp</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pgrp_nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">tty_check_change</span><span class="p">(</span><span class="n">real_tty</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">real_tty</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">real_tty</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">!=</span> <span class="n">task_session</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">pgrp_nr</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgrp_nr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">pgrp</span> <span class="o">=</span> <span class="n">find_vpid</span><span class="p">(</span><span class="n">pgrp_nr</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgrp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">session_of_pgrp</span><span class="p">(</span><span class="n">pgrp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">task_session</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">real_tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
	<span class="n">real_tty</span><span class="o">-&gt;</span><span class="n">pgrp</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">pgrp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tiocgsid		-	get session id</span>
<span class="cm"> *	@tty: tty passed by user</span>
<span class="cm"> *	@real_tty: tty side of the tty passed by the user if a pty else the tty</span>
<span class="cm"> *	@p: pointer to returned session id</span>
<span class="cm"> *</span>
<span class="cm"> *	Obtain the session id of the tty. If there is no session</span>
<span class="cm"> *	return an error.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none. Reference to current-&gt;signal-&gt;tty is safe.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocgsid</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">real_tty</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * (tty == real_tty) is a cheap way of</span>
<span class="cm">	 * testing if the tty is NOT a master pty.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span> <span class="o">==</span> <span class="n">real_tty</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">real_tty</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">real_tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">pid_vnr</span><span class="p">(</span><span class="n">real_tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tiocsetd	-	set line discipline</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *	@p: pointer to user data</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the line discipline according to user request.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: see tty_set_ldisc, this function is just a helper</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tiocsetd</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ldisc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ldisc</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tty_set_ldisc</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ldisc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	send_break	-	performed time break</span>
<span class="cm"> *	@tty: device to break on</span>
<span class="cm"> *	@duration: timeout in mS</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform a timed break on hardware that lacks its own driver level</span>
<span class="cm"> *	timed break functionality.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *		atomic_write_lock serializes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">duration</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_HARDWARE_BREAK</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">duration</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Do the work ourselves */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty_write_lock</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="n">msleep_interruptible</span><span class="p">(</span><span class="n">duration</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
		<span class="n">tty_write_unlock</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_tiocmget		-	get modem status</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *	@file: user file pointer</span>
<span class="cm"> *	@p: pointer to result</span>
<span class="cm"> *</span>
<span class="cm"> *	Obtain the modem status bits from the tty driver if the feature</span>
<span class="cm"> *	is supported. Return -EINVAL if it is not available.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none (up to the driver)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_tiocmget</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tiocmget</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_tiocmset		-	set modem status</span>
<span class="cm"> *	@tty: tty device</span>
<span class="cm"> *	@cmd: command - clear bits, set bits or set all</span>
<span class="cm"> *	@p: pointer to desired bits</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the modem status bits from the tty driver if the feature</span>
<span class="cm"> *	is supported. Return -EINVAL if it is not available.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none (up to the driver)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_tiocmset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	     <span class="kt">unsigned</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="n">clear</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tiocmset</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">set</span> <span class="o">=</span> <span class="n">clear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCMBIS</span>:
		<span class="n">set</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCMBIC</span>:
		<span class="n">clear</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCMSET</span>:
		<span class="n">set</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">clear</span> <span class="o">=</span> <span class="o">~</span><span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">set</span> <span class="o">&amp;=</span> <span class="n">TIOCM_DTR</span><span class="o">|</span><span class="n">TIOCM_RTS</span><span class="o">|</span><span class="n">TIOCM_OUT1</span><span class="o">|</span><span class="n">TIOCM_OUT2</span><span class="o">|</span><span class="n">TIOCM_LOOP</span><span class="p">;</span>
	<span class="n">clear</span> <span class="o">&amp;=</span> <span class="n">TIOCM_DTR</span><span class="o">|</span><span class="n">TIOCM_RTS</span><span class="o">|</span><span class="n">TIOCM_OUT1</span><span class="o">|</span><span class="n">TIOCM_OUT2</span><span class="o">|</span><span class="n">TIOCM_LOOP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tiocmset</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">set</span><span class="p">,</span> <span class="n">clear</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tty_tiocgicount</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serial_icounter_struct</span> <span class="n">icount</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icount</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">icount</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_icount</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_icount</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">icount</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">tty_pair_get_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TTY_DRIVER_TYPE_PTY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">PTY_TYPE_MASTER</span><span class="p">)</span>
		<span class="n">tty</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tty</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_pair_get_tty</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">tty_pair_get_pty</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TTY_DRIVER_TYPE_PTY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">PTY_TYPE_MASTER</span><span class="p">)</span>
	    <span class="k">return</span> <span class="n">tty</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_pair_get_pty</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Split this up, as gcc can choke on it otherwise..</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">tty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">file_tty</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">real_tty</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_paranoia_check</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="s">&quot;tty_ioctl&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">real_tty</span> <span class="o">=</span> <span class="n">tty_pair_get_tty</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Factor out some common prep work</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCSETD</span>:
	<span class="k">case</span> <span class="n">TIOCSBRK</span>:
	<span class="k">case</span> <span class="n">TIOCCBRK</span>:
	<span class="k">case</span> <span class="n">TCSBRK</span>:
	<span class="k">case</span> <span class="n">TCSBRKP</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_check_change</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">TIOCCBRK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tty_wait_until_sent</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Now do the stuff.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCSTI</span>:
		<span class="k">return</span> <span class="n">tiocsti</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCGWINSZ</span>:
		<span class="k">return</span> <span class="n">tiocgwinsz</span><span class="p">(</span><span class="n">real_tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCSWINSZ</span>:
		<span class="k">return</span> <span class="n">tiocswinsz</span><span class="p">(</span><span class="n">real_tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCCONS</span>:
		<span class="k">return</span> <span class="n">real_tty</span> <span class="o">!=</span> <span class="n">tty</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="n">tioccons</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FIONBIO</span>:
		<span class="k">return</span> <span class="n">fionbio</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCEXCL</span>:
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_EXCLUSIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCNXCL</span>:
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_EXCLUSIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCNOTTY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">tty</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="n">no_tty</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCSCTTY</span>:
		<span class="k">return</span> <span class="n">tiocsctty</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCGPGRP</span>:
		<span class="k">return</span> <span class="n">tiocgpgrp</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">real_tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCSPGRP</span>:
		<span class="k">return</span> <span class="n">tiocspgrp</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">real_tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCGSID</span>:
		<span class="k">return</span> <span class="n">tiocgsid</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">real_tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCGETD</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCSETD</span>:
		<span class="k">return</span> <span class="n">tiocsetd</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCVHANGUP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">tty_vhangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCGDEV</span>:
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">new_encode_dev</span><span class="p">(</span><span class="n">tty_devnum</span><span class="p">(</span><span class="n">real_tty</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Break handling</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">TIOCSBRK</span>:	<span class="cm">/* Turn break on, unconditionally */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIOCCBRK</span>:	<span class="cm">/* Turn break off, unconditionally */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCSBRK</span>:   <span class="cm">/* SVID version: non-zero arg --&gt; no break */</span>
		<span class="cm">/* non-zero arg means wait for all output data</span>
<span class="cm">		 * to be sent (performed above) but don&#39;t send break.</span>
<span class="cm">		 * This is used by the tcdrain() termios function.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">send_break</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCSBRKP</span>:	<span class="cm">/* support for POSIX tcsendbreak() */</span>
		<span class="k">return</span> <span class="n">send_break</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">arg</span> <span class="o">?</span> <span class="n">arg</span><span class="o">*</span><span class="mi">100</span> <span class="o">:</span> <span class="mi">250</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">TIOCMGET</span>:
		<span class="k">return</span> <span class="n">tty_tiocmget</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCMSET</span>:
	<span class="k">case</span> <span class="n">TIOCMBIC</span>:
	<span class="k">case</span> <span class="n">TIOCMBIS</span>:
		<span class="k">return</span> <span class="n">tty_tiocmset</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">TIOCGICOUNT</span>:
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_tiocgicount</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="cm">/* For the moment allow fall through to the old method */</span>
        	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCFLSH</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TCIFLUSH</span>:
		<span class="k">case</span> <span class="n">TCIOFLUSH</span>:
		<span class="cm">/* flush tty buffer and allow ldisc to process ioctl */</span>
			<span class="n">tty_buffer_flush</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">)(</span><span class="n">tty</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref_wait</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">tty_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">file_tty</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_paranoia_check</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="s">&quot;tty_ioctl&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">)(</span><span class="n">tty</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref_wait</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">n_tty_compat_ioctl_helper</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * This implements the &quot;Secure Attention Key&quot; ---  the idea is to</span>
<span class="cm"> * prevent trojan horses by killing all processes associated with this</span>
<span class="cm"> * tty when the user hits the &quot;Secure Attention Key&quot;.  Required for</span>
<span class="cm"> * super-paranoid applications --- see the Orange Book for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * This code could be nicer; ideally it should send a HUP, wait a few</span>
<span class="cm"> * seconds, then send a INT, and then a KILL signal.  But you then</span>
<span class="cm"> * have to coordinate with the init process, since all processes associated</span>
<span class="cm"> * with the current tty must be dead before the new getty is allowed</span>
<span class="cm"> * to spawn.</span>
<span class="cm"> *</span>
<span class="cm"> * Now, if it would be correct ;-/ The current code has a nasty hole -</span>
<span class="cm"> * it doesn&#39;t catch files in flight. We may send the descriptor to ourselves</span>
<span class="cm"> * via AF_UNIX socket, close it and later fetch from socket. FIXME.</span>
<span class="cm"> *</span>
<span class="cm"> * Nasty bug: do_SAK is being called in interrupt context.  This can</span>
<span class="cm"> * deadlock.  We punt it up to process context.  AKPM - 16Mar2001</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__do_SAK</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef TTY_SOFT_SAK</span>
	<span class="n">tty_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">session</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">;</span>

	<span class="n">tty_ldisc_flush</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">tty_driver_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="cm">/* Kill the entire session */</span>
	<span class="n">do_each_pid_task</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;SAK: killed process %d&quot;</span>
			<span class="s">&quot; (%s): task_session(p)==tty-&gt;session</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_pid_task</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="cm">/* Now kill any processes that happen to have the</span>
<span class="cm">	 * tty open.</span>
<span class="cm">	 */</span>
	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">==</span> <span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;SAK: killed process %d&quot;</span>
			    <span class="s">&quot; (%s): task_session(p)==tty-&gt;session</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
			<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We don&#39;t take a ref to the file, so we must</span>
<span class="cm">			 * hold -&gt;file_lock instead.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
			<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">max_fds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">filp</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span> <span class="o">==</span> <span class="n">tty_read</span> <span class="o">&amp;&amp;</span>
				    <span class="n">file_tty</span><span class="p">(</span><span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;SAK: killed process %d&quot;</span>
					    <span class="s">&quot; (%s): fd#%d opened to the tty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
					<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_SAK_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span><span class="p">,</span> <span class="n">SAK_work</span><span class="p">);</span>
	<span class="n">__do_SAK</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The tq handling here is a little racy - tty-&gt;SAK_work may already be queued.</span>
<span class="cm"> * Fortunately we don&#39;t need to worry, because if -&gt;SAK_work is already queued,</span>
<span class="cm"> * the values which we write to it will be identical to the values which it</span>
<span class="cm"> * already has. --akpm</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_SAK</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">SAK_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">do_SAK</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_match_devt</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_t</span> <span class="o">*</span><span class="n">devt</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span> <span class="o">==</span> <span class="o">*</span><span class="n">devt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must put_device() after it&#39;s unused! */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">tty_get_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_t</span> <span class="n">devt</span> <span class="o">=</span> <span class="n">tty_devnum</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">class_find_device</span><span class="p">(</span><span class="n">tty_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devt</span><span class="p">,</span> <span class="n">dev_match_devt</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	initialize_tty_struct</span>
<span class="cm"> *	@tty: tty to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	This subroutine initializes a tty structure that has been newly</span>
<span class="cm"> *	allocated.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none - tty in question must not be exposed at this point</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">initialize_tty_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span><span class="p">));</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">TTY_MAGIC</span><span class="p">;</span>
	<span class="n">tty_ldisc_init</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">overrun_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">tty_buffer_init</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ldisc_mutex</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">write_wait</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hangup_work</span><span class="p">,</span> <span class="n">do_tty_hangup</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">atomic_read_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">atomic_write_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">output_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">echo_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">read_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">tty_files</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">SAK_work</span><span class="p">,</span> <span class="n">do_SAK_work</span><span class="p">);</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">tty_line_name</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">tty_get_device</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	deinitialize_tty_struct</span>
<span class="cm"> *	@tty: tty to deinitialize</span>
<span class="cm"> *</span>
<span class="cm"> *	This subroutine deinitializes a tty structure that has been newly</span>
<span class="cm"> *	allocated but tty_release cannot be called on that yet.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: none - tty in question must not be exposed at this point</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">deinitialize_tty_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tty_ldisc_deinit</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_put_char	-	write one character to a tty</span>
<span class="cm"> *	@tty: tty</span>
<span class="cm"> *	@ch: character</span>
<span class="cm"> *</span>
<span class="cm"> *	Write one byte to the tty using the provided put_char method</span>
<span class="cm"> *	if present. Returns the number of characters successfully output.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: the specific put_char operation in the driver layer may go</span>
<span class="cm"> *	away soon. Don&#39;t call it directly, use this method</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tty_put_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">put_char</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">put_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tty_put_char</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">tty_class</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	tty_register_device - register a tty device</span>
<span class="cm"> *	@driver: the tty driver that describes the tty device</span>
<span class="cm"> *	@index: the index in the tty driver for this tty device</span>
<span class="cm"> *	@device: a struct device that is associated with this tty device.</span>
<span class="cm"> *		This field is optional, if there is no known struct device</span>
<span class="cm"> *		for this tty device it can be set to NULL safely.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a pointer to the struct device for this tty device</span>
<span class="cm"> *	(or ERR_PTR(-EFOO) on error).</span>
<span class="cm"> *</span>
<span class="cm"> *	This call is required to be made to register an individual tty device</span>
<span class="cm"> *	if the tty driver&#39;s flags have the TTY_DRIVER_DYNAMIC_DEV bit set.  If</span>
<span class="cm"> *	that bit is not set, this function should not be called by a tty</span>
<span class="cm"> *	driver.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: ??</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">tty_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">dev_t</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Attempt to register invalid tty line number &quot;</span>
		       <span class="s">&quot; (%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TTY_DRIVER_TYPE_PTY</span><span class="p">)</span>
		<span class="n">pty_line_name</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tty_line_name</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">device_create</span><span class="p">(</span><span class="n">tty_class</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_register_device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * 	tty_unregister_device - unregister a tty device</span>
<span class="cm"> * 	@driver: the tty driver that describes the tty device</span>
<span class="cm"> * 	@index: the index in the tty driver for this tty device</span>
<span class="cm"> *</span>
<span class="cm"> * 	If a tty device is registered with a call to tty_register_device() then</span>
<span class="cm"> *	this function must be called when the tty device is gone.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking: ??</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tty_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">device_destroy</span><span class="p">(</span><span class="n">tty_class</span><span class="p">,</span>
		<span class="n">MKDEV</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_unregister_device</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">__alloc_tty_driver</span><span class="p">(</span><span class="kt">int</span> <span class="n">lines</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>

	<span class="n">driver</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">TTY_DRIVER_MAGIC</span><span class="p">;</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">=</span> <span class="n">lines</span><span class="p">;</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
		<span class="cm">/* later we&#39;ll move allocation of tables here */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">driver</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__alloc_tty_driver</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destruct_tty_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_driver</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_INSTALLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Free the termios and termios_locked structures because</span>
<span class="cm">		 * we don&#39;t want to get memory leaks when modular tty</span>
<span class="cm">		 * drivers are removed from the kernel.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_DYNAMIC_DEV</span><span class="p">))</span>
				<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span><span class="p">;</span>
		<span class="n">proc_tty_unregister_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tty_driver_kref_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">destruct_tty_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_driver_kref_put</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tty_set_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_set_operations</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">put_tty_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tty_driver_kref_put</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">put_tty_driver</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called by a tty driver to register itself.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tty_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_DEVPTS_MEM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">,</span>
						<span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">driver</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">driver</span><span class="o">-&gt;</span><span class="n">minor_start</span> <span class="o">=</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">register_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">**</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span> <span class="o">**</span><span class="p">)(</span><span class="n">p</span> <span class="o">+</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_fops</span><span class="p">);</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">tty_drivers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_drivers</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TTY_DRIVER_DYNAMIC_DEV</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">tty_register_device</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">proc_tty_register_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TTY_DRIVER_INSTALLED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">tty_drivers</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>

	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">ttys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">driver</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_register_driver</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called by a tty driver to unregister itself.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tty_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* FIXME */</span>
<span class="c">	if (driver-&gt;refcount)</span>
<span class="c">		return -EBUSY;</span>
<span class="cp">#endif</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">),</span>
				<span class="n">driver</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">tty_drivers</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_unregister_driver</span><span class="p">);</span>

<span class="n">dev_t</span> <span class="nf">tty_devnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">)</span> <span class="o">+</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tty_devnum</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">proc_clear_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called under the sighand lock */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__proc_set_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="cm">/* We should not have a session or pgrp to put here but.... */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span><span class="p">);</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">pgrp</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">task_pgrp</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">task_session</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;tty not NULL!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty_old_pgrp</span><span class="p">);</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty_kref_get</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty_old_pgrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">proc_set_tty</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">__proc_set_tty</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="nf">get_current_tty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty</span> <span class="o">=</span> <span class="n">tty_kref_get</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tty</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_current_tty</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tty_default_fops</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">fops</span> <span class="o">=</span> <span class="n">tty_fops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the console device. This is called *early*, so</span>
<span class="cm"> * we can&#39;t necessarily depend on lots of kernel help here.</span>
<span class="cm"> * Just do some early initializations, and do the complex setup</span>
<span class="cm"> * later.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">console_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">initcall_t</span> <span class="o">*</span><span class="n">call</span><span class="p">;</span>

	<span class="cm">/* Setup the default TTY line discipline. */</span>
	<span class="n">tty_ldisc_begin</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * set up the console device so that later boot sequences can</span>
<span class="cm">	 * inform about problems etc..</span>
<span class="cm">	 */</span>
	<span class="n">call</span> <span class="o">=</span> <span class="n">__con_initcall_start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">call</span> <span class="o">&lt;</span> <span class="n">__con_initcall_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">call</span><span class="p">)();</span>
		<span class="n">call</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">tty_devnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span> <span class="o">==</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span> <span class="o">==</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
		<span class="o">*</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0666</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">tty_class_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tty_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="s">&quot;tty&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tty_class</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tty_class</span><span class="p">);</span>
	<span class="n">tty_class</span><span class="o">-&gt;</span><span class="n">devnode</span> <span class="o">=</span> <span class="n">tty_devnode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">tty_class_init</span><span class="p">);</span>

<span class="cm">/* 3/2004 jmc: why do these devices exist? */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cdev</span> <span class="n">tty_cdev</span><span class="p">,</span> <span class="n">console_cdev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_cons_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">cs</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">console_lock</span><span class="p">();</span>
	<span class="n">for_each_console</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_ENABLED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">count</span><span class="p">,</span> <span class="s">&quot;%s%d%c&quot;</span><span class="p">,</span>
				 <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span><span class="o">:</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="n">console_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">active</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">show_cons_active</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">consdev</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">console_sysfs_notify</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">consdev</span><span class="p">)</span>
		<span class="n">sysfs_notify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consdev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;active&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ok, now we can initialize the rest of the tty devices and can count</span>
<span class="cm"> * on memory allocations, interrupts etc..</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">tty_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tty_cdev</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">register_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;/dev/tty&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t register /dev/tty driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">device_create</span><span class="p">(</span><span class="n">tty_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;tty&quot;</span><span class="p">);</span>

	<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">console_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_cdev</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">register_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;/dev/console&quot;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t register /dev/console driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">consdev</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="n">tty_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">TTYAUX_MAJOR</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span>
			      <span class="s">&quot;console&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">consdev</span><span class="p">))</span>
		<span class="n">consdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">device_create_file</span><span class="p">(</span><span class="n">consdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_active</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_VT</span>
	<span class="n">vty_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">console_fops</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
