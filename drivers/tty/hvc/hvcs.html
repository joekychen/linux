<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › hvc › hvcs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hvcs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IBM eServer Hypervisor Virtual Console Server Device Driver</span>
<span class="cm"> * Copyright (C) 2003, 2004 IBM Corp.</span>
<span class="cm"> *  Ryan S. Arnold (rsa@us.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *  (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author(s) :  Ryan S. Arnold &lt;rsa@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This is the device driver for the IBM Hypervisor Virtual Console Server,</span>
<span class="cm"> * &quot;hvcs&quot;.  The IBM hvcs provides a tty driver interface to allow Linux</span>
<span class="cm"> * user space applications access to the system consoles of logically</span>
<span class="cm"> * partitioned operating systems, e.g. Linux, running on the same partitioned</span>
<span class="cm"> * Power5 ppc64 system.  Physical hardware consoles per partition are not</span>
<span class="cm"> * practical on this hardware so system consoles are accessed by this driver</span>
<span class="cm"> * using inter-partition firmware interfaces to virtual terminal devices.</span>
<span class="cm"> *</span>
<span class="cm"> * A vty is known to the HMC as a &quot;virtual serial server adapter&quot;.  It is a</span>
<span class="cm"> * virtual terminal device that is created by firmware upon partition creation</span>
<span class="cm"> * to act as a partitioned OS&#39;s console device.</span>
<span class="cm"> *</span>
<span class="cm"> * Firmware dynamically (via hotplug) exposes vty-servers to a running ppc64</span>
<span class="cm"> * Linux system upon their creation by the HMC or their exposure during boot.</span>
<span class="cm"> * The non-user interactive backend of this driver is implemented as a vio</span>
<span class="cm"> * device driver so that it can receive notification of vty-server lifetimes</span>
<span class="cm"> * after it registers with the vio bus to handle vty-server probe and remove</span>
<span class="cm"> * callbacks.</span>
<span class="cm"> *</span>
<span class="cm"> * Many vty-servers can be configured to connect to one vty, but a vty can</span>
<span class="cm"> * only be actively connected to by a single vty-server, in any manner, at one</span>
<span class="cm"> * time.  If the HMC is currently hosting the console for a target Linux</span>
<span class="cm"> * partition; attempts to open the tty device to the partition&#39;s console using</span>
<span class="cm"> * the hvcs on any partition will return -EBUSY with every open attempt until</span>
<span class="cm"> * the HMC frees the connection between its vty-server and the desired</span>
<span class="cm"> * partition&#39;s vty device.  Conversely, a vty-server may only be connected to</span>
<span class="cm"> * a single vty at one time even though it may have several configured vty</span>
<span class="cm"> * partner possibilities.</span>
<span class="cm"> *</span>
<span class="cm"> * Firmware does not provide notification of vty partner changes to this</span>
<span class="cm"> * driver.  This means that an HMC Super Admin may add or remove partner vtys</span>
<span class="cm"> * from a vty-server&#39;s partner list but the changes will not be signaled to</span>
<span class="cm"> * the vty-server.  Firmware only notifies the driver when a vty-server is</span>
<span class="cm"> * added or removed from the system.  To compensate for this deficiency, this</span>
<span class="cm"> * driver implements a sysfs update attribute which provides a method for</span>
<span class="cm"> * rescanning partner information upon a user&#39;s request.</span>
<span class="cm"> *</span>
<span class="cm"> * Each vty-server, prior to being exposed to this driver is reference counted</span>
<span class="cm"> * using the 2.6 Linux kernel kref construct.</span>
<span class="cm"> *</span>
<span class="cm"> * For direction on installation and usage of this driver please reference</span>
<span class="cm"> * Documentation/powerpc/hvcs.txt.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/major.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;asm/hvconsole.h&gt;</span>
<span class="cp">#include &lt;asm/hvcserver.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/vio.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * 1.3.0 -&gt; 1.3.1 In hvcs_open memset(..,0x00,..) instead of memset(..,0x3F,00).</span>
<span class="cm"> * Removed braces around single statements following conditionals.  Removed &#39;=</span>
<span class="cm"> * 0&#39; after static int declarations since these default to zero.  Removed</span>
<span class="cm"> * list_for_each_safe() and replaced with list_for_each_entry() in</span>
<span class="cm"> * hvcs_get_by_index().  The &#39;safe&#39; version is un-needed now that the driver is</span>
<span class="cm"> * using spinlocks.  Changed spin_lock_irqsave() to spin_lock() when locking</span>
<span class="cm"> * hvcs_structs_lock and hvcs_pi_lock since these are not touched in an int</span>
<span class="cm"> * handler.  Initialized hvcs_structs_lock and hvcs_pi_lock to</span>
<span class="cm"> * SPIN_LOCK_UNLOCKED at declaration time rather than in hvcs_module_init().</span>
<span class="cm"> * Added spin_lock around list_del() in destroy_hvcs_struct() to protect the</span>
<span class="cm"> * list traversals from a deletion.  Removed &#39;= NULL&#39; from pointer declaration</span>
<span class="cm"> * statements since they are initialized NULL by default.  Removed wmb()</span>
<span class="cm"> * instances from hvcs_try_write().  They probably aren&#39;t needed with locking in</span>
<span class="cm"> * place.  Added check and cleanup for hvcs_pi_buff = kmalloc() in</span>
<span class="cm"> * hvcs_module_init().  Exposed hvcs_struct.index via a sysfs attribute so that</span>
<span class="cm"> * the coupling between /dev/hvcs* and a vty-server can be automatically</span>
<span class="cm"> * determined.  Moved kobject_put() in hvcs_open outside of the</span>
<span class="cm"> * spin_unlock_irqrestore().</span>
<span class="cm"> *</span>
<span class="cm"> * 1.3.1 -&gt; 1.3.2 Changed method for determining hvcs_struct-&gt;index and had it</span>
<span class="cm"> * align with how the tty layer always assigns the lowest index available.  This</span>
<span class="cm"> * change resulted in a list of ints that denotes which indexes are available.</span>
<span class="cm"> * Device additions and removals use the new hvcs_get_index() and</span>
<span class="cm"> * hvcs_return_index() helper functions.  The list is created with</span>
<span class="cm"> * hvsc_alloc_index_list() and it is destroyed with hvcs_free_index_list().</span>
<span class="cm"> * Without these fixes hotplug vty-server adapter support goes crazy with this</span>
<span class="cm"> * driver if the user removes a vty-server adapter.  Moved free_irq() outside of</span>
<span class="cm"> * the hvcs_final_close() function in order to get it out of the spinlock.</span>
<span class="cm"> * Rearranged hvcs_close().  Cleaned up some printks and did some housekeeping</span>
<span class="cm"> * on the changelog.  Removed local CLC_LENGTH and used HVCS_CLC_LENGTH from</span>
<span class="cm"> * arch/powerepc/include/asm/hvcserver.h</span>
<span class="cm"> *</span>
<span class="cm"> * 1.3.2 -&gt; 1.3.3 Replaced yield() in hvcs_close() with tty_wait_until_sent() to</span>
<span class="cm"> * prevent possible lockup with realtime scheduling as similarly pointed out by</span>
<span class="cm"> * akpm in hvc_console.  Changed resulted in the removal of hvcs_final_close()</span>
<span class="cm"> * to reorder cleanup operations and prevent discarding of pending data during</span>
<span class="cm"> * an hvcs_close().  Removed spinlock protection of hvcs_struct data members in</span>
<span class="cm"> * hvcs_write_room() and hvcs_chars_in_buffer() because they aren&#39;t needed.</span>
<span class="cm"> */</span>

<span class="cp">#define HVCS_DRIVER_VERSION &quot;1.3.3&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Ryan S. Arnold &lt;rsa@us.ibm.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;IBM hvcs (Hypervisor Virtual Console Server) Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">HVCS_DRIVER_VERSION</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Wait this long per iteration while trying to push buffered data to the</span>
<span class="cm"> * hypervisor before allowing the tty to complete a close operation.</span>
<span class="cm"> */</span>
<span class="cp">#define HVCS_CLOSE_WAIT (HZ/100) </span><span class="cm">/* 1/10 of a second */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Since the Linux TTY code does not currently (2-04-2004) support dynamic</span>
<span class="cm"> * addition of tty derived devices and we shouldn&#39;t allocate thousands of</span>
<span class="cm"> * tty_device pointers when the number of vty-server &amp; vty partner connections</span>
<span class="cm"> * will most often be much lower than this, we&#39;ll arbitrarily allocate</span>
<span class="cm"> * HVCS_DEFAULT_SERVER_ADAPTERS tty_structs and cdev&#39;s by default when we</span>
<span class="cm"> * register the tty_driver. This can be overridden using an insmod parameter.</span>
<span class="cm"> */</span>
<span class="cp">#define HVCS_DEFAULT_SERVER_ADAPTERS	64</span>

<span class="cm">/*</span>
<span class="cm"> * The user can&#39;t insmod with more than HVCS_MAX_SERVER_ADAPTERS hvcs device</span>
<span class="cm"> * nodes as a sanity check.  Theoretically there can be over 1 Billion</span>
<span class="cm"> * vty-server &amp; vty partner connections.</span>
<span class="cm"> */</span>
<span class="cp">#define HVCS_MAX_SERVER_ADAPTERS	1024</span>

<span class="cm">/*</span>
<span class="cm"> * We let Linux assign us a major number and we start the minors at zero.  There</span>
<span class="cm"> * is no intuitive mapping between minor number and the target vty-server</span>
<span class="cm"> * adapter except that each new vty-server adapter is always assigned to the</span>
<span class="cm"> * smallest minor number available.</span>
<span class="cm"> */</span>
<span class="cp">#define HVCS_MINOR_START	0</span>

<span class="cm">/*</span>
<span class="cm"> * The hcall interface involves putting 8 chars into each of two registers.</span>
<span class="cm"> * We load up those 2 registers (in arch/powerpc/platforms/pseries/hvconsole.c)</span>
<span class="cm"> * by casting char[16] to long[2].  It would work without __ALIGNED__, but a </span>
<span class="cm"> * little (tiny) bit slower because an unaligned load is slower than aligned </span>
<span class="cm"> * load.</span>
<span class="cm"> */</span>
<span class="cp">#define __ALIGNED__	__attribute__((__aligned__(8)))</span>

<span class="cm">/*</span>
<span class="cm"> * How much data can firmware send with each hvc_put_chars()?  Maybe this</span>
<span class="cm"> * should be moved into an architecture specific area.</span>
<span class="cm"> */</span>
<span class="cp">#define HVCS_BUFF_LEN	16</span>

<span class="cm">/*</span>
<span class="cm"> * This is the maximum amount of data we&#39;ll let the user send us (hvcs_write) at</span>
<span class="cm"> * once in a chunk as a sanity check.</span>
<span class="cm"> */</span>
<span class="cp">#define HVCS_MAX_FROM_USER	4096</span>

<span class="cm">/*</span>
<span class="cm"> * Be careful when adding flags to this line discipline.  Don&#39;t add anything</span>
<span class="cm"> * that will cause echoing or we&#39;ll go into recursive loop echoing chars back</span>
<span class="cm"> * and forth with the console drivers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="n">hvcs_tty_termios</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">c_iflag</span> <span class="o">=</span> <span class="n">IGNBRK</span> <span class="o">|</span> <span class="n">IGNPAR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_oflag</span> <span class="o">=</span> <span class="n">OPOST</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_cflag</span> <span class="o">=</span> <span class="n">B38400</span> <span class="o">|</span> <span class="n">CS8</span> <span class="o">|</span> <span class="n">CREAD</span> <span class="o">|</span> <span class="n">HUPCL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_cc</span> <span class="o">=</span> <span class="n">INIT_C_CC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_ispeed</span> <span class="o">=</span> <span class="mi">38400</span><span class="p">,</span>
	<span class="p">.</span><span class="n">c_ospeed</span> <span class="o">=</span> <span class="mi">38400</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This value is used to take the place of a command line parameter when the</span>
<span class="cm"> * module is inserted.  It starts as -1 and stays as such if the user doesn&#39;t</span>
<span class="cm"> * specify a module insmod parameter.  If they DO specify one then it is set to</span>
<span class="cm"> * the value of the integer passed in.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_parm_num_devs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">hvcs_parm_num_devs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">hvcs_driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;hvcs&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">hvcs_device_node</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;hvcs&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">hvcs_driver_string</span><span class="p">[]</span>
	<span class="o">=</span> <span class="s">&quot;IBM hvcs (Hypervisor Virtual Console Server) Driver&quot;</span><span class="p">;</span>

<span class="cm">/* Status of partner info rescan triggered via sysfs. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_rescan_status</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">hvcs_tty_driver</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * In order to be somewhat sane this driver always associates the hvcs_struct</span>
<span class="cm"> * index element with the numerically equal tty-&gt;index.  This means that a</span>
<span class="cm"> * hotplugged vty-server adapter will always map to the lowest index valued</span>
<span class="cm"> * device node.  If vty-servers were hotplug removed from the system and then</span>
<span class="cm"> * new ones added the new vty-server may have the largest slot number of all</span>
<span class="cm"> * the vty-server adapters in the partition but it may have the lowest dev node</span>
<span class="cm"> * index of all the adapters due to the hole left by the hotplug removed</span>
<span class="cm"> * adapter.  There are a set of functions provided to get the lowest index for</span>
<span class="cm"> * a new device as well as return the index to the list.  This list is allocated</span>
<span class="cm"> * with a number of elements equal to the number of device nodes requested when</span>
<span class="cm"> * the module was inserted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hvcs_index_list</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * How large is the list?  This is kept for traversal since the list is</span>
<span class="cm"> * dynamically created.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_index_count</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Used by the khvcsd to pick up I/O operations when the kernel_thread is</span>
<span class="cm"> * already awake but potentially shifted to TASK_INTERRUPTIBLE state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_kicked</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Use by the kthread construct for task operations like waking the sleeping</span>
<span class="cm"> * thread and stopping the kthread.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">hvcs_task</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * We allocate this for the use of all of the hvcs_structs when they fetch</span>
<span class="cm"> * partner info.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">hvcs_pi_buff</span><span class="p">;</span>

<span class="cm">/* Only allow one hvcs_struct to use the hvcs_pi_buff at a time. */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">hvcs_pi_lock</span><span class="p">);</span>

<span class="cm">/* One vty-server per hvcs_struct */</span>
<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This index identifies this hvcs device as the complement to a</span>
<span class="cm">	 * specific tty index.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Used to tell the driver kernel_thread what operations need to take</span>
<span class="cm">	 * place upon this hvcs_struct instance.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">todo_mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This buffer is required so that when hvcs_write_room() reports that</span>
<span class="cm">	 * it can send HVCS_BUFF_LEN characters that it will buffer the full</span>
<span class="cm">	 * HVCS_BUFF_LEN characters if need be.  This is essential for opost</span>
<span class="cm">	 * writes since they do not do high level buffering and expect to be</span>
<span class="cm">	 * able to send what the driver commits to sending buffering</span>
<span class="cm">	 * [e.g. tab to space conversions in n_tty.c opost()].</span>
<span class="cm">	 */</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">HVCS_BUFF_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">chars_in_buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Any variable below is valid before a tty is connected and</span>
<span class="cm">	 * stays valid after the tty is disconnected.  These shouldn&#39;t be</span>
<span class="cm">	 * whacked until the kobject refcount reaches zero though some entries</span>
<span class="cm">	 * may be changed via sysfs initiatives.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">connected</span><span class="p">;</span> <span class="cm">/* is the vty-server currently connected to a vty? */</span>
	<span class="kt">uint32_t</span> <span class="n">p_unit_address</span><span class="p">;</span> <span class="cm">/* partner unit address */</span>
	<span class="kt">uint32_t</span> <span class="n">p_partition_ID</span><span class="p">;</span> <span class="cm">/* partner partition ID */</span>
	<span class="kt">char</span> <span class="n">p_location_code</span><span class="p">[</span><span class="n">HVCS_CLC_LENGTH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="cm">/* CLC + Null Term */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">next</span><span class="p">;</span> <span class="cm">/* list management */</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">hvcs_structs</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">hvcs_init_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">hvcs_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hvcs_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">hvcs_handle_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_has_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hvcs_set_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_partner_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_get_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_rescan_devices_list</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_partner_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hvcs_partner_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">unit_address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hvcs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hvcs_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">hvcs_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">hvcs_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">vio_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="n">hvcs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">hvcs_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="n">hvcs_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">hvcs_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#define HVCS_SCHED_READ	0x00000001</span>
<span class="cp">#define HVCS_QUICK_READ	0x00000002</span>
<span class="cp">#define HVCS_TRY_WRITE	0x00000004</span>
<span class="cp">#define HVCS_READ_MASK	(HVCS_SCHED_READ | HVCS_QUICK_READ)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="nf">from_vio_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">viod</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* The sysfs interface for the driver and devices */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_partner_vtys_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viod</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">from_vio_dev</span><span class="p">(</span><span class="n">viod</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">partner_vtys</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">hvcs_partner_vtys_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_partner_clcs_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viod</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">from_vio_dev</span><span class="p">(</span><span class="n">viod</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_location_code</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">partner_clcs</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">hvcs_partner_clcs_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_current_vty_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t need this feature at the present time because firmware doesn&#39;t</span>
<span class="cm">	 * yet support multiple partners.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: Denied current_vty change: -EPERM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_current_vty_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viod</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">from_vio_dev</span><span class="p">(</span><span class="n">viod</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_location_code</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">current_vty</span><span class="p">,</span>
	<span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">hvcs_current_vty_show</span><span class="p">,</span> <span class="n">hvcs_current_vty_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_vterm_state_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viod</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">from_vio_dev</span><span class="p">(</span><span class="n">viod</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* writing a &#39;0&#39; to this sysfs entry will result in the disconnect. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">simple_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: vterm state unchanged.  &quot;</span>
				<span class="s">&quot;The hvcs device node is still in use.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: vterm state unchanged. The&quot;</span>
				<span class="s">&quot; vty-server is not connected to a vty.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hvcs_partner_free</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: Closed vty-server@%X and&quot;</span>
			<span class="s">&quot; partner vty@%X:%d connection.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">,</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_partition_ID</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_vterm_state_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viod</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">from_vio_dev</span><span class="p">(</span><span class="n">viod</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">vterm_state</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		<span class="n">hvcs_vterm_state_show</span><span class="p">,</span> <span class="n">hvcs_vterm_state_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_index_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">viod</span> <span class="o">=</span> <span class="n">to_vio_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">from_vio_dev</span><span class="p">(</span><span class="n">viod</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">hvcs_index_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">hvcs_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_partner_vtys</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_partner_clcs</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_current_vty</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_vterm_state</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_index</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">hvcs_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">hvcs_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_rescan_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">ddp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* A 1 means it is updating, a 0 means it is done updating */</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hvcs_rescan_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hvcs_rescan_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">ddp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">simple_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hvcs_rescan_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">hvcs_rescan_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: rescanning partner info for all&quot;</span>
		<span class="s">&quot; vty-servers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">hvcs_rescan_devices_list</span><span class="p">();</span>
	<span class="n">hvcs_rescan_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">rescan</span><span class="p">,</span>
	<span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">hvcs_rescan_show</span><span class="p">,</span> <span class="n">hvcs_rescan_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_kick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hvcs_kicked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">hvcs_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">|=</span> <span class="n">HVCS_SCHED_READ</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hvcs_kick</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">vio_disable_interrupts</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the device is being removed we don&#39;t have to worry about this interrupt</span>
<span class="cm"> * handler taking any further interrupts because they are disabled which means</span>
<span class="cm"> * the hvcs_struct will always be valid in this handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">hvcs_handle_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">dev_instance</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">vio_disable_interrupts</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">|=</span> <span class="n">HVCS_SCHED_READ</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">hvcs_kick</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function must be called with the hvcsd-&gt;lock held */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_try_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">unit_address</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">&amp;</span> <span class="n">HVCS_TRY_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* won&#39;t send partial writes */</span>
		<span class="n">sent</span> <span class="o">=</span> <span class="n">hvc_put_chars</span><span class="p">(</span><span class="n">unit_address</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* wmb(); */</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HVCS_TRY_WRITE</span><span class="p">);</span>
			<span class="cm">/* wmb(); */</span>

			<span class="cm">/*</span>
<span class="cm">			 * We are still obligated to deliver the data to the</span>
<span class="cm">			 * hypervisor even if the tty has been closed because</span>
<span class="cm">			 * we committed to delivering it.  But don&#39;t try to wake</span>
<span class="cm">			 * a non-existent tty.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">unit_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">HVCS_BUFF_LEN</span><span class="p">]</span> <span class="n">__ALIGNED__</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">got</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">unit_address</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">;</span>
	<span class="n">tty</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">hvcs_try_write</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span> <span class="o">||</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_THROTTLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HVCS_READ_MASK</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HVCS_READ_MASK</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/* remove the read masks */</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HVCS_READ_MASK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_buffer_request_room</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">HVCS_BUFF_LEN</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">HVCS_BUFF_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">got</span> <span class="o">=</span> <span class="n">hvc_get_chars</span><span class="p">(</span><span class="n">unit_address</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">HVCS_BUFF_LEN</span><span class="p">);</span>
		<span class="n">tty_insert_flip_string</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">got</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Give the TTY time to process the data we just sent. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">got</span><span class="p">)</span>
		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">|=</span> <span class="n">HVCS_QUICK_READ</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* This is synch because tty-&gt;low_latency == 1 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">got</span><span class="p">)</span>
		<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">got</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Do this _after_ the flip_buffer_push */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">vio_enable_interrupts</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span><span class="p">;</span>

 <span class="nl">bail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">khvcsd</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hvcs_todo_mask</span><span class="p">;</span>

	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">hvcs_todo_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hvcs_kicked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcs_structs</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hvcs_todo_mask</span> <span class="o">|=</span> <span class="n">hvcs_io</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If any of the hvcs adapters want to try a write or quick read</span>
<span class="cm">		 * don&#39;t schedule(), yield a smidgen then execute the hvcs_io</span>
<span class="cm">		 * thread again for those that want the write.</span>
<span class="cm">		 */</span>
		 <span class="k">if</span> <span class="p">(</span><span class="n">hvcs_todo_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HVCS_TRY_WRITE</span> <span class="o">|</span> <span class="n">HVCS_QUICK_READ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">yield</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_kicked</span><span class="p">)</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">());</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vio_device_id</span> <span class="n">hvcs_driver_table</span><span class="p">[]</span> <span class="n">__devinitdata</span><span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;serial-server&quot;</span><span class="p">,</span> <span class="s">&quot;hvterm2&quot;</span><span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">vio</span><span class="p">,</span> <span class="n">hvcs_driver_table</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_return_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Paranoia check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_index_list</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">hvcs_index_count</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hvcs_index_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hvcs_index_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_destruct_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hvcs_struct</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* the list_del poisons the pointers */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hvcs_partner_free</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: Closed vty-server@%X and&quot;</span>
				<span class="s">&quot; partner vty@%X:%d connection.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">,</span>
				<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_partition_ID</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: Destroyed hvcs_struct for vty-server@%X.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">);</span>

	<span class="n">vdev</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_partition_ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hvcs_return_index</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_location_code</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">HVCS_CLC_LENGTH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>

	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcs_attr_group</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="n">hvcs_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">destruct</span> <span class="o">=</span> <span class="n">hvcs_destruct_port</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_get_index</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* Paranoia check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_index_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: hvcs_index_list NOT valid!.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Find the numerically lowest first free index. */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hvcs_index_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hvcs_index_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hvcs_index_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hvcs_probe</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vio_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: probed with invalid parameter.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure we are properly initialized */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">hvcs_initialize</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;HVCS: Failed to initialize core driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* early to avoid cleanup on failure */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">hvcs_get_index</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hvcsd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hvcsd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcsd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">tty_port_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hvcs_port_ops</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">hvcsd</span><span class="p">);</span>

	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* hvcsd-&gt;index = ++hvcs_struct_count; */</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This will populate the hvcs_struct&#39;s partner info fields for the</span>
<span class="cm">	 * first time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hvcs_get_pi</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: Failed to fetch partner&quot;</span>
			<span class="s">&quot; info for vty-server@%X on device probe.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a user app opens a tty that corresponds to this vty-server before</span>
<span class="cm">	 * the hvcs_struct has been added to the devices list then the user app</span>
<span class="cm">	 * will get -ENODEV.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">hvcs_structs</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcs_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: Can&#39;t create sysfs attrs for vty-server@%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: vty-server@%X added to the vio bus.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * DON&#39;T enable interrupts here because there is no user to receive the</span>
<span class="cm">	 * data.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">hvcs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcsd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* By this time the vty-server won&#39;t be getting any more interrupts */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let the last holder of this object cause it to be removed, which</span>
<span class="cm">	 * would probably be tty_hangup below.</span>
<span class="cm">	 */</span>
	<span class="n">tty_port_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The hangup is a scheduled function which will auto chain call</span>
<span class="cm">	 * hvcs_hangup.  The tty should always be valid at this time unless a</span>
<span class="cm">	 * simultaneous tty close already cleaned up the hvcs_struct.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">tty_hangup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: vty-server@%X removed from the&quot;</span>
			<span class="s">&quot; vio bus.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vio_driver</span> <span class="n">hvcs_vio_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">hvcs_driver_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">hvcs_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">hvcs_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">hvcs_driver_name</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Only called from hvcs_get_pi please */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_set_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_partner_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">clclength</span><span class="p">;</span>

	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span> <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_partition_ID</span>  <span class="o">=</span> <span class="n">pi</span><span class="o">-&gt;</span><span class="n">partition_ID</span><span class="p">;</span>
	<span class="n">clclength</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">location_code</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clclength</span> <span class="o">&gt;</span> <span class="n">HVCS_CLC_LENGTH</span><span class="p">)</span>
		<span class="n">clclength</span> <span class="o">=</span> <span class="n">HVCS_CLC_LENGTH</span><span class="p">;</span>

	<span class="cm">/* copy the null-term char too */</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_location_code</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">location_code</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">clclength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Traverse the list and add the partner info that is found to the hvcs_struct</span>
<span class="cm"> * struct entry. NOTE: At this time I know that partner info will return a</span>
<span class="cm"> * single entry but in the future there may be multiple partner info entries per</span>
<span class="cm"> * vty-server and you&#39;ll want to zero out that list and reset it.  If for some</span>
<span class="cm"> * reason you have an old version of this driver but there IS more than one</span>
<span class="cm"> * partner info then hvcsd-&gt;p_* will hold the last partner info data from the</span>
<span class="cm"> * firmware query.  A good way to update this code would be to replace the three</span>
<span class="cm"> * partner info fields in hvcs_struct with a list of hvcs_partner_info</span>
<span class="cm"> * instances.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called with the hvcsd-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_get_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_partner_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">unit_address</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_pi_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_pi_buff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_pi_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">hvcs_get_partner_info</span><span class="p">(</span><span class="n">unit_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">hvcs_pi_buff</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_pi_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: Failed to fetch partner&quot;</span>
			<span class="s">&quot; info for vty-server@%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unit_address</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* nixes the values if the partner vty went away */</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_partition_ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">hvcs_set_pi</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">hvcsd</span><span class="p">);</span>

	<span class="n">hvcs_free_partner_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is executed by the driver &quot;rescan&quot; sysfs entry.  It shouldn&#39;t</span>
<span class="cm"> * be executed elsewhere, in order to prevent deadlock issues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_rescan_devices_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcs_structs</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hvcs_get_pi</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Farm this off into its own function because it could be more complex once</span>
<span class="cm"> * multiple partners support is added. This function should be called with</span>
<span class="cm"> * the hvcsd-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_has_pi</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_partition_ID</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: It is possible that the super admin removed a partner vty and then</span>
<span class="cm"> * added a different vty as the new partner.</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called with the hvcsd-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_partner_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unit_address</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there wasn&#39;t any pi when the device was added it doesn&#39;t meant</span>
<span class="cm">	 * there isn&#39;t any now.  This driver isn&#39;t notified when a new partner</span>
<span class="cm">	 * vty is added to a vty-server so we discover changes on our own.</span>
<span class="cm">	 * Please see comments in hvcs_register_connection() for justification</span>
<span class="cm">	 * of this bizarre code.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">hvcs_register_connection</span><span class="p">(</span><span class="n">unit_address</span><span class="p">,</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_partition_ID</span><span class="p">,</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * As per the spec re-get the pi and try again if -EINVAL after the</span>
<span class="cm">	 * first connection attempt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hvcs_get_pi</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_has_pi</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">hvcs_register_connection</span><span class="p">(</span><span class="n">unit_address</span><span class="p">,</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_partition_ID</span><span class="p">,</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">p_unit_address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * EBUSY is the most likely scenario though the vty could have been</span>
<span class="cm">	 * removed or there really could be an hcall error due to the parameter</span>
<span class="cm">	 * data but thanks to ambiguous firmware return codes we can&#39;t really</span>
<span class="cm">	 * tell.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: vty-server or partner&quot;</span>
			<span class="s">&quot; vty is busy.  Try again later.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function must be called with the hvcsd-&gt;lock held */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_partner_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">hvcs_free_connection</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This helper function must be called WITHOUT the hvcsd-&gt;lock held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_enable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">unit_address</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is possible that the vty-server was removed between the time that</span>
<span class="cm">	 * the conn was registered and now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rc</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcs_handle_interrupt</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ibmhvcs&quot;</span><span class="p">,</span> <span class="n">hvcsd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It is possible the vty-server was removed after the irq was</span>
<span class="cm">		 * requested but before we have time to enable interrupts.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vio_enable_interrupts</span><span class="p">(</span><span class="n">vdev</span><span class="p">)</span> <span class="o">==</span> <span class="n">H_SUCCESS</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: int enable failed for&quot;</span>
					<span class="s">&quot; vty-server@%X.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unit_address</span><span class="p">);</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">hvcsd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: irq req failed for&quot;</span>
				<span class="s">&quot; vty-server@%X.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unit_address</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hvcs_partner_free</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This always increments the kref ref count if the call is successful.</span>
<span class="cm"> * Please remember to dec when you are done with the instance.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTICE: Do NOT hold either the hvcs_struct.lock or hvcs_structs_lock when</span>
<span class="cm"> * calling this function or you will get deadlock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="nf">hvcs_get_by_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcs_structs</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tty_port_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">hvcsd</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_structs_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is invoked via the tty_open interface when a user app connects to the</span>
<span class="cm"> * /dev node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vio_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unit_address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fast_open</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is there a vty-server that shares the same index?</span>
<span class="cm">	 * This function increments the kref index.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">hvcs_get_by_index</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;HVCS: open failed, no device associated&quot;</span>
				<span class="s">&quot; with tty-&gt;index %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">connected</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">hvcs_partner_connect</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">error_release</span><span class="p">;</span>

	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">HVCS_BUFF_LEN</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save these in the spinlock for the enable operations that need them</span>
<span class="cm">	 * outside of the spinlock.</span>
<span class="cm">	 */</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">vdev</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">;</span>
	<span class="n">unit_address</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">;</span>

	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">|=</span> <span class="n">HVCS_SCHED_READ</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This must be done outside of the spinlock because it requests irqs</span>
<span class="cm">	 * and will grab the spinlock and free the connection if it fails.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">hvcs_enable_device</span><span class="p">(</span><span class="n">hvcsd</span><span class="p">,</span> <span class="n">unit_address</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">vdev</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">tty_port_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;HVCS: enable device failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">open_success</span><span class="p">;</span>

<span class="nl">fast_open:</span>
	<span class="n">hvcsd</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty_port_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">|=</span> <span class="n">HVCS_SCHED_READ</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">open_success:</span>
	<span class="n">hvcs_kick</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: vty-server@%X connection opened.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span> <span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_release:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty_port_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;HVCS: partner connect failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is someone trying to close the file associated with this device after</span>
<span class="cm">	 * we have hung up?  If so tty-&gt;driver_data wouldn&#39;t be valid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No driver_data means that this close was probably issued after a</span>
<span class="cm">	 * failed hvcs_open by the tty layer&#39;s release_dev() api and we can just</span>
<span class="cm">	 * exit cleanly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hvcsd</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">vio_disable_interrupts</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * NULL this early so that the kernel_thread doesn&#39;t try to</span>
<span class="cm">		 * execute any operations on the TTY even though it is obligated</span>
<span class="cm">		 * to deliver any pending I/O to the hypervisor.</span>
<span class="cm">		 */</span>
		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">irq</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">tty_wait_until_sent_from_close</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">HVCS_CLOSE_WAIT</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This line is important because it tells hvcs_open that this</span>
<span class="cm">		 * device needs to be re-configured the next time hvcs_open is</span>
<span class="cm">		 * called.</span>
<span class="cm">		 */</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">hvcsd</span><span class="p">);</span>
		<span class="n">tty_port_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: vty-server@%X open_count: %d&quot;</span>
				<span class="s">&quot; is missmanaged.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">,</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty_port_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span> <span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">temp_open_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Preserve this so that we know how many kref refs to put */</span>
	<span class="n">temp_open_count</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t kref put inside the spinlock because the destruction</span>
<span class="cm">	 * callback may use the spinlock and it may get called before the</span>
<span class="cm">	 * spinlock has been released.</span>
<span class="cm">	 */</span>
	<span class="n">vio_disable_interrupts</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="p">);</span>

	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* I don&#39;t think the tty needs the hvcs_struct pointer after a hangup */</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This will drop any buffered data on the floor which is OK in a hangup</span>
<span class="cm">	 * scenario. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">HVCS_BUFF_LEN</span><span class="p">);</span>
	<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">hvcsd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to kref_put() for every open_count we have since the</span>
<span class="cm">	 * tty_hangup() function doesn&#39;t invoke a close per open connection on a</span>
<span class="cm">	 * non-console device.</span>
<span class="cm">	 */</span>
	<span class="k">while</span><span class="p">(</span><span class="n">temp_open_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">temp_open_count</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The final put will trigger destruction of the hvcs_struct.</span>
<span class="cm">		 * NOTE:  If this hangup was signaled from user space then the</span>
<span class="cm">		 * final put will never happen.</span>
<span class="cm">		 */</span>
		<span class="n">tty_port_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE: This is almost always from_user since user level apps interact with the</span>
<span class="cm"> * /dev nodes. I&#39;m trusting that if hvcs_write gets called and interrupted by</span>
<span class="cm"> * hvcs_remove (which removes the target device and executes tty_hangup()) that</span>
<span class="cm"> * tty_hangup will allow hvcs_write time to complete execution before it</span>
<span class="cm"> * terminates our device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unit_address</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">charbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tosend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If they don&#39;t check the return code off of their open they may</span>
<span class="cm">	 * attempt this even if there is no connected device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcsd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Reasonable size to prevent user level flooding */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">HVCS_MAX_FROM_USER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;HVCS write: count being truncated to&quot;</span>
				<span class="s">&quot; HVCS_MAX_FROM_USER.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">HVCS_MAX_FROM_USER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">charbuf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Somehow an open succeeded but the device was removed or the</span>
<span class="cm">	 * connection terminated between the vty-server and partner vty during</span>
<span class="cm">	 * the middle of a write operation?  This is a crummy place to do this</span>
<span class="cm">	 * but we want to keep it all in the spinlock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unit_address</span> <span class="o">=</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">unit_address</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tosend</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="n">HVCS_BUFF_LEN</span> <span class="o">-</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * No more space, this probably means that the last call to</span>
<span class="cm">		 * hvcs_write() didn&#39;t succeed and the buffer was filled up.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tosend</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span><span class="p">],</span>
				<span class="o">&amp;</span><span class="n">charbuf</span><span class="p">[</span><span class="n">total_sent</span><span class="p">],</span>
				<span class="n">tosend</span><span class="p">);</span>

		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span> <span class="o">+=</span> <span class="n">tosend</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this is true then we don&#39;t want to try writing to the</span>
<span class="cm">		 * hypervisor because that is the kernel_threads job now.  We&#39;ll</span>
<span class="cm">		 * just add to the buffer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">&amp;</span> <span class="n">HVCS_TRY_WRITE</span><span class="p">))</span>
			<span class="cm">/* won&#39;t send partial writes */</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">hvc_put_chars</span><span class="p">(</span><span class="n">unit_address</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since we know we have enough room in hvcsd-&gt;buffer for</span>
<span class="cm">		 * tosend we record that it was sent regardless of whether the</span>
<span class="cm">		 * hypervisor actually took it because we have it buffered.</span>
<span class="cm">		 */</span>
		<span class="n">total_sent</span><span class="o">+=</span><span class="n">tosend</span><span class="p">;</span>
		<span class="n">count</span><span class="o">-=</span><span class="n">tosend</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">todo_mask</span> <span class="o">|=</span> <span class="n">HVCS_TRY_WRITE</span><span class="p">;</span>
			<span class="n">hvcs_kick</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Test after the chars_in_buffer reset otherwise this could</span>
<span class="cm">		 * deadlock our writes if hvc_put_chars fails.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">total_sent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is really asking how much can we guarantee that we can send or that we</span>
<span class="cm"> * absolutely WILL BUFFER if we can&#39;t send it.  This driver MUST honor the</span>
<span class="cm"> * return value, hence the reason for hvcs_struct buffering.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcsd</span> <span class="o">||</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">HVCS_BUFF_LEN</span> <span class="o">-</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hvcs_struct</span> <span class="o">*</span><span class="n">hvcsd</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hvcsd</span><span class="o">-&gt;</span><span class="n">chars_in_buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="n">hvcs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">hvcs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">hvcs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hangup</span> <span class="o">=</span> <span class="n">hvcs_hangup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">hvcs_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_room</span> <span class="o">=</span> <span class="n">hvcs_write_room</span><span class="p">,</span>
	<span class="p">.</span><span class="n">chars_in_buffer</span> <span class="o">=</span> <span class="n">hvcs_chars_in_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unthrottle</span> <span class="o">=</span> <span class="n">hvcs_unthrottle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">throttle</span> <span class="o">=</span> <span class="n">hvcs_throttle</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hvcs_alloc_index_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hvcs_index_list</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hvcs_index_count</span><span class="p">),</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_index_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">hvcs_index_count</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hvcs_index_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hvcs_index_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hvcs_free_index_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Paranoia check to be thorough. */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hvcs_index_list</span><span class="p">);</span>
	<span class="n">hvcs_index_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hvcs_index_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">hvcs_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">num_ttys_to_alloc</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_init_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hvcs_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_init_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Has the user specified an overload with an insmod param? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hvcs_parm_num_devs</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">hvcs_parm_num_devs</span> <span class="o">&gt;</span> <span class="n">HVCS_MAX_SERVER_ADAPTERS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">num_ttys_to_alloc</span> <span class="o">=</span> <span class="n">HVCS_DEFAULT_SERVER_ADAPTERS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">num_ttys_to_alloc</span> <span class="o">=</span> <span class="n">hvcs_parm_num_devs</span><span class="p">;</span>

	<span class="n">hvcs_tty_driver</span> <span class="o">=</span> <span class="n">alloc_tty_driver</span><span class="p">(</span><span class="n">num_ttys_to_alloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_tty_driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hvcs_alloc_index_list</span><span class="p">(</span><span class="n">num_ttys_to_alloc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">index_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hvcs_tty_driver</span><span class="o">-&gt;</span><span class="n">driver_name</span> <span class="o">=</span> <span class="n">hvcs_driver_name</span><span class="p">;</span>
	<span class="n">hvcs_tty_driver</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">hvcs_device_node</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ll let the system assign us a major number, indicated by leaving</span>
<span class="cm">	 * it blank.</span>
<span class="cm">	 */</span>

	<span class="n">hvcs_tty_driver</span><span class="o">-&gt;</span><span class="n">minor_start</span> <span class="o">=</span> <span class="n">HVCS_MINOR_START</span><span class="p">;</span>
	<span class="n">hvcs_tty_driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">TTY_DRIVER_TYPE_SYSTEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We role our own so that we DONT ECHO.  We can&#39;t echo because the</span>
<span class="cm">	 * device we are connecting to already echoes by default and this would</span>
<span class="cm">	 * throw us into a horrible recursive echo-echo-echo loop.</span>
<span class="cm">	 */</span>
	<span class="n">hvcs_tty_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span> <span class="o">=</span> <span class="n">hvcs_tty_termios</span><span class="p">;</span>
	<span class="n">hvcs_tty_driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">TTY_DRIVER_REAL_RAW</span><span class="p">;</span>

	<span class="n">tty_set_operations</span><span class="p">(</span><span class="n">hvcs_tty_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hvcs_ops</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following call will result in sysfs entries that denote the</span>
<span class="cm">	 * dynamically assigned major and minor numbers for our devices.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_register_driver</span><span class="p">(</span><span class="n">hvcs_tty_driver</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: registration as a tty driver failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">register_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hvcs_pi_buff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_pi_buff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">buff_alloc_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hvcs_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">khvcsd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;khvcsd&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">hvcs_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: khvcsd creation failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">kthread_fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_init_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">kthread_fail:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hvcs_pi_buff</span><span class="p">);</span>
<span class="nl">buff_alloc_fail:</span>
	<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">hvcs_tty_driver</span><span class="p">);</span>
<span class="nl">register_fail:</span>
	<span class="n">hvcs_free_index_list</span><span class="p">();</span>
<span class="nl">index_fail:</span>
	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">hvcs_tty_driver</span><span class="p">);</span>
	<span class="n">hvcs_tty_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_init_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hvcs_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">vio_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_vio_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: can&#39;t register vio driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;HVCS: Driver registered.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* This needs to be done AFTER the vio_register_driver() call or else</span>
<span class="cm">	 * the kobjects won&#39;t be initialized properly.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hvcs_vio_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">driver_attr_rescan</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;HVCS: Failed to create rescan file (err %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hvcs_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This driver receives hvcs_remove callbacks for each device upon</span>
<span class="cm">	 * module removal.</span>
<span class="cm">	 */</span>
	<span class="n">vio_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_vio_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hvcs_task</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This synchronous operation  will wake the khvcsd kthread if it is</span>
<span class="cm">	 * asleep and will return when khvcsd has terminated.</span>
<span class="cm">	 */</span>
	<span class="n">kthread_stop</span><span class="p">(</span><span class="n">hvcs_task</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_pi_lock</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hvcs_pi_buff</span><span class="p">);</span>
	<span class="n">hvcs_pi_buff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_pi_lock</span><span class="p">);</span>

	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hvcs_vio_driver</span><span class="p">.</span><span class="n">driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_rescan</span><span class="p">);</span>

	<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">hvcs_tty_driver</span><span class="p">);</span>

	<span class="n">hvcs_free_index_list</span><span class="p">();</span>

	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">hvcs_tty_driver</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HVCS: driver module removed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">hvcs_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hvcs_module_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
