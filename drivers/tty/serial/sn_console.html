<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › serial › sn_console.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sn_console.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * C-Brick Serial Port (and console) driver for SGI Altix machines.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is NOT suitable for talking to the l1-controller for</span>
<span class="cm"> * anything other than &#39;console activities&#39; --- please use the l1</span>
<span class="cm"> * driver for that.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004-2006 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of version 2 of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it would be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> *</span>
<span class="cm"> * Further, this software is distributed without any warranty that it is</span>
<span class="cm"> * free of the rightful claim of any third person regarding infringement</span>
<span class="cm"> * or the like.  Any license provided herein, whether implied or</span>
<span class="cm"> * otherwise, applies only to this software file.  Patent licenses, if</span>
<span class="cm"> * any, provided herein do not apply to combinations of this program with</span>
<span class="cm"> * other software, or any other product whatsoever.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact information:  Silicon Graphics, Inc., 1500 Crittenden Lane,</span>
<span class="cm"> * Mountain View, CA  94043, or:</span>
<span class="cm"> *</span>
<span class="cm"> * http://www.sgi.com</span>
<span class="cm"> *</span>
<span class="cm"> * For further information regarding this notice, see:</span>
<span class="cm"> *</span>
<span class="cm"> * http://oss.sgi.com/projects/GenInfo/NoticeExplan</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sysrq.h&gt;</span>
<span class="cp">#include &lt;linux/circ_buf.h&gt;</span>
<span class="cp">#include &lt;linux/serial_reg.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt; </span><span class="cm">/* for mdelay */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/serial_core.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/sn/simulator.h&gt;</span>
<span class="cp">#include &lt;asm/sn/sn_sal.h&gt;</span>

<span class="cm">/* number of characters we can transmit to the SAL console at a time */</span>
<span class="cp">#define SN_SAL_MAX_CHARS 120</span>

<span class="cm">/* 64K, when we&#39;re asynch, it must be at least printk&#39;s LOG_BUF_LEN to</span>
<span class="cm"> * avoid losing chars, (always has to be a power of 2) */</span>
<span class="cp">#define SN_SAL_BUFFER_SIZE (64 * (1 &lt;&lt; 10))</span>

<span class="cp">#define SN_SAL_UART_FIFO_DEPTH 16</span>
<span class="cp">#define SN_SAL_UART_FIFO_SPEED_CPS (9600/10)</span>

<span class="cm">/* sn_transmit_chars() calling args */</span>
<span class="cp">#define TRANSMIT_BUFFERED	0</span>
<span class="cp">#define TRANSMIT_RAW		1</span>

<span class="cm">/* To use dynamic numbers only and not use the assigned major and minor,</span>
<span class="cm"> * define the following.. */</span>
				  <span class="cm">/* #define USE_DYNAMIC_MINOR 1 *//* use dynamic minor number */</span>
<span class="cp">#define USE_DYNAMIC_MINOR 0	</span><span class="cm">/* Don&#39;t rely on misc_register dynamic minor */</span><span class="cp"></span>

<span class="cm">/* Device name we&#39;re using */</span>
<span class="cp">#define DEVICE_NAME &quot;ttySG&quot;</span>
<span class="cp">#define DEVICE_NAME_DYNAMIC &quot;ttySG0&quot;	</span><span class="cm">/* need full name for misc_register */</span><span class="cp"></span>
<span class="cm">/* The major/minor we are using, ignored for USE_DYNAMIC_MINOR */</span>
<span class="cp">#define DEVICE_MAJOR 204</span>
<span class="cp">#define DEVICE_MINOR 40</span>

<span class="cp">#ifdef CONFIG_MAGIC_SYSRQ</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">sysrq_serial_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;\eSYS&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sysrq_serial_ptr</span> <span class="o">=</span> <span class="n">sysrq_serial_str</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysrq_requested</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MAGIC_SYSRQ */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Port definition - this kinda drives it all</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">sc_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="n">sc_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_sal_ops</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sal_puts_raw</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sal_puts</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sal_getc</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sal_input_pending</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sal_wakeup_transmit</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">sc_ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sc_interrupt_timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sc_is_asynch</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="n">sal_console_port</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sn_process_input</span><span class="p">;</span>

<span class="cm">/* Only used if USE_DYNAMIC_MINOR is set to 1 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">misc</span><span class="p">;</span>	<span class="cm">/* used with misc_register for dynamic */</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">early_sn_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#undef DEBUG</span>
<span class="cp">#ifdef DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sn_debug_printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#define DPRINTF(x...) sn_debug_printf(x)</span>
<span class="cp">#else</span>
<span class="cp">#define DPRINTF(x...) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/* Prototypes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">snt_hw_puts_raw</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">snt_hw_puts_buffered</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">snt_poll_getc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">snt_poll_input_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">snt_intr_getc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">snt_intr_input_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sn_transmit_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* A table for polling:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sn_sal_ops</span> <span class="n">poll_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sal_puts_raw</span> <span class="o">=</span> <span class="n">snt_hw_puts_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sal_puts</span> <span class="o">=</span> <span class="n">snt_hw_puts_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sal_getc</span> <span class="o">=</span> <span class="n">snt_poll_getc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sal_input_pending</span> <span class="o">=</span> <span class="n">snt_poll_input_pending</span>
<span class="p">};</span>

<span class="cm">/* A table for interrupts enabled */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sn_sal_ops</span> <span class="n">intr_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sal_puts_raw</span> <span class="o">=</span> <span class="n">snt_hw_puts_raw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sal_puts</span> <span class="o">=</span> <span class="n">snt_hw_puts_buffered</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sal_getc</span> <span class="o">=</span> <span class="n">snt_intr_getc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sal_input_pending</span> <span class="o">=</span> <span class="n">snt_intr_input_pending</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sal_wakeup_transmit</span> <span class="o">=</span> <span class="n">sn_transmit_chars</span>
<span class="p">};</span>

<span class="cm">/* the console does output in two distinctly different ways:</span>
<span class="cm"> * synchronous (raw) and asynchronous (buffered).  initially, early_printk</span>
<span class="cm"> * does synchronous output.  any data written goes directly to the SAL</span>
<span class="cm"> * to be output (incidentally, it is internally buffered by the SAL)</span>
<span class="cm"> * after interrupts and timers are initialized and available for use,</span>
<span class="cm"> * the console init code switches to asynchronous output.  this is</span>
<span class="cm"> * also the earliest opportunity to begin polling for console input.</span>
<span class="cm"> * after console initialization, console output and tty (serial port)</span>
<span class="cm"> * output is buffered and sent to the SAL asynchronously (either by</span>
<span class="cm"> * timer callback or by UART interrupt) */</span>

<span class="cm">/* routines for running the console in polling mode */</span>

<span class="cm">/**</span>
<span class="cm"> * snt_poll_getc - Get a character from the console in polling mode</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snt_poll_getc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>

	<span class="n">ia64_sn_console_getc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snt_poll_input_pending - Check if any input is waiting - polling mode.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snt_poll_input_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">input</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ia64_sn_console_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">input</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* routines for an interrupt driven console (normal) */</span>

<span class="cm">/**</span>
<span class="cm"> * snt_intr_getc - Get a character from the console, interrupt mode</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snt_intr_getc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ia64_sn_console_readc</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snt_intr_input_pending - Check if input is pending, interrupt mode</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snt_intr_input_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ia64_sn_console_intr_status</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">SAL_CONSOLE_INTR_RECV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* these functions are polled and interrupt */</span>

<span class="cm">/**</span>
<span class="cm"> * snt_hw_puts_raw - Send raw string to the console, polled or interrupt mode</span>
<span class="cm"> * @s: String</span>
<span class="cm"> * @len: Length</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snt_hw_puts_raw</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* this will call the PROM and not return until this is done */</span>
	<span class="k">return</span> <span class="n">ia64_sn_console_putb</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snt_hw_puts_buffered - Send string to console, polled or interrupt mode</span>
<span class="cm"> * @s: String</span>
<span class="cm"> * @len: Length</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snt_hw_puts_buffered</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* queue data to the PROM */</span>
	<span class="k">return</span> <span class="n">ia64_sn_console_xmit_chars</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* uart interface structs</span>
<span class="cm"> * These functions are associated with the uart_port that the serial core</span>
<span class="cm"> * infrastructure calls.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Due to how the console works, many routines are no-ops.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * snp_type - What type of console are we?</span>
<span class="cm"> * @port: Port to operate with (we ignore since we only have one port)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">snp_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="s">&quot;SGI SN L1&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_tx_empty - Is the transmitter empty?  We pretend we&#39;re always empty</span>
<span class="cm"> * @port: Port to operate on (we ignore since we only have one port)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">snp_tx_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_stop_tx - stop the transmitter - no-op for us</span>
<span class="cm"> * @port: Port to operat eon - we ignore - no-op function</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_release_port - Free i/o and resources for port - no-op for us</span>
<span class="cm"> * @port: Port to operate on - we ignore - no-op function</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_release_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_enable_ms - Force modem status interrupts on - no-op for us</span>
<span class="cm"> * @port: Port to operate on - we ignore - no-op function</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_enable_ms</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_shutdown - shut down the port - free irq and disable - no-op for us</span>
<span class="cm"> * @port: Port to shut down - we ignore</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_set_mctrl - set control lines (dtr, rts, etc) - no-op for our console</span>
<span class="cm"> * @port: Port to operate on - we ignore</span>
<span class="cm"> * @mctrl: Lines to set/unset - we ignore</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_set_mctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mctrl</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_get_mctrl - get contorl line info, we just return a static value</span>
<span class="cm"> * @port: port to operate on - we only have one port so we ignore this</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">snp_get_mctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">TIOCM_CAR</span> <span class="o">|</span> <span class="n">TIOCM_RNG</span> <span class="o">|</span> <span class="n">TIOCM_DSR</span> <span class="o">|</span> <span class="n">TIOCM_CTS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_stop_rx - Stop the receiver - we ignor ethis</span>
<span class="cm"> * @port: Port to operate on - we ignore</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_stop_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_start_tx - Start transmitter</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_wakeup_transmit</span><span class="p">)</span>
		<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_wakeup_transmit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">,</span>
							     <span class="n">TRANSMIT_BUFFERED</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_break_ctl - handle breaks - ignored by us</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> * @break_state: Break state</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_break_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">break_state</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_startup - Start up the serial port - always return 0 (We&#39;re always on)</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snp_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_set_termios - set termios stuff - we ignore these</span>
<span class="cm"> * @port: port to operate on</span>
<span class="cm"> * @termios: New settings</span>
<span class="cm"> * @termios: Old</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">snp_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_request_port - allocate resources for port - ignored by us</span>
<span class="cm"> * @port: port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">snp_request_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * snp_config_port - allocate resources, set up - we ignore,  we&#39;re always on</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> * @flags: flags used for port setup</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">snp_config_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* Associate the uart functions above - given to serial core */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_ops</span> <span class="n">sn_console_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">tx_empty</span> <span class="o">=</span> <span class="n">snp_tx_empty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mctrl</span> <span class="o">=</span> <span class="n">snp_set_mctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_mctrl</span> <span class="o">=</span> <span class="n">snp_get_mctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_tx</span> <span class="o">=</span> <span class="n">snp_stop_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_tx</span> <span class="o">=</span> <span class="n">snp_start_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_rx</span> <span class="o">=</span> <span class="n">snp_stop_rx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_ms</span> <span class="o">=</span> <span class="n">snp_enable_ms</span><span class="p">,</span>
	<span class="p">.</span><span class="n">break_ctl</span> <span class="o">=</span> <span class="n">snp_break_ctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">startup</span> <span class="o">=</span> <span class="n">snp_startup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">snp_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span> <span class="o">=</span> <span class="n">snp_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">snp_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_port</span> <span class="o">=</span> <span class="n">snp_release_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">request_port</span> <span class="o">=</span> <span class="n">snp_request_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">config_port</span> <span class="o">=</span> <span class="n">snp_config_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">verify_port</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* End of uart struct functions and defines */</span>

<span class="cp">#ifdef DEBUG</span>

<span class="cm">/**</span>
<span class="cm"> * sn_debug_printf - close to hardware debugging printf</span>
<span class="cm"> * @fmt: printf format</span>
<span class="cm"> *</span>
<span class="cm"> * This is as &quot;close to the metal&quot; as we can get, used when the driver</span>
<span class="cm"> * itself may be broken.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sn_debug_printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">printk_buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">printed_len</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">printed_len</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">printk_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">printk_buf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poll_ops</span><span class="p">;</span>
		<span class="n">early_sn_setup</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_puts_raw</span><span class="p">(</span><span class="n">printk_buf</span><span class="p">,</span> <span class="n">printed_len</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">printed_len</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handling routines.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * sn_receive_chars - Grab characters, pass them to tty layer</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> * @flags: irq flags</span>
<span class="cm"> *</span>
<span class="cm"> * Note: If we&#39;re not registered with the serial core infrastructure yet,</span>
<span class="cm"> * we don&#39;t try to send characters to it...</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sn_receive_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sn_receive_chars - port NULL so can&#39;t receive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sn_receive_chars - port-&gt;sc_ops  NULL so can&#39;t receive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The serial_core stuffs are initialized, use them */</span>
		<span class="n">tty</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Not registered yet - can&#39;t pass to tty layer.  */</span>
		<span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_input_pending</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_getc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sn_console: An error occurred while &quot;</span>
			       <span class="s">&quot;obtaining data from the console (0x%0x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_MAGIC_SYSRQ</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sysrq_requested</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sysrq_timeout</span> <span class="o">=</span> <span class="n">sysrq_requested</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">*</span><span class="mi">5</span><span class="p">;</span>

                        <span class="n">sysrq_requested</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sysrq_timeout</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
                                <span class="n">handle_sysrq</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
                                <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
                                <span class="cm">/* ignore actual sysrq command char */</span>
                                <span class="k">continue</span><span class="p">;</span>
                        <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="o">*</span><span class="n">sysrq_serial_ptr</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*++</span><span class="n">sysrq_serial_ptr</span><span class="p">))</span> <span class="p">{</span>
                                <span class="n">sysrq_requested</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
                                <span class="n">sysrq_serial_ptr</span> <span class="o">=</span> <span class="n">sysrq_serial_str</span><span class="p">;</span>
                        <span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * ignore the whole sysrq string except for the</span>
<span class="cm">			 * leading escape</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">!=</span> <span class="sc">&#39;\e&#39;</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span>
			<span class="n">sysrq_serial_ptr</span> <span class="o">=</span> <span class="n">sysrq_serial_str</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MAGIC_SYSRQ */</span><span class="cp"></span>

		<span class="cm">/* record the character to pass up to the tty layer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">TTY_NORMAL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">icount</span><span class="p">.</span><span class="n">rx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_transmit_chars - grab characters from serial core, send off</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> * @raw: Transmit raw or buffered</span>
<span class="cm"> *</span>
<span class="cm"> * Note: If we&#39;re early, before we&#39;re registered with serial core, the</span>
<span class="cm"> * writes are going through sn_sal_console_write because that&#39;s how</span>
<span class="cm"> * register_console has been set up.  We currently could have asynch</span>
<span class="cm"> * polls calling this function due to sn_sal_switch_to_asynch but we can</span>
<span class="cm"> * ignore them until we register with the serial core stuffs.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_transmit_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">raw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">xmit_count</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">loops</span><span class="p">,</span> <span class="n">ii</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">xmit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_is_asynch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We&#39;re initialized, using serial core infrastructure */</span>
		<span class="n">xmit</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Probably sn_sal_switch_to_asynch has been run but serial core isn&#39;t</span>
<span class="cm">		 * initialized yet.  Just return.  Writes are going through</span>
<span class="cm">		 * sn_sal_console_write (due to register_console) at this time.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">xmit</span><span class="p">)</span> <span class="o">||</span> <span class="n">uart_tx_stopped</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Nothing to do. */</span>
		<span class="n">ia64_sn_console_intr_disable</span><span class="p">(</span><span class="n">SAL_CONSOLE_INTR_XMIT</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">xmit</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">tail</span><span class="p">];</span>

	<span class="cm">/* twice around gets the tail to the end of the buffer and</span>
<span class="cm">	 * then to the head, if needed */</span>
	<span class="n">loops</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">&lt;</span> <span class="n">tail</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">loops</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xmit_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">&lt;</span> <span class="n">tail</span><span class="p">)</span> <span class="o">?</span>
		    <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="n">tail</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">head</span> <span class="o">-</span> <span class="n">tail</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">xmit_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">raw</span> <span class="o">==</span> <span class="n">TRANSMIT_RAW</span><span class="p">)</span>
				<span class="n">result</span> <span class="o">=</span>
				    <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_puts_raw</span><span class="p">(</span><span class="n">start</span><span class="p">,</span>
							       <span class="n">xmit_count</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">result</span> <span class="o">=</span>
				    <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_puts</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">xmit_count</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
				<span class="n">DPRINTF</span><span class="p">(</span><span class="s">&quot;`&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">xmit_count</span> <span class="o">-=</span> <span class="n">result</span><span class="p">;</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span> <span class="o">+=</span> <span class="n">result</span><span class="p">;</span>
				<span class="n">tail</span> <span class="o">+=</span> <span class="n">result</span><span class="p">;</span>
				<span class="n">tail</span> <span class="o">&amp;=</span> <span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
				<span class="n">start</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">tail</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_chars_pending</span><span class="p">(</span><span class="n">xmit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">WAKEUP_CHARS</span><span class="p">)</span>
		<span class="n">uart_write_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">xmit</span><span class="p">))</span>
		<span class="n">snp_stop_tx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">);</span>	<span class="cm">/* no-op for us */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_interrupt - Handle console interrupts</span>
<span class="cm"> * @irq: irq #, useful for debug statements</span>
<span class="cm"> * @dev_id: our pointer to our port (sn_cons_port which contains the uart port)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">sn_sal_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ia64_sn_console_intr_status</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SAL_CONSOLE_INTR_RECV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sn_receive_chars</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">SAL_CONSOLE_INTR_XMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sn_transmit_chars</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">TRANSMIT_BUFFERED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_timer_poll - this function handles polled console mode</span>
<span class="cm"> * @data: A pointer to our sn_cons_port (which contains the uart port)</span>
<span class="cm"> *</span>
<span class="cm"> * data is the pointer that init_timer will store for us.  This function is</span>
<span class="cm"> * associated with init_timer to see if there is any console traffic.</span>
<span class="cm"> * Obviously not used in interrupt mode</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sn_sal_timer_poll</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sn_process_input</span><span class="p">)</span>
			<span class="n">sn_receive_chars</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">sn_transmit_chars</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">TRANSMIT_RAW</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">,</span>
			  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_interrupt_timeout</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Boot-time initialization code</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_switch_to_asynch - Switch to async mode (as opposed to synch)</span>
<span class="cm"> * @port: Our sn_cons_port (which contains the uart port)</span>
<span class="cm"> *</span>
<span class="cm"> * So this is used by sn_sal_serial_console_init (early on, before we&#39;re</span>
<span class="cm"> * registered with serial core).  It&#39;s also used by sn_sal_module_init</span>
<span class="cm"> * right after we&#39;ve registered with serial core.  The later only happens</span>
<span class="cm"> * if we didn&#39;t already come through here via sn_sal_serial_console_init.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sn_sal_switch_to_asynch</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">DPRINTF</span><span class="p">(</span><span class="s">&quot;sn_console: about to switch to asynchronous console</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* without early_printk, we may be invoked late enough to race</span>
<span class="cm">	 * with other cpus doing console IO at this point, however</span>
<span class="cm">	 * console interrupts will never be enabled */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* early_printk invocation may have done this for us */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poll_ops</span><span class="p">;</span>

	<span class="cm">/* we can&#39;t turn on the console interrupt (as request_irq</span>
<span class="cm">	 * calls kmalloc, which isn&#39;t set up yet), so we rely on a</span>
<span class="cm">	 * timer to poll for input and push data from the console</span>
<span class="cm">	 * buffer.</span>
<span class="cm">	 */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sn_sal_timer_poll</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_RUNNING_ON_SIMULATOR</span><span class="p">())</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_interrupt_timeout</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 960cps / 16 char FIFO = 60HZ</span>
<span class="cm">		 * HZ / (SN_SAL_FIFO_SPEED_CPS / SN_SAL_FIFO_DEPTH) */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_interrupt_timeout</span> <span class="o">=</span>
		    <span class="n">HZ</span> <span class="o">*</span> <span class="n">SN_SAL_UART_FIFO_DEPTH</span> <span class="o">/</span> <span class="n">SN_SAL_UART_FIFO_SPEED_CPS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_interrupt_timeout</span><span class="p">);</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_is_asynch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_switch_to_interrupts - Switch to interrupt driven mode</span>
<span class="cm"> * @port: Our sn_cons_port (which contains the uart port)</span>
<span class="cm"> *</span>
<span class="cm"> * In sn_sal_module_init, after we&#39;re registered with serial core and</span>
<span class="cm"> * the port is added, this function is called to switch us to interrupt</span>
<span class="cm"> * mode.  We were previously in asynch/polling mode (using init_timer).</span>
<span class="cm"> *</span>
<span class="cm"> * We attempt to switch to interrupt mode here by calling</span>
<span class="cm"> * request_irq.  If that works out, we enable receive interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">sn_sal_switch_to_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTF</span><span class="p">(</span><span class="s">&quot;sn_console: switching to interrupt driven console</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">SGI_UART_VECTOR</span><span class="p">,</span> <span class="n">sn_sal_interrupt</span><span class="p">,</span>
				<span class="n">IRQF_SHARED</span><span class="p">,</span>
				<span class="s">&quot;SAL console driver&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">SGI_UART_VECTOR</span><span class="p">;</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intr_ops</span><span class="p">;</span>
			<span class="n">irq_set_handler</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">handle_level_irq</span><span class="p">);</span>

			<span class="cm">/* turn on receive interrupts */</span>
			<span class="n">ia64_sn_console_intr_enable</span><span class="p">(</span><span class="n">SAL_CONSOLE_INTR_RECV</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			    <span class="s">&quot;sn_console: console proceeding in polled mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kernel console definitions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sn_sal_console_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sn_sal_console_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_driver</span> <span class="n">sal_console_uart</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">uart_console_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">console</span> <span class="n">sal_console</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DEVICE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sn_sal_console_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">uart_console_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup</span> <span class="o">=</span> <span class="n">sn_sal_console_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>		<span class="cm">/* unspecified */</span>
	<span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sal_console_uart</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define SAL_CONSOLE	&amp;sal_console</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_driver</span> <span class="n">sal_console_uart</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver_name</span> <span class="o">=</span> <span class="s">&quot;sn_console&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span> <span class="o">=</span> <span class="n">DEVICE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>		<span class="cm">/* major/minor set at registration time per USE_DYNAMIC_MINOR */</span>
	<span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>		<span class="cm">/* one port */</span>
	<span class="p">.</span><span class="n">cons</span> <span class="o">=</span> <span class="n">SAL_CONSOLE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_module_init - When the kernel loads us, get us rolling w/ serial core</span>
<span class="cm"> *</span>
<span class="cm"> * Before this is called, we&#39;ve been printing kernel messages in a special</span>
<span class="cm"> * early mode not making use of the serial core infrastructure.  When our</span>
<span class="cm"> * driver is loaded for real, we register the driver and port with serial</span>
<span class="cm"> * core and try to enable interrupt driven mode.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sn_sal_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;sn_console: Console driver init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">USE_DYNAMIC_MINOR</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">misc</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">;</span>
		<span class="n">misc</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DEVICE_NAME_DYNAMIC</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">misc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Failed to register console &quot;</span>
			       <span class="s">&quot;device using misc_register.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sal_console_uart</span><span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="n">MISC_MAJOR</span><span class="p">;</span>
		<span class="n">sal_console_uart</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">misc</span><span class="p">.</span><span class="n">minor</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sal_console_uart</span><span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="n">DEVICE_MAJOR</span><span class="p">;</span>
		<span class="n">sal_console_uart</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">DEVICE_MINOR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We register the driver and the port before switching to interrupts</span>
<span class="cm">	 * or async above so the proper uart structures are populated */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_uart</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span>
		    <span class="p">(</span><span class="s">&quot;ERROR sn_sal_module_init failed uart_register_driver, line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">__LINE__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Setup the port struct with the minimum needed */</span>
	<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">.</span><span class="n">membase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* just needs to be non-zero */</span>
	<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PORT_16550A</span><span class="p">;</span>
	<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">.</span><span class="n">fifosize</span> <span class="o">=</span> <span class="n">SN_SAL_MAX_CHARS</span><span class="p">;</span>
	<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sn_console_ops</span><span class="p">;</span>
	<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">.</span><span class="n">line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_add_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_uart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* error - not sure what I&#39;d do - so I&#39;ll do nothing */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: unable to add port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* when this driver is compiled in, the console initialization</span>
<span class="cm">	 * will have already switched us into asynchronous operation</span>
<span class="cm">	 * before we get here through the module initcalls */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_is_asynch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sn_sal_switch_to_asynch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* at this point (module_init) we can try to turn on interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_RUNNING_ON_SIMULATOR</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">sn_sal_switch_to_interrupts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sn_process_input</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_module_exit - When we&#39;re unloaded, remove the driver/port</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">sn_sal_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_timer</span><span class="p">);</span>
	<span class="n">uart_remove_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_uart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">);</span>
	<span class="n">uart_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_uart</span><span class="p">);</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">misc</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">sn_sal_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">sn_sal_module_exit</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * puts_raw_fixed - sn_sal_console_write helper for adding \r&#39;s as required</span>
<span class="cm"> * @puts_raw : puts function to do the writing</span>
<span class="cm"> * @s: input string</span>
<span class="cm"> * @count: length</span>
<span class="cm"> *</span>
<span class="cm"> * We need a \r ahead of every \n for direct writes through</span>
<span class="cm"> * ia64_sn_console_putb (what sal_puts_raw below actually does).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">puts_raw_fixed</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">puts_raw</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">),</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">;</span>

	<span class="cm">/* Output &#39;\r&#39; before each &#39;\n&#39; */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">s1</span> <span class="o">=</span> <span class="n">memchr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">puts_raw</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">puts_raw</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">s1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">puts_raw</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_console_write - Print statements before serial core available</span>
<span class="cm"> * @console: Console to operate on - we ignore since we have just one</span>
<span class="cm"> * @s: String to send</span>
<span class="cm"> * @count: length</span>
<span class="cm"> *</span>
<span class="cm"> * This is referenced in the console struct.  It is used for early</span>
<span class="cm"> * console printing before we register with serial core and for things</span>
<span class="cm"> * such as kdb.  The console_lock must be held when we get here.</span>
<span class="cm"> *</span>
<span class="cm"> * This function has some code for trying to print output even if the lock</span>
<span class="cm"> * is held.  We try to cover the case where a lock holder could have died.</span>
<span class="cm"> * We don&#39;t use this special case code if we&#39;re not registered with serial</span>
<span class="cm"> * core yet.  After we&#39;re registered with serial core, the only time this</span>
<span class="cm"> * function would be used is for high level kernel output like magic sys req,</span>
<span class="cm"> * kdb, and printk&#39;s.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sn_sal_console_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sn_cons_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">stole_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_is_asynch</span><span class="p">);</span>

	<span class="cm">/* We can&#39;t look at the xmit buffer if we&#39;re not registered with serial core</span>
<span class="cm">	 *  yet.  So only do the fancy recovery after registering</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not yet registered with serial core - simple case */</span>
		<span class="n">puts_raw_fixed</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_puts_raw</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* somebody really wants this output, might be an</span>
<span class="cm">	 * oops, kdb, panic, etc.  make sure they get it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spin_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lhead</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ltail</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">counter</span><span class="p">,</span> <span class="n">got_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We attempt to determine if someone has died with the</span>
<span class="cm">		 * lock. We wait ~20 secs after the head and tail ptrs</span>
<span class="cm">		 * stop moving and assume the lock holder is not functional</span>
<span class="cm">		 * and plow ahead. If the lock is freed within the time out</span>
<span class="cm">		 * period we re-get the lock and go ahead normally. We also</span>
<span class="cm">		 * remember if we have plowed ahead so that we don&#39;t have</span>
<span class="cm">		 * to wait out the time out period again - the asumption</span>
<span class="cm">		 * is that we will time out again.</span>
<span class="cm">		 */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">150</span><span class="p">;</span> <span class="n">mdelay</span><span class="p">(</span><span class="mi">125</span><span class="p">),</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">)</span>
			    <span class="o">||</span> <span class="n">stole_lock</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stole_lock</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span>
							  <span class="n">flags</span><span class="p">);</span>
					<span class="n">got_lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* still locked */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">lhead</span> <span class="o">!=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
				    <span class="o">||</span> <span class="p">(</span><span class="n">ltail</span> <span class="o">!=</span>
					<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">tail</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">lhead</span> <span class="o">=</span>
						<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
					<span class="n">ltail</span> <span class="o">=</span>
						<span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
					<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* flush anything in the serial core xmit buffer, raw */</span>
		<span class="n">sn_transmit_chars</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">got_lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">stole_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* fell thru */</span>
			<span class="n">stole_lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">puts_raw_fixed</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_puts_raw</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">stole_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">sn_transmit_chars</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">puts_raw_fixed</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_puts_raw</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * sn_sal_console_setup - Set up console for early printing</span>
<span class="cm"> * @co: Console to work with</span>
<span class="cm"> * @options: Options to set</span>
<span class="cm"> *</span>
<span class="cm"> * Altix console doesn&#39;t do anything with baud rates, etc, anyway.</span>
<span class="cm"> *</span>
<span class="cm"> * This isn&#39;t required since not providing the setup function in the</span>
<span class="cm"> * console struct is ok.  However, other patches like KDB plop something</span>
<span class="cm"> * here so providing it is easier.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sn_sal_console_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_console_write_early - simple early output routine</span>
<span class="cm"> * @co - console struct</span>
<span class="cm"> * @s - string to print</span>
<span class="cm"> * @count - count</span>
<span class="cm"> *</span>
<span class="cm"> * Simple function to provide early output, before even</span>
<span class="cm"> * sn_sal_serial_console_init is called.  Referenced in the</span>
<span class="cm"> * console struct registerd in sn_serial_console_early_setup.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">sn_sal_console_write_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">puts_raw_fixed</span><span class="p">(</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">sal_puts_raw</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used for very early console printing - again, before</span>
<span class="cm"> * sn_sal_serial_console_init is run */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">console</span> <span class="n">sal_console_early</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;sn_sal&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sn_sal_console_write_early</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CON_PRINTBUFFER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * sn_serial_console_early_setup - Sets up early console output support</span>
<span class="cm"> *</span>
<span class="cm"> * Register a console early on...  This is for output before even</span>
<span class="cm"> * sn_sal_serial_cosnole_init is called.  This function is called from</span>
<span class="cm"> * setup.c.  This allows us to do really early polled writes. When</span>
<span class="cm"> * sn_sal_serial_console_init is called, this console is unregistered</span>
<span class="cm"> * and a new one registered.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">sn_serial_console_early_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">poll_ops</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">.</span><span class="n">sc_port</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">early_sn_setup</span><span class="p">();</span>	<span class="cm">/* Find SAL entry points */</span>
	<span class="n">register_console</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_early</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sn_sal_serial_console_init - Early console output - set up for register</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when regular console init happens.  Because we</span>
<span class="cm"> * support even earlier console output with sn_serial_console_early_setup</span>
<span class="cm"> * (called from setup.c directly), this function unregisters the really</span>
<span class="cm"> * early console.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Even if setup.c doesn&#39;t register sal_console_early, unregistering</span>
<span class="cm"> * it here doesn&#39;t hurt anything.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sn_sal_serial_console_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ia64_platform_is</span><span class="p">(</span><span class="s">&quot;sn2&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sn_sal_switch_to_asynch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_port</span><span class="p">);</span>
		<span class="n">DPRINTF</span><span class="p">(</span><span class="s">&quot;sn_sal_serial_console_init : register console</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">register_console</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console</span><span class="p">);</span>
		<span class="n">unregister_console</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sal_console_early</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">console_initcall</span><span class="p">(</span><span class="n">sn_sal_serial_console_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
