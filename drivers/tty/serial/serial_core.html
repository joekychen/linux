<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › serial › serial_core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>serial_core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Driver core for serial ports</span>
<span class="cm"> *</span>
<span class="cm"> *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts&#39;o.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright 1999 ARM Limited</span>
<span class="cm"> *  Copyright (C) 2000-2001 Deep Blue Solutions Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt; </span><span class="cm">/* for serial_state and serial_icounter_struct */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/serial_core.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * This is used to lock changes in serial line configuration.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">port_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * lockdep: port-&gt;lock is initialized in two places, but we</span>
<span class="cm"> *          want only one lock-class:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">port_lock_key</span><span class="p">;</span>

<span class="cp">#define HIGH_BITS_OFFSET	((sizeof(long)-sizeof(int))*8)</span>

<span class="cp">#ifdef CONFIG_SERIAL_CORE_CONSOLE</span>
<span class="cp">#define uart_console(port)	((port)-&gt;cons &amp;&amp; (port)-&gt;cons-&gt;index == (port)-&gt;line)</span>
<span class="cp">#else</span>
<span class="cp">#define uart_console(port)	(0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">uart_change_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old_termios</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">uart_wait_until_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">uart_change_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pm_state</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">uart_port_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is used by the interrupt handler to schedule processing in</span>
<span class="cm"> * the software interrupt portion of the driver.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uart_write_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This means you called this function _after_ the port was</span>
<span class="cm">	 * closed.  No cookie for you.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">);</span>
	<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop_tx</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__uart_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">buf</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">start_tx</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__uart_start</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">uart_update_mctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mctrl</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">mctrl</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">clear</span><span class="p">)</span> <span class="o">|</span> <span class="n">set</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mctrl</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_mctrl</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mctrl</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define uart_set_mctrl(port, set)	uart_update_mctrl(port, set, 0)</span>
<span class="cp">#define uart_clear_mctrl(port, clear)	uart_update_mctrl(port, 0, clear)</span>

<span class="cm">/*</span>
<span class="cm"> * Startup the port.  This will be called once per open.  All calls</span>
<span class="cm"> * will be serialised by the per-port mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_port_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">init_hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialise and allocate the transmit and temporary</span>
<span class="cm">	 * buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is protected by the per port mutex */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">uart_circ_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">startup</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">cflag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">cflag</span><span class="p">;</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">cflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Initialise the hardware port settings.</span>
<span class="cm">		 */</span>
		<span class="n">uart_change_speed</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">init_hw</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Setup the RTS and DTR signals once the</span>
<span class="cm">			 * port is open and ready to respond.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">)</span>
				<span class="n">uart_set_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">TIOCM_RTS</span> <span class="o">|</span> <span class="n">TIOCM_DTR</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CTS_FLOW</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TIOCM_CTS</span><span class="p">))</span>
				<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is to allow setserial on this port. People may want to set</span>
<span class="cm">	 * port/irq/type and then reconfigure the port properly if it failed</span>
<span class="cm">	 * now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">init_hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the TTY IO error marker - we will only clear this</span>
<span class="cm">	 * once we have successfully opened the port.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">uart_port_startup</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">init_hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ASYNCB_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine will shutdown a serial port; interrupts are disabled, and</span>
<span class="cm"> * DTR is dropped if the hangup on close termio flag is on.  Calls to</span>
<span class="cm"> * uart_shutdown are serialised by the per-port semaphore.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the TTY IO error marker</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_IO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">ASYNCB_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Turn off DTR and RTS early.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span> <span class="o">||</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">HUPCL</span><span class="p">))</span>
			<span class="n">uart_clear_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">TIOCM_DTR</span> <span class="o">|</span> <span class="n">TIOCM_RTS</span><span class="p">);</span>

		<span class="n">uart_port_shutdown</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s possible for shutdown to be called after suspend if we get</span>
<span class="cm">	 * a DCD drop (hangup) at just the right time.  Clear suspended bit so</span>
<span class="cm">	 * we don&#39;t try to resume a port that has been shutdown.</span>
<span class="cm">	 */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNCB_SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the transmit buffer page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_update_timeout - update per-port FIFO timeout.</span>
<span class="cm"> *	@port:  uart_port structure describing the port</span>
<span class="cm"> *	@cflag: termios cflag value</span>
<span class="cm"> *	@baud:  speed of the port</span>
<span class="cm"> *</span>
<span class="cm"> *	Set the port FIFO timeout value.  The @cflag value should</span>
<span class="cm"> *	reflect the actual hardware settings.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">uart_update_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflag</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">baud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>

	<span class="cm">/* byte size and parity */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CSIZE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CS5</span>:
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS6</span>:
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS7</span>:
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span> <span class="cm">/* CS8 */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CSTOPB</span><span class="p">)</span>
		<span class="n">bits</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">PARENB</span><span class="p">)</span>
		<span class="n">bits</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The total number of bits to be transmitted in the fifo.</span>
<span class="cm">	 */</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">*</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">fifosize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure the timeout to send the above number of bits.</span>
<span class="cm">	 * Add .02 seconds of slop</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">*</span> <span class="n">bits</span><span class="p">)</span> <span class="o">/</span> <span class="n">baud</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">50</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_update_timeout</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_get_baud_rate - return baud rate for a particular port</span>
<span class="cm"> *	@port: uart_port structure describing the port in question.</span>
<span class="cm"> *	@termios: desired termios settings.</span>
<span class="cm"> *	@old: old termios (or NULL)</span>
<span class="cm"> *	@min: minimum acceptable baud rate</span>
<span class="cm"> *	@max: maximum acceptable baud rate</span>
<span class="cm"> *</span>
<span class="cm"> *	Decode the termios structure into a numeric baud rate,</span>
<span class="cm"> *	taking account of the magic 38400 baud rate (with spd_*</span>
<span class="cm"> *	flags), and mapping the %B0 rate to 9600 baud.</span>
<span class="cm"> *</span>
<span class="cm"> *	If the new baud rate is invalid, try the old termios setting.</span>
<span class="cm"> *	If it&#39;s still invalid, we try 9600 baud.</span>
<span class="cm"> *</span>
<span class="cm"> *	Update the @termios structure to reflect the baud rate</span>
<span class="cm"> *	we&#39;re actually going to be using. Don&#39;t do this for the case</span>
<span class="cm"> *	where B0 is requested (&quot;hang up&quot;).</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">uart_get_baud_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">try</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span> <span class="n">altbaud</span> <span class="o">=</span> <span class="mi">38400</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hung_up</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">upf_t</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_SPD_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">UPF_SPD_HI</span><span class="p">)</span>
		<span class="n">altbaud</span> <span class="o">=</span> <span class="mi">57600</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">UPF_SPD_VHI</span><span class="p">)</span>
		<span class="n">altbaud</span> <span class="o">=</span> <span class="mi">115200</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">UPF_SPD_SHI</span><span class="p">)</span>
		<span class="n">altbaud</span> <span class="o">=</span> <span class="mi">230400</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">UPF_SPD_WARP</span><span class="p">)</span>
		<span class="n">altbaud</span> <span class="o">=</span> <span class="mi">460800</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">try</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">try</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">try</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">baud</span> <span class="o">=</span> <span class="n">tty_termios_baud_rate</span><span class="p">(</span><span class="n">termios</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The spd_hi, spd_vhi, spd_shi, spd_warp kludge...</span>
<span class="cm">		 * Die! Die! Die!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">baud</span> <span class="o">==</span> <span class="mi">38400</span><span class="p">)</span>
			<span class="n">baud</span> <span class="o">=</span> <span class="n">altbaud</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Special case: B0 rate.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">baud</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hung_up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">baud</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">baud</span> <span class="o">&gt;=</span> <span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="n">baud</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">baud</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Oops, the quotient was zero.  Try again with</span>
<span class="cm">		 * the old baud rate if possible.</span>
<span class="cm">		 */</span>
		<span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CBAUD</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">baud</span> <span class="o">=</span> <span class="n">tty_termios_baud_rate</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hung_up</span><span class="p">)</span>
				<span class="n">tty_termios_encode_baud_rate</span><span class="p">(</span><span class="n">termios</span><span class="p">,</span>
								<span class="n">baud</span><span class="p">,</span> <span class="n">baud</span><span class="p">);</span>
			<span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * As a last resort, if the range cannot be met then clip to</span>
<span class="cm">		 * the nearest chip supported rate.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hung_up</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">baud</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">)</span>
				<span class="n">tty_termios_encode_baud_rate</span><span class="p">(</span><span class="n">termios</span><span class="p">,</span>
							<span class="n">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">tty_termios_encode_baud_rate</span><span class="p">(</span><span class="n">termios</span><span class="p">,</span>
							<span class="n">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Should never happen */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_get_baud_rate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_get_divisor - return uart clock divisor</span>
<span class="cm"> *	@port: uart_port structure describing the port.</span>
<span class="cm"> *	@baud: desired baud rate</span>
<span class="cm"> *</span>
<span class="cm"> *	Calculate the uart clock divisor for the port.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">uart_get_divisor</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">baud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quot</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Old custom speed handling.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">baud</span> <span class="o">==</span> <span class="mi">38400</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_SPD_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">UPF_SPD_CUST</span><span class="p">)</span>
		<span class="n">quot</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">custom_divisor</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">quot</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">uartclk</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">baud</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">quot</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_get_divisor</span><span class="p">);</span>

<span class="cm">/* FIXME: Consistent locking policy */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_change_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old_termios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have no tty, termios, or the port does not exist,</span>
<span class="cm">	 * then we can&#39;t set the parameters for this port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span> <span class="o">||</span> <span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">||</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">termios</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set flags based on termios cflag</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ASYNCB_CTS_FLOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNCB_CTS_FLOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CLOCAL</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNCB_CHECK_CD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">ASYNCB_CHECK_CD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_termios</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">termios</span><span class="p">,</span> <span class="n">old_termios</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__uart_put_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">circ</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_chars_free</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">circ</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">circ</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_put_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__uart_put_char</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_flush_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uart_start</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">circ</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This means you called this function _after_ the port was</span>
<span class="cm">	 * closed.  No cookie for you.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EL3HLT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="n">circ</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">CIRC_SPACE_TO_END</span><span class="p">(</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">circ</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">UART_XMIT_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">circ</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">circ</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">uart_start</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_circ_chars_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_chars_in_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_circ_chars_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_flush_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This means you called this function _after_ the port was</span>
<span class="cm">	 * closed.  No cookie for you.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;uart_flush_buffer(%d) called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">uart_circ_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flush_buffer</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">flush_buffer</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is used to send a high-priority XON/XOFF character to</span>
<span class="cm"> * the device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_send_xchar</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">send_xchar</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">send_xchar</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">start_tx</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">I_IXOFF</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span>
		<span class="n">uart_send_xchar</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">STOP_CHAR</span><span class="p">(</span><span class="n">tty</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="n">uart_clear_mctrl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">,</span> <span class="n">TIOCM_RTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">I_IXOFF</span><span class="p">(</span><span class="n">tty</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">x_char</span><span class="p">)</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">uart_send_xchar</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">START_CHAR</span><span class="p">(</span><span class="n">tty</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="n">uart_set_mctrl</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">TIOCM_RTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">serial_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">retinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serial_struct</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

	<span class="cm">/* Ensure the state we copy is consistent and no hardware changes</span>
<span class="cm">	   occur as we go */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">tmp</span><span class="p">.</span><span class="n">type</span>	    <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">line</span>	    <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">port</span>	    <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HIGH_BITS_OFFSET</span><span class="p">)</span>
		<span class="n">tmp</span><span class="p">.</span><span class="n">port_high</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">&gt;&gt;</span> <span class="n">HIGH_BITS_OFFSET</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">irq</span>		    <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">flags</span>	    <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">xmit_fifo_size</span>  <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">fifosize</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">baud_base</span>	    <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">uartclk</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">close_delay</span>	    <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">close_delay</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">closing_wait</span>    <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">closing_wait</span> <span class="o">==</span> <span class="n">ASYNC_CLOSING_WAIT_NONE</span> <span class="o">?</span>
				<span class="n">ASYNC_CLOSING_WAIT_NONE</span> <span class="o">:</span>
				<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">closing_wait</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">custom_divisor</span>  <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">custom_divisor</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">hub6</span>	    <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">hub6</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">io_type</span>         <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">iotype</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">iomem_reg_shift</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">iomem_base</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">mapbase</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">retinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">retinfo</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_set_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">serial_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="n">newinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">serial_struct</span> <span class="n">new_serial</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">change_irq</span><span class="p">,</span> <span class="n">change_port</span><span class="p">,</span> <span class="n">closing_wait</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_custom_divisor</span><span class="p">,</span> <span class="n">close_delay</span><span class="p">;</span>
	<span class="n">upf_t</span> <span class="n">old_flags</span><span class="p">,</span> <span class="n">new_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_serial</span><span class="p">,</span> <span class="n">newinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_serial</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">new_port</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HIGH_BITS_OFFSET</span><span class="p">)</span>
		<span class="n">new_port</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">port_high</span> <span class="o">&lt;&lt;</span> <span class="n">HIGH_BITS_OFFSET</span><span class="p">;</span>

	<span class="n">new_serial</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_canonicalize</span><span class="p">(</span><span class="n">new_serial</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">close_delay</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">new_serial</span><span class="p">.</span><span class="n">close_delay</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">closing_wait</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">closing_wait</span> <span class="o">==</span> <span class="n">ASYNC_CLOSING_WAIT_NONE</span> <span class="o">?</span>
			<span class="n">ASYNC_CLOSING_WAIT_NONE</span> <span class="o">:</span>
			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">new_serial</span><span class="p">.</span><span class="n">closing_wait</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This semaphore protects port-&gt;count.  It is also</span>
<span class="cm">	 * very useful to prevent opens.  Also, take the</span>
<span class="cm">	 * port configuration semaphore to make sure that a</span>
<span class="cm">	 * module insertion/removal doesn&#39;t change anything</span>
<span class="cm">	 * under us.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">change_irq</span>  <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_FIXED_PORT</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since changing the &#39;type&#39; of the port changes its resource</span>
<span class="cm">	 * allocations, we should treat type changes the same as</span>
<span class="cm">	 * IO port changes.</span>
<span class="cm">	 */</span>
	<span class="n">change_port</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_FIXED_PORT</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">new_port</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">||</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_serial</span><span class="p">.</span><span class="n">iomem_base</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">mapbase</span> <span class="o">||</span>
		    <span class="n">new_serial</span><span class="p">.</span><span class="n">hub6</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">hub6</span> <span class="o">||</span>
		    <span class="n">new_serial</span><span class="p">.</span><span class="n">io_type</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">iotype</span> <span class="o">||</span>
		    <span class="n">new_serial</span><span class="p">.</span><span class="n">iomem_reg_shift</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">regshift</span> <span class="o">||</span>
		    <span class="n">new_serial</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="n">old_flags</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">new_flags</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">old_custom_divisor</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">custom_divisor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">change_irq</span> <span class="o">||</span> <span class="n">change_port</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">new_serial</span><span class="p">.</span><span class="n">baud_base</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">uartclk</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">close_delay</span> <span class="o">!=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">close_delay</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">closing_wait</span> <span class="o">!=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">closing_wait</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">new_serial</span><span class="p">.</span><span class="n">xmit_fifo_size</span> <span class="o">&amp;&amp;</span>
		     <span class="n">new_serial</span><span class="p">.</span><span class="n">xmit_fifo_size</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">fifosize</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(((</span><span class="n">new_flags</span> <span class="o">^</span> <span class="n">old_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">UPF_USR_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="p">((</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">UPF_USR_MASK</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">new_flags</span> <span class="o">&amp;</span> <span class="n">UPF_USR_MASK</span><span class="p">));</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">custom_divisor</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">custom_divisor</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">check_and_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ask the low level driver to verify the settings.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">verify_port</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">verify_port</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_serial</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">new_serial</span><span class="p">.</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">nr_irqs</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">new_serial</span><span class="p">.</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">new_serial</span><span class="p">.</span><span class="n">baud_base</span> <span class="o">&lt;</span> <span class="mi">9600</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">change_port</span> <span class="o">||</span> <span class="n">change_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure that we are the sole user of this port.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty_port_users</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to shutdown the serial port at the old</span>
<span class="cm">		 * port/type/irq combination.</span>
<span class="cm">		 */</span>
		<span class="n">uart_shutdown</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">change_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_iobase</span><span class="p">,</span> <span class="n">old_mapbase</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_type</span><span class="p">,</span> <span class="n">old_iotype</span><span class="p">,</span> <span class="n">old_hub6</span><span class="p">,</span> <span class="n">old_shift</span><span class="p">;</span>

		<span class="n">old_iobase</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">;</span>
		<span class="n">old_mapbase</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">mapbase</span><span class="p">;</span>
		<span class="n">old_type</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">old_hub6</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">hub6</span><span class="p">;</span>
		<span class="n">old_iotype</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">iotype</span><span class="p">;</span>
		<span class="n">old_shift</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">regshift</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Free and release old regions</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_type</span> <span class="o">!=</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">release_port</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">new_port</span><span class="p">;</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">hub6</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">hub6</span><span class="p">;</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">iotype</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">io_type</span><span class="p">;</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">regshift</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">iomem_reg_shift</span><span class="p">;</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">mapbase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_serial</span><span class="p">.</span><span class="n">iomem_base</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Claim and map the new regions</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">request_port</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Always success - Jean II */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we fail to request resources for the</span>
<span class="cm">		 * new port, try to restore the old settings.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&amp;&amp;</span> <span class="n">old_type</span> <span class="o">!=</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">old_iobase</span><span class="p">;</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">old_type</span><span class="p">;</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">hub6</span> <span class="o">=</span> <span class="n">old_hub6</span><span class="p">;</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">iotype</span> <span class="o">=</span> <span class="n">old_iotype</span><span class="p">;</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">regshift</span> <span class="o">=</span> <span class="n">old_shift</span><span class="p">;</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">mapbase</span> <span class="o">=</span> <span class="n">old_mapbase</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">request_port</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we failed to restore the old settings,</span>
<span class="cm">			 * we fail like this.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PORT_UNKNOWN</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * We failed anyway.</span>
<span class="cm">			 */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="cm">/* Added to return the correct error -Ram Gupta */</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">change_irq</span><span class="p">)</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span>      <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_FIXED_PORT</span><span class="p">))</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">uartclk</span>  <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">baud_base</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span>            <span class="o">=</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">UPF_CHANGE_MASK</span><span class="p">)</span> <span class="o">|</span>
				 <span class="p">(</span><span class="n">new_flags</span> <span class="o">&amp;</span> <span class="n">UPF_CHANGE_MASK</span><span class="p">);</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">custom_divisor</span>   <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">custom_divisor</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">close_delay</span>     <span class="o">=</span> <span class="n">close_delay</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">closing_wait</span>    <span class="o">=</span> <span class="n">closing_wait</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_serial</span><span class="p">.</span><span class="n">xmit_fifo_size</span><span class="p">)</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">fifosize</span> <span class="o">=</span> <span class="n">new_serial</span><span class="p">.</span><span class="n">xmit_fifo_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">low_latency</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_LOW_LATENCY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">check_and_exit:</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">old_flags</span> <span class="o">^</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UPF_SPD_MASK</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">old_custom_divisor</span> <span class="o">!=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">custom_divisor</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If they&#39;re setting up a custom divisor or speed,</span>
<span class="cm">			 * instead of clearing it, then bitch about it. No</span>
<span class="cm">			 * need to rate-limit; it&#39;s CAP_SYS_ADMIN only.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_SPD_MASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
				       <span class="s">&quot;%s sets custom speed on %s. This &quot;</span>
				       <span class="s">&quot;is deprecated.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
				       <span class="n">tty_name</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">,</span> <span class="n">buf</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">uart_change_speed</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">uart_startup</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
 <span class="nl">exit:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_get_lsr_info	-	get line status register info</span>
<span class="cm"> *	@tty: tty associated with the UART</span>
<span class="cm"> *	@state: UART being queried</span>
<span class="cm"> *	@value: returned modem value</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: uart_ioctl protects us against hangups.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_get_lsr_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_empty</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re about to load something into the transmit</span>
<span class="cm">	 * register, we&#39;ll pretend the transmitter isn&#39;t empty to</span>
<span class="cm">	 * avoid a race condition (depending on when the transmit</span>
<span class="cm">	 * interrupt happens).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">uart_circ_chars_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">))</span>
		<span class="n">result</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TIOCSER_TEMT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_tiocmget</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TTY_IO_ERROR</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">mctrl</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">uart_tiocmset</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">set</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clear</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TTY_IO_ERROR</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">uart_update_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">set</span><span class="p">,</span> <span class="n">clear</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_break_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">break_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">break_ctl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">break_state</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_do_autoconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span><span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take the per-port semaphore.  This prevents count from</span>
<span class="cm">	 * changing, and hence any extra opens of the port while</span>
<span class="cm">	 * we&#39;re auto-configuring.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_port_users</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uart_shutdown</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we already have a port type configured,</span>
<span class="cm">		 * we must release its resources.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">release_port</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="n">UART_CONFIG_TYPE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_AUTO_IRQ</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">UART_CONFIG_IRQ</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This will claim the ports resources if</span>
<span class="cm">		 * a port is found.</span>
<span class="cm">		 */</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">config_port</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_startup</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change</span>
<span class="cm"> * - mask passed in arg for lines of interest</span>
<span class="cm"> *   (use |&#39;ed TIOCM_RNG/DSR/CD/CTS for masking)</span>
<span class="cm"> * Caller should use TIOCGICOUNT to see which one it was</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: This wants extracting into a common all driver implementation</span>
<span class="cm"> * of TIOCMWAIT using tty_port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">uart_wait_modem_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uart_icount</span> <span class="n">cprev</span><span class="p">,</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * note the counters on entry</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cprev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_icount</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Force modem status interrupts on</span>
<span class="cm">	 */</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable_ms</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">delta_msr_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cnow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_icount</span><span class="p">));</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_RNG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">rng</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">rng</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_DSR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">dsr</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">dsr</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_CD</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">dcd</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">dcd</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">TIOCM_CTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cnow</span><span class="p">.</span><span class="n">cts</span> <span class="o">!=</span> <span class="n">cprev</span><span class="p">.</span><span class="n">cts</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">schedule</span><span class="p">();</span>

		<span class="cm">/* see if a signal did it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cprev</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">delta_msr_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)</span>
<span class="cm"> * Return: write counters to the user passed counter struct</span>
<span class="cm"> * NB: both 1-&gt;0 and 0-&gt;1 transitions are counted except for</span>
<span class="cm"> *     RI where only 0-&gt;1 is counted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_get_icount</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">serial_icounter_struct</span> <span class="o">*</span><span class="n">icount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_icount</span> <span class="n">cnow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cnow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_icount</span><span class="p">));</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">cts</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">cts</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dsr</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dsr</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rng</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">rng</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">dcd</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">dcd</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">rx</span>          <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">rx</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">tx</span>          <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">tx</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">frame</span>       <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">overrun</span>     <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">overrun</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">parity</span>      <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">parity</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">brk</span>         <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">brk</span><span class="p">;</span>
	<span class="n">icount</span><span class="o">-&gt;</span><span class="n">buf_overrun</span> <span class="o">=</span> <span class="n">cnow</span><span class="p">.</span><span class="n">buf_overrun</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called via sys_ioctl.  We can use spin_lock_irq() here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">uart_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uarg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * These ioctls don&#39;t rely on the hardware to be present.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCGSERIAL</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_get_info</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">uarg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TIOCSSERIAL</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_set_info</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">uarg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TIOCSERCONFIG</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_do_autoconfig</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TIOCSERGWILD</span>: <span class="cm">/* obsolete */</span>
	<span class="k">case</span> <span class="n">TIOCSERSWILD</span>: <span class="cm">/* obsolete */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TTY_IO_ERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following should only be used when hardware is present.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCMIWAIT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_wait_modem_status</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TTY_IO_ERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All these rely on hardware being present and need to be</span>
<span class="cm">	 * protected against the tty being hung up.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIOCSERGETLSR</span>: <span class="cm">/* Get line status register */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_get_lsr_info</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">uarg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_up:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_set_ldisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_ldisc</span><span class="p">)</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_ldisc</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_line</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old_termios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflag</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * These are the bits that are used to setup various</span>
<span class="cm">	 * flags in the low level driver. We can ignore the Bfoo</span>
<span class="cm">	 * bits in c_cflag; c_[io]speed will always be set</span>
<span class="cm">	 * appropriately by set_termios() in tty_ioctl.c</span>
<span class="cm">	 */</span>
<span class="cp">#define RELEVANT_IFLAG(iflag)	((iflag) &amp; (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cflag</span> <span class="o">^</span> <span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_ospeed</span> <span class="o">==</span> <span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_ospeed</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_ispeed</span> <span class="o">==</span> <span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_ispeed</span> <span class="o">&amp;&amp;</span>
	    <span class="n">RELEVANT_IFLAG</span><span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">^</span> <span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uart_change_speed</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">old_termios</span><span class="p">);</span>

	<span class="cm">/* Handle transition to B0 status */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">))</span>
		<span class="n">uart_clear_mctrl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">,</span> <span class="n">TIOCM_RTS</span> <span class="o">|</span> <span class="n">TIOCM_DTR</span><span class="p">);</span>
	<span class="cm">/* Handle transition away from B0 status */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CBAUD</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">TIOCM_DTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">TTY_THROTTLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">TIOCM_RTS</span><span class="p">;</span>
		<span class="n">uart_set_mctrl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Handle turning off CRTSCTS */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__uart_start</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Handle turning on CRTSCTS */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">old_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_mctrl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TIOCM_CTS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop_tx</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In 2.4.5, calls to this will be serialized via the BKL in</span>
<span class="cm"> *  linux/drivers/char/tty_io.c:tty_release()</span>
<span class="cm"> *  linux/drivers/char/tty_io.c:do_tty_handup()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;uart_close(%d) called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty_port_close_start</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, we stop accepting input.  To do this, we</span>
<span class="cm">	 * disable the receive line status interrupts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop_rx</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Before we drop DTR, make sure the UART transmitter</span>
<span class="cm">		 * has completely drained; this is especially</span>
<span class="cm">		 * important if there is a transmit FIFO!</span>
<span class="cm">		 */</span>
		<span class="n">uart_wait_until_sent</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">uart_shutdown</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="n">uart_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">tty_ldisc_flush</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">tty_port_tty_set</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">closing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">blocked_open</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">close_delay</span><span class="p">)</span>
			<span class="n">msleep_interruptible</span><span class="p">(</span>
					<span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">close_delay</span><span class="p">));</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wake up anyone trying to open this port.</span>
<span class="cm">	 */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNCB_NORMAL_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNCB_CLOSING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">close_wait</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_wait_until_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">char_time</span><span class="p">,</span> <span class="n">expire</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PORT_UNKNOWN</span> <span class="o">||</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">fifosize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the check interval to be 1/5 of the estimated time to</span>
<span class="cm">	 * send a single character, and make it at least 1.  The check</span>
<span class="cm">	 * interval should also be less than the timeout.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: we have to use pretty tight timings here to satisfy</span>
<span class="cm">	 * the NIST-PCTS.</span>
<span class="cm">	 */</span>
	<span class="n">char_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">-</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">50</span><span class="p">)</span> <span class="o">/</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">fifosize</span><span class="p">;</span>
	<span class="n">char_time</span> <span class="o">=</span> <span class="n">char_time</span> <span class="o">/</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">char_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">char_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="n">char_time</span><span class="p">)</span>
		<span class="n">char_time</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the transmitter hasn&#39;t cleared in twice the approximate</span>
<span class="cm">	 * amount of time to send the entire FIFO, it probably won&#39;t</span>
<span class="cm">	 * ever clear.  This assumes the UART isn&#39;t doing flow</span>
<span class="cm">	 * control, which is currently the case.  Hence, if it ever</span>
<span class="cm">	 * takes longer than port-&gt;timeout, this is probably due to a</span>
<span class="cm">	 * UART bug of some kind.  So, we clamp the timeout parameter at</span>
<span class="cm">	 * 2*port-&gt;timeout.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>

	<span class="n">expire</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;uart_wait_until_sent(%d), jiffies=%lu, expire=%lu...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">,</span> <span class="n">expire</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether the transmitter is empty every &#39;char_time&#39;.</span>
<span class="cm">	 * &#39;timeout&#39; / &#39;expire&#39; give us the maximum amount of time</span>
<span class="cm">	 * we wait.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_empty</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">msleep_interruptible</span><span class="p">(</span><span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">char_time</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expire</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called with the BKL held in</span>
<span class="cm"> *  linux/drivers/char/tty_io.c:do_tty_hangup()</span>
<span class="cm"> * We&#39;re called from the eventd thread, so we can sleep for</span>
<span class="cm"> * a _short_ time only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;uart_hangup(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_NORMAL_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uart_flush_buffer</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">uart_shutdown</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNCB_NORMAL_ACTIVE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">tty_port_tty_set</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">delta_msr_wait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_port_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_port_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * clear delta_msr_wait queue to avoid mem leaks: we may free</span>
<span class="cm">	 * the irq here so the queue might never be woken up.  Note</span>
<span class="cm">	 * that we won&#39;t end up waiting on delta_msr_wait again since</span>
<span class="cm">	 * any outstanding file descriptors should be pointing at</span>
<span class="cm">	 * hung_up_tty_fops now.</span>
<span class="cm">	 */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">delta_msr_wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the IRQ and disable the port.</span>
<span class="cm">	 */</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the IRQ handler isn&#39;t running on another CPU.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_carrier_raised</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mctrl</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">enable_ms</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="n">mctrl</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mctrl</span> <span class="o">&amp;</span> <span class="n">TIOCM_CAR</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_dtr_rts</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">onoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">onoff</span><span class="p">)</span>
		<span class="n">uart_set_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">TIOCM_DTR</span> <span class="o">|</span> <span class="n">TIOCM_RTS</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">uart_clear_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">TIOCM_DTR</span> <span class="o">|</span> <span class="n">TIOCM_RTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * calls to uart_open are serialised by the BKL in</span>
<span class="cm"> *   fs/char_dev.c:chrdev_open()</span>
<span class="cm"> * Note that if this fails, then uart_close() _will_ be called.</span>
<span class="cm"> *</span>
<span class="cm"> * In time, we want to scrap the &quot;opening nonpresent ports&quot;</span>
<span class="cm"> * behaviour and implement an alternative way for setserial</span>
<span class="cm"> * to set base addresses/ports/types.  This will allow us to</span>
<span class="cm"> * get rid of a certain amount of extra tests.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="p">)</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">line</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;uart_open(%d) called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We take the semaphore here to guarantee that we won&#39;t be re-entered</span>
<span class="cm">	 * while allocating the state structure, or while we request any IRQs</span>
<span class="cm">	 * that the driver may need.  This also has the nice side-effect that</span>
<span class="cm">	 * it delays the action of uart_hangup, so we can guarantee that</span>
<span class="cm">	 * state-&gt;port.tty will always contain something reasonable.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span> <span class="o">||</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_DEAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_dec_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once we set tty-&gt;driver_data here, we are guaranteed that</span>
<span class="cm">	 * uart_close() will decrement the driver module use count.</span>
<span class="cm">	 * Any failures from here onwards should not touch the count.</span>
<span class="cm">	 */</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">low_latency</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_LOW_LATENCY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tty_port_tty_set</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the port is in the middle of closing, bail out now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_hung_up_p</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_dec_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the device is in D0 state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start up the serial port.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">uart_startup</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we succeeded, wait until the port is ready.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_port_block_til_ready</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">tty</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>

<span class="nl">end:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="nl">err_dec_count:</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">uart_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="n">str</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="n">str</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_line_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pm_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">stat_buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mmio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uport</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mmio</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">iotype</span> <span class="o">&gt;=</span> <span class="n">UPIO_MEM</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%d: uart:%s %s%08llX irq:%d&quot;</span><span class="p">,</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span> <span class="n">uart_type</span><span class="p">(</span><span class="n">uport</span><span class="p">),</span>
			<span class="n">mmio</span> <span class="o">?</span> <span class="s">&quot;mmio:0x&quot;</span> <span class="o">:</span> <span class="s">&quot;port:&quot;</span><span class="p">,</span>
			<span class="n">mmio</span> <span class="o">?</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">mapbase</span>
			     <span class="o">:</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">,</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">pm_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">pm_state</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm_state</span><span class="p">)</span>
			<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm_state</span><span class="p">)</span>
			<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pm_state</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; tx:%d rx:%d&quot;</span><span class="p">,</span>
				<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">frame</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; fe:%d&quot;</span><span class="p">,</span>
				<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">frame</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">parity</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; pe:%d&quot;</span><span class="p">,</span>
				<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">parity</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">brk</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; brk:%d&quot;</span><span class="p">,</span>
				<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">brk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">overrun</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; oe:%d&quot;</span><span class="p">,</span>
				<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">overrun</span><span class="p">);</span>

<span class="cp">#define INFOBIT(bit, str) \</span>
<span class="cp">	if (uport-&gt;mctrl &amp; (bit)) \</span>
<span class="cp">		strncat(stat_buf, (str), sizeof(stat_buf) - \</span>
<span class="cp">			strlen(stat_buf) - 2)</span>
<span class="cp">#define STATBIT(bit, str) \</span>
<span class="cp">	if (status &amp; (bit)) \</span>
<span class="cp">		strncat(stat_buf, (str), sizeof(stat_buf) - \</span>
<span class="cp">		       strlen(stat_buf) - 2)</span>

		<span class="n">stat_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">stat_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">INFOBIT</span><span class="p">(</span><span class="n">TIOCM_RTS</span><span class="p">,</span> <span class="s">&quot;|RTS&quot;</span><span class="p">);</span>
		<span class="n">STATBIT</span><span class="p">(</span><span class="n">TIOCM_CTS</span><span class="p">,</span> <span class="s">&quot;|CTS&quot;</span><span class="p">);</span>
		<span class="n">INFOBIT</span><span class="p">(</span><span class="n">TIOCM_DTR</span><span class="p">,</span> <span class="s">&quot;|DTR&quot;</span><span class="p">);</span>
		<span class="n">STATBIT</span><span class="p">(</span><span class="n">TIOCM_DSR</span><span class="p">,</span> <span class="s">&quot;|DSR&quot;</span><span class="p">);</span>
		<span class="n">STATBIT</span><span class="p">(</span><span class="n">TIOCM_CAR</span><span class="p">,</span> <span class="s">&quot;|CD&quot;</span><span class="p">);</span>
		<span class="n">STATBIT</span><span class="p">(</span><span class="n">TIOCM_RNG</span><span class="p">,</span> <span class="s">&quot;|RI&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">stat_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

		<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">stat_buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="cp">#undef STATBIT</span>
<span class="cp">#undef INFOBIT</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_proc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">ttydrv</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">ttydrv</span><span class="o">-&gt;</span><span class="n">driver_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;serinfo:1.0 driver%s%s revision:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">uart_line_info</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">drv</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">uart_proc_show</span><span class="p">,</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">uart_proc_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">uart_proc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(CONFIG_CONSOLE_POLL)</span>
<span class="cm">/*</span>
<span class="cm"> *	uart_console_write - write a console message to a serial port</span>
<span class="cm"> *	@port: the port to write the message</span>
<span class="cm"> *	@s: array of characters</span>
<span class="cm"> *	@count: number of characters in string to write</span>
<span class="cm"> *	@write: function to write character to port</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uart_console_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">putchar</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="n">putchar</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="sc">&#39;\r&#39;</span><span class="p">);</span>
		<span class="n">putchar</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uart_console_write</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Check whether an invalid uart number has been specified, and</span>
<span class="cm"> *	if so, search for the first available port that does have</span>
<span class="cm"> *	console support.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span> <span class="n">__init</span>
<span class="nf">uart_get_console</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">ports</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">co</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">nr</span> <span class="o">||</span> <span class="p">(</span><span class="n">ports</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">iobase</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				     <span class="n">ports</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">membase</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ports</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">iobase</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
			    <span class="n">ports</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">membase</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

	<span class="n">co</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ports</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_parse_options - Parse serial port baud/parity/bits/flow contro.</span>
<span class="cm"> *	@options: pointer to option string</span>
<span class="cm"> *	@baud: pointer to an &#39;int&#39; variable for the baud rate.</span>
<span class="cm"> *	@parity: pointer to an &#39;int&#39; variable for the parity.</span>
<span class="cm"> *	@bits: pointer to an &#39;int&#39; variable for the number of data bits.</span>
<span class="cm"> *	@flow: pointer to an &#39;int&#39; variable for the flow control character.</span>
<span class="cm"> *</span>
<span class="cm"> *	uart_parse_options decodes a string containing the serial console</span>
<span class="cm"> *	options.  The format of the string is &lt;baud&gt;&lt;parity&gt;&lt;bits&gt;&lt;flow&gt;,</span>
<span class="cm"> *	eg: 115200n8r</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">uart_parse_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">baud</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">parity</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bits</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>

	<span class="o">*</span><span class="n">baud</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span>
		<span class="n">s</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
		<span class="o">*</span><span class="n">parity</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
		<span class="o">*</span><span class="n">bits</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
		<span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uart_parse_options</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">baud_rates</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflag</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">baud_rates</span> <span class="n">baud_rates</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="mi">921600</span><span class="p">,</span> <span class="n">B921600</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">460800</span><span class="p">,</span> <span class="n">B460800</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">230400</span><span class="p">,</span> <span class="n">B230400</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">115200</span><span class="p">,</span> <span class="n">B115200</span> <span class="p">},</span>
	<span class="p">{</span>  <span class="mi">57600</span><span class="p">,</span> <span class="n">B57600</span>  <span class="p">},</span>
	<span class="p">{</span>  <span class="mi">38400</span><span class="p">,</span> <span class="n">B38400</span>  <span class="p">},</span>
	<span class="p">{</span>  <span class="mi">19200</span><span class="p">,</span> <span class="n">B19200</span>  <span class="p">},</span>
	<span class="p">{</span>   <span class="mi">9600</span><span class="p">,</span> <span class="n">B9600</span>   <span class="p">},</span>
	<span class="p">{</span>   <span class="mi">4800</span><span class="p">,</span> <span class="n">B4800</span>   <span class="p">},</span>
	<span class="p">{</span>   <span class="mi">2400</span><span class="p">,</span> <span class="n">B2400</span>   <span class="p">},</span>
	<span class="p">{</span>   <span class="mi">1200</span><span class="p">,</span> <span class="n">B1200</span>   <span class="p">},</span>
	<span class="p">{</span>      <span class="mi">0</span><span class="p">,</span> <span class="n">B38400</span>  <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_set_options - setup the serial console parameters</span>
<span class="cm"> *	@port: pointer to the serial ports uart_port structure</span>
<span class="cm"> *	@co: console pointer</span>
<span class="cm"> *	@baud: baud rate</span>
<span class="cm"> *	@parity: parity character - &#39;n&#39; (none), &#39;o&#39; (odd), &#39;e&#39; (even)</span>
<span class="cm"> *	@bits: number of data bits</span>
<span class="cm"> *	@flow: flow control character - &#39;r&#39; (rts)</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">uart_set_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">baud</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="n">termios</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the serial console lock is initialised</span>
<span class="cm">	 * early.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_lock_key</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">termios</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span><span class="p">));</span>

	<span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">=</span> <span class="n">CREAD</span> <span class="o">|</span> <span class="n">HUPCL</span> <span class="o">|</span> <span class="n">CLOCAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Construct a cflag setting.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">baud_rates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rate</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">baud_rates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rate</span> <span class="o">&lt;=</span> <span class="n">baud</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">|=</span> <span class="n">baud_rates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cflag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">|=</span> <span class="n">CS7</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">|=</span> <span class="n">CS8</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">parity</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;o&#39;</span>: <span class="k">case</span> <span class="sc">&#39;O&#39;</span>:
		<span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">|=</span> <span class="n">PARODD</span><span class="p">;</span>
		<span class="cm">/*fall through*/</span>
	<span class="k">case</span> <span class="sc">&#39;e&#39;</span>: <span class="k">case</span> <span class="sc">&#39;E&#39;</span>:
		<span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">|=</span> <span class="n">PARENB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flow</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="p">)</span>
		<span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">|=</span> <span class="n">CRTSCTS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * some uarts on other side don&#39;t support no flow control.</span>
<span class="cm">	 * So we set * DTR in host uart to make them happy</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">mctrl</span> <span class="o">|=</span> <span class="n">TIOCM_DTR</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_termios</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">termios</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Allow the setting of the UART parameters with a NULL console</span>
<span class="cm">	 * too:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">co</span><span class="p">)</span>
		<span class="n">co</span><span class="o">-&gt;</span><span class="n">cflag</span> <span class="o">=</span> <span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uart_set_options</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SERIAL_CORE_CONSOLE */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * uart_change_pm - set power state of the port</span>
<span class="cm"> *</span>
<span class="cm"> * @state: port descriptor</span>
<span class="cm"> * @pm_state: new state</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: port-&gt;mutex has to be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_change_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pm_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">pm_state</span> <span class="o">!=</span> <span class="n">pm_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pm</span><span class="p">)</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">pm</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">pm_state</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">pm_state</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">pm_state</span> <span class="o">=</span> <span class="n">pm_state</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">uart_match</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">serial_match_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_match</span> <span class="o">*</span><span class="n">match</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">tty_drv</span> <span class="o">=</span> <span class="n">match</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">tty_driver</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">,</span> <span class="n">tty_drv</span><span class="o">-&gt;</span><span class="n">minor_start</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">match</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span> <span class="o">==</span> <span class="n">devt</span><span class="p">;</span> <span class="cm">/* Actually, only one tty per port */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">uart_suspend_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">tty_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_match</span> <span class="n">match</span> <span class="o">=</span> <span class="p">{</span><span class="n">uport</span><span class="p">,</span> <span class="n">drv</span><span class="p">};</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">tty_dev</span> <span class="o">=</span> <span class="n">device_find_child</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">match</span><span class="p">,</span> <span class="n">serial_match_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="n">tty_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enable_irq_wake</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq_wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">tty_dev</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_suspend_enabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_INITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">uart_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">tries</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">console_suspend_enabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">ASYNCB_SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNCB_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop_tx</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
			<span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop_rx</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait for the transmitter to empty.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">tries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">tx_empty</span><span class="p">(</span><span class="n">uport</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tries</span><span class="p">;</span> <span class="n">tries</span><span class="o">--</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tries</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s%s%s%d: Unable to drain &quot;</span>
					<span class="s">&quot;transmitter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			       <span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="s">&quot;: &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			       <span class="n">drv</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">,</span>
			       <span class="n">drv</span><span class="o">-&gt;</span><span class="n">tty_driver</span><span class="o">-&gt;</span><span class="n">name_base</span> <span class="o">+</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">console_suspend_enabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span>
			<span class="n">ops</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable the console device before suspending.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">console_suspend_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span>
		<span class="n">console_stop</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">cons</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">console_suspend_enabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span>
		<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">uart_resume_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">tty_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_match</span> <span class="n">match</span> <span class="o">=</span> <span class="p">{</span><span class="n">uport</span><span class="p">,</span> <span class="n">drv</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">ktermios</span> <span class="n">termios</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">tty_dev</span> <span class="o">=</span> <span class="n">device_find_child</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">match</span><span class="p">,</span> <span class="n">serial_match_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">&amp;&amp;</span> <span class="n">device_may_wakeup</span><span class="p">(</span><span class="n">tty_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq_wake</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">disable_irq_wake</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
			<span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq_wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Re-enable the console device after suspending.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First try to use the console cflag setting.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">termios</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ktermios</span><span class="p">));</span>
		<span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">cflag</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If that&#39;s unset, use the tty termios setting.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">&amp;&amp;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span> <span class="o">&amp;&amp;</span> <span class="n">termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">termios</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">termios</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">console_suspend_enabled</span><span class="p">)</span>
			<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_termios</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">termios</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">console_suspend_enabled</span><span class="p">)</span>
			<span class="n">console_start</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">cons</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_SUSPENDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">uart_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">console_suspend_enabled</span> <span class="o">||</span> <span class="o">!</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Protected by port mutex for now */</span>
			<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">startup</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="p">)</span>
					<span class="n">uart_change_speed</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_mctrl</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">mctrl</span><span class="p">);</span>
				<span class="n">ops</span><span class="o">-&gt;</span><span class="n">start_tx</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">ASYNCB_INITIALIZED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Failed to resume - maybe hardware went away?</span>
<span class="cm">				 * Clear the &quot;initialized&quot; flag so we won&#39;t try</span>
<span class="cm">				 * to call the low level drivers shutdown method.</span>
<span class="cm">				 */</span>
				<span class="n">uart_shutdown</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">ASYNCB_SUSPENDED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">uart_report_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">address</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">iotype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UPIO_PORT</span>:
		<span class="n">snprintf</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">),</span> <span class="s">&quot;I/O 0x%lx&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UPIO_HUB6</span>:
		<span class="n">snprintf</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">),</span>
			 <span class="s">&quot;I/O 0x%lx offset 0x%x&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">hub6</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UPIO_MEM</span>:
	<span class="k">case</span> <span class="n">UPIO_MEM32</span>:
	<span class="k">case</span> <span class="n">UPIO_AU</span>:
	<span class="k">case</span> <span class="n">UPIO_TSI</span>:
		<span class="n">snprintf</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">),</span>
			 <span class="s">&quot;MMIO 0x%llx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mapbase</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="s">&quot;*unknown*&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s%s%s%d at %s (irq = %d) is a %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="s">&quot;: &quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
	       <span class="n">drv</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">,</span>
	       <span class="n">drv</span><span class="o">-&gt;</span><span class="n">tty_driver</span><span class="o">-&gt;</span><span class="n">name_base</span> <span class="o">+</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span>
	       <span class="n">address</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">uart_type</span><span class="p">(</span><span class="n">port</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">uart_configure_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there isn&#39;t a port here, don&#39;t do anything further.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mapbase</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now do the auto configuration stuff.  Note that config_port</span>
<span class="cm">	 * is expected to claim the resources and map the port for us.</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_AUTO_IRQ</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">UART_CONFIG_IRQ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_BOOT_AUTOCONF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_FIXED_TYPE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PORT_UNKNOWN</span><span class="p">;</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">UART_CONFIG_TYPE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">config_port</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">uart_report_port</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

		<span class="cm">/* Power up port for set_mctrl() */</span>
		<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ensure that the modem control lines are de-activated.</span>
<span class="cm">		 * keep the DTR setting that is set in uart_set_options()</span>
<span class="cm">		 * We probably don&#39;t need a spinlock around this, but</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_mctrl</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">mctrl</span> <span class="o">&amp;</span> <span class="n">TIOCM_DTR</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this driver supports console, and it hasn&#39;t been</span>
<span class="cm">		 * successfully registered yet, try to re-register it.</span>
<span class="cm">		 * It may be that the port was not available.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cons</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_ENABLED</span><span class="p">))</span>
			<span class="n">register_console</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cons</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Power down all ports by default, except the</span>
<span class="cm">		 * console if we have one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uart_console</span><span class="p">(</span><span class="n">port</span><span class="p">))</span>
			<span class="n">uart_change_pm</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CONSOLE_POLL</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_poll_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">line</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">baud</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">parity</span> <span class="o">=</span> <span class="sc">&#39;n&#39;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flow</span> <span class="o">=</span> <span class="sc">&#39;n&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span> <span class="o">||</span> <span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll_get_char</span> <span class="o">&amp;&amp;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll_put_char</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uart_parse_options</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">baud</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parity</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flow</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">uart_set_options</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">flow</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uart_poll_get_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">line</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span> <span class="o">||</span> <span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll_get_char</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_poll_put_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">line</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span> <span class="o">||</span> <span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll_put_char</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="n">uart_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">uart_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">uart_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">uart_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_char</span>	<span class="o">=</span> <span class="n">uart_put_char</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_chars</span>	<span class="o">=</span> <span class="n">uart_flush_chars</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_room</span>	<span class="o">=</span> <span class="n">uart_write_room</span><span class="p">,</span>
	<span class="p">.</span><span class="n">chars_in_buffer</span><span class="o">=</span> <span class="n">uart_chars_in_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_buffer</span>	<span class="o">=</span> <span class="n">uart_flush_buffer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">uart_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">throttle</span>	<span class="o">=</span> <span class="n">uart_throttle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unthrottle</span>	<span class="o">=</span> <span class="n">uart_unthrottle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_xchar</span>	<span class="o">=</span> <span class="n">uart_send_xchar</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span>	<span class="o">=</span> <span class="n">uart_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_ldisc</span>	<span class="o">=</span> <span class="n">uart_set_ldisc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>		<span class="o">=</span> <span class="n">uart_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start</span>		<span class="o">=</span> <span class="n">uart_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hangup</span>		<span class="o">=</span> <span class="n">uart_hangup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">break_ctl</span>	<span class="o">=</span> <span class="n">uart_break_ctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">wait_until_sent</span><span class="o">=</span> <span class="n">uart_wait_until_sent</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="p">.</span><span class="n">proc_fops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">uart_proc_fops</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">tiocmget</span>	<span class="o">=</span> <span class="n">uart_tiocmget</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tiocmset</span>	<span class="o">=</span> <span class="n">uart_tiocmset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_icount</span>	<span class="o">=</span> <span class="n">uart_get_icount</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CONSOLE_POLL</span>
	<span class="p">.</span><span class="n">poll_init</span>	<span class="o">=</span> <span class="n">uart_poll_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll_get_char</span>	<span class="o">=</span> <span class="n">uart_poll_get_char</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll_put_char</span>	<span class="o">=</span> <span class="n">uart_poll_put_char</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="n">uart_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">activate</span>	<span class="o">=</span> <span class="n">uart_port_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">uart_port_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">carrier_raised</span> <span class="o">=</span> <span class="n">uart_carrier_raised</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dtr_rts</span>	<span class="o">=</span> <span class="n">uart_dtr_rts</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_register_driver - register a driver with the uart core layer</span>
<span class="cm"> *	@drv: low level driver structure</span>
<span class="cm"> *</span>
<span class="cm"> *	Register a uart driver with the core driver.  We in turn register</span>
<span class="cm"> *	with the tty layer, and initialise the core driver per-port state.</span>
<span class="cm"> *</span>
<span class="cm"> *	We have a proc file in /proc/tty/driver which is named after the</span>
<span class="cm"> *	normal driver.</span>
<span class="cm"> *</span>
<span class="cm"> *	drv-&gt;port should be NULL, and the per-port structures should be</span>
<span class="cm"> *	registered using uart_add_one_port after this call has succeeded.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uart_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">normal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maybe we should be using a slab cache for this, especially if</span>
<span class="cm">	 * we have a large number of ports to handle.</span>
<span class="cm">	 */</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_state</span><span class="p">)</span> <span class="o">*</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">normal</span> <span class="o">=</span> <span class="n">alloc_tty_driver</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">normal</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_kfree</span><span class="p">;</span>

	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">tty_driver</span> <span class="o">=</span> <span class="n">normal</span><span class="p">;</span>

	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">driver_name</span>	<span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver_name</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">name</span>		<span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">major</span>		<span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">minor_start</span>	<span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">type</span>		<span class="o">=</span> <span class="n">TTY_DRIVER_TYPE_SERIAL</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">subtype</span>		<span class="o">=</span> <span class="n">SERIAL_TYPE_NORMAL</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">init_termios</span>	<span class="o">=</span> <span class="n">tty_std_termios</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">.</span><span class="n">c_cflag</span> <span class="o">=</span> <span class="n">B9600</span> <span class="o">|</span> <span class="n">CS8</span> <span class="o">|</span> <span class="n">CREAD</span> <span class="o">|</span> <span class="n">HUPCL</span> <span class="o">|</span> <span class="n">CLOCAL</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">.</span><span class="n">c_ispeed</span> <span class="o">=</span> <span class="n">normal</span><span class="o">-&gt;</span><span class="n">init_termios</span><span class="p">.</span><span class="n">c_ospeed</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">TTY_DRIVER_REAL_RAW</span> <span class="o">|</span> <span class="n">TTY_DRIVER_DYNAMIC_DEV</span><span class="p">;</span>
	<span class="n">normal</span><span class="o">-&gt;</span><span class="n">driver_state</span>    <span class="o">=</span> <span class="n">drv</span><span class="p">;</span>
	<span class="n">tty_set_operations</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart_ops</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialise the UART state(s).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

		<span class="n">tty_port_init</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uart_port_ops</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">close_delay</span>     <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* .5 seconds */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">closing_wait</span>    <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span><span class="cm">/* 30 seconds */</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_register_driver</span><span class="p">(</span><span class="n">normal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">normal</span><span class="p">);</span>
<span class="nl">out_kfree:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_unregister_driver - remove a driver from the uart core layer</span>
<span class="cm"> *	@drv: low level driver structure</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove all references to a driver from the core driver.  The low</span>
<span class="cm"> *	level driver must have removed all its ports via the</span>
<span class="cm"> *	uart_remove_one_port() if it registered them with uart_add_one_port().</span>
<span class="cm"> *	(ie, drv-&gt;port == NULL)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uart_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">tty_driver</span><span class="p">;</span>
	<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">tty_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">uart_console_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">co</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">co</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">tty_driver</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_add_one_port - attach a driver-defined port structure</span>
<span class="cm"> *	@drv: pointer to the uart low level driver structure for this port</span>
<span class="cm"> *	@uport: uart port structure to use for this port.</span>
<span class="cm"> *</span>
<span class="cm"> *	This allows the driver to register its own uart_port structure</span>
<span class="cm"> *	with the core driver.  The main purpose is to allow the low</span>
<span class="cm"> *	level uart drivers to expand uart_port, rather than having yet</span>
<span class="cm"> *	more levels of structures.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uart_add_one_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">tty_dev</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">&gt;=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>
	<span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span> <span class="o">=</span> <span class="n">uport</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">pm_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">cons</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">cons</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this port is a console, then the spinlock is already</span>
<span class="cm">	 * initialised.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">uart_console</span><span class="p">(</span><span class="n">uport</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CON_ENABLED</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_lock_key</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">uart_configure_port</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">uport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register the port whether it&#39;s detected or not.  This allows</span>
<span class="cm">	 * setserial to be used to alter this ports parameters.</span>
<span class="cm">	 */</span>
	<span class="n">tty_dev</span> <span class="o">=</span> <span class="n">tty_register_device</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">tty_driver</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tty_dev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">device_set_wakeup_capable</span><span class="p">(</span><span class="n">tty_dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Cannot register tty device on line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure UPF_DEAD is not set.</span>
<span class="cm">	 */</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UPF_DEAD</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_remove_one_port - detach a driver defined port structure</span>
<span class="cm"> *	@drv: pointer to the uart low level driver structure for this port</span>
<span class="cm"> *	@uport: uart port structure for this port</span>
<span class="cm"> *</span>
<span class="cm"> *	This unhooks (and hangs up) the specified port structure from the</span>
<span class="cm"> *	core driver.  No further calls will be made to the low-level code</span>
<span class="cm"> *	for this port.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uart_remove_one_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span> <span class="o">!=</span> <span class="n">uport</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;Removing wrong port: %p != %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">,</span> <span class="n">uport</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark the port &quot;dead&quot; - this prevents any opens from</span>
<span class="cm">	 * succeeding while we shut down the port.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">UPF_DEAD</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the devices from the tty layer</span>
<span class="cm">	 */</span>
	<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">tty_driver</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span>
		<span class="n">tty_vhangup</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the port IO and memory resources, if any.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PORT_UNKNOWN</span><span class="p">)</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">release_port</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Indicate that there isn&#39;t a port here anymore.</span>
<span class="cm">	 */</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PORT_UNKNOWN</span><span class="p">;</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">uart_port</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Are the two ports equivalent?</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">uart_match_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port1</span><span class="o">-&gt;</span><span class="n">iotype</span> <span class="o">!=</span> <span class="n">port2</span><span class="o">-&gt;</span><span class="n">iotype</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">port1</span><span class="o">-&gt;</span><span class="n">iotype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UPIO_PORT</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">port1</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">==</span> <span class="n">port2</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">UPIO_HUB6</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">port1</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">==</span> <span class="n">port2</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">port1</span><span class="o">-&gt;</span><span class="n">hub6</span>   <span class="o">==</span> <span class="n">port2</span><span class="o">-&gt;</span><span class="n">hub6</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">UPIO_MEM</span>:
	<span class="k">case</span> <span class="n">UPIO_MEM32</span>:
	<span class="k">case</span> <span class="n">UPIO_AU</span>:
	<span class="k">case</span> <span class="n">UPIO_TSI</span>:
		<span class="k">return</span> <span class="p">(</span><span class="n">port1</span><span class="o">-&gt;</span><span class="n">mapbase</span> <span class="o">==</span> <span class="n">port2</span><span class="o">-&gt;</span><span class="n">mapbase</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_match_port</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_handle_dcd_change - handle a change of carrier detect state</span>
<span class="cm"> *	@uport: uart_port structure for the open port</span>
<span class="cm"> *	@status: new carrier detect status, nonzero if active</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uart_handle_dcd_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_ldisc</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">tty_ldisc_ref</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pps_event_time</span> <span class="n">ts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span> <span class="o">&amp;&amp;</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dcd_change</span><span class="p">)</span>
		<span class="n">pps_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">dcd</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_HARD_PPS</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPF_HARDPPS_CD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">status</span><span class="p">)</span>
		<span class="n">hardpps</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CHECK_CD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">open_wait</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span>
			<span class="n">tty_hangup</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span> <span class="o">&amp;&amp;</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dcd_change</span><span class="p">)</span>
		<span class="n">ld</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dcd_change</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span><span class="p">)</span>
		<span class="n">tty_ldisc_deref</span><span class="p">(</span><span class="n">ld</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uart_handle_dcd_change</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	uart_handle_cts_change - handle a change of clear-to-send state</span>
<span class="cm"> *	@uport: uart_port structure for the open port</span>
<span class="cm"> *	@status: new clear to send status, nonzero if active</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uart_handle_cts_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">cts</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ASYNC_CTS_FLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">start_tx</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
				<span class="n">uart_write_wakeup</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tty</span><span class="o">-&gt;</span><span class="n">hw_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">stop_tx</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uart_handle_cts_change</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * uart_insert_char - push a char to the uart layer</span>
<span class="cm"> *</span>
<span class="cm"> * User is responsible to call tty_flip_buffer_push when they are done with</span>
<span class="cm"> * insertion.</span>
<span class="cm"> *</span>
<span class="cm"> * @port: corresponding port</span>
<span class="cm"> * @status: state of the serial port RX buffer (LSR for 8250)</span>
<span class="cm"> * @overrun: mask of overrun bits in @status</span>
<span class="cm"> * @ch: character to push</span>
<span class="cm"> * @flag: flag for the character (see TTY_NORMAL and friends)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">uart_insert_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">overrun</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">overrun</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Overrun is special.  Since it&#39;s reported immediately,</span>
<span class="cm">	 * it doesn&#39;t affect the current character.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">&amp;</span> <span class="n">overrun</span><span class="p">)</span>
		<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_OVERRUN</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">uart_insert_char</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_write_wakeup</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_register_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_unregister_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_suspend_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_resume_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_add_one_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">uart_remove_one_port</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Serial driver core&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
