<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › serial › jsm › jsm_neo.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>jsm_neo.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/************************************************************************</span>
<span class="cm"> * Copyright 2003 Digi International (www.digi.com)</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 IBM Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED; without even the</span>
<span class="cm"> * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</span>
<span class="cm"> * PURPOSE.  See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 * Temple Place - Suite 330, Boston,</span>
<span class="cm"> * MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Contact Information:</span>
<span class="cm"> * Scott H Kilau &lt;Scott_Kilau@digi.com&gt;</span>
<span class="cm"> * Wendy Xiong   &lt;wendyx@us.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> ***********************************************************************/</span>
<span class="cp">#include &lt;linux/delay.h&gt;	</span><span class="cm">/* For udelay */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/serial_reg.h&gt;	</span><span class="cm">/* For the various UART offsets */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &quot;jsm.h&quot;		</span><span class="cm">/* Driver main header file */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">jsm_offset_table</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x80</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This function allows calls to ensure that all outstanding</span>
<span class="cm"> * PCI writes have been completed, by doing a PCI read against</span>
<span class="cm"> * a non-destructive, read-only location on the Neo card.</span>
<span class="cm"> *</span>
<span class="cm"> * In this case, we are reading the DVID (Read-only Device Identification)</span>
<span class="cm"> * value of the Neo card.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">neo_pci_posting_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_board</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">readb</span><span class="p">(</span><span class="n">bd</span><span class="o">-&gt;</span><span class="n">re_map_membase</span> <span class="o">+</span> <span class="mh">0x8D</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_set_cts_flow_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ier</span><span class="p">,</span> <span class="n">efr</span><span class="p">;</span>
	<span class="n">ier</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">PARAM</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;Setting CTSFLOW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Turn on auto CTS flow control */</span>
	<span class="n">ier</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_17158_IER_CTSDSR</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_17158_EFR_ECB</span> <span class="o">|</span> <span class="n">UART_17158_EFR_CTSDSR</span><span class="p">);</span>

	<span class="cm">/* Turn off auto Xon flow control */</span>
	<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_IXON</span><span class="p">);</span>

	<span class="cm">/* Why? Becuz Exar&#39;s spec says we have to zero it out before setting it */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on UART enhanced bits */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">efr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on table D, with 8 char hi/low watermarks */</span>
	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_17158_FCTR_TRGD</span> <span class="o">|</span> <span class="n">UART_17158_FCTR_RTS_4DELAY</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">fctr</span><span class="p">);</span>

	<span class="cm">/* Feed the UART our trigger levels */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">tfifo</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_t_tlevel</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_set_rts_flow_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ier</span><span class="p">,</span> <span class="n">efr</span><span class="p">;</span>
	<span class="n">ier</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">PARAM</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;Setting RTSFLOW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Turn on auto RTS flow control */</span>
	<span class="n">ier</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_17158_IER_RTSDTR</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_17158_EFR_ECB</span> <span class="o">|</span> <span class="n">UART_17158_EFR_RTSDTR</span><span class="p">);</span>

	<span class="cm">/* Turn off auto Xoff flow control */</span>
	<span class="n">ier</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_IER_XOFF</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_IXOFF</span><span class="p">);</span>

	<span class="cm">/* Why? Becuz Exar&#39;s spec says we have to zero it out before setting it */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on UART enhanced bits */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">efr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_17158_FCTR_TRGD</span> <span class="o">|</span> <span class="n">UART_17158_FCTR_RTS_4DELAY</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">fctr</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_watermark</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">rfifo</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_tlevel</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * From the Neo UART spec sheet:</span>
<span class="cm">	 * The auto RTS/DTR function must be started by asserting</span>
<span class="cm">	 * RTS/DTR# output pin (MCR bit-0 or 1 to logic 1 after</span>
<span class="cm">	 * it is enabled.</span>
<span class="cm">	 */</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_MCR_RTS</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_set_ixon_flow_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ier</span><span class="p">,</span> <span class="n">efr</span><span class="p">;</span>
	<span class="n">ier</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">PARAM</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;Setting IXON FLOW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Turn off auto CTS flow control */</span>
	<span class="n">ier</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_IER_CTSDSR</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_CTSDSR</span><span class="p">);</span>

	<span class="cm">/* Turn on auto Xon flow control */</span>
	<span class="n">efr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_17158_EFR_ECB</span> <span class="o">|</span> <span class="n">UART_17158_EFR_IXON</span><span class="p">);</span>

	<span class="cm">/* Why? Becuz Exar&#39;s spec says we have to zero it out before setting it */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on UART enhanced bits */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">efr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_17158_FCTR_TRGD</span> <span class="o">|</span> <span class="n">UART_17158_FCTR_RTS_8DELAY</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">fctr</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_watermark</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">rfifo</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_tlevel</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

	<span class="cm">/* Tell UART what start/stop chars it should be looking for */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_startc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xonchar1</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xonchar2</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_stopc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xoffchar1</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xoffchar2</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_set_ixoff_flow_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ier</span><span class="p">,</span> <span class="n">efr</span><span class="p">;</span>
	<span class="n">ier</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">PARAM</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;Setting IXOFF FLOW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Turn off auto RTS flow control */</span>
	<span class="n">ier</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_IER_RTSDTR</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_RTSDTR</span><span class="p">);</span>

	<span class="cm">/* Turn on auto Xoff flow control */</span>
	<span class="n">ier</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_17158_IER_XOFF</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_17158_EFR_ECB</span> <span class="o">|</span> <span class="n">UART_17158_EFR_IXOFF</span><span class="p">);</span>

	<span class="cm">/* Why? Becuz Exar&#39;s spec says we have to zero it out before setting it */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on UART enhanced bits */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">efr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on table D, with 8 char hi/low watermarks */</span>
	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_17158_FCTR_TRGD</span> <span class="o">|</span> <span class="n">UART_17158_FCTR_RTS_8DELAY</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">fctr</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">tfifo</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_t_tlevel</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="cm">/* Tell UART what start/stop chars it should be looking for */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_startc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xonchar1</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xonchar2</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_stopc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xoffchar1</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xoffchar2</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_set_no_input_flow_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ier</span><span class="p">,</span> <span class="n">efr</span><span class="p">;</span>
	<span class="n">ier</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">PARAM</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;Unsetting Input FLOW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Turn off auto RTS flow control */</span>
	<span class="n">ier</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_IER_RTSDTR</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_RTSDTR</span><span class="p">);</span>

	<span class="cm">/* Turn off auto Xoff flow control */</span>
	<span class="n">ier</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_IER_XOFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_iflag</span> <span class="o">&amp;</span> <span class="n">IXON</span><span class="p">)</span>
		<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_IXOFF</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_ECB</span> <span class="o">|</span> <span class="n">UART_17158_EFR_IXOFF</span><span class="p">);</span>

	<span class="cm">/* Why? Becuz Exar&#39;s spec says we have to zero it out before setting it */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on UART enhanced bits */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">efr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on table D, with 8 char hi/low watermarks */</span>
	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_17158_FCTR_TRGD</span> <span class="o">|</span> <span class="n">UART_17158_FCTR_RTS_8DELAY</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">fctr</span><span class="p">);</span>

	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_watermark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">tfifo</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_t_tlevel</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">rfifo</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_tlevel</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_set_no_output_flow_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ier</span><span class="p">,</span> <span class="n">efr</span><span class="p">;</span>
	<span class="n">ier</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">PARAM</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;Unsetting Output FLOW</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Turn off auto CTS flow control */</span>
	<span class="n">ier</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_IER_CTSDSR</span><span class="p">);</span>
	<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_CTSDSR</span><span class="p">);</span>

	<span class="cm">/* Turn off auto Xon flow control */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_iflag</span> <span class="o">&amp;</span> <span class="n">IXOFF</span><span class="p">)</span>
		<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_IXON</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">efr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_EFR_ECB</span> <span class="o">|</span> <span class="n">UART_17158_EFR_IXON</span><span class="p">);</span>

	<span class="cm">/* Why? Becuz Exar&#39;s spec says we have to zero it out before setting it */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on UART enhanced bits */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">efr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Turn on table D, with 8 char hi/low watermarks */</span>
	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_17158_FCTR_TRGD</span> <span class="o">|</span> <span class="n">UART_17158_FCTR_RTS_8DELAY</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">fctr</span><span class="p">);</span>

	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_watermark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">tfifo</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_t_tlevel</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">rfifo</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_tlevel</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">neo_set_new_start_stop_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* if hardware flow control is set, then skip this whole thing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">PARAM</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Tell UART what start/stop chars it should be looking for */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_startc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xonchar1</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xonchar2</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_stopc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xoffchar1</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xoffchar2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_copy_data_from_uart_to_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">qleft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">linestatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">error_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* cache head and tail of queue */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_head</span> <span class="o">&amp;</span> <span class="n">RQUEUEMASK</span><span class="p">;</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_tail</span> <span class="o">&amp;</span> <span class="n">RQUEUEMASK</span><span class="p">;</span>

	<span class="cm">/* Get our cached LSR */</span>
	<span class="n">linestatus</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span><span class="p">;</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Store how much space we have left in the queue */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">qleft</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">-</span> <span class="n">head</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">qleft</span> <span class="o">+=</span> <span class="n">RQUEUEMASK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the UART is not in FIFO mode, force the FIFO copy to</span>
<span class="cm">	 * NOT be run, by setting total to 0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * On the other hand, if the UART IS in FIFO mode, then ask</span>
<span class="cm">	 * the UART to give us an approximation of data it has RX&#39;ed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_FIFO_ENABLED</span><span class="p">))</span>
		<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">total</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">rfifo</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * EXAR chip bug - RX FIFO COUNT - Fudge factor.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This resolves a problem/bug with the Exar chip that sometimes</span>
<span class="cm">		 * returns a bogus value in the rfifo register.</span>
<span class="cm">		 * The count can be any where from 0-3 bytes &quot;off&quot;.</span>
<span class="cm">		 * Bizarre, but true.</span>
<span class="cm">		 */</span>
		<span class="n">total</span> <span class="o">-=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, bound the copy to make sure we don&#39;t overflow</span>
<span class="cm">	 * our own queue...</span>
<span class="cm">	 * The byte by byte copy loop below this loop this will</span>
<span class="cm">	 * deal with the queue overflow possibility.</span>
<span class="cm">	 */</span>
	<span class="n">total</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">qleft</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Grab the linestatus register, we need to check</span>
<span class="cm">		 * to see if there are any errors in the FIFO.</span>
<span class="cm">		 */</span>
		<span class="n">linestatus</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lsr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Break out if there is a FIFO error somewhere.</span>
<span class="cm">		 * This will allow us to go byte by byte down below,</span>
<span class="cm">		 * finding the exact location of the error.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_17158_RX_FIFO_DATA_ERROR</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Make sure we don&#39;t go over the end of our queue */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(((</span><span class="n">u32</span><span class="p">)</span> <span class="n">total</span><span class="p">),</span> <span class="p">(</span><span class="n">RQUEUESIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">head</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Cut down n even further if needed, this is to fix</span>
<span class="cm">		 * a problem with memcpy_fromio() with the Neo on the</span>
<span class="cm">		 * IBM pSeries platform.</span>
<span class="cm">		 * 15 bytes max appears to be the magic number.</span>
<span class="cm">		 */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="mi">12</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since we are grabbing the linestatus register, which</span>
<span class="cm">		 * will reset some bits after our read, we need to ensure</span>
<span class="cm">		 * we don&#39;t miss our TX FIFO emptys.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_LSR_THRE</span> <span class="o">|</span> <span class="n">UART_17158_TX_AND_FIFO_CLR</span><span class="p">))</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">);</span>

		<span class="n">linestatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Copy data from uart to the queue */</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_rqueue</span> <span class="o">+</span> <span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrxburst</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since RX_FIFO_DATA_ERROR was 0, we are guaranteed</span>
<span class="cm">		 * that all the data currently in the FIFO is free of</span>
<span class="cm">		 * breaks and parity/frame/orun errors.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_equeue</span> <span class="o">+</span> <span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="cm">/* Add to and flip head if needed */</span>
		<span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RQUEUEMASK</span><span class="p">;</span>
		<span class="n">total</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">qleft</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_rxcount</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create a mask to determine whether we should</span>
<span class="cm">	 * insert the character (if any) into our queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_iflag</span> <span class="o">&amp;</span> <span class="n">IGNBRK</span><span class="p">)</span>
		<span class="n">error_mask</span> <span class="o">|=</span> <span class="n">UART_LSR_BI</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now cleanup any leftover bytes still in the UART.</span>
<span class="cm">	 * Also deal with any possible queue overflow here as well.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Its possible we have a linestatus from the loop above</span>
<span class="cm">		 * this, so we &quot;OR&quot; on any extra bits.</span>
<span class="cm">		 */</span>
		<span class="n">linestatus</span> <span class="o">|=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lsr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the chip tells us there is no more data pending to</span>
<span class="cm">		 * be read, we can then leave.</span>
<span class="cm">		 * But before we do, cache the linestatus, just in case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_LSR_DR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span> <span class="o">=</span> <span class="n">linestatus</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* No need to store this bit */</span>
		<span class="n">linestatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_LSR_DR</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since we are grabbing the linestatus register, which</span>
<span class="cm">		 * will reset some bits after our read, we need to ensure</span>
<span class="cm">		 * we don&#39;t miss our TX FIFO emptys.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_LSR_THRE</span> <span class="o">|</span> <span class="n">UART_17158_TX_AND_FIFO_CLR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">linestatus</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_LSR_THRE</span> <span class="o">|</span> <span class="n">UART_17158_TX_AND_FIFO_CLR</span><span class="p">);</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Discard character if we are ignoring the error mask.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">error_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">discard</span><span class="p">;</span>
			<span class="n">linestatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memcpy_fromio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">discard</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrxburst</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If our queue is full, we have no choice but to drop some data.</span>
<span class="cm">		 * The assumption is that HWFLOW or SWFLOW should have stopped</span>
<span class="cm">		 * things way way before we got to this point.</span>
<span class="cm">		 *</span>
<span class="cm">		 * I decided that I wanted to ditch the oldest data first,</span>
<span class="cm">		 * I hope thats okay with everyone? Yes? Good.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">qleft</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jsm_printk</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="s">&quot;Queue full, dropping DATA:%x LSR:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_rqueue</span><span class="p">[</span><span class="n">tail</span><span class="p">],</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_equeue</span><span class="p">[</span><span class="n">tail</span><span class="p">]);</span>

			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_tail</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RQUEUEMASK</span><span class="p">;</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_err_overrun</span><span class="o">++</span><span class="p">;</span>
			<span class="n">qleft</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_rqueue</span> <span class="o">+</span> <span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrxburst</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_equeue</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">linestatus</span><span class="p">;</span>

		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="s">&quot;DATA/LSR pair: %x %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_rqueue</span><span class="p">[</span><span class="n">head</span><span class="p">],</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_equeue</span><span class="p">[</span><span class="n">head</span><span class="p">]);</span>

		<span class="cm">/* Ditch any remaining linestatus value. */</span>
		<span class="n">linestatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Add to and flip head if needed */</span>
		<span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RQUEUEMASK</span><span class="p">;</span>

		<span class="n">qleft</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_rxcount</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write new final heads to channel structure.</span>
<span class="cm">	 */</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_head</span> <span class="o">=</span> <span class="n">head</span> <span class="o">&amp;</span> <span class="n">RQUEUEMASK</span><span class="p">;</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_e_head</span> <span class="o">=</span> <span class="n">head</span> <span class="o">&amp;</span> <span class="n">EQUEUEMASK</span><span class="p">;</span>
	<span class="n">jsm_input</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_copy_data_from_queue_to_uart</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qlen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">circ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">circ</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>

	<span class="cm">/* No data to write to the UART */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">circ</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If port is &quot;stopped&quot;, don&#39;t send any data to the UART */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_STOP</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_BREAK_SENDING</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If FIFOs are disabled. Send data directly to txrx register</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_FIFO_ENABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">lsrbits</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lsr</span><span class="p">);</span>

		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span> <span class="o">|=</span> <span class="n">lsrbits</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span> <span class="o">&amp;</span> <span class="n">UART_LSR_THRE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_LSR_THRE</span><span class="p">);</span>

			<span class="n">writeb</span><span class="p">(</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrx</span><span class="p">);</span>
			<span class="n">jsm_printk</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					<span class="s">&quot;Tx data: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">]);</span>
			<span class="n">circ</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">circ</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_txcount</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to do it this way, because of the EXAR TXFIFO count bug.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">UART_17158_TX_FIFOSIZE</span> <span class="o">-</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_t_tlevel</span><span class="p">;</span>

	<span class="cm">/* cache head and tail of queue */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">circ</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">circ</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">qlen</span> <span class="o">=</span> <span class="n">uart_circ_chars_pending</span><span class="p">(</span><span class="n">circ</span><span class="p">);</span>

	<span class="cm">/* Find minimum of the FIFO space, versus queue length */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">qlen</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">s</span> <span class="o">=</span> <span class="p">((</span><span class="n">head</span> <span class="o">&gt;=</span> <span class="n">tail</span><span class="p">)</span> <span class="o">?</span> <span class="n">head</span> <span class="o">:</span> <span class="n">UART_XMIT_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="n">tail</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">memcpy_toio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrxburst</span><span class="p">,</span> <span class="n">circ</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="cm">/* Add and flip queue if needed */</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">tail</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_txcount</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">len_written</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Update the final tail */</span>
	<span class="n">circ</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len_written</span> <span class="o">&gt;=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_t_tlevel</span><span class="p">)</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">circ</span><span class="p">))</span>
		<span class="n">uart_write_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_parse_modem</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span> <span class="n">u8</span> <span class="n">signals</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">msignals</span> <span class="o">=</span> <span class="n">signals</span><span class="p">;</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">MSIGS</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;neo_parse_modem: port: %d msignals: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_portnum</span><span class="p">,</span> <span class="n">msignals</span><span class="p">);</span>

	<span class="cm">/* Scrub off lower bits. They signify delta&#39;s, which I don&#39;t care about */</span>
	<span class="cm">/* Keep DDCD and DDSR though */</span>
	<span class="n">msignals</span> <span class="o">&amp;=</span> <span class="mh">0xf8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msignals</span> <span class="o">&amp;</span> <span class="n">UART_MSR_DDCD</span><span class="p">)</span>
		<span class="n">uart_handle_dcd_change</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">,</span> <span class="n">msignals</span> <span class="o">&amp;</span> <span class="n">UART_MSR_DCD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msignals</span> <span class="o">&amp;</span> <span class="n">UART_MSR_DDSR</span><span class="p">)</span>
		<span class="n">uart_handle_cts_change</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">,</span> <span class="n">msignals</span> <span class="o">&amp;</span> <span class="n">UART_MSR_CTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msignals</span> <span class="o">&amp;</span> <span class="n">UART_MSR_DCD</span><span class="p">)</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|=</span> <span class="n">UART_MSR_DCD</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_MSR_DCD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msignals</span> <span class="o">&amp;</span> <span class="n">UART_MSR_DSR</span><span class="p">)</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|=</span> <span class="n">UART_MSR_DSR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_MSR_DSR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msignals</span> <span class="o">&amp;</span> <span class="n">UART_MSR_RI</span><span class="p">)</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|=</span> <span class="n">UART_MSR_RI</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_MSR_RI</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msignals</span> <span class="o">&amp;</span> <span class="n">UART_MSR_CTS</span><span class="p">)</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|=</span> <span class="n">UART_MSR_CTS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UART_MSR_CTS</span><span class="p">;</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">MSIGS</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;Port: %d DTR: %d RTS: %d CTS: %d DSR: %d &quot;</span> <span class="s">&quot;RI: %d CD: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_portnum</span><span class="p">,</span>
		<span class="o">!!</span><span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_MCR_DTR</span><span class="p">),</span>
		<span class="o">!!</span><span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_MCR_RTS</span><span class="p">),</span>
		<span class="o">!!</span><span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_MSR_CTS</span><span class="p">),</span>
		<span class="o">!!</span><span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_MSR_DSR</span><span class="p">),</span>
		<span class="o">!!</span><span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_MSR_RI</span><span class="p">),</span>
		<span class="o">!!</span><span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mistat</span> <span class="o">|</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_MSR_DCD</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Make the UART raise any of the output signals we want up */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_assert_modem_signals</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">mcr</span><span class="p">);</span>

	<span class="cm">/* flush write operation */</span>
	<span class="n">neo_pci_posting_flush</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush the WRITE FIFO on the Neo.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Channel lock MUST be held before calling this function!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_flush_uart_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_FCR_ENABLE_FIFO</span> <span class="o">|</span> <span class="n">UART_FCR_CLEAR_XMIT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">isr_fcr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Check to see if the UART feels it completely flushed the FIFO. */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">isr_fcr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jsm_printk</span><span class="p">(</span><span class="n">IOCTL</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					<span class="s">&quot;Still flushing TX UART... i: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Flush the READ FIFO on the Neo.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Channel lock MUST be held before calling this function!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_flush_uart_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_FCR_ENABLE_FIFO</span> <span class="o">|</span> <span class="n">UART_FCR_CLEAR_RCVR</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">isr_fcr</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Check to see if the UART feels it completely flushed the FIFO. */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">isr_fcr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jsm_printk</span><span class="p">(</span><span class="n">IOCTL</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					<span class="s">&quot;Still flushing RX UART... i: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * No locks are assumed to be held when calling this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_clear_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="cm">/* Turn break off, and unset some variables */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_BREAK_SENDING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lcr</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">((</span><span class="n">temp</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">UART_LCR_SBC</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lcr</span><span class="p">);</span>

		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CH_BREAK_SENDING</span><span class="p">);</span>
		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">IOCTL</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="s">&quot;clear break Finishing UART_LCR_SBC! finished: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>

		<span class="cm">/* flush write operation */</span>
		<span class="n">neo_pci_posting_flush</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse the ISR register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">neo_parse_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_board</span> <span class="o">*</span><span class="n">brd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">isr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cause</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">brd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&gt;</span> <span class="n">brd</span><span class="o">-&gt;</span><span class="n">maxports</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="n">brd</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Here we try to figure out what caused the interrupt to happen */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">isr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">isr_fcr</span><span class="p">);</span>

		<span class="cm">/* Bail if no pending interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="n">UART_IIR_NO_INT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Yank off the upper 2 bits, which just show that the FIFO&#39;s are enabled.</span>
<span class="cm">		 */</span>
		<span class="n">isr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_17158_IIR_FIFO_ENABLED</span><span class="p">);</span>

		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="s">&quot;%s:%d isr: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">isr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_17158_IIR_RDI_TIMEOUT</span> <span class="o">|</span> <span class="n">UART_IIR_RDI</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Read data from uart -&gt; queue */</span>
			<span class="n">neo_copy_data_from_uart_to_queue</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

			<span class="cm">/* Call our tty layer to enforce queue flow control if needed. */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
			<span class="n">jsm_check_queue_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="n">UART_IIR_THRI</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Transfer data (if any) from Write Queue -&gt; UART. */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
			<span class="n">neo_copy_data_from_queue_to_uart</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="n">UART_17158_IIR_XONXOFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cause</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">xoffchar1</span><span class="p">);</span>

			<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
					<span class="s">&quot;Port %d. Got ISR_XONXOFF: cause:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">cause</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Since the UART detected either an XON or</span>
<span class="cm">			 * XOFF match, we need to figure out which</span>
<span class="cm">			 * one it was, so we can suspend or resume data flow.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">==</span> <span class="n">UART_17158_XON_DETECT</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Is output stopped right now, if so, resume it */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">port</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_STOP</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CH_STOP</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
						<span class="s">&quot;Port %d. XON detected in incoming data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">==</span> <span class="n">UART_17158_XOFF_DETECT</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">port</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_STOP</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="n">CH_STOP</span><span class="p">;</span>
					<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
							<span class="s">&quot;Setting CH_STOP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
						<span class="s">&quot;Port: %d. XOFF detected in incoming data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">isr</span> <span class="o">&amp;</span> <span class="n">UART_17158_IIR_HWFLOW_STATE_CHANGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we get here, this means the hardware is doing auto flow control.</span>
<span class="cm">			 * Check to see whether RTS/DTR or CTS/DSR caused this interrupt.</span>
<span class="cm">			 */</span>
			<span class="n">cause</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">mcr</span><span class="p">);</span>

			<span class="cm">/* Which pin is doing auto flow? RTS or DTR? */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">UART_MCR_RTS</span><span class="p">)</span>
					<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span> <span class="o">|=</span> <span class="n">UART_MCR_RTS</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_MCR_RTS</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">&amp;</span> <span class="n">UART_MCR_DTR</span><span class="p">)</span>
					<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span> <span class="o">|=</span> <span class="n">UART_MCR_DTR</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_MCR_DTR</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Parse any modem signal changes */</span>
		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="s">&quot;MOD_STAT: sending to parse_modem_sigs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">neo_parse_modem</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">neo_parse_lsr</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_board</span> <span class="o">*</span><span class="n">brd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">linestatus</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">brd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&gt;</span> <span class="n">brd</span><span class="o">-&gt;</span><span class="n">maxports</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="n">brd</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">linestatus</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lsr</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;%s:%d port: %d linestatus: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">linestatus</span><span class="p">);</span>

	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span> <span class="o">|=</span> <span class="n">linestatus</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span> <span class="o">&amp;</span> <span class="n">UART_LSR_DR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read data from uart -&gt; queue */</span>
		<span class="n">neo_copy_data_from_uart_to_queue</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">jsm_check_queue_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a special flag. It indicates that at least 1</span>
<span class="cm">	 * RX error (parity, framing, or break) has happened.</span>
<span class="cm">	 * Mark this in our struct, which will tell me that I have</span>
<span class="cm">	 *to do the special RX+LSR read for this FIFO load.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_17158_RX_FIFO_DATA_ERROR</span><span class="p">)</span>
		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;%s:%d Port: %d Got an RX error, need to parse LSR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next 3 tests should *NOT* happen, as the above test</span>
<span class="cm">	 * should encapsulate all 3... At least, thats what Exar says.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_LSR_PE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_err_parity</span><span class="o">++</span><span class="p">;</span>
		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;%s:%d Port: %d. PAR ERR!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_LSR_FE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_err_frame</span><span class="o">++</span><span class="p">;</span>
		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;%s:%d Port: %d. FRM ERR!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_LSR_BI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_err_break</span><span class="o">++</span><span class="p">;</span>
		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;%s:%d Port: %d. BRK INTR!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_LSR_OE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Rx Oruns. Exar says that an orun will NOT corrupt</span>
<span class="cm">		 * the FIFO. It will just replace the holding register</span>
<span class="cm">		 * with this new data byte. So basically just ignore this.</span>
<span class="cm">		 * Probably we should eventually have an orun stat in our driver...</span>
<span class="cm">		 */</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_err_overrun</span><span class="o">++</span><span class="p">;</span>
		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;%s:%d Port: %d. Rx Overrun!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_LSR_THRE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

		<span class="cm">/* Transfer data (if any) from Write Queue -&gt; UART. */</span>
		<span class="n">neo_copy_data_from_queue_to_uart</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">linestatus</span> <span class="o">&amp;</span> <span class="n">UART_17158_TX_AND_FIFO_CLR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

		<span class="cm">/* Transfer data (if any) from Write Queue -&gt; UART. */</span>
		<span class="n">neo_copy_data_from_queue_to_uart</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * neo_param()</span>
<span class="cm"> * Send any/all changes to the line to the UART.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">lcr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">uart_lcr</span><span class="p">,</span> <span class="n">ier</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">baud</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">quot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jsm_board</span> <span class="o">*</span><span class="n">bd</span><span class="p">;</span>

	<span class="n">bd</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If baud rate is zero, flush queues, and set mval to drop DTR.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CBAUD</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_head</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_e_head</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_e_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">neo_flush_uart_write</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="n">neo_flush_uart_read</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_BAUD0</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_MCR_RTS</span> <span class="o">|</span> <span class="n">UART_MCR_DTR</span><span class="p">);</span>
		<span class="n">neo_assert_modem_signals</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflag</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflag</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">baud_rates</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">{</span> <span class="mi">921600</span><span class="p">,</span> <span class="n">B921600</span> <span class="p">},</span>
			<span class="p">{</span> <span class="mi">460800</span><span class="p">,</span> <span class="n">B460800</span> <span class="p">},</span>
			<span class="p">{</span> <span class="mi">230400</span><span class="p">,</span> <span class="n">B230400</span> <span class="p">},</span>
			<span class="p">{</span> <span class="mi">115200</span><span class="p">,</span> <span class="n">B115200</span> <span class="p">},</span>
			<span class="p">{</span>  <span class="mi">57600</span><span class="p">,</span> <span class="n">B57600</span>  <span class="p">},</span>
			<span class="p">{</span>  <span class="mi">38400</span><span class="p">,</span> <span class="n">B38400</span>  <span class="p">},</span>
			<span class="p">{</span>  <span class="mi">19200</span><span class="p">,</span> <span class="n">B19200</span>  <span class="p">},</span>
			<span class="p">{</span>   <span class="mi">9600</span><span class="p">,</span> <span class="n">B9600</span>   <span class="p">},</span>
			<span class="p">{</span>   <span class="mi">4800</span><span class="p">,</span> <span class="n">B4800</span>   <span class="p">},</span>
			<span class="p">{</span>   <span class="mi">2400</span><span class="p">,</span> <span class="n">B2400</span>   <span class="p">},</span>
			<span class="p">{</span>   <span class="mi">1200</span><span class="p">,</span> <span class="n">B1200</span>   <span class="p">},</span>
			<span class="p">{</span>    <span class="mi">600</span><span class="p">,</span> <span class="n">B600</span>    <span class="p">},</span>
			<span class="p">{</span>    <span class="mi">300</span><span class="p">,</span> <span class="n">B300</span>    <span class="p">},</span>
			<span class="p">{</span>    <span class="mi">200</span><span class="p">,</span> <span class="n">B200</span>    <span class="p">},</span>
			<span class="p">{</span>    <span class="mi">150</span><span class="p">,</span> <span class="n">B150</span>    <span class="p">},</span>
			<span class="p">{</span>    <span class="mi">134</span><span class="p">,</span> <span class="n">B134</span>    <span class="p">},</span>
			<span class="p">{</span>    <span class="mi">110</span><span class="p">,</span> <span class="n">B110</span>    <span class="p">},</span>
			<span class="p">{</span>     <span class="mi">75</span><span class="p">,</span> <span class="n">B75</span>     <span class="p">},</span>
			<span class="p">{</span>     <span class="mi">50</span><span class="p">,</span> <span class="n">B50</span>     <span class="p">},</span>
		<span class="p">};</span>

		<span class="n">cflag</span> <span class="o">=</span> <span class="n">C_BAUD</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">uart_port</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">);</span>
		<span class="n">baud</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">baud_rates</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">baud_rates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cflag</span> <span class="o">==</span> <span class="n">cflag</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">baud</span> <span class="o">=</span> <span class="n">baud_rates</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rate</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_BAUD0</span><span class="p">)</span>
			<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CH_BAUD0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">PARENB</span><span class="p">)</span>
		<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_PARITY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">PARODD</span><span class="p">))</span>
		<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_EPAR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not all platforms support mark/space parity,</span>
<span class="cm">	 * so this will hide behind an ifdef.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef CMSPAR</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">CMSPAR</span><span class="p">)</span>
		<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_SPAR</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">CSTOPB</span><span class="p">)</span>
		<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_STOP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">CSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CS5</span>:
			<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_WLEN5</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CS6</span>:
			<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_WLEN6</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CS7</span>:
			<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_WLEN7</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CS8</span>:
		<span class="nl">default:</span>
			<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_WLEN8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ier</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">uart_lcr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lcr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">baud</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">baud</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>

	<span class="n">quot</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="o">-&gt;</span><span class="n">bd_dividend</span> <span class="o">/</span> <span class="n">baud</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quot</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">UART_LCR_DLAB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lcr</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">((</span><span class="n">quot</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrx</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">((</span><span class="n">quot</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">lcr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lcr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_lcr</span> <span class="o">!=</span> <span class="n">lcr</span><span class="p">)</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">lcr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lcr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">CREAD</span><span class="p">)</span>
		<span class="n">ier</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_IER_RDI</span> <span class="o">|</span> <span class="n">UART_IER_RLSI</span><span class="p">);</span>

	<span class="n">ier</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_IER_THRI</span> <span class="o">|</span> <span class="n">UART_IER_MSI</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>

	<span class="cm">/* Set new start/stop chars */</span>
	<span class="n">neo_set_new_start_stop_chars</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="n">neo_set_cts_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_iflag</span> <span class="o">&amp;</span> <span class="n">IXON</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If start/stop is set to disable, then we should disable flow control */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_startc</span> <span class="o">==</span> <span class="n">__DISABLED_CHAR</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_stopc</span> <span class="o">==</span> <span class="n">__DISABLED_CHAR</span><span class="p">))</span>
			<span class="n">neo_set_no_output_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">neo_set_ixon_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">neo_set_no_output_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span>
		<span class="n">neo_set_rts_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_c_iflag</span> <span class="o">&amp;</span> <span class="n">IXOFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If start/stop is set to disable, then we should disable flow control */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_startc</span> <span class="o">==</span> <span class="n">__DISABLED_CHAR</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_stopc</span> <span class="o">==</span> <span class="n">__DISABLED_CHAR</span><span class="p">))</span>
			<span class="n">neo_set_no_input_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">neo_set_ixoff_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">neo_set_no_input_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Adjust the RX FIFO Trigger level if baud is less than 9600.</span>
<span class="cm">	 * Not exactly elegant, but this is needed because of the Exar chip&#39;s</span>
<span class="cm">	 * delay on firing off the RX FIFO interrupt on slower baud rates.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">baud</span> <span class="o">&lt;</span> <span class="mi">9600</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writeb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">rfifo</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_r_tlevel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">neo_assert_modem_signals</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

	<span class="cm">/* Get current status of the modem signals now */</span>
	<span class="n">neo_parse_modem</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * jsm_neo_intr()</span>
<span class="cm"> *</span>
<span class="cm"> * Neo specific interrupt handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">neo_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">voidbrd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jsm_board</span> <span class="o">*</span><span class="n">brd</span> <span class="o">=</span> <span class="n">voidbrd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">current_port</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uart_poll</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock_flags2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">outofloop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Lock out the slow poller from running on this board. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">bd_intr_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read in &quot;extended&quot; IRQ information from the 32bit Neo register.</span>
<span class="cm">	 * Bits 0-7: What port triggered the interrupt.</span>
<span class="cm">	 * Bits 8-31: Each 3bits indicate what type of interrupt occurred.</span>
<span class="cm">	 */</span>
	<span class="n">uart_poll</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">re_map_membase</span> <span class="o">+</span> <span class="n">UART_17158_POLL_ADDR_OFFSET</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
		<span class="s">&quot;%s:%d uart_poll: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">uart_poll</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uart_poll</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
			<span class="s">&quot;Kernel interrupted to me, but no pending interrupts...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">bd_intr_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* At this point, we have at least SOMETHING to service, dig further... */</span>

	<span class="n">current_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Loop on each port */</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">uart_poll</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">outofloop_count</span> <span class="o">&lt;</span> <span class="mh">0xff</span><span class="p">)){</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">uart_poll</span><span class="p">;</span>
		<span class="n">outofloop_count</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Check current port to see if it has interrupt pending */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">jsm_offset_table</span><span class="p">[</span><span class="n">current_port</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port</span> <span class="o">=</span> <span class="n">current_port</span><span class="p">;</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="n">port</span> <span class="o">*</span> <span class="mi">3</span><span class="p">));</span>
			<span class="n">type</span> <span class="o">&amp;=</span> <span class="mh">0x7</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">current_port</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
		<span class="s">&quot;%s:%d port: %x type: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

		<span class="cm">/* Remove this port + type from uart_poll */</span>
		<span class="n">uart_poll</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">jsm_offset_table</span><span class="p">[</span><span class="n">port</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If no type, just ignore it, and move onto next port */</span>
			<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="s">&quot;Interrupt with no type! port: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Switch on type of interrupt we have */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">UART_17158_RXRDY_TIMEOUT</span>:
			<span class="cm">/*</span>
<span class="cm">			 * RXRDY Time-out is cleared by reading data in the</span>
<span class="cm">			* RX FIFO until it falls below the trigger level.</span>
<span class="cm">			 */</span>

			<span class="cm">/* Verify the port is in range. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&gt;</span> <span class="n">brd</span><span class="o">-&gt;</span><span class="n">nasync</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ch</span> <span class="o">=</span> <span class="n">brd</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
			<span class="n">neo_copy_data_from_uart_to_queue</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>

			<span class="cm">/* Call our tty layer to enforce queue flow control if needed. */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags2</span><span class="p">);</span>
			<span class="n">jsm_check_queue_flow_control</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_lock</span><span class="p">,</span> <span class="n">lock_flags2</span><span class="p">);</span>

			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">UART_17158_RX_LINE_STATUS</span>:
			<span class="cm">/*</span>
<span class="cm">			 * RXRDY and RX LINE Status (logic OR of LSR[4:1])</span>
<span class="cm">			 */</span>
			<span class="n">neo_parse_lsr</span><span class="p">(</span><span class="n">brd</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">UART_17158_TXRDY</span>:
			<span class="cm">/*</span>
<span class="cm">			 * TXRDY interrupt clears after reading ISR register for the UART channel.</span>
<span class="cm">			 */</span>

			<span class="cm">/*</span>
<span class="cm">			 * Yes, this is odd...</span>
<span class="cm">			 * Why would I check EVERY possibility of type of</span>
<span class="cm">			 * interrupt, when we know its TXRDY???</span>
<span class="cm">			 * Becuz for some reason, even tho we got triggered for TXRDY,</span>
<span class="cm">			 * it seems to be occasionally wrong. Instead of TX, which</span>
<span class="cm">			 * it should be, I was getting things like RXDY too. Weird.</span>
<span class="cm">			 */</span>
			<span class="n">neo_parse_isr</span><span class="p">(</span><span class="n">brd</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">UART_17158_MSR</span>:
			<span class="cm">/*</span>
<span class="cm">			 * MSR or flow control was seen.</span>
<span class="cm">			 */</span>
			<span class="n">neo_parse_isr</span><span class="p">(</span><span class="n">brd</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="cm">/*</span>
<span class="cm">			 * The UART triggered us with a bogus interrupt type.</span>
<span class="cm">			 * It appears the Exar chip, when REALLY bogged down, will throw</span>
<span class="cm">			 * these once and awhile.</span>
<span class="cm">			 * Its harmless, just ignore it and move on.</span>
<span class="cm">			 */</span>
			<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span>
				<span class="s">&quot;%s:%d Unknown Interrupt type: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">bd_intr_lock</span><span class="p">,</span> <span class="n">lock_flags</span><span class="p">);</span>

	<span class="n">jsm_printk</span><span class="p">(</span><span class="n">INTR</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">brd</span><span class="o">-&gt;</span><span class="n">pci_dev</span><span class="p">,</span> <span class="s">&quot;finish.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Neo specific way of turning off the receiver.</span>
<span class="cm"> * Used as a way to enforce queue flow control when in</span>
<span class="cm"> * hardware flow control mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_disable_receiver</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UART_IER_RDI</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>

	<span class="cm">/* flush write operation */</span>
	<span class="n">neo_pci_posting_flush</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Neo specific way of turning on the receiver.</span>
<span class="cm"> * Used as a way to un-enforce queue flow control when in</span>
<span class="cm"> * hardware flow control mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_enable_receiver</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UART_IER_RDI</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>

	<span class="cm">/* flush write operation */</span>
	<span class="n">neo_pci_posting_flush</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_send_start_character</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_startc</span> <span class="o">!=</span> <span class="n">__DISABLED_CHAR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_xon_sends</span><span class="o">++</span><span class="p">;</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_startc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrx</span><span class="p">);</span>

		<span class="cm">/* flush write operation */</span>
		<span class="n">neo_pci_posting_flush</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_send_stop_character</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_stopc</span> <span class="o">!=</span> <span class="n">__DISABLED_CHAR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_xoff_sends</span><span class="o">++</span><span class="p">;</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_stopc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrx</span><span class="p">);</span>

		<span class="cm">/* flush write operation */</span>
		<span class="n">neo_pci_posting_flush</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * neo_uart_init</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_uart_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">UART_EFR_ECB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Clear out UART and FIFO */</span>
	<span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrx</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">((</span><span class="n">UART_FCR_ENABLE_FIFO</span><span class="o">|</span><span class="n">UART_FCR_CLEAR_RCVR</span><span class="o">|</span><span class="n">UART_FCR_CLEAR_XMIT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">isr_fcr</span><span class="p">);</span>
	<span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lsr</span><span class="p">);</span>
	<span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">msr</span><span class="p">);</span>

	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="n">CH_FIFO_ENABLED</span><span class="p">;</span>

	<span class="cm">/* Assert any signals we want up */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_mostat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">mcr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Make the UART completely turn off.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_uart_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Turn off UART enhanced bits */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">efr</span><span class="p">);</span>

	<span class="cm">/* Stop all interrupts from occurring. */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">neo_get_uart_bytes_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">lsr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lsr</span><span class="p">);</span>

	<span class="cm">/* We must cache the LSR as some of the bits get reset once read... */</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_cached_lsr</span> <span class="o">|=</span> <span class="n">lsr</span><span class="p">;</span>

	<span class="cm">/* Determine whether the Transmitter is empty or not */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lsr</span> <span class="o">&amp;</span> <span class="n">UART_LSR_TEMT</span><span class="p">))</span>
		<span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_TX_FIFO_EMPTY</span> <span class="o">|</span> <span class="n">CH_TX_FIFO_LWM</span><span class="p">);</span>
		<span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Channel lock MUST be held by the calling function! */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_send_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set the time we should stop sending the break.</span>
<span class="cm">	 * If we are already sending a break, toss away the existing</span>
<span class="cm">	 * time to stop, and use this new value instead.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Tell the UART to start sending the break */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">&amp;</span> <span class="n">CH_BREAK_SENDING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lcr</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">((</span><span class="n">temp</span> <span class="o">|</span> <span class="n">UART_LCR_SBC</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">lcr</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CH_BREAK_SENDING</span><span class="p">);</span>

		<span class="cm">/* flush write operation */</span>
		<span class="n">neo_pci_posting_flush</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * neo_send_immediate_char.</span>
<span class="cm"> *</span>
<span class="cm"> * Sends a specific character as soon as possible to the UART,</span>
<span class="cm"> * jumping over any bytes that might be in the write queue.</span>
<span class="cm"> *</span>
<span class="cm"> * The channel lock MUST be held by the calling function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">neo_send_immediate_char</span><span class="p">(</span><span class="k">struct</span> <span class="n">jsm_channel</span> <span class="o">*</span><span class="n">ch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_neo_uart</span><span class="o">-&gt;</span><span class="n">txrx</span><span class="p">);</span>

	<span class="cm">/* flush write operation */</span>
	<span class="n">neo_pci_posting_flush</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">ch_bd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">board_ops</span> <span class="n">jsm_neo_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">intr</span>				<span class="o">=</span> <span class="n">neo_intr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uart_init</span>			<span class="o">=</span> <span class="n">neo_uart_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uart_off</span>			<span class="o">=</span> <span class="n">neo_uart_off</span><span class="p">,</span>
	<span class="p">.</span><span class="n">param</span>				<span class="o">=</span> <span class="n">neo_param</span><span class="p">,</span>
	<span class="p">.</span><span class="n">assert_modem_signals</span>		<span class="o">=</span> <span class="n">neo_assert_modem_signals</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_uart_write</span>		<span class="o">=</span> <span class="n">neo_flush_uart_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush_uart_read</span>		<span class="o">=</span> <span class="n">neo_flush_uart_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_receiver</span>		<span class="o">=</span> <span class="n">neo_disable_receiver</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_receiver</span>		<span class="o">=</span> <span class="n">neo_enable_receiver</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_break</span>			<span class="o">=</span> <span class="n">neo_send_break</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_break</span>			<span class="o">=</span> <span class="n">neo_clear_break</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_start_character</span>		<span class="o">=</span> <span class="n">neo_send_start_character</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_stop_character</span>		<span class="o">=</span> <span class="n">neo_send_stop_character</span><span class="p">,</span>
	<span class="p">.</span><span class="n">copy_data_from_queue_to_uart</span>	<span class="o">=</span> <span class="n">neo_copy_data_from_queue_to_uart</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_uart_bytes_left</span>		<span class="o">=</span> <span class="n">neo_get_uart_bytes_left</span><span class="p">,</span>
	<span class="p">.</span><span class="n">send_immediate_char</span>		<span class="o">=</span> <span class="n">neo_send_immediate_char</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
