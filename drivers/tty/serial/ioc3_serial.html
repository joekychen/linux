<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › serial › ioc3_serial.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ioc3_serial.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 Silicon Graphics, Inc.  All Rights Reserved.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file contains a module version of the ioc3 serial driver. This</span>
<span class="cm"> * includes all the support functions needed (support functions, etc.)</span>
<span class="cm"> * and the serial driver itself.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/circ_buf.h&gt;</span>
<span class="cp">#include &lt;linux/serial_reg.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/serial_core.h&gt;</span>
<span class="cp">#include &lt;linux/ioc3.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Interesting things about the ioc3</span>
<span class="cm"> */</span>

<span class="cp">#define LOGICAL_PORTS		2	</span><span class="cm">/* rs232(0) and rs422(1) */</span><span class="cp"></span>
<span class="cp">#define PORTS_PER_CARD		2</span>
<span class="cp">#define LOGICAL_PORTS_PER_CARD (PORTS_PER_CARD * LOGICAL_PORTS)</span>
<span class="cp">#define MAX_CARDS		8</span>
<span class="cp">#define MAX_LOGICAL_PORTS	(LOGICAL_PORTS_PER_CARD * MAX_CARDS)</span>

<span class="cm">/* determine given the sio_ir what port it applies to */</span>
<span class="cp">#define GET_PORT_FROM_SIO_IR(_x)	(_x &amp; SIO_IR_SA) ? 0 : 1</span>


<span class="cm">/*</span>
<span class="cm"> * we have 2 logical ports (rs232, rs422) for each physical port</span>
<span class="cm"> * evens are rs232, odds are rs422</span>
<span class="cm"> */</span>
<span class="cp">#define GET_PHYSICAL_PORT(_x)	((_x) &gt;&gt; 1)</span>
<span class="cp">#define GET_LOGICAL_PORT(_x)	((_x) &amp; 1)</span>
<span class="cp">#define IS_PHYSICAL_PORT(_x)	!((_x) &amp; 1)</span>
<span class="cp">#define IS_RS232(_x)		!((_x) &amp; 1)</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Num_of_ioc3_cards</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Submodule_slot</span><span class="p">;</span>

<span class="cm">/* defining this will get you LOTS of great debug info */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><h1>define DEBUG_INTERRUPTS</h1></td><td class="code"><div class="highlight"><pre><span class="cp">#define DPRINT_CONFIG(_x...)	;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><h1>define DPRINT<em>CONFIG(</em>x...)  printk _x</h1></td><td class="code"><div class="highlight"><pre><span class="cp">#define NOT_PROGRESS()	;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><h1>define NOT_PROGRESS()    printk("%s : fails %d\n", <strong>func</strong>, <strong>LINE</strong>)</h1></td><td class="code"><div class="highlight"><pre><span class="cm">/* number of characters we want to transmit to the lower level at a time */</span>
<span class="cp">#define MAX_CHARS		256</span>
<span class="cp">#define FIFO_SIZE		(MAX_CHARS-1)	</span><span class="cm">/* it&#39;s a uchar */</span><span class="cp"></span>

<span class="cm">/* Device name we&#39;re using */</span>
<span class="cp">#define DEVICE_NAME		&quot;ttySIOC&quot;</span>
<span class="cp">#define DEVICE_MAJOR		204</span>
<span class="cp">#define DEVICE_MINOR		116</span>

<span class="cm">/* flags for next_char_state */</span>
<span class="cp">#define NCS_BREAK		0x1</span>
<span class="cp">#define NCS_PARITY		0x2</span>
<span class="cp">#define NCS_FRAMING		0x4</span>
<span class="cp">#define NCS_OVERRUN		0x8</span>

<span class="cm">/* cause we need SOME parameters ... */</span>
<span class="cp">#define MIN_BAUD_SUPPORTED	1200</span>
<span class="cp">#define MAX_BAUD_SUPPORTED	115200</span>

<span class="cm">/* protocol types supported */</span>
<span class="cp">#define PROTO_RS232		0</span>
<span class="cp">#define PROTO_RS422		1</span>

<span class="cm">/* Notification types */</span>
<span class="cp">#define N_DATA_READY		0x01</span>
<span class="cp">#define N_OUTPUT_LOWAT		0x02</span>
<span class="cp">#define N_BREAK			0x04</span>
<span class="cp">#define N_PARITY_ERROR		0x08</span>
<span class="cp">#define N_FRAMING_ERROR		0x10</span>
<span class="cp">#define N_OVERRUN_ERROR		0x20</span>
<span class="cp">#define N_DDCD			0x40</span>
<span class="cp">#define N_DCTS			0x80</span>

<span class="cp">#define N_ALL_INPUT		(N_DATA_READY | N_BREAK			   \</span>
<span class="cp">					| N_PARITY_ERROR | N_FRAMING_ERROR \</span>
<span class="cp">					| N_OVERRUN_ERROR | N_DDCD | N_DCTS)</span>

<span class="cp">#define N_ALL_OUTPUT		N_OUTPUT_LOWAT</span>

<span class="cp">#define N_ALL_ERRORS		(N_PARITY_ERROR | N_FRAMING_ERROR \</span>
<span class="cp">						| N_OVERRUN_ERROR)</span>

<span class="cp">#define N_ALL			(N_DATA_READY | N_OUTPUT_LOWAT | N_BREAK    \</span>
<span class="cp">					| N_PARITY_ERROR | N_FRAMING_ERROR  \</span>
<span class="cp">					| N_OVERRUN_ERROR | N_DDCD | N_DCTS)</span>

<span class="cp">#define SER_CLK_SPEED(prediv)	((22000000 &lt;&lt; 1) / prediv)</span>
<span class="cp">#define SER_DIVISOR(x, clk)	(((clk) + (x) * 8) / ((x) * 16))</span>
<span class="cp">#define DIVISOR_TO_BAUD(div, clk) ((clk) / 16 / (div))</span>

<span class="cm">/* Some masks */</span>
<span class="cp">#define LCR_MASK_BITS_CHAR	(UART_LCR_WLEN5 | UART_LCR_WLEN6 \</span>
<span class="cp">					| UART_LCR_WLEN7 | UART_LCR_WLEN8)</span>
<span class="cp">#define LCR_MASK_STOP_BITS	(UART_LCR_STOP)</span>

<span class="cp">#define PENDING(_a, _p)		(readl(&amp;(_p)-&gt;vma-&gt;sio_ir) &amp; (_a)-&gt;ic_enable)</span>

<span class="cp">#define RING_BUF_SIZE		4096</span>
<span class="cp">#define BUF_SIZE_BIT		SBBR_L_SIZE</span>
<span class="cp">#define PROD_CONS_MASK		PROD_CONS_PTR_4K</span>

<span class="cp">#define TOTAL_RING_BUF_SIZE	(RING_BUF_SIZE * 4)</span>

<span class="cm">/* driver specific - one per card */</span>
<span class="k">struct</span> <span class="n">ioc3_card</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/* uart ports are allocated here */</span>
		<span class="k">struct</span> <span class="n">uart_port</span> <span class="n">icp_uart_port</span><span class="p">[</span><span class="n">LOGICAL_PORTS</span><span class="p">];</span>
		<span class="cm">/* the ioc3_port used for this port */</span>
		<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">icp_port</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ic_port</span><span class="p">[</span><span class="n">PORTS_PER_CARD</span><span class="p">];</span>
	<span class="cm">/* currently enabled interrupts */</span>
	<span class="kt">uint32_t</span> <span class="n">ic_enable</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Local port info for each IOC3 serial port */</span>
<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="p">{</span>
	<span class="cm">/* handy reference material */</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">ip_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_card</span> <span class="o">*</span><span class="n">ip_card</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_driver_data</span> <span class="o">*</span><span class="n">ip_idd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_submodule</span> <span class="o">*</span><span class="n">ip_is</span><span class="p">;</span>

	<span class="cm">/* pci mem addresses for this port */</span>
	<span class="k">struct</span> <span class="n">ioc3_serialregs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ip_serial_regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_uartregs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ip_uart_regs</span><span class="p">;</span>

	<span class="cm">/* Ring buffer page for this port */</span>
	<span class="n">dma_addr_t</span> <span class="n">ip_dma_ringbuf</span><span class="p">;</span>
	<span class="cm">/* vaddr of ring buffer */</span>
	<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="o">*</span><span class="n">ip_cpu_ringbuf</span><span class="p">;</span>

	<span class="cm">/* Rings for this port */</span>
	<span class="k">struct</span> <span class="n">ring</span> <span class="o">*</span><span class="n">ip_inring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring</span> <span class="o">*</span><span class="n">ip_outring</span><span class="p">;</span>

	<span class="cm">/* Hook to port specific values */</span>
	<span class="k">struct</span> <span class="n">port_hooks</span> <span class="o">*</span><span class="n">ip_hooks</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">ip_lock</span><span class="p">;</span>

	<span class="cm">/* Various rx/tx parameters */</span>
	<span class="kt">int</span> <span class="n">ip_baud</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ip_tx_lowat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ip_rx_timeout</span><span class="p">;</span>

	<span class="cm">/* Copy of notification bits */</span>
	<span class="kt">int</span> <span class="n">ip_notify</span><span class="p">;</span>

	<span class="cm">/* Shadow copies of various registers so we don&#39;t need to PIO</span>
<span class="cm">	 * read them constantly</span>
<span class="cm">	 */</span>
	<span class="kt">uint32_t</span> <span class="n">ip_sscr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ip_tx_prod</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ip_rx_cons</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ip_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* tx low water mark.  We need to notify the driver whenever tx is getting</span>
<span class="cm"> * close to empty so it can refill the tx buffer and keep things going.</span>
<span class="cm"> * Let&#39;s assume that if we interrupt 1 ms before the tx goes idle, we&#39;ll</span>
<span class="cm"> * have no trouble getting in more chars in time (I certainly hope so).</span>
<span class="cm"> */</span>
<span class="cp">#define TX_LOWAT_LATENCY      1000</span>
<span class="cp">#define TX_LOWAT_HZ          (1000000 / TX_LOWAT_LATENCY)</span>
<span class="cp">#define TX_LOWAT_CHARS(baud) (baud / 10 / TX_LOWAT_HZ)</span>

<span class="cm">/* Flags per port */</span>
<span class="cp">#define INPUT_HIGH		0x01</span>
	<span class="cm">/* used to signify that we have turned off the rx_high</span>
<span class="cm">	 * temporarily - we need to drain the fifo and don&#39;t</span>
<span class="cm">	 * want to get blasted with interrupts.</span>
<span class="cm">	 */</span>
<span class="cp">#define DCD_ON			0x02</span>
	<span class="cm">/* DCD state is on */</span>
<span class="cp">#define LOWAT_WRITTEN		0x04</span>
<span class="cp">#define READ_ABORTED		0x08</span>
	<span class="cm">/* the read was aborted - used to avaoid infinate looping</span>
<span class="cm">	 * in the interrupt handler</span>
<span class="cm">	 */</span>
<span class="cp">#define INPUT_ENABLE		0x10</span>

<span class="cm">/* Since each port has different register offsets and bitmasks</span>
<span class="cm"> * for everything, we&#39;ll store those that we need in tables so we</span>
<span class="cm"> * don&#39;t have to be constantly checking the port we are dealing with.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">port_hooks</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">intr_delta_dcd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_delta_cts</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_tx_mt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_rx_timer</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_rx_high</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_tx_explicit</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_clear</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_all</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">rs422_select_pin</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">port_hooks</span> <span class="n">hooks_array</span><span class="p">[</span><span class="n">PORTS_PER_CARD</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* values for port A */</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">intr_delta_dcd</span> <span class="o">=</span> <span class="n">SIO_IR_SA_DELTA_DCD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_delta_cts</span> <span class="o">=</span> <span class="n">SIO_IR_SA_DELTA_CTS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_tx_mt</span> <span class="o">=</span> <span class="n">SIO_IR_SA_TX_MT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_rx_timer</span> <span class="o">=</span> <span class="n">SIO_IR_SA_RX_TIMER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_rx_high</span> <span class="o">=</span> <span class="n">SIO_IR_SA_RX_HIGH</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_tx_explicit</span> <span class="o">=</span> <span class="n">SIO_IR_SA_TX_EXPLICIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_clear</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIO_IR_SA_TX_MT</span> <span class="o">|</span> <span class="n">SIO_IR_SA_RX_FULL</span>
				<span class="o">|</span> <span class="n">SIO_IR_SA_RX_HIGH</span>
				<span class="o">|</span> <span class="n">SIO_IR_SA_RX_TIMER</span>
				<span class="o">|</span> <span class="n">SIO_IR_SA_DELTA_DCD</span>
				<span class="o">|</span> <span class="n">SIO_IR_SA_DELTA_CTS</span>
				<span class="o">|</span> <span class="n">SIO_IR_SA_INT</span>
				<span class="o">|</span> <span class="n">SIO_IR_SA_TX_EXPLICIT</span>
				<span class="o">|</span> <span class="n">SIO_IR_SA_MEMERR</span><span class="p">),</span>
	<span class="p">.</span><span class="n">intr_all</span> <span class="o">=</span>  <span class="n">SIO_IR_SA</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rs422_select_pin</span> <span class="o">=</span> <span class="n">GPPR_UARTA_MODESEL_PIN</span><span class="p">,</span>
	 <span class="p">},</span>

	<span class="cm">/* values for port B */</span>
	<span class="p">{</span>
	<span class="p">.</span><span class="n">intr_delta_dcd</span> <span class="o">=</span> <span class="n">SIO_IR_SB_DELTA_DCD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_delta_cts</span> <span class="o">=</span> <span class="n">SIO_IR_SB_DELTA_CTS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_tx_mt</span> <span class="o">=</span> <span class="n">SIO_IR_SB_TX_MT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_rx_timer</span> <span class="o">=</span> <span class="n">SIO_IR_SB_RX_TIMER</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_rx_high</span> <span class="o">=</span> <span class="n">SIO_IR_SB_RX_HIGH</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_tx_explicit</span> <span class="o">=</span> <span class="n">SIO_IR_SB_TX_EXPLICIT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr_clear</span> <span class="o">=</span> <span class="p">(</span><span class="n">SIO_IR_SB_TX_MT</span> <span class="o">|</span> <span class="n">SIO_IR_SB_RX_FULL</span>
				<span class="o">|</span> <span class="n">SIO_IR_SB_RX_HIGH</span>
				<span class="o">|</span> <span class="n">SIO_IR_SB_RX_TIMER</span>
				<span class="o">|</span> <span class="n">SIO_IR_SB_DELTA_DCD</span>
				<span class="o">|</span> <span class="n">SIO_IR_SB_DELTA_CTS</span>
				<span class="o">|</span> <span class="n">SIO_IR_SB_INT</span>
				<span class="o">|</span> <span class="n">SIO_IR_SB_TX_EXPLICIT</span>
				<span class="o">|</span> <span class="n">SIO_IR_SB_MEMERR</span><span class="p">),</span>
	<span class="p">.</span><span class="n">intr_all</span> <span class="o">=</span> <span class="n">SIO_IR_SB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rs422_select_pin</span> <span class="o">=</span> <span class="n">GPPR_UARTB_MODESEL_PIN</span><span class="p">,</span>
	 <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ring_entry</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">alldata</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">allsc</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">all</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* data bytes */</span>
			<span class="kt">char</span> <span class="n">sc</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="cm">/* status/control */</span>
		<span class="p">}</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Test the valid bits in any of the 4 sc chars using &quot;allsc&quot; member */</span>
<span class="cp">#define RING_ANY_VALID \</span>
<span class="cp">	((uint32_t)(RXSB_MODEM_VALID | RXSB_DATA_VALID) * 0x01010101)</span>

<span class="cp">#define ring_sc		u.s.sc</span>
<span class="cp">#define ring_data	u.s.data</span>
<span class="cp">#define ring_allsc	u.all.allsc</span>

<span class="cm">/* Number of entries per ring buffer. */</span>
<span class="cp">#define ENTRIES_PER_RING (RING_BUF_SIZE / (int) sizeof(struct ring_entry))</span>

<span class="cm">/* An individual ring */</span>
<span class="k">struct</span> <span class="n">ring</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring_entry</span> <span class="n">entries</span><span class="p">[</span><span class="n">ENTRIES_PER_RING</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* The whole enchilada */</span>
<span class="k">struct</span> <span class="n">ring_buffer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ring</span> <span class="n">TX_A</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring</span> <span class="n">RX_A</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring</span> <span class="n">TX_B</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring</span> <span class="n">RX_B</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Get a ring from a port struct */</span>
<span class="cp">#define RING(_p, _wh)	&amp;(((struct ring_buffer *)((_p)-&gt;ip_cpu_ringbuf))-&gt;_wh)</span>

<span class="cm">/* for Infinite loop detection  */</span>
<span class="cp">#define MAXITER		10000000</span>


<span class="cm">/**</span>
<span class="cm"> * set_baud - Baud rate setting code</span>
<span class="cm"> * @port: port to set</span>
<span class="cm"> * @baud: baud rate to use</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_baud</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">baud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">divisor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">actual_baud</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">diff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lcr</span><span class="p">,</span> <span class="n">prediv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_uartregs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">prediv</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="n">prediv</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">prediv</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">divisor</span> <span class="o">=</span> <span class="n">SER_DIVISOR</span><span class="p">(</span><span class="n">baud</span><span class="p">,</span> <span class="n">SER_CLK_SPEED</span><span class="p">(</span><span class="n">prediv</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">divisor</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* invalid divisor */</span>
		<span class="n">actual_baud</span> <span class="o">=</span> <span class="n">DIVISOR_TO_BAUD</span><span class="p">(</span><span class="n">divisor</span><span class="p">,</span> <span class="n">SER_CLK_SPEED</span><span class="p">(</span><span class="n">prediv</span><span class="p">));</span>

		<span class="n">diff</span> <span class="o">=</span> <span class="n">actual_baud</span> <span class="o">-</span> <span class="n">baud</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span><span class="p">;</span>

		<span class="cm">/* if we&#39;re within 1% we&#39;ve found a match */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">&lt;=</span> <span class="n">actual_baud</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if the above loop completed, we didn&#39;t match</span>
<span class="cm">	 * the baud rate.  give up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prediv</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NOT_PROGRESS</span><span class="p">();</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">uart</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="p">;</span>
	<span class="n">lcr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_lcr</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">lcr</span> <span class="o">|</span> <span class="n">UART_LCR_DLAB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_lcr</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">divisor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_dll</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">divisor</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_dlm</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">prediv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_scr</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">lcr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_lcr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_ioc3_port - given a uart port, return the control structure</span>
<span class="cm"> * @the_port: uart port to find</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="nf">get_ioc3_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_driver_data</span> <span class="o">*</span><span class="n">idd</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ioc3_card</span> <span class="o">*</span><span class="n">card_ptr</span> <span class="o">=</span> <span class="n">idd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">Submodule_slot</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">card_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NOT_PROGRESS</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">PORTS_PER_CARD</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">jj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="n">LOGICAL_PORTS</span><span class="p">;</span> <span class="n">jj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">the_port</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">ii</span><span class="p">].</span><span class="n">icp_uart_port</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
				<span class="k">return</span> <span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">ii</span><span class="p">].</span><span class="n">icp_port</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">NOT_PROGRESS</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * port_init - Initialize the sio and ioc3 hardware for a given port</span>
<span class="cm"> *			called per port from attach...</span>
<span class="cm"> * @port: port to initialize</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="kr">inline</span> <span class="nf">port_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">sio_cr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_hooks</span> <span class="o">*</span><span class="n">hooks</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_uartregs</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uart</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reset_loop_counter</span> <span class="o">=</span> <span class="mh">0xfffff</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_driver_data</span> <span class="o">*</span><span class="n">idd</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_idd</span><span class="p">;</span>

	<span class="cm">/* Idle the IOC3 serial interface */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">SSCR_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>

	<span class="cm">/* Wait until any pending bus activity for this port has ceased */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sio_cr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">sio_cr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset_loop_counter</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;IOC3 unable to come out of reset&quot;</span>
				<span class="s">&quot; scr 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sio_cr</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sio_cr</span> <span class="o">&amp;</span> <span class="n">SIO_CR_ARB_DIAG_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(((</span><span class="n">sio_cr</span> <span class="o">&amp;=</span> <span class="n">SIO_CR_ARB_DIAG</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIO_CR_ARB_DIAG_TXA</span><span class="p">)</span>
		<span class="o">||</span> <span class="n">sio_cr</span> <span class="o">==</span> <span class="n">SIO_CR_ARB_DIAG_TXB</span>
		<span class="o">||</span> <span class="n">sio_cr</span> <span class="o">==</span> <span class="n">SIO_CR_ARB_DIAG_RXA</span>
		<span class="o">||</span> <span class="n">sio_cr</span> <span class="o">==</span> <span class="n">SIO_CR_ARB_DIAG_RXB</span><span class="p">));</span>

	<span class="cm">/* Finish reset sequence */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>

	<span class="cm">/* Once RESET is done, reload cached tx_prod and rx_cons values</span>
<span class="cm">	 * and set rings to empty by making prod == cons</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_prod</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">stcir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_prod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">stpir</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_rx_cons</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srpir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_rx_cons</span> <span class="o">|</span> <span class="n">SRCIR_ARM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srcir</span><span class="p">);</span>

	<span class="cm">/* Disable interrupts for this 16550 */</span>
	<span class="n">uart</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="p">;</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_lcr</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_ier</span><span class="p">);</span>

	<span class="cm">/* Set the default baud */</span>
	<span class="n">set_baud</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_baud</span><span class="p">);</span>

	<span class="cm">/* Set line control to 8 bits no parity */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">UART_LCR_WLEN8</span> <span class="o">|</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_lcr</span><span class="p">);</span>
	<span class="cm">/* UART_LCR_STOP == 1 stop */</span>

	<span class="cm">/* Enable the FIFOs */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">UART_FCR_ENABLE_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_fcr</span><span class="p">);</span>
	<span class="cm">/* then reset 16550 FIFOs */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">UART_FCR_ENABLE_FIFO</span> <span class="o">|</span> <span class="n">UART_FCR_CLEAR_RCVR</span> <span class="o">|</span> <span class="n">UART_FCR_CLEAR_XMIT</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_fcr</span><span class="p">);</span>

	<span class="cm">/* Clear modem control register */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">iu_mcr</span><span class="p">);</span>

	<span class="cm">/* Clear deltas in modem status register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>

	<span class="cm">/* Only do this once per port pair */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">hooks_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ring_pci_addr</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">sbbr_l</span><span class="p">,</span> <span class="o">*</span><span class="n">sbbr_h</span><span class="p">;</span>

		<span class="n">sbbr_l</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">sbbr_l</span><span class="p">;</span>
		<span class="n">sbbr_h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">sbbr_h</span><span class="p">;</span>
		<span class="n">ring_pci_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__iomem</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_dma_ringbuf</span><span class="p">;</span>
		<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s: ring_pci_addr 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ring_pci_addr</span><span class="p">));</span>

		<span class="n">writel</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">ring_pci_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">),</span> <span class="n">sbbr_h</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ring_pci_addr</span> <span class="o">|</span> <span class="n">BUF_SIZE_BIT</span><span class="p">,</span> <span class="n">sbbr_l</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the receive timeout value to 10 msec */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">SRTR_HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srtr</span><span class="p">);</span>

	<span class="cm">/* Set rx threshold, enable DMA */</span>
	<span class="cm">/* Set high water mark at 3/4 of full ring */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ENTRIES_PER_RING</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* uart experiences pauses at high baud rate reducing actual</span>
<span class="cm">	 * throughput by 10% or so unless we enable high speed polling</span>
<span class="cm">	 * XXX when this hardware bug is resolved we should revert to</span>
<span class="cm">	 * normal polling speed</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|=</span> <span class="n">SSCR_HIGH_SPD</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>

	<span class="cm">/* Disable and clear all serial related interrupt bits */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_card</span><span class="o">-&gt;</span><span class="n">ic_enable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_clear</span><span class="p">;</span>
	<span class="n">ioc3_disable</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_clear</span><span class="p">);</span>
	<span class="n">ioc3_ack</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_clear</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * enable_intrs - enable interrupts</span>
<span class="cm"> * @port: port to enable</span>
<span class="cm"> * @mask: mask to use</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_intrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_card</span><span class="o">-&gt;</span><span class="n">ic_enable</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_card</span><span class="o">-&gt;</span><span class="n">ic_enable</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">ioc3_enable</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_is</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_idd</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * local_open - local open a port</span>
<span class="cm"> * @port: port to open</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">local_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">spiniter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">=</span> <span class="n">INPUT_ENABLE</span><span class="p">;</span>

	<span class="cm">/* Pause the DMA interface if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;</span> <span class="n">SSCR_DMA_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|</span> <span class="n">SSCR_DMA_PAUSE</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="n">SSCR_PAUSE_STATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spiniter</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spiniter</span> <span class="o">&gt;</span> <span class="n">MAXITER</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">NOT_PROGRESS</span><span class="p">();</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Reset the input fifo.  If the uart received chars while the port</span>
<span class="cm">	 * was closed and DMA is not enabled, the uart may have a bunch of</span>
<span class="cm">	 * chars hanging around in its rx fifo which will not be discarded</span>
<span class="cm">	 * by rclr in the upper layer. We must get rid of them here.</span>
<span class="cm">	 */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">UART_FCR_ENABLE_FIFO</span> <span class="o">|</span> <span class="n">UART_FCR_CLEAR_RCVR</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="o">-&gt;</span><span class="n">iu_fcr</span><span class="p">);</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">UART_LCR_WLEN8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="o">-&gt;</span><span class="n">iu_lcr</span><span class="p">);</span>
	<span class="cm">/* UART_LCR_STOP == 1 stop */</span>

	<span class="cm">/* Re-enable DMA, set default threshold to intr whenever there is</span>
<span class="cm">	 * data available.</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR_RX_THRESHOLD</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* default threshold */</span>

	<span class="cm">/* Plug in the new sscr.  This implicitly clears the DMA_PAUSE</span>
<span class="cm">	 * flag if it was set above</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_lowat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_rx_timeout - Set rx timeout and threshold values.</span>
<span class="cm"> * @port: port to use</span>
<span class="cm"> * @timeout: timeout value in ticks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">set_rx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_rx_timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* Timeout is in ticks.  Let&#39;s figure out how many chars we</span>
<span class="cm">	 * can receive at the current baud rate in that interval</span>
<span class="cm">	 * and set the rx threshold to that amount.  There are 4 chars</span>
<span class="cm">	 * per ring entry, so we&#39;ll divide the number of chars that will</span>
<span class="cm">	 * arrive in timeout by 4.</span>
<span class="cm">	 * So .... timeout * baud / 10 / HZ / 4, with HZ = 100.</span>
<span class="cm">	 */</span>
	<span class="n">threshold</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">*</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_baud</span> <span class="o">/</span> <span class="mi">4000</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">threshold</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* otherwise we&#39;ll intr all the time! */</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">SSCR_RX_THRESHOLD</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR_RX_THRESHOLD</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|=</span> <span class="n">threshold</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>

	<span class="cm">/* Now set the rx timeout to the given value</span>
<span class="cm">	 * again timeout * SRTR_HZ / HZ</span>
<span class="cm">	 */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">*</span> <span class="n">SRTR_HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">SRTR_CNT</span><span class="p">)</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">SRTR_CNT</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srtr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * config_port - config the hardware</span>
<span class="cm"> * @port: port to config</span>
<span class="cm"> * @baud: baud rate for the port</span>
<span class="cm"> * @byte_size: data size</span>
<span class="cm"> * @stop_bits: number of stop bits</span>
<span class="cm"> * @parenb: parity enable ?</span>
<span class="cm"> * @parodd: odd parity ?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">config_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
	    <span class="kt">int</span> <span class="n">baud</span><span class="p">,</span> <span class="kt">int</span> <span class="n">byte_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stop_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parenb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parodd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">lcr</span><span class="p">,</span> <span class="n">sizebits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spiniter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s: line %d baud %d byte_size %d stop %d parenb %d &quot;</span>
			<span class="s">&quot;parodd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span>
			<span class="n">baud</span><span class="p">,</span> <span class="n">byte_size</span><span class="p">,</span> <span class="n">stop_bits</span><span class="p">,</span> <span class="n">parenb</span><span class="p">,</span> <span class="n">parodd</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_baud</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">baud</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">byte_size</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">sizebits</span> <span class="o">=</span> <span class="n">UART_LCR_WLEN5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="n">sizebits</span> <span class="o">=</span> <span class="n">UART_LCR_WLEN6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">7</span>:
		<span class="n">sizebits</span> <span class="o">=</span> <span class="n">UART_LCR_WLEN7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8</span>:
		<span class="n">sizebits</span> <span class="o">=</span> <span class="n">UART_LCR_WLEN8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Pause the DMA interface if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;</span> <span class="n">SSCR_DMA_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|</span> <span class="n">SSCR_DMA_PAUSE</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="n">SSCR_PAUSE_STATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spiniter</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spiniter</span> <span class="o">&gt;</span> <span class="n">MAXITER</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Clear relevant fields in lcr */</span>
	<span class="n">lcr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="o">-&gt;</span><span class="n">iu_lcr</span><span class="p">);</span>
	<span class="n">lcr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LCR_MASK_BITS_CHAR</span> <span class="o">|</span> <span class="n">UART_LCR_EPAR</span> <span class="o">|</span>
		 <span class="n">UART_LCR_PARITY</span> <span class="o">|</span> <span class="n">LCR_MASK_STOP_BITS</span><span class="p">);</span>

	<span class="cm">/* Set byte size in lcr */</span>
	<span class="n">lcr</span> <span class="o">|=</span> <span class="n">sizebits</span><span class="p">;</span>

	<span class="cm">/* Set parity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parenb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_PARITY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parodd</span><span class="p">)</span>
			<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_EPAR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set stop bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stop_bits</span><span class="p">)</span>
		<span class="n">lcr</span> <span class="o">|=</span> <span class="n">UART_LCR_STOP</span> <span class="cm">/* 2 stop bits */</span> <span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="n">lcr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="o">-&gt;</span><span class="n">iu_lcr</span><span class="p">);</span>

	<span class="cm">/* Re-enable the DMA interface if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;</span> <span class="n">SSCR_DMA_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_baud</span> <span class="o">=</span> <span class="n">baud</span><span class="p">;</span>

	<span class="cm">/* When we get within this number of ring entries of filling the</span>
<span class="cm">	 * entire ring on tx, place an EXPLICIT intr to generate a lowat</span>
<span class="cm">	 * notification when output has drained.</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_lowat</span> <span class="o">=</span> <span class="p">(</span><span class="n">TX_LOWAT_CHARS</span><span class="p">(</span><span class="n">baud</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_lowat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_lowat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">set_rx_timeout</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_write - Write bytes to the port.  Returns the number of bytes</span>
<span class="cm"> *			actually written. Called from transmit_chars</span>
<span class="cm"> * @port: port to use</span>
<span class="cm"> * @buf: the stuff to write</span>
<span class="cm"> * @len: how many bytes in &#39;buf&#39;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prod_ptr</span><span class="p">,</span> <span class="n">cons_ptr</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring</span> <span class="o">*</span><span class="n">outring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_hooks</span> <span class="o">*</span><span class="n">hooks</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">prod_ptr</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_prod</span><span class="p">;</span>
	<span class="n">cons_ptr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">stcir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>
	<span class="n">outring</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_outring</span><span class="p">;</span>

	<span class="cm">/* Maintain a 1-entry red-zone.  The ring buffer is full when</span>
<span class="cm">	 * (cons - prod) % ring_size is 1.  Rather than do this subtraction</span>
<span class="cm">	 * in the body of the loop, I&#39;ll do it now.</span>
<span class="cm">	 */</span>
	<span class="n">cons_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">cons_ptr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_entry</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>

	<span class="cm">/* Stuff the bytes into the output */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">prod_ptr</span> <span class="o">!=</span> <span class="n">cons_ptr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">xx</span><span class="p">;</span>

		<span class="cm">/* Get 4 bytes (one ring entry) at a time */</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ring_entry</span> <span class="o">*</span><span class="p">)((</span><span class="n">caddr_t</span><span class="p">)</span> <span class="n">outring</span> <span class="o">+</span> <span class="n">prod_ptr</span><span class="p">);</span>

		<span class="cm">/* Invalidate all entries */</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_allsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Copy in some bytes */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_data</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_sc</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="n">TXCB_VALID</span><span class="p">;</span>
			<span class="n">len</span><span class="o">--</span><span class="p">;</span>
			<span class="n">total</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we are within some small threshold of filling up the</span>
<span class="cm">		 * entire ring buffer, we must place an EXPLICIT intr here</span>
<span class="cm">		 * to generate a lowat interrupt in case we subsequently</span>
<span class="cm">		 * really do fill up the ring and the caller goes to sleep.</span>
<span class="cm">		 * No need to place more than one though.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;</span> <span class="n">LOWAT_WRITTEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">cons_ptr</span> <span class="o">-</span> <span class="n">prod_ptr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">)</span>
		    <span class="o">&lt;=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_lowat</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">|=</span> <span class="n">LOWAT_WRITTEN</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">TXCB_INT_WHEN_DONE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Go on to next entry */</span>
		<span class="n">prod_ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_entry</span><span class="p">);</span>
		<span class="n">prod_ptr</span> <span class="o">&amp;=</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we sent something, start DMA if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;</span> <span class="n">SSCR_DMA_EN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|=</span> <span class="n">SSCR_DMA_EN</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Store the new producer pointer.  If tx is disabled, we stuff the</span>
<span class="cm">	 * data into the ring buffer, but we don&#39;t actually start tx.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uart_tx_stopped</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">prod_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">stpir</span><span class="p">);</span>

		<span class="cm">/* If we are now transmitting, enable tx_mt interrupt so we</span>
<span class="cm">		 * can disable DMA if necessary when the tx finishes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">enable_intrs</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_mt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_tx_prod</span> <span class="o">=</span> <span class="n">prod_ptr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * disable_intrs - disable interrupts</span>
<span class="cm"> * @port: port to enable</span>
<span class="cm"> * @mask: mask to use</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">disable_intrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_card</span><span class="o">-&gt;</span><span class="n">ic_enable</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ioc3_disable</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_is</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_idd</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_card</span><span class="o">-&gt;</span><span class="n">ic_enable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_notification - Modify event notification</span>
<span class="cm"> * @port: port to use</span>
<span class="cm"> * @mask: events mask</span>
<span class="cm"> * @set_on: set ?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_notification</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">port_hooks</span> <span class="o">*</span><span class="n">hooks</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intrbits</span><span class="p">,</span> <span class="n">sscrbits</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">intrbits</span> <span class="o">=</span> <span class="n">sscrbits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">N_DATA_READY</span><span class="p">)</span>
		<span class="n">intrbits</span> <span class="o">|=</span> <span class="p">(</span><span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_timer</span> <span class="o">|</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_high</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">N_OUTPUT_LOWAT</span><span class="p">)</span>
		<span class="n">intrbits</span> <span class="o">|=</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_explicit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">N_DDCD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">intrbits</span> <span class="o">|=</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_delta_dcd</span><span class="p">;</span>
		<span class="n">sscrbits</span> <span class="o">|=</span> <span class="n">SSCR_RX_RING_DCD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">N_DCTS</span><span class="p">)</span>
		<span class="n">intrbits</span> <span class="o">|=</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_delta_cts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enable_intrs</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">intrbits</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|=</span> <span class="n">sscrbits</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">disable_intrs</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">intrbits</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">sscrbits</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We require DMA if either DATA_READY or DDCD notification is</span>
<span class="cm">	 * currently requested. If neither of these is requested and</span>
<span class="cm">	 * there is currently no tx in progress, DMA may be disabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N_DATA_READY</span> <span class="o">|</span> <span class="n">N_DDCD</span><span class="p">))</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|=</span> <span class="n">SSCR_DMA_EN</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_card</span><span class="o">-&gt;</span><span class="n">ic_enable</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_mt</span><span class="p">))</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR_DMA_EN</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_mcr - set the master control reg</span>
<span class="cm"> * @the_port: port to use</span>
<span class="cm"> * @mask1: mcr mask</span>
<span class="cm"> * @mask2: shadow mask</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">set_mcr</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">mask1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">shadow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spiniter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">mcr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Pause the DMA interface if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;</span> <span class="n">SSCR_DMA_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|</span> <span class="n">SSCR_DMA_PAUSE</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="n">SSCR_PAUSE_STATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spiniter</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spiniter</span> <span class="o">&gt;</span> <span class="n">MAXITER</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">shadow</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>
	<span class="n">mcr</span> <span class="o">=</span> <span class="p">(</span><span class="n">shadow</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>

	<span class="cm">/* Set new value */</span>
	<span class="n">mcr</span> <span class="o">|=</span> <span class="n">mask1</span><span class="p">;</span>
	<span class="n">shadow</span> <span class="o">|=</span> <span class="n">mask2</span><span class="p">;</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">mcr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="o">-&gt;</span><span class="n">iu_mcr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">shadow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>

	<span class="cm">/* Re-enable the DMA interface if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;</span> <span class="n">SSCR_DMA_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ioc3_set_proto - set the protocol for the port</span>
<span class="cm"> * @port: port to use</span>
<span class="cm"> * @proto: protocol to use</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioc3_set_proto</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">port_hooks</span> <span class="o">*</span><span class="n">hooks</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">proto</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">PROTO_RS232</span>:
		<span class="cm">/* Clear the appropriate GIO pin */</span>
		<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s: rs232</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">gppr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="o">+</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">rs422_select_pin</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PROTO_RS422</span>:
		<span class="cm">/* Set the appropriate GIO pin */</span>
		<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s: rs422</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">gppr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="o">+</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">rs422_select_pin</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * transmit_chars - upper level write, called with the_port-&gt;lock</span>
<span class="cm"> * @the_port: port to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">transmit_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">xmit_count</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">the_port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">tty</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">)</span> <span class="o">||</span> <span class="n">uart_tx_stopped</span><span class="p">(</span><span class="n">the_port</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Nothing to do or hw stopped */</span>
		<span class="n">set_notification</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">N_ALL_OUTPUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">tail</span><span class="p">];</span>

	<span class="cm">/* write out all the data or until the end of the buffer */</span>
	<span class="n">xmit_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">&lt;</span> <span class="n">tail</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="n">tail</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">head</span> <span class="o">-</span> <span class="n">tail</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">do_write</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">xmit_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* booking */</span>
			<span class="n">xmit_count</span> <span class="o">-=</span> <span class="n">result</span><span class="p">;</span>
			<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span> <span class="o">+=</span> <span class="n">result</span><span class="p">;</span>
			<span class="cm">/* advance the pointers */</span>
			<span class="n">tail</span> <span class="o">+=</span> <span class="n">result</span><span class="p">;</span>
			<span class="n">tail</span> <span class="o">&amp;=</span> <span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">tail</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_chars_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">WAKEUP_CHARS</span><span class="p">)</span>
		<span class="n">uart_write_wakeup</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_notification</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">N_OUTPUT_LOWAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">set_notification</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">N_OUTPUT_LOWAT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ioc3_change_speed - change the speed of the port</span>
<span class="cm"> * @the_port: port to change</span>
<span class="cm"> * @new_termios: new termios settings</span>
<span class="cm"> * @old_termios: old termios settings</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ioc3_change_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">new_termios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old_termios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cflag</span><span class="p">,</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">baud</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_parity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_parity_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_data</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>

	<span class="n">cflag</span> <span class="o">=</span> <span class="n">new_termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span><span class="p">;</span>
	<span class="n">iflag</span> <span class="o">=</span> <span class="n">new_termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CSIZE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CS5</span>:
		<span class="n">new_data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS6</span>:
		<span class="n">new_data</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS7</span>:
		<span class="n">new_data</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS8</span>:
		<span class="n">new_data</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* cuz we always need a default ... */</span>
		<span class="n">new_data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CSTOPB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_stop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">PARENB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_parity_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">PARODD</span><span class="p">)</span>
			<span class="n">new_parity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">baud</span> <span class="o">=</span> <span class="n">uart_get_baud_rate</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span> <span class="n">new_termios</span><span class="p">,</span> <span class="n">old_termios</span><span class="p">,</span>
				  <span class="n">MIN_BAUD_SUPPORTED</span><span class="p">,</span> <span class="n">MAX_BAUD_SUPPORTED</span><span class="p">);</span>
	<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s: returned baud %d for line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span>
				<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">fifosize</span><span class="p">)</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">fifosize</span> <span class="o">=</span> <span class="n">FIFO_SIZE</span><span class="p">;</span>
	<span class="n">uart_update_timeout</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span> <span class="n">cflag</span><span class="p">,</span> <span class="n">baud</span><span class="p">);</span>

	<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">=</span> <span class="n">N_ALL_INPUT</span><span class="p">;</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">low_latency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iflag</span> <span class="o">&amp;</span> <span class="n">IGNPAR</span><span class="p">)</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">N_PARITY_ERROR</span>
						  <span class="o">|</span> <span class="n">N_FRAMING_ERROR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iflag</span> <span class="o">&amp;</span> <span class="n">IGNBRK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">N_BREAK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iflag</span> <span class="o">&amp;</span> <span class="n">IGNPAR</span><span class="p">)</span>
			<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">N_OVERRUN_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CREAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* ignore everything */</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">N_DATA_READY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable hardware flow control */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|=</span> <span class="n">SSCR_HFC_EN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* disable hardware flow control */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR_HFC_EN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>

	<span class="cm">/* Set the configuration and proper notification call */</span>
	<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s : port 0x%p line %d cflag 0%o &quot;</span>
		       <span class="s">&quot;config_port(baud %d data %d stop %d penable %d &quot;</span>
			<span class="s">&quot; parity %d), notification 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="p">,</span> <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span> <span class="n">cflag</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span>
		       <span class="n">new_data</span><span class="p">,</span> <span class="n">new_stop</span><span class="p">,</span> <span class="n">new_parity_enable</span><span class="p">,</span> <span class="n">new_parity</span><span class="p">,</span>
		       <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">config_port</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span>	<span class="cm">/* baud */</span>
			 <span class="n">new_data</span><span class="p">,</span>	<span class="cm">/* byte size */</span>
			 <span class="n">new_stop</span><span class="p">,</span>	<span class="cm">/* stop bits */</span>
			 <span class="n">new_parity_enable</span><span class="p">,</span>	<span class="cm">/* set parity */</span>
			 <span class="n">new_parity</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* parity 1==odd */</span>
		<span class="n">set_notification</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_startup_local - Start up the serial port - returns &gt;= 0 if no errors</span>
<span class="cm"> * @the_port: Port to operate on</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ic3_startup_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">the_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NOT_PROGRESS</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NOT_PROGRESS</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">local_open</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* set the protocol */</span>
	<span class="n">ioc3_set_proto</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">IS_RS232</span><span class="p">(</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">)</span> <span class="o">?</span> <span class="n">PROTO_RS232</span> <span class="o">:</span>
							<span class="n">PROTO_RS422</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ioc3_cb_output_lowat - called when the output low water mark is hit</span>
<span class="cm"> * @port: port to output</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ioc3_cb_output_lowat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pflags</span><span class="p">;</span>

	<span class="cm">/* the_port-&gt;lock is set on the call here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">pflags</span><span class="p">);</span>
		<span class="n">transmit_chars</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">pflags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ioc3_cb_post_ncs - called for some basic errors</span>
<span class="cm"> * @port: port to use</span>
<span class="cm"> * @ncs: event</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ioc3_cb_post_ncs</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ncs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_icount</span> <span class="o">*</span><span class="n">icount</span><span class="p">;</span>

	<span class="n">icount</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ncs</span> <span class="o">&amp;</span> <span class="n">NCS_BREAK</span><span class="p">)</span>
		<span class="n">icount</span><span class="o">-&gt;</span><span class="n">brk</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ncs</span> <span class="o">&amp;</span> <span class="n">NCS_FRAMING</span><span class="p">)</span>
		<span class="n">icount</span><span class="o">-&gt;</span><span class="n">frame</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ncs</span> <span class="o">&amp;</span> <span class="n">NCS_OVERRUN</span><span class="p">)</span>
		<span class="n">icount</span><span class="o">-&gt;</span><span class="n">overrun</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ncs</span> <span class="o">&amp;</span> <span class="n">NCS_PARITY</span><span class="p">)</span>
		<span class="n">icount</span><span class="o">-&gt;</span><span class="n">parity</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_read - Read in bytes from the port.  Return the number of bytes</span>
<span class="cm"> *			actually read.</span>
<span class="cm"> * @the_port: port to use</span>
<span class="cm"> * @buf: place to put the stuff we read</span>
<span class="cm"> * @len: how big &#39;buf&#39; is</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">prod_ptr</span><span class="p">,</span> <span class="n">cons_ptr</span><span class="p">,</span> <span class="n">total</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ring</span> <span class="o">*</span><span class="n">inring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ring_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">port_hooks</span> <span class="o">*</span><span class="n">hooks</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">byte_num</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop_counter</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">);</span>

	<span class="cm">/* There is a nasty timing issue in the IOC3. When the rx_timer</span>
<span class="cm">	 * expires or the rx_high condition arises, we take an interrupt.</span>
<span class="cm">	 * At some point while servicing the interrupt, we read bytes from</span>
<span class="cm">	 * the ring buffer and re-arm the rx_timer.  However the rx_timer is</span>
<span class="cm">	 * not started until the first byte is received *after* it is armed,</span>
<span class="cm">	 * and any bytes pending in the rx construction buffers are not drained</span>
<span class="cm">	 * to memory until either there are 4 bytes available or the rx_timer</span>
<span class="cm">	 * expires.  This leads to a potential situation where data is left</span>
<span class="cm">	 * in the construction buffers forever - 1 to 3 bytes were received</span>
<span class="cm">	 * after the interrupt was generated but before the rx_timer was</span>
<span class="cm">	 * re-armed. At that point as long as no subsequent bytes are received</span>
<span class="cm">	 * the timer will never be started and the bytes will remain in the</span>
<span class="cm">	 * construction buffer forever.  The solution is to execute a DRAIN</span>
<span class="cm">	 * command after rearming the timer.  This way any bytes received before</span>
<span class="cm">	 * the DRAIN will be drained to memory, and any bytes received after</span>
<span class="cm">	 * the DRAIN will start the TIMER and be drained when it expires.</span>
<span class="cm">	 * Luckily, this only needs to be done when the DMA buffer is empty</span>
<span class="cm">	 * since there is no requirement that this function return all</span>
<span class="cm">	 * available data as long as it returns some.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Re-arm the timer */</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_rx_cons</span> <span class="o">|</span> <span class="n">SRCIR_ARM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srcir</span><span class="p">);</span>

	<span class="n">prod_ptr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srpir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>
	<span class="n">cons_ptr</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_rx_cons</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prod_ptr</span> <span class="o">==</span> <span class="n">cons_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">reset_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Input buffer appears empty, do a flush. */</span>

		<span class="cm">/* DMA must be enabled for this to work. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;</span> <span class="n">SSCR_DMA_EN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|=</span> <span class="n">SSCR_DMA_EN</span><span class="p">;</span>
			<span class="n">reset_dma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Potential race condition: we must reload the srpir after</span>
<span class="cm">		 * issuing the drain command, otherwise we could think the rx</span>
<span class="cm">		 * buffer is empty, then take a very long interrupt, and when</span>
<span class="cm">		 * we come back it&#39;s full and we wait forever for the drain to</span>
<span class="cm">		 * complete.</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">|</span> <span class="n">SSCR_RX_DRAIN</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
		<span class="n">prod_ptr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srpir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>

		<span class="cm">/* We must not wait for the DRAIN to complete unless there are</span>
<span class="cm">		 * at least 8 bytes (2 ring entries) available to receive the</span>
<span class="cm">		 * data otherwise the DRAIN will never complete and we&#39;ll</span>
<span class="cm">		 * deadlock here.</span>
<span class="cm">		 * In fact, to make things easier, I&#39;ll just ignore the flush if</span>
<span class="cm">		 * there is any data at all now available.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prod_ptr</span> <span class="o">==</span> <span class="n">cons_ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">loop_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">)</span> <span class="o">&amp;</span>
			       <span class="n">SSCR_RX_DRAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">loop_counter</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">loop_counter</span> <span class="o">&gt;</span> <span class="n">MAXITER</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* SIGH. We have to reload the prod_ptr *again* since</span>
<span class="cm">			 * the drain may have caused it to change</span>
<span class="cm">			 */</span>
			<span class="n">prod_ptr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srpir</span><span class="p">)</span>
			    <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reset_dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR_DMA_EN</span><span class="p">;</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">inring</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_inring</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">READ_ABORTED</span><span class="p">;</span>

	<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loop_counter</span> <span class="o">=</span> <span class="mh">0xfffff</span><span class="p">;</span>	<span class="cm">/* to avoid hangs */</span>

	<span class="cm">/* Grab bytes from the hardware */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">prod_ptr</span> <span class="o">!=</span> <span class="n">cons_ptr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ring_entry</span> <span class="o">*</span><span class="p">)((</span><span class="n">caddr_t</span><span class="p">)</span> <span class="n">inring</span> <span class="o">+</span> <span class="n">cons_ptr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">loop_counter</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;IOC3 serial: &quot;</span>
			       <span class="s">&quot;possible hang condition/&quot;</span>
			       <span class="s">&quot;port stuck on read (line %d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* According to the producer pointer, this ring entry</span>
<span class="cm">		 * must contain some data.  But if the PIO happened faster</span>
<span class="cm">		 * than the DMA, the data may not be available yet, so let&#39;s</span>
<span class="cm">		 * wait until it arrives.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_allsc</span> <span class="o">&amp;</span> <span class="n">RING_ANY_VALID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Indicate the read is aborted so we don&#39;t disable</span>
<span class="cm">			 * the interrupt thinking that the consumer is</span>
<span class="cm">			 * congested.</span>
<span class="cm">			 */</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">|=</span> <span class="n">READ_ABORTED</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Load the bytes/status out of the ring entry */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">byte_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">byte_num</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">byte_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_sc</span><span class="p">[</span><span class="n">byte_num</span><span class="p">]);</span>

			<span class="cm">/* Check for change in modem state or overrun */</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_MODEM_VALID</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_DDCD</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Notify upper layer if DCD dropped */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;</span> <span class="n">DCD_ON</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_DCD</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* If we have already copied some data,</span>
<span class="cm">					 * return it.  We&#39;ll pick up the carrier</span>
<span class="cm">					 * drop on the next pass.  That way we</span>
<span class="cm">					 * don&#39;t throw away the data that has</span>
<span class="cm">					 * already been copied back to</span>
<span class="cm">					 * the caller&#39;s buffer.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCD_ON</span><span class="p">;</span>

					<span class="cm">/* Turn off this notification so the</span>
<span class="cm">					 * carrier drop protocol won&#39;t see it</span>
<span class="cm">					 * again when it does a read.</span>
<span class="cm">					 */</span>
					<span class="o">*</span><span class="n">sc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RXSB_MODEM_VALID</span><span class="p">;</span>

					<span class="cm">/* To keep things consistent, we need</span>
<span class="cm">					 * to update the consumer pointer so</span>
<span class="cm">					 * the next reader won&#39;t come in and</span>
<span class="cm">					 * try to read the same ring entries</span>
<span class="cm">					 * again. This must be done here before</span>
<span class="cm">					 * the dcd change.</span>
<span class="cm">					 */</span>

					<span class="k">if</span> <span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_allsc</span> <span class="o">&amp;</span> <span class="n">RING_ANY_VALID</span><span class="p">)</span>
					    <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">cons_ptr</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span>
						    <span class="p">(</span><span class="k">struct</span> <span class="n">ring_entry</span><span class="p">);</span>
						<span class="n">cons_ptr</span> <span class="o">&amp;=</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">writel</span><span class="p">(</span><span class="n">cons_ptr</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srcir</span><span class="p">);</span>
					<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_rx_cons</span> <span class="o">=</span> <span class="n">cons_ptr</span><span class="p">;</span>

					<span class="cm">/* Notify upper layer of carrier drop */</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_DDCD</span><span class="p">)</span>
					    <span class="o">&amp;&amp;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">uart_handle_dcd_change</span>
							<span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
						<span class="n">wake_up_interruptible</span>
						    <span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span>
						     <span class="n">port</span><span class="p">.</span><span class="n">delta_msr_wait</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="cm">/* If we had any data to return, we</span>
<span class="cm">					 * would have returned it above.</span>
<span class="cm">					 */</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_MODEM_VALID</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Notify that an input overrun occurred */</span>
				<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_OVERRUN</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_OVERRUN_ERROR</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ioc3_cb_post_ncs</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span> <span class="n">NCS_OVERRUN</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/* Don&#39;t look at this byte again */</span>
				<span class="o">*</span><span class="n">sc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RXSB_MODEM_VALID</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Check for valid data or RX errors */</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_DATA_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">((</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RXSB_PAR_ERR</span>
				     <span class="o">|</span> <span class="n">RXSB_FRAME_ERR</span> <span class="o">|</span> <span class="n">RXSB_BREAK</span><span class="p">))</span>
			     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N_PARITY_ERROR</span>
						    <span class="o">|</span> <span class="n">N_FRAMING_ERROR</span>
						    <span class="o">|</span> <span class="n">N_BREAK</span><span class="p">))))</span> <span class="p">{</span>
				<span class="cm">/* There is an error condition on the next byte.</span>
<span class="cm">				 * If we have already transferred some bytes,</span>
<span class="cm">				 * we&#39;ll stop here. Otherwise if this is the</span>
<span class="cm">				 * first byte to be read, we&#39;ll just transfer</span>
<span class="cm">				 * it alone after notifying the</span>
<span class="cm">				 * upper layer of its status.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_PAR_ERR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					    <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span>
					     <span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_PARITY_ERROR</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">ioc3_cb_post_ncs</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span>
								 <span class="n">NCS_PARITY</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_FRAME_ERR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					    <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span>
					     <span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_FRAMING_ERROR</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">ioc3_cb_post_ncs</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span>
								 <span class="n">NCS_FRAMING</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_BREAK</span><span class="p">)</span>
					    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_BREAK</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">ioc3_cb_post_ncs</span>
						    <span class="p">(</span><span class="n">the_port</span><span class="p">,</span> <span class="n">NCS_BREAK</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">sc</span> <span class="o">&amp;</span> <span class="n">RXSB_DATA_VALID</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">sc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RXSB_DATA_VALID</span><span class="p">;</span>
				<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_data</span><span class="p">[</span><span class="n">byte_num</span><span class="p">];</span>
				<span class="n">buf</span><span class="o">++</span><span class="p">;</span>
				<span class="n">len</span><span class="o">--</span><span class="p">;</span>
				<span class="n">total</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* If we used up this entry entirely, go on to the next one,</span>
<span class="cm">		 * otherwise we must have run out of buffer space, so</span>
<span class="cm">		 * leave the consumer pointer here for the next read in case</span>
<span class="cm">		 * there are still unread bytes in this entry.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ring_allsc</span> <span class="o">&amp;</span> <span class="n">RING_ANY_VALID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cons_ptr</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ring_entry</span><span class="p">);</span>
			<span class="n">cons_ptr</span> <span class="o">&amp;=</span> <span class="n">PROD_CONS_MASK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Update consumer pointer and re-arm rx timer interrupt */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cons_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">srcir</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_rx_cons</span> <span class="o">=</span> <span class="n">cons_ptr</span><span class="p">;</span>

	<span class="cm">/* If we have now dipped below the rx high water mark and we have</span>
<span class="cm">	 * rx_high interrupt turned off, we can now turn it back on again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;</span> <span class="n">INPUT_HIGH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(((</span><span class="n">prod_ptr</span> <span class="o">-</span> <span class="n">cons_ptr</span><span class="p">)</span>
					       <span class="o">&amp;</span> <span class="n">PROD_CONS_MASK</span><span class="p">)</span> <span class="o">&lt;</span>
					      <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span>
						<span class="n">ip_sscr</span> <span class="o">&amp;</span>
						<span class="n">SSCR_RX_THRESHOLD</span><span class="p">)</span>
					       <span class="o">&lt;&lt;</span> <span class="n">PROD_CONS_PTR_OFF</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INPUT_HIGH</span><span class="p">;</span>
		<span class="n">enable_intrs</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_high</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * receive_chars - upper level read.</span>
<span class="cm"> * @the_port: port to read from</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">receive_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">[</span><span class="n">MAX_CHARS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">read_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">read_room</span><span class="p">,</span> <span class="n">flip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pflags</span><span class="p">;</span>

	<span class="cm">/* Make sure all the pointers are &quot;good&quot; ones */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;</span> <span class="n">INPUT_ENABLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">pflags</span><span class="p">);</span>
	<span class="n">tty</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">read_count</span> <span class="o">=</span> <span class="n">do_read</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">MAX_CHARS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">read_room</span> <span class="o">=</span> <span class="n">tty_insert_flip_string</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">read_count</span><span class="p">);</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rx</span> <span class="o">+=</span> <span class="n">read_count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">pflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flip</span><span class="p">)</span>
		<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">read_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ioc3uart_intr_one - lowest level (per port) interrupt handler.</span>
<span class="cm"> * @is : submodule</span>
<span class="cm"> * @idd: driver data</span>
<span class="cm"> * @pending: interrupts to handle</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="kr">inline</span>
<span class="nf">ioc3uart_intr_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_submodule</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ioc3_driver_data</span> <span class="o">*</span><span class="n">idd</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pending</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port_num</span> <span class="o">=</span> <span class="n">GET_PORT_FROM_SIO_IR</span><span class="p">(</span><span class="n">pending</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">port_hooks</span> <span class="o">*</span><span class="n">hooks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_high_rd_aborted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_card</span> <span class="o">*</span><span class="n">card_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sio_ir</span><span class="p">;</span>

	<span class="n">card_ptr</span> <span class="o">=</span> <span class="n">idd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">port_num</span><span class="p">].</span><span class="n">icp_port</span><span class="p">;</span>
	<span class="n">hooks</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span><span class="p">;</span>

	<span class="cm">/* Possible race condition here: The tx_mt interrupt bit may be</span>
<span class="cm">	 * cleared without the intervention of the interrupt handler,</span>
<span class="cm">	 * e.g. by a write.  If the top level interrupt handler reads a</span>
<span class="cm">	 * tx_mt, then some other processor does a write, starting up</span>
<span class="cm">	 * output, then we come in here, see the tx_mt and stop DMA, the</span>
<span class="cm">	 * output started by the other processor will hang.  Thus we can</span>
<span class="cm">	 * only rely on tx_mt being legitimate if it is read while the</span>
<span class="cm">	 * port lock is held.  Therefore this bit must be ignored in the</span>
<span class="cm">	 * passed in interrupt mask which was read by the top level</span>
<span class="cm">	 * interrupt handler since the port lock was not held at the time</span>
<span class="cm">	 * it was read.  We can only rely on this bit being accurate if it</span>
<span class="cm">	 * is read while the port lock is held.  So we&#39;ll clear it for now,</span>
<span class="cm">	 * and reload it later once we have the port lock.</span>
<span class="cm">	 */</span>

	<span class="n">sio_ir</span> <span class="o">=</span> <span class="n">pending</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_mt</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">loop_counter</span> <span class="o">=</span> <span class="n">MAXITER</span><span class="p">;</span>	<span class="cm">/* to avoid hangs */</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">shadow</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">loop_counter</span><span class="o">--</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;IOC3 serial: &quot;</span>
			       <span class="s">&quot;possible hang condition/&quot;</span>
			       <span class="s">&quot;port stuck on interrupt (line %d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">((</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Handle a DCD change */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_delta_dcd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ioc3_ack</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_delta_dcd</span><span class="p">);</span>
			<span class="n">shadow</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_DDCD</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">shadow</span> <span class="o">&amp;</span> <span class="n">SHADOW_DCD</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">the_port</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">;</span>
				<span class="n">uart_handle_dcd_change</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span>
						<span class="n">shadow</span> <span class="o">&amp;</span> <span class="n">SHADOW_DCD</span><span class="p">);</span>
				<span class="n">wake_up_interruptible</span>
				    <span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">delta_msr_wait</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_DDCD</span><span class="p">)</span>
				   <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">shadow</span> <span class="o">&amp;</span> <span class="n">SHADOW_DCD</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Flag delta DCD/no DCD */</span>
				<span class="n">uart_handle_dcd_change</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">,</span>
						<span class="n">shadow</span> <span class="o">&amp;</span> <span class="n">SHADOW_DCD</span><span class="p">);</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">|=</span> <span class="n">DCD_ON</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Handle a CTS change */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_delta_cts</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ioc3_ack</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_delta_cts</span><span class="p">);</span>
			<span class="n">shadow</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_DCTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">the_port</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">;</span>
				<span class="n">uart_handle_cts_change</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span> <span class="n">shadow</span>
						<span class="o">&amp;</span> <span class="n">SHADOW_CTS</span><span class="p">);</span>
				<span class="n">wake_up_interruptible</span>
				    <span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">delta_msr_wait</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* rx timeout interrupt.  Must be some data available.  Put this</span>
<span class="cm">		 * before the check for rx_high since servicing this condition</span>
<span class="cm">		 * may cause that condition to clear.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_timer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ioc3_ack</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_timer</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_DATA_READY</span><span class="p">)</span>
						<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">receive_chars</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* rx high interrupt. Must be after rx_timer.  */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_high</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Data available, notify upper layer */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_DATA_READY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">receive_chars</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* We can&#39;t ACK this interrupt.  If receive_chars didn&#39;t</span>
<span class="cm">			 * cause the condition to clear, we&#39;ll have to disable</span>
<span class="cm">			 * the interrupt until the data is drained.</span>
<span class="cm">			 * If the read was aborted, don&#39;t disable the interrupt</span>
<span class="cm">			 * as this may cause us to hang indefinitely.  An</span>
<span class="cm">			 * aborted read generally means that this interrupt</span>
<span class="cm">			 * hasn&#39;t been delivered to the cpu yet anyway, even</span>
<span class="cm">			 * though we see it as asserted when we read the sio_ir.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sio_ir</span> <span class="o">=</span> <span class="n">PENDING</span><span class="p">(</span><span class="n">card_ptr</span><span class="p">,</span> <span class="n">idd</span><span class="p">))</span>
					<span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_high</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;</span> <span class="n">READ_ABORTED</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">rx_high_rd_aborted</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_enable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_high</span><span class="p">;</span>
					<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">|=</span> <span class="n">INPUT_HIGH</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* We got a low water interrupt: notify upper layer to</span>
<span class="cm">		 * send more data.  Must come before tx_mt since servicing</span>
<span class="cm">		 * this condition may cause that condition to clear.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_explicit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOWAT_WRITTEN</span><span class="p">;</span>
			<span class="n">ioc3_ack</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_explicit</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_OUTPUT_LOWAT</span><span class="p">)</span>
				<span class="n">ioc3_cb_output_lowat</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Handle tx_mt.  Must come after tx_explicit.  */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_mt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we are expecting a lowat notification</span>
<span class="cm">			 * and we get to this point it probably means that for</span>
<span class="cm">			 * some reason the tx_explicit didn&#39;t work as expected</span>
<span class="cm">			 * (that can legitimately happen if the output buffer is</span>
<span class="cm">			 * filled up in just the right way).</span>
<span class="cm">			 * So send the notification now.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span> <span class="o">&amp;</span> <span class="n">N_OUTPUT_LOWAT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ioc3_cb_output_lowat</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

				<span class="cm">/* We need to reload the sio_ir since the lowat</span>
<span class="cm">				 * call may have caused another write to occur,</span>
<span class="cm">				 * clearing the tx_mt condition.</span>
<span class="cm">				 */</span>
				<span class="n">sio_ir</span> <span class="o">=</span> <span class="n">PENDING</span><span class="p">(</span><span class="n">card_ptr</span><span class="p">,</span> <span class="n">idd</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* If the tx_mt condition still persists even after the</span>
<span class="cm">			 * lowat call, we&#39;ve got some work to do.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_mt</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* If we are not currently expecting DMA input,</span>
<span class="cm">				 * and the transmitter has just gone idle,</span>
<span class="cm">				 * there is no longer any reason for DMA, so</span>
<span class="cm">				 * disable it.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_notify</span>
				      <span class="o">&amp;</span> <span class="p">(</span><span class="n">N_DATA_READY</span> <span class="o">|</span> <span class="n">N_DDCD</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span>
						 <span class="o">&amp;</span> <span class="n">SSCR_DMA_EN</span><span class="p">));</span>
					<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SSCR_DMA_EN</span><span class="p">;</span>
					<span class="n">writel</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_sscr</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">sscr</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="cm">/* Prevent infinite tx_mt interrupt */</span>
				<span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_enable</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_mt</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">sio_ir</span> <span class="o">=</span> <span class="n">PENDING</span><span class="p">(</span><span class="n">card_ptr</span><span class="p">,</span> <span class="n">idd</span><span class="p">);</span>

		<span class="cm">/* if the read was aborted and only hooks-&gt;intr_rx_high,</span>
<span class="cm">		 * clear hooks-&gt;intr_rx_high, so we do not loop forever.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_high_rd_aborted</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">==</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_high</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sio_ir</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_rx_high</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sio_ir</span> <span class="o">&amp;</span> <span class="n">hooks</span><span class="o">-&gt;</span><span class="n">intr_all</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ioc3_enable</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_enable</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ioc3uart_intr - field all serial interrupts</span>
<span class="cm"> * @is : submodule</span>
<span class="cm"> * @idd: driver data</span>
<span class="cm"> * @pending: interrupts to handle</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioc3uart_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_submodule</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ioc3_driver_data</span> <span class="o">*</span><span class="n">idd</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pending</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The upper level interrupt handler sends interrupts for both ports</span>
<span class="cm">	 * here. So we need to call for each port with its interrupts.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">SIO_IR_SA</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">ioc3uart_intr_one</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">pending</span> <span class="o">&amp;</span> <span class="n">SIO_IR_SA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">SIO_IR_SB</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">ioc3uart_intr_one</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">,</span> <span class="n">pending</span> <span class="o">&amp;</span> <span class="n">SIO_IR_SB</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_type</span>
<span class="cm"> * @port: Port to operate with (we ignore since we only have one port)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ic3_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_RS232</span><span class="p">(</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">))</span>
		<span class="k">return</span> <span class="s">&quot;SGI IOC3 Serial [rs232]&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="s">&quot;SGI IOC3 Serial [rs422]&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_tx_empty - Is the transmitter empty?</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ic3_tx_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SHADOW_TEMT</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">TIOCSER_TEMT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_stop_tx - stop the transmitter</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ic3_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span>
		<span class="n">set_notification</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">N_OUTPUT_LOWAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_stop_rx - stop the receiver</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ic3_stop_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INPUT_ENABLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * null_void_function</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">null_void_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_shutdown - shut down the port - free irq and disable</span>
<span class="cm"> * @port: port to shut down</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ic3_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">delta_msr_wait</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">port_flags</span><span class="p">);</span>
	<span class="n">set_notification</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">N_ALL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">port_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_set_mctrl - set control lines (dtr, rts, etc)</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> * @mctrl: Lines to set/unset</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ic3_set_mctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mcr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mctrl</span> <span class="o">&amp;</span> <span class="n">TIOCM_RTS</span><span class="p">)</span>
		<span class="n">mcr</span> <span class="o">|=</span> <span class="n">UART_MCR_RTS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mctrl</span> <span class="o">&amp;</span> <span class="n">TIOCM_DTR</span><span class="p">)</span>
		<span class="n">mcr</span> <span class="o">|=</span> <span class="n">UART_MCR_DTR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mctrl</span> <span class="o">&amp;</span> <span class="n">TIOCM_OUT1</span><span class="p">)</span>
		<span class="n">mcr</span> <span class="o">|=</span> <span class="n">UART_MCR_OUT1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mctrl</span> <span class="o">&amp;</span> <span class="n">TIOCM_OUT2</span><span class="p">)</span>
		<span class="n">mcr</span> <span class="o">|=</span> <span class="n">UART_MCR_OUT2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mctrl</span> <span class="o">&amp;</span> <span class="n">TIOCM_LOOP</span><span class="p">)</span>
		<span class="n">mcr</span> <span class="o">|=</span> <span class="n">UART_MCR_LOOP</span><span class="p">;</span>

	<span class="n">set_mcr</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span> <span class="n">mcr</span><span class="p">,</span> <span class="n">SHADOW_DTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_get_mctrl - get control line info</span>
<span class="cm"> * @port: port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ic3_get_mctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">shadow</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shadow</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="o">-&gt;</span><span class="n">shadow</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shadow</span> <span class="o">&amp;</span> <span class="n">SHADOW_DCD</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">TIOCM_CD</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shadow</span> <span class="o">&amp;</span> <span class="n">SHADOW_DR</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">TIOCM_DSR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shadow</span> <span class="o">&amp;</span> <span class="n">SHADOW_CTS</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">TIOCM_CTS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_start_tx - Start transmitter. Called with the_port-&gt;lock</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ic3_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_notification</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">N_OUTPUT_LOWAT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">enable_intrs</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span><span class="o">-&gt;</span><span class="n">intr_tx_mt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_break_ctl - handle breaks</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> * @break_state: Break state</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ic3_break_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">break_state</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_startup - Start up the serial port - always return 0 (We&#39;re always on)</span>
<span class="cm"> * @port: Port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ic3_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_card</span> <span class="o">*</span><span class="n">card_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">the_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NOT_PROGRESS</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">get_ioc3_port</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NOT_PROGRESS</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">card_ptr</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_card</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span> <span class="o">=</span> <span class="n">the_port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">card_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NOT_PROGRESS</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start up the serial port */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">port_flags</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ic3_startup_local</span><span class="p">(</span><span class="n">the_port</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">port_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_set_termios - set termios stuff</span>
<span class="cm"> * @port: port to operate on</span>
<span class="cm"> * @termios: New settings</span>
<span class="cm"> * @termios: Old</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ic3_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old_termios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">port_flags</span><span class="p">);</span>
	<span class="n">ioc3_change_speed</span><span class="p">(</span><span class="n">the_port</span><span class="p">,</span> <span class="n">termios</span><span class="p">,</span> <span class="n">old_termios</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">port_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ic3_request_port - allocate resources for port - no op....</span>
<span class="cm"> * @port: port to operate on</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ic3_request_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Associate the uart functions above - given to serial core */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_ops</span> <span class="n">ioc3_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">tx_empty</span> <span class="o">=</span> <span class="n">ic3_tx_empty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mctrl</span> <span class="o">=</span> <span class="n">ic3_set_mctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_mctrl</span> <span class="o">=</span> <span class="n">ic3_get_mctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_tx</span> <span class="o">=</span> <span class="n">ic3_stop_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_tx</span> <span class="o">=</span> <span class="n">ic3_start_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_rx</span> <span class="o">=</span> <span class="n">ic3_stop_rx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_ms</span> <span class="o">=</span> <span class="n">null_void_function</span><span class="p">,</span>
	<span class="p">.</span><span class="n">break_ctl</span> <span class="o">=</span> <span class="n">ic3_break_ctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">startup</span> <span class="o">=</span> <span class="n">ic3_startup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">ic3_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span> <span class="o">=</span> <span class="n">ic3_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ic3_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_port</span> <span class="o">=</span> <span class="n">null_void_function</span><span class="p">,</span>
	<span class="p">.</span><span class="n">request_port</span> <span class="o">=</span> <span class="n">ic3_request_port</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Boot-time initialization code</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_driver</span> <span class="n">ioc3_uart</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver_name</span> <span class="o">=</span> <span class="s">&quot;ioc3_serial&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span> <span class="o">=</span> <span class="n">DEVICE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="n">DEVICE_MAJOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="n">DEVICE_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">MAX_LOGICAL_PORTS</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ioc3_serial_core_attach - register with serial core</span>
<span class="cm"> *		This is done during pci probing</span>
<span class="cm"> * @is: submodule struct for this</span>
<span class="cm"> * @idd: handle for this card</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ioc3_serial_core_attach</span><span class="p">(</span> <span class="k">struct</span> <span class="n">ioc3_submodule</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ioc3_driver_data</span> <span class="o">*</span><span class="n">idd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_card</span> <span class="o">*</span><span class="n">card_ptr</span> <span class="o">=</span> <span class="n">idd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ii</span><span class="p">,</span> <span class="n">phys_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">idd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s: attach pdev 0x%p - card_ptr 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">card_ptr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">card_ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* once around for each logical port on this card */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">LOGICAL_PORTS_PER_CARD</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phys_port</span> <span class="o">=</span> <span class="n">GET_PHYSICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">);</span>
		<span class="n">the_port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">phys_port</span><span class="p">].</span>
				<span class="n">icp_uart_port</span><span class="p">[</span><span class="n">GET_LOGICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">)];</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">phys_port</span><span class="p">].</span><span class="n">icp_port</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_port</span> <span class="o">=</span> <span class="n">the_port</span><span class="p">;</span>

		<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s: attach the_port 0x%p / port 0x%p [%d/%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">the_port</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="p">,</span>
				<span class="n">phys_port</span><span class="p">,</span> <span class="n">ii</span><span class="p">));</span>

		<span class="cm">/* membase, iobase and mapbase just need to be non-0 */</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>  <span class="n">ii</span><span class="p">;</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="n">Num_of_ioc3_cards</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">ii</span><span class="p">;</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">mapbase</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PORT_16550A</span><span class="p">;</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">fifosize</span> <span class="o">=</span> <span class="n">FIFO_SIZE</span><span class="p">;</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ioc3_ops</span><span class="p">;</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">idd</span><span class="o">-&gt;</span><span class="n">irq_io</span><span class="p">;</span>
		<span class="n">the_port</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">uart_add_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc3_uart</span><span class="p">,</span> <span class="n">the_port</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		          <span class="s">&quot;%s: unable to add port %d bus %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;IOC3 serial port %d irq %d bus %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		          <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">,</span> <span class="n">the_port</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* all ports are rs232 for now */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_PHYSICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">))</span>
			<span class="n">ioc3_set_proto</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">PROTO_RS232</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ioc3uart_remove - register detach function</span>
<span class="cm"> * @is: submodule struct for this submodule</span>
<span class="cm"> * @idd: ioc3 driver data for this submodule</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ioc3uart_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_submodule</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ioc3_driver_data</span> <span class="o">*</span><span class="n">idd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ioc3_card</span> <span class="o">*</span><span class="n">card_ptr</span> <span class="o">=</span> <span class="n">idd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">the_port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">card_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">LOGICAL_PORTS_PER_CARD</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">the_port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">GET_PHYSICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">)].</span>
					<span class="n">icp_uart_port</span><span class="p">[</span><span class="n">GET_LOGICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">)];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">the_port</span><span class="p">)</span>
				<span class="n">uart_remove_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc3_uart</span><span class="p">,</span> <span class="n">the_port</span><span class="p">);</span>
			<span class="n">port</span> <span class="o">=</span> <span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">GET_PHYSICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">)].</span><span class="n">icp_port</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&amp;&amp;</span> <span class="n">IS_PHYSICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">GET_PHYSICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_idd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
					<span class="n">TOTAL_RING_BUF_SIZE</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_cpu_ringbuf</span><span class="p">,</span>
					<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_dma_ringbuf</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
				<span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">GET_PHYSICAL_PORT</span><span class="p">(</span><span class="n">ii</span><span class="p">)].</span>
							<span class="n">icp_port</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">card_ptr</span><span class="p">);</span>
		<span class="n">idd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ioc3uart_probe - card probe function called from shim driver</span>
<span class="cm"> * @is: submodule struct for this submodule</span>
<span class="cm"> * @idd: ioc3 driver data for this card</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">ioc3uart_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_submodule</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ioc3_driver_data</span> <span class="o">*</span><span class="n">idd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">idd</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_card</span> <span class="o">*</span><span class="n">card_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ioc3_port</span> <span class="o">*</span><span class="n">ports</span><span class="p">[</span><span class="n">PORTS_PER_CARD</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">phys_port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s (0x%p, 0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">));</span>

	<span class="n">card_ptr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_card</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">card_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ioc3_attach_one&quot;</span>
		       <span class="s">&quot;: unable to get memory for the IOC3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">idd</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">card_ptr</span><span class="p">;</span>
	<span class="n">Submodule_slot</span> <span class="o">=</span> <span class="n">is</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(((</span><span class="n">UARTA_BASE</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">SIO_CR_SER_A_BASE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">UARTB_BASE</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">SIO_CR_SER_B_BASE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="mh">0xf</span> <span class="o">&lt;&lt;</span> <span class="n">SIO_CR_CMD_PULSE_SHIFT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">sio_cr</span><span class="p">);</span>

	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_LAT</span><span class="p">,</span> <span class="mh">0xff00</span><span class="p">);</span>

	<span class="cm">/* Enable serial port mode select generic PIO pins as outputs */</span>
	<span class="n">ioc3_gpcr_set</span><span class="p">(</span><span class="n">idd</span><span class="p">,</span> <span class="n">GPCR_UARTA_MODESEL</span> <span class="o">|</span> <span class="n">GPCR_UARTB_MODESEL</span><span class="p">);</span>

	<span class="cm">/* Create port structures for each port */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">phys_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phys_port</span> <span class="o">&lt;</span> <span class="n">PORTS_PER_CARD</span><span class="p">;</span> <span class="n">phys_port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ioc3_port</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;IOC3 serial memory not available for port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_lock</span><span class="p">);</span>

		<span class="cm">/* we need to remember the previous ones, to point back to</span>
<span class="cm">		 * them farther down - setting up the ring buffers.</span>
<span class="cm">		 */</span>
		<span class="n">ports</span><span class="p">[</span><span class="n">phys_port</span><span class="p">]</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>

		<span class="cm">/* init to something useful */</span>
		<span class="n">card_ptr</span><span class="o">-&gt;</span><span class="n">ic_port</span><span class="p">[</span><span class="n">phys_port</span><span class="p">].</span><span class="n">icp_port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_is</span> <span class="o">=</span> <span class="n">is</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_idd</span> <span class="o">=</span> <span class="n">idd</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_baud</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_card</span> <span class="o">=</span> <span class="n">card_ptr</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_hooks</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hooks_array</span><span class="p">[</span><span class="n">phys_port</span><span class="p">];</span>

		<span class="cm">/* Setup each port */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phys_port</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">port_a</span><span class="p">;</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">sregs</span><span class="p">.</span><span class="n">uarta</span><span class="p">;</span>

			<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s : Port A ip_serial_regs 0x%p &quot;</span>
				       <span class="s">&quot;ip_uart_regs 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="p">));</span>

			<span class="cm">/* setup ring buffers */</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_cpu_ringbuf</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
				<span class="n">TOTAL_RING_BUF_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_dma_ringbuf</span><span class="p">);</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">((((</span><span class="kt">int64_t</span><span class="p">)</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_dma_ringbuf</span><span class="p">)</span> <span class="o">&amp;</span>
				  <span class="p">(</span><span class="n">TOTAL_RING_BUF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_inring</span> <span class="o">=</span> <span class="n">RING</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">RX_A</span><span class="p">);</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_outring</span> <span class="o">=</span> <span class="n">RING</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">TX_A</span><span class="p">);</span>
			<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s : Port A ip_cpu_ringbuf 0x%p &quot;</span>
				       <span class="s">&quot;ip_dma_ringbuf 0x%p, ip_inring 0x%p &quot;</span>
					<span class="s">&quot;ip_outring 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_cpu_ringbuf</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_dma_ringbuf</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_inring</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_outring</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">port_b</span><span class="p">;</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idd</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">sregs</span><span class="p">.</span><span class="n">uartb</span><span class="p">;</span>

			<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s : Port B ip_serial_regs 0x%p &quot;</span>
				       <span class="s">&quot;ip_uart_regs 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="p">));</span>

			<span class="cm">/* share the ring buffers */</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_dma_ringbuf</span> <span class="o">=</span>
			    <span class="n">ports</span><span class="p">[</span><span class="n">phys_port</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ip_dma_ringbuf</span><span class="p">;</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_cpu_ringbuf</span> <span class="o">=</span>
			    <span class="n">ports</span><span class="p">[</span><span class="n">phys_port</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ip_cpu_ringbuf</span><span class="p">;</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_inring</span> <span class="o">=</span> <span class="n">RING</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">RX_B</span><span class="p">);</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_outring</span> <span class="o">=</span> <span class="n">RING</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">TX_B</span><span class="p">);</span>
			<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s : Port B ip_cpu_ringbuf 0x%p &quot;</span>
				       <span class="s">&quot;ip_dma_ringbuf 0x%p, ip_inring 0x%p &quot;</span>
					<span class="s">&quot;ip_outring 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_cpu_ringbuf</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_dma_ringbuf</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_inring</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_outring</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s : port %d [addr 0x%p] card_ptr 0x%p&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span>
			       <span class="n">phys_port</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">card_ptr</span><span class="p">));</span>
		<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot; ip_serial_regs 0x%p ip_uart_regs 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_serial_regs</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_uart_regs</span><span class="p">));</span>

		<span class="cm">/* Initialize the hardware for IOC3 */</span>
		<span class="n">port_init</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

		<span class="n">DPRINT_CONFIG</span><span class="p">((</span><span class="s">&quot;%s: phys_port %d port 0x%p inring 0x%p &quot;</span>
			       <span class="s">&quot;outring 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span>
			       <span class="n">phys_port</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_inring</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ip_outring</span><span class="p">));</span>

	<span class="p">}</span>

	<span class="cm">/* register port with the serial core */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ioc3_serial_core_attach</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">idd</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>

	<span class="n">Num_of_ioc3_cards</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* error exits that give back resources */</span>
<span class="nl">out4:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">phys_port</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ports</span><span class="p">[</span><span class="n">cnt</span><span class="p">]);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">card_ptr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ioc3_submodule</span> <span class="n">ioc3uart_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;IOC3uart&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ioc3uart_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">ioc3uart_remove</span><span class="p">,</span>
	<span class="cm">/* call .intr for both ports initially */</span>
	<span class="p">.</span><span class="n">irq_mask</span> <span class="o">=</span> <span class="n">SIO_IR_SA</span> <span class="o">|</span> <span class="n">SIO_IR_SB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">intr</span> <span class="o">=</span> <span class="n">ioc3uart_intr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ioc3_detect - module init called,</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ioc3uart_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* register with serial core */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">uart_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc3_uart</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;%s: Couldn&#39;t register IOC3 uart serial driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ioc3_register_submodule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc3uart_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">uart_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc3_uart</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ioc3uart_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ioc3_unregister_submodule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc3uart_ops</span><span class="p">);</span>
	<span class="n">uart_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc3_uart</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ioc3uart_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ioc3uart_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Pat Gefre - Silicon Graphics Inc. (SGI) &lt;pfg@sgi.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Serial PCI driver module for SGI IOC3 card&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
