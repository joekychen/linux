<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › serial › msm_serial_hs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>msm_serial_hs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * MSM 7k/8k High speed uart driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2007-2011, Code Aurora Forum. All rights reserved.</span>
<span class="cm"> * Copyright (c) 2008 Google Inc.</span>
<span class="cm"> * Modified: Nick Pelly &lt;npelly@google.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Has optional support for uart power management independent of linux</span>
<span class="cm"> * suspend/resume:</span>
<span class="cm"> *</span>
<span class="cm"> * RX wakeup.</span>
<span class="cm"> * UART wakeup can be triggered by RX activity (using a wakeup GPIO on the</span>
<span class="cm"> * UART RX pin). This should only be used if there is not a wakeup</span>
<span class="cm"> * GPIO on the UART CTS, and the first RX byte is known (for example, with the</span>
<span class="cm"> * Bluetooth Texas Instruments HCILL protocol), since the first RX byte will</span>
<span class="cm"> * always be lost. RTS will be asserted even while the UART is off in this mode</span>
<span class="cm"> * of operation. See msm_serial_hs_platform_data.rx_wakeup_irq.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/serial_core.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/dmapool.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>

<span class="cp">#include &lt;mach/hardware.h&gt;</span>
<span class="cp">#include &lt;mach/dma.h&gt;</span>
<span class="cp">#include &lt;linux/platform_data/msm_serial_hs.h&gt;</span>

<span class="cm">/* HSUART Registers */</span>
<span class="cp">#define UARTDM_MR1_ADDR 0x0</span>
<span class="cp">#define UARTDM_MR2_ADDR 0x4</span>

<span class="cm">/* Data Mover result codes */</span>
<span class="cp">#define RSLT_FIFO_CNTR_BMSK (0xE &lt;&lt; 28)</span>
<span class="cp">#define RSLT_VLD            BIT(1)</span>

<span class="cm">/* write only register */</span>
<span class="cp">#define UARTDM_CSR_ADDR 0x8</span>
<span class="cp">#define UARTDM_CSR_115200 0xFF</span>
<span class="cp">#define UARTDM_CSR_57600  0xEE</span>
<span class="cp">#define UARTDM_CSR_38400  0xDD</span>
<span class="cp">#define UARTDM_CSR_28800  0xCC</span>
<span class="cp">#define UARTDM_CSR_19200  0xBB</span>
<span class="cp">#define UARTDM_CSR_14400  0xAA</span>
<span class="cp">#define UARTDM_CSR_9600   0x99</span>
<span class="cp">#define UARTDM_CSR_7200   0x88</span>
<span class="cp">#define UARTDM_CSR_4800   0x77</span>
<span class="cp">#define UARTDM_CSR_3600   0x66</span>
<span class="cp">#define UARTDM_CSR_2400   0x55</span>
<span class="cp">#define UARTDM_CSR_1200   0x44</span>
<span class="cp">#define UARTDM_CSR_600    0x33</span>
<span class="cp">#define UARTDM_CSR_300    0x22</span>
<span class="cp">#define UARTDM_CSR_150    0x11</span>
<span class="cp">#define UARTDM_CSR_75     0x00</span>

<span class="cm">/* write only register */</span>
<span class="cp">#define UARTDM_TF_ADDR 0x70</span>
<span class="cp">#define UARTDM_TF2_ADDR 0x74</span>
<span class="cp">#define UARTDM_TF3_ADDR 0x78</span>
<span class="cp">#define UARTDM_TF4_ADDR 0x7C</span>

<span class="cm">/* write only register */</span>
<span class="cp">#define UARTDM_CR_ADDR 0x10</span>
<span class="cp">#define UARTDM_IMR_ADDR 0x14</span>

<span class="cp">#define UARTDM_IPR_ADDR 0x18</span>
<span class="cp">#define UARTDM_TFWR_ADDR 0x1c</span>
<span class="cp">#define UARTDM_RFWR_ADDR 0x20</span>
<span class="cp">#define UARTDM_HCR_ADDR 0x24</span>
<span class="cp">#define UARTDM_DMRX_ADDR 0x34</span>
<span class="cp">#define UARTDM_IRDA_ADDR 0x38</span>
<span class="cp">#define UARTDM_DMEN_ADDR 0x3c</span>

<span class="cm">/* UART_DM_NO_CHARS_FOR_TX */</span>
<span class="cp">#define UARTDM_NCF_TX_ADDR 0x40</span>

<span class="cp">#define UARTDM_BADR_ADDR 0x44</span>

<span class="cp">#define UARTDM_SIM_CFG_ADDR 0x80</span>
<span class="cm">/* Read Only register */</span>
<span class="cp">#define UARTDM_SR_ADDR 0x8</span>

<span class="cm">/* Read Only register */</span>
<span class="cp">#define UARTDM_RF_ADDR  0x70</span>
<span class="cp">#define UARTDM_RF2_ADDR 0x74</span>
<span class="cp">#define UARTDM_RF3_ADDR 0x78</span>
<span class="cp">#define UARTDM_RF4_ADDR 0x7C</span>

<span class="cm">/* Read Only register */</span>
<span class="cp">#define UARTDM_MISR_ADDR 0x10</span>

<span class="cm">/* Read Only register */</span>
<span class="cp">#define UARTDM_ISR_ADDR 0x14</span>
<span class="cp">#define UARTDM_RX_TOTAL_SNAP_ADDR 0x38</span>

<span class="cp">#define UARTDM_RXFS_ADDR 0x50</span>

<span class="cm">/* Register field Mask Mapping */</span>
<span class="cp">#define UARTDM_SR_PAR_FRAME_BMSK        BIT(5)</span>
<span class="cp">#define UARTDM_SR_OVERRUN_BMSK          BIT(4)</span>
<span class="cp">#define UARTDM_SR_TXEMT_BMSK            BIT(3)</span>
<span class="cp">#define UARTDM_SR_TXRDY_BMSK            BIT(2)</span>
<span class="cp">#define UARTDM_SR_RXRDY_BMSK            BIT(0)</span>

<span class="cp">#define UARTDM_CR_TX_DISABLE_BMSK       BIT(3)</span>
<span class="cp">#define UARTDM_CR_RX_DISABLE_BMSK       BIT(1)</span>
<span class="cp">#define UARTDM_CR_TX_EN_BMSK            BIT(2)</span>
<span class="cp">#define UARTDM_CR_RX_EN_BMSK            BIT(0)</span>

<span class="cm">/* UARTDM_CR channel_comman bit value (register field is bits 8:4) */</span>
<span class="cp">#define RESET_RX                0x10</span>
<span class="cp">#define RESET_TX                0x20</span>
<span class="cp">#define RESET_ERROR_STATUS      0x30</span>
<span class="cp">#define RESET_BREAK_INT         0x40</span>
<span class="cp">#define START_BREAK             0x50</span>
<span class="cp">#define STOP_BREAK              0x60</span>
<span class="cp">#define RESET_CTS               0x70</span>
<span class="cp">#define RESET_STALE_INT         0x80</span>
<span class="cp">#define RFR_LOW                 0xD0</span>
<span class="cp">#define RFR_HIGH                0xE0</span>
<span class="cp">#define CR_PROTECTION_EN        0x100</span>
<span class="cp">#define STALE_EVENT_ENABLE      0x500</span>
<span class="cp">#define STALE_EVENT_DISABLE     0x600</span>
<span class="cp">#define FORCE_STALE_EVENT       0x400</span>
<span class="cp">#define CLEAR_TX_READY          0x300</span>
<span class="cp">#define RESET_TX_ERROR          0x800</span>
<span class="cp">#define RESET_TX_DONE           0x810</span>

<span class="cp">#define UARTDM_MR1_AUTO_RFR_LEVEL1_BMSK 0xffffff00</span>
<span class="cp">#define UARTDM_MR1_AUTO_RFR_LEVEL0_BMSK 0x3f</span>
<span class="cp">#define UARTDM_MR1_CTS_CTL_BMSK 0x40</span>
<span class="cp">#define UARTDM_MR1_RX_RDY_CTL_BMSK 0x80</span>

<span class="cp">#define UARTDM_MR2_ERROR_MODE_BMSK 0x40</span>
<span class="cp">#define UARTDM_MR2_BITS_PER_CHAR_BMSK 0x30</span>

<span class="cm">/* bits per character configuration */</span>
<span class="cp">#define FIVE_BPC  (0 &lt;&lt; 4)</span>
<span class="cp">#define SIX_BPC   (1 &lt;&lt; 4)</span>
<span class="cp">#define SEVEN_BPC (2 &lt;&lt; 4)</span>
<span class="cp">#define EIGHT_BPC (3 &lt;&lt; 4)</span>

<span class="cp">#define UARTDM_MR2_STOP_BIT_LEN_BMSK 0xc</span>
<span class="cp">#define STOP_BIT_ONE (1 &lt;&lt; 2)</span>
<span class="cp">#define STOP_BIT_TWO (3 &lt;&lt; 2)</span>

<span class="cp">#define UARTDM_MR2_PARITY_MODE_BMSK 0x3</span>

<span class="cm">/* Parity configuration */</span>
<span class="cp">#define NO_PARITY 0x0</span>
<span class="cp">#define EVEN_PARITY 0x1</span>
<span class="cp">#define ODD_PARITY 0x2</span>
<span class="cp">#define SPACE_PARITY 0x3</span>

<span class="cp">#define UARTDM_IPR_STALE_TIMEOUT_MSB_BMSK 0xffffff80</span>
<span class="cp">#define UARTDM_IPR_STALE_LSB_BMSK 0x1f</span>

<span class="cm">/* These can be used for both ISR and IMR register */</span>
<span class="cp">#define UARTDM_ISR_TX_READY_BMSK        BIT(7)</span>
<span class="cp">#define UARTDM_ISR_CURRENT_CTS_BMSK     BIT(6)</span>
<span class="cp">#define UARTDM_ISR_DELTA_CTS_BMSK       BIT(5)</span>
<span class="cp">#define UARTDM_ISR_RXLEV_BMSK           BIT(4)</span>
<span class="cp">#define UARTDM_ISR_RXSTALE_BMSK         BIT(3)</span>
<span class="cp">#define UARTDM_ISR_RXBREAK_BMSK         BIT(2)</span>
<span class="cp">#define UARTDM_ISR_RXHUNT_BMSK          BIT(1)</span>
<span class="cp">#define UARTDM_ISR_TXLEV_BMSK           BIT(0)</span>

<span class="cm">/* Field definitions for UART_DM_DMEN*/</span>
<span class="cp">#define UARTDM_TX_DM_EN_BMSK 0x1</span>
<span class="cp">#define UARTDM_RX_DM_EN_BMSK 0x2</span>

<span class="cp">#define UART_FIFOSIZE 64</span>
<span class="cp">#define UARTCLK 7372800</span>

<span class="cm">/* Rx DMA request states */</span>
<span class="k">enum</span> <span class="n">flush_reason</span> <span class="p">{</span>
	<span class="n">FLUSH_NONE</span><span class="p">,</span>
	<span class="n">FLUSH_DATA_READY</span><span class="p">,</span>
	<span class="n">FLUSH_DATA_INVALID</span><span class="p">,</span>  <span class="cm">/* values after this indicate invalid data */</span>
	<span class="n">FLUSH_IGNORE</span> <span class="o">=</span> <span class="n">FLUSH_DATA_INVALID</span><span class="p">,</span>
	<span class="n">FLUSH_STOP</span><span class="p">,</span>
	<span class="n">FLUSH_SHUTDOWN</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* UART clock states */</span>
<span class="k">enum</span> <span class="n">msm_hs_clk_states_e</span> <span class="p">{</span>
	<span class="n">MSM_HS_CLK_PORT_OFF</span><span class="p">,</span>     <span class="cm">/* port not in use */</span>
	<span class="n">MSM_HS_CLK_OFF</span><span class="p">,</span>          <span class="cm">/* clock disabled */</span>
	<span class="n">MSM_HS_CLK_REQUEST_OFF</span><span class="p">,</span>  <span class="cm">/* disable after TX and RX flushed */</span>
	<span class="n">MSM_HS_CLK_ON</span><span class="p">,</span>           <span class="cm">/* clock enabled */</span>
<span class="p">};</span>

<span class="cm">/* Track the forced RXSTALE flush during clock off sequence.</span>
<span class="cm"> * These states are only valid during MSM_HS_CLK_REQUEST_OFF */</span>
<span class="k">enum</span> <span class="n">msm_hs_clk_req_off_state_e</span> <span class="p">{</span>
	<span class="n">CLK_REQ_OFF_START</span><span class="p">,</span>
	<span class="n">CLK_REQ_OFF_RXSTALE_ISSUED</span><span class="p">,</span>
	<span class="n">CLK_REQ_OFF_FLUSH_ISSUED</span><span class="p">,</span>
	<span class="n">CLK_REQ_OFF_RXSTALE_FLUSHED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct msm_hs_tx</span>
<span class="cm"> * @tx_ready_int_en: ok to dma more tx?</span>
<span class="cm"> * @dma_in_flight: tx dma in progress</span>
<span class="cm"> * @xfer: top level DMA command pointer structure</span>
<span class="cm"> * @command_ptr: third level command struct pointer</span>
<span class="cm"> * @command_ptr_ptr: second level command list struct pointer</span>
<span class="cm"> * @mapped_cmd_ptr: DMA view of third level command struct</span>
<span class="cm"> * @mapped_cmd_ptr_ptr: DMA view of second level command list struct</span>
<span class="cm"> * @tx_count: number of bytes to transfer in DMA transfer</span>
<span class="cm"> * @dma_base: DMA view of UART xmit buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This structure describes a single Tx DMA transaction. MSM DMA</span>
<span class="cm"> * commands have two levels of indirection. The top level command</span>
<span class="cm"> * ptr points to a list of command ptr which in turn points to a</span>
<span class="cm"> * single DMA &#39;command&#39;. In our case each Tx transaction consists</span>
<span class="cm"> * of a single second level pointer pointing to a &#39;box type&#39; command.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">msm_hs_tx</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_ready_int_en</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dma_in_flight</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_dmov_cmd</span> <span class="n">xfer</span><span class="p">;</span>
	<span class="n">dmov_box</span> <span class="o">*</span><span class="n">command_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">command_ptr_ptr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">mapped_cmd_ptr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">mapped_cmd_ptr_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_count</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_base</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct msm_hs_rx</span>
<span class="cm"> * @flush: Rx DMA request state</span>
<span class="cm"> * @xfer: top level DMA command pointer structure</span>
<span class="cm"> * @cmdptr_dmaaddr: DMA view of second level command structure</span>
<span class="cm"> * @command_ptr: third level DMA command pointer structure</span>
<span class="cm"> * @command_ptr_ptr: second level DMA command list pointer</span>
<span class="cm"> * @mapped_cmd_ptr: DMA view of the third level command structure</span>
<span class="cm"> * @wait: wait for DMA completion before shutdown</span>
<span class="cm"> * @buffer: destination buffer for RX DMA</span>
<span class="cm"> * @rbuffer: DMA view of buffer</span>
<span class="cm"> * @pool: dma pool out of which coherent rx buffer is allocated</span>
<span class="cm"> * @tty_work: private work-queue for tty flip buffer push task</span>
<span class="cm"> *</span>
<span class="cm"> * This structure describes a single Rx DMA transaction. Rx DMA</span>
<span class="cm"> * transactions use box mode DMA commands.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">msm_hs_rx</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">flush_reason</span> <span class="n">flush</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_dmov_cmd</span> <span class="n">xfer</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">cmdptr_dmaaddr</span><span class="p">;</span>
	<span class="n">dmov_box</span> <span class="o">*</span><span class="n">command_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">command_ptr_ptr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">mapped_cmd_ptr</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rbuffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">tty_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct msm_hs_rx_wakeup</span>
<span class="cm"> * @irq: IRQ line to be configured as interrupt source on Rx activity</span>
<span class="cm"> * @ignore: boolean value. 1 = ignore the wakeup interrupt</span>
<span class="cm"> * @rx_to_inject: extra character to be inserted to Rx tty on wakeup</span>
<span class="cm"> * @inject_rx: 1 = insert rx_to_inject. 0 = do not insert extra character</span>
<span class="cm"> *</span>
<span class="cm"> * This is an optional structure required for UART Rx GPIO IRQ based</span>
<span class="cm"> * wakeup from low power state. UART wakeup can be triggered by RX activity</span>
<span class="cm"> * (using a wakeup GPIO on the UART RX pin). This should only be used if</span>
<span class="cm"> * there is not a wakeup GPIO on the UART CTS, and the first RX byte is</span>
<span class="cm"> * known (eg., with the Bluetooth Texas Instruments HCILL protocol),</span>
<span class="cm"> * since the first RX byte will always be lost. RTS will be asserted even</span>
<span class="cm"> * while the UART is clocked off in this mode of operation.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">msm_hs_rx_wakeup</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>  <span class="cm">/* &lt; 0 indicates low power wakeup disabled */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ignore</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">inject_rx</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">rx_to_inject</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct msm_hs_port</span>
<span class="cm"> * @uport: embedded uart port structure</span>
<span class="cm"> * @imr_reg: shadow value of UARTDM_IMR</span>
<span class="cm"> * @clk: uart input clock handle</span>
<span class="cm"> * @tx: Tx transaction related data structure</span>
<span class="cm"> * @rx: Rx transaction related data structure</span>
<span class="cm"> * @dma_tx_channel: Tx DMA command channel</span>
<span class="cm"> * @dma_rx_channel Rx DMA command channel</span>
<span class="cm"> * @dma_tx_crci: Tx channel rate control interface number</span>
<span class="cm"> * @dma_rx_crci: Rx channel rate control interface number</span>
<span class="cm"> * @clk_off_timer: Timer to poll DMA event completion before clock off</span>
<span class="cm"> * @clk_off_delay: clk_off_timer poll interval</span>
<span class="cm"> * @clk_state: overall clock state</span>
<span class="cm"> * @clk_req_off_state: post flush clock states</span>
<span class="cm"> * @rx_wakeup: optional rx_wakeup feature related data</span>
<span class="cm"> * @exit_lpm_cb: optional callback to exit low power mode</span>
<span class="cm"> *</span>
<span class="cm"> * Low level serial port structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="n">uport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imr_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_tx</span> <span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_rx</span> <span class="n">rx</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">dma_tx_channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_rx_channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_tx_crci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_rx_crci</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">clk_off_timer</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">clk_off_delay</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">msm_hs_clk_states_e</span> <span class="n">clk_state</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">msm_hs_clk_req_off_state_e</span> <span class="n">clk_req_off_state</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">msm_hs_rx_wakeup</span> <span class="n">rx_wakeup</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exit_lpm_cb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define MSM_UARTDM_BURST_SIZE 16   </span><span class="cm">/* DM burst size (in bytes) */</span><span class="cp"></span>
<span class="cp">#define UARTDM_TX_BUF_SIZE UART_XMIT_SIZE</span>
<span class="cp">#define UARTDM_RX_BUF_SIZE 512</span>

<span class="cp">#define UARTDM_NR 2</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="n">q_uart_port</span><span class="p">[</span><span class="n">UARTDM_NR</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">msm_serial_hs_platform_driver</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_driver</span> <span class="n">msm_hs_driver</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_ops</span> <span class="n">msm_hs_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">msm_hs_workqueue</span><span class="p">;</span>

<span class="cp">#define UARTDM_TO_MSM(uart_port) \</span>
<span class="cp">	container_of((uart_port), struct msm_hs_port, uport)</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">use_low_power_rx_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_hs_port</span>
						   <span class="o">*</span><span class="n">msm_uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">msm_hs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_release_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hs_request_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">mapbase</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* configure the CR Protection to Enable */</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">CR_PROTECTION_EN</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">msm_hs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">UARTDM_NR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Invalid plaform device ID = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msm_uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q_uart_port</span><span class="p">[</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">mapped_cmd_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dmov_box</span><span class="p">),</span>
			 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">pool</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span>
		      <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">rbuffer</span><span class="p">);</span>
	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">pool</span><span class="p">);</span>

	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">cmdptr_dmaaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
			 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">mapped_cmd_ptr_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span>
			 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">mapped_cmd_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dmov_box</span><span class="p">),</span>
			 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="n">uart_remove_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_hs_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* Free the tx resources */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">command_ptr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">command_ptr_ptr</span><span class="p">);</span>

	<span class="cm">/* Free the rx resources */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">command_ptr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">command_ptr_ptr</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">.</span><span class="n">membase</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hs_init_clk_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Error could not turn on UART clk</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up the MREG/NREG/DREG/MNDREG */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">clk_set_rate</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">uartclk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Error setting clock rate on UART</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">=</span> <span class="n">MSM_HS_CLK_ON</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Enable and Disable clocks  (Used for power management) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_low_power_rx_wakeup</span><span class="p">(</span><span class="n">msm_uport</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">exit_lpm_cb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>  <span class="cm">/* ignore linux PM states,</span>
<span class="cm">			    use msm_hs_request_clock API */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;msm_serial: Unknown PM state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">state</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * programs the UARTDM_CSR register with correct bit rates</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupts should be disabled before we are called, as</span>
<span class="cm"> * we modify Set Baud rate</span>
<span class="cm"> * Set receive stale interrupt level, dependent on Bit Rate</span>
<span class="cm"> * Goal is to have around 8 ms before indicate stale.</span>
<span class="cm"> * roundup (((Bit Rate * .008) / 10) + 1</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_set_bps_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rxstale</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bps</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">300</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_75</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">600</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_150</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1200</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_300</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2400</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_600</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4800</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_1200</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">9600</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_2400</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">14400</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_3600</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">19200</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_4800</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">28800</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_7200</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">38400</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_9600</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">57600</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_14400</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">76800</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_19200</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">115200</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_28800</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">230400</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_57600</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">460800</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_115200</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4000000</span>:
	<span class="k">case</span> <span class="mi">3686400</span>:
	<span class="k">case</span> <span class="mi">3200000</span>:
	<span class="k">case</span> <span class="mi">3500000</span>:
	<span class="k">case</span> <span class="mi">3000000</span>:
	<span class="k">case</span> <span class="mi">2500000</span>:
	<span class="k">case</span> <span class="mi">1500000</span>:
	<span class="k">case</span> <span class="mi">1152000</span>:
	<span class="k">case</span> <span class="mi">1000000</span>:
	<span class="k">case</span> <span class="mi">921600</span>:
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_115200</span><span class="p">);</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CSR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CSR_2400</span><span class="p">);</span>
		<span class="cm">/* default to 9600 */</span>
		<span class="n">bps</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
		<span class="n">rxstale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bps</span> <span class="o">&gt;</span> <span class="mi">460800</span><span class="p">)</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">uartclk</span> <span class="o">=</span> <span class="n">bps</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">uartclk</span> <span class="o">=</span> <span class="n">UARTCLK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clk_set_rate</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">uartclk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Error setting clock rate on UART</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">rxstale</span> <span class="o">&amp;</span> <span class="n">UARTDM_IPR_STALE_LSB_BMSK</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">UARTDM_IPR_STALE_TIMEOUT_MSB_BMSK</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rxstale</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IPR_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * termios :  new ktermios</span>
<span class="cm"> * oldtermios:  old ktermios previous setting</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the serial port</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">oldtermios</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bps</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c_cflag</span> <span class="o">=</span> <span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* 300 is the minimum baud support by the driver  */</span>
	<span class="n">bps</span> <span class="o">=</span> <span class="n">uart_get_baud_rate</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">termios</span><span class="p">,</span> <span class="n">oldtermios</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">4000000</span><span class="p">);</span>

	<span class="cm">/* Temporary remapping  200 BAUD to 3.2 mbps */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bps</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span>
		<span class="n">bps</span> <span class="o">=</span> <span class="mi">3200000</span><span class="p">;</span>

	<span class="n">msm_hs_set_bps_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">bps</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR2_ADDR</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_MR2_PARITY_MODE_BMSK</span><span class="p">;</span>
	<span class="cm">/* set parity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PARENB</span> <span class="o">==</span> <span class="p">(</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">PARENB</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PARODD</span> <span class="o">==</span> <span class="p">(</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">PARODD</span><span class="p">))</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">ODD_PARITY</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">CMSPAR</span> <span class="o">==</span> <span class="p">(</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CMSPAR</span><span class="p">))</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">SPACE_PARITY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">EVEN_PARITY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set bits per char */</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_MR2_BITS_PER_CHAR_BMSK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CSIZE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CS5</span>:
		<span class="n">data</span> <span class="o">|=</span> <span class="n">FIVE_BPC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS6</span>:
		<span class="n">data</span> <span class="o">|=</span> <span class="n">SIX_BPC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS7</span>:
		<span class="n">data</span> <span class="o">|=</span> <span class="n">SEVEN_BPC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">EIGHT_BPC</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* stop bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CSTOPB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">STOP_BIT_TWO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* otherwise 1 stop bit */</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">STOP_BIT_ONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">UARTDM_MR2_ERROR_MODE_BMSK</span><span class="p">;</span>
	<span class="cm">/* write parity/bits per char/stop bit configuration */</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR2_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Configure HW flow control */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR1_ADDR</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UARTDM_MR1_CTS_CTL_BMSK</span> <span class="o">|</span> <span class="n">UARTDM_MR1_RX_RDY_CTL_BMSK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CRTSCTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">UARTDM_MR1_CTS_CTL_BMSK</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">UARTDM_MR1_RX_RDY_CTL_BMSK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR1_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">=</span> <span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;</span> <span class="n">INPCK</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">|=</span> <span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;</span> <span class="n">IGNPAR</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CREAD</span><span class="p">);</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set Transmit software time out */</span>
	<span class="n">uart_update_timeout</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">c_cflag</span><span class="p">,</span> <span class="n">bps</span><span class="p">);</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_RX</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_TX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">FLUSH_IGNORE</span><span class="p">;</span>
		<span class="n">msm_dmov_stop_cmd</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_rx_channel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Standard API, Transmitter</span>
<span class="cm"> *  Any character in the transmit shift register is sent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">msm_hs_tx_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_SR_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">UARTDM_SR_TXEMT_BMSK</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">TIOCSER_TEMT</span><span class="p">;</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Standard API, Stop transmitter.</span>
<span class="cm"> *  Any character in the transmit shift register is sent as</span>
<span class="cm"> *  well as the current data mover transfer .</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_stop_tx_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">tx_ready_int_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Standard API, Stop receiver as soon as possible.</span>
<span class="cm"> *</span>
<span class="cm"> *  Function immediately terminates the operation of the</span>
<span class="cm"> *  channel receiver and any incoming characters are lost. None</span>
<span class="cm"> *  of the receiver status bits are affected by this command and</span>
<span class="cm"> *  characters that are already in the receive FIFO there.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_stop_rx_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* disable dlink */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_DMEN_ADDR</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_RX_DM_EN_BMSK</span><span class="p">;</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_DMEN_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Disable the receiver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_NONE</span><span class="p">)</span>
		<span class="n">msm_dmov_stop_cmd</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_rx_channel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">!=</span> <span class="n">FLUSH_SHUTDOWN</span><span class="p">)</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">FLUSH_STOP</span><span class="p">;</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Transmit the next chunk of data */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_submit_tx_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_count</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">src_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">msm_hs_tx</span> <span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">tx_buf</span><span class="p">)</span> <span class="o">||</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msm_hs_stop_tx_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">dma_in_flight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tx_count</span> <span class="o">=</span> <span class="n">uart_circ_chars_pending</span><span class="p">(</span><span class="n">tx_buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">UARTDM_TX_BUF_SIZE</span> <span class="o">&lt;</span> <span class="n">tx_count</span><span class="p">)</span>
		<span class="n">tx_count</span> <span class="o">=</span> <span class="n">UARTDM_TX_BUF_SIZE</span><span class="p">;</span>

	<span class="n">left</span> <span class="o">=</span> <span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_count</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span>
		<span class="n">tx_count</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

	<span class="n">src_addr</span> <span class="o">=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">+</span> <span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">src_addr</span><span class="p">,</span> <span class="n">tx_count</span><span class="p">,</span>
				   <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="p">(((</span><span class="n">tx_count</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				     <span class="p">((</span><span class="n">tx_count</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">src_row_addr</span> <span class="o">=</span> <span class="n">src_addr</span><span class="p">;</span>

	<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mapped_cmd_ptr</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="n">dmov_box</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="o">*</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr_ptr</span> <span class="o">=</span> <span class="n">CMD_PTR_LP</span> <span class="o">|</span> <span class="n">DMOV_CMD_ADDR</span><span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">mapped_cmd_ptr</span><span class="p">);</span>

	<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">mapped_cmd_ptr_ptr</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="cm">/* Save tx_count to use in Callback */</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_count</span> <span class="o">=</span> <span class="n">tx_count</span><span class="p">;</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_NCF_TX_ADDR</span><span class="p">,</span> <span class="n">tx_count</span><span class="p">);</span>

	<span class="cm">/* Disable the tx_ready interrupt */</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_ISR_TX_READY_BMSK</span><span class="p">;</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>
	<span class="n">msm_dmov_enqueue_cmd</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_tx_channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Start to receive the next chunk of data */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_start_rx_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_STALE_INT</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_DMRX_ADDR</span><span class="p">,</span> <span class="n">UARTDM_RX_BUF_SIZE</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">STALE_EVENT_ENABLE</span><span class="p">);</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">|=</span> <span class="n">UARTDM_ISR_RXLEV_BMSK</span><span class="p">;</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>

	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">FLUSH_NONE</span><span class="p">;</span>
	<span class="n">msm_dmov_enqueue_cmd</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_rx_channel</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">xfer</span><span class="p">);</span>

	<span class="cm">/* might have finished RX and be ready to clock off */</span>
	<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_timer</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_delay</span><span class="p">,</span>
			<span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Enable the transmitter Interrupt */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_start_tx_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">exit_lpm_cb</span><span class="p">)</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">exit_lpm_cb</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">tx_ready_int_en</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">tx_ready_int_en</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">msm_hs_submit_tx_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  This routine is called when we are done with a DMA transfer</span>
<span class="cm"> *</span>
<span class="cm"> *  This routine is registered with Data mover when we set</span>
<span class="cm"> *  up a Data Mover transfer. It is called from Data mover ISR</span>
<span class="cm"> *  when the DMA transfer is done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_dmov_tx_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_dmov_cmd</span> <span class="o">*</span><span class="n">cmd_ptr</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">msm_dmov_errdata</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span><span class="p">;</span>

	<span class="cm">/* DMA did not finish properly */</span>
	<span class="n">WARN_ON</span><span class="p">((((</span><span class="n">result</span> <span class="o">&amp;</span> <span class="n">RSLT_FIFO_CNTR_BMSK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">result</span> <span class="o">&amp;</span> <span class="n">RSLT_VLD</span><span class="p">));</span>

	<span class="n">msm_uport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cmd_ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_hs_port</span><span class="p">,</span> <span class="n">tx</span><span class="p">.</span><span class="n">xfer</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">|=</span> <span class="n">UARTDM_ISR_TX_READY_BMSK</span><span class="p">;</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine is called when we are done with a DMA transfer or the</span>
<span class="cm"> * a flush has been sent to the data mover driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is registered with Data mover when we set up a Data Mover</span>
<span class="cm"> *  transfer. It is called from Data mover ISR when the DMA transfer is done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_dmov_rx_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">msm_dmov_cmd</span> <span class="o">*</span><span class="n">cmd_ptr</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">msm_dmov_errdata</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">error_f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span><span class="p">;</span>

	<span class="n">msm_uport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cmd_ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_hs_port</span><span class="p">,</span> <span class="n">rx</span><span class="p">.</span><span class="n">xfer</span><span class="p">);</span>
	<span class="n">uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">tty</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">STALE_EVENT_DISABLE</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_SR_ADDR</span><span class="p">);</span>

	<span class="cm">/* overflow is not connect to data in a FIFO */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">UARTDM_SR_OVERRUN_BMSK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">&amp;</span> <span class="n">CREAD</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_OVERRUN</span><span class="p">);</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">buf_overrun</span><span class="o">++</span><span class="p">;</span>
		<span class="n">error_f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">&amp;</span> <span class="n">INPCK</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">UARTDM_SR_PAR_FRAME_BMSK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">UARTDM_SR_PAR_FRAME_BMSK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Can not tell difference between parity &amp; frame error */</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">parity</span><span class="o">++</span><span class="p">;</span>
		<span class="n">error_f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">&amp;</span> <span class="n">IGNPAR</span><span class="p">)</span>
			<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_PARITY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error_f</span><span class="p">)</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_ERROR_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_req_off_state</span> <span class="o">==</span> <span class="n">CLK_REQ_OFF_FLUSH_ISSUED</span><span class="p">)</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_req_off_state</span> <span class="o">=</span> <span class="n">CLK_REQ_OFF_RXSTALE_FLUSHED</span><span class="p">;</span>

	<span class="n">flush</span> <span class="o">=</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_IGNORE</span><span class="p">)</span>
		<span class="n">msm_hs_start_rx_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_STOP</span><span class="p">)</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">FLUSH_SHUTDOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">&gt;=</span> <span class="n">FLUSH_DATA_INVALID</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rx_count</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_RX_TOTAL_SNAP_ADDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">&amp;</span> <span class="n">CREAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">tty_insert_flip_string</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span>
						<span class="n">rx_count</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">rx_count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">msm_hs_start_rx_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">&lt;</span> <span class="n">FLUSH_DATA_INVALID</span><span class="p">)</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">msm_hs_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">tty_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_tty_flip_buffer_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span>
			<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_hs_port</span><span class="p">,</span> <span class="n">rx</span><span class="p">.</span><span class="n">tty_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">.</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>

	<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Standard API, Current states of modem control inputs</span>
<span class="cm"> *</span>
<span class="cm"> * Since CTS can be handled entirely by HARDWARE we always</span>
<span class="cm"> * indicate clear to send and count on the TX FIFO to block when</span>
<span class="cm"> * it fills up.</span>
<span class="cm"> *</span>
<span class="cm"> * - TIOCM_DCD</span>
<span class="cm"> * - TIOCM_CTS</span>
<span class="cm"> * - TIOCM_DSR</span>
<span class="cm"> * - TIOCM_RI</span>
<span class="cm"> *  (Unsupported) DCD and DSR will return them high. RI will return low.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">msm_hs_get_mctrl_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">TIOCM_DSR</span> <span class="o">|</span> <span class="n">TIOCM_CAR</span> <span class="o">|</span> <span class="n">TIOCM_CTS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * True enables UART auto RFR, which indicates we are ready for data if the RX</span>
<span class="cm"> * buffer is not full. False disables auto RFR, and deasserts RFR to indicate</span>
<span class="cm"> * we are not ready for data. Must be called with UART clock on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_rfr_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">auto_rfr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR1_ADDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">auto_rfr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable auto ready-for-receiving */</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">UARTDM_MR1_RX_RDY_CTL_BMSK</span><span class="p">;</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR1_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* disable auto ready-for-receiving */</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_MR1_RX_RDY_CTL_BMSK</span><span class="p">;</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR1_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="cm">/* RFR is active low, set high */</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RFR_HIGH</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Standard API, used to set or clear RFR</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_set_mctrl_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">auto_rfr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">auto_rfr</span> <span class="o">=</span> <span class="n">TIOCM_RTS</span> <span class="o">&amp;</span> <span class="n">mctrl</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">set_rfr_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">auto_rfr</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Standard API, Enable modem status (CTS) interrupt  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_enable_ms_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* Enable DELTA_CTS Interrupt */</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">|=</span> <span class="n">UARTDM_ISR_DELTA_CTS_BMSK</span><span class="p">;</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Standard API, Break Signal</span>
<span class="cm"> *</span>
<span class="cm"> * Control the transmission of a break signal. ctl eq 0 =&gt; break</span>
<span class="cm"> * signal terminate ctl ne 0 =&gt; start break signal</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_break_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">ctl</span> <span class="o">?</span> <span class="n">START_BREAK</span> <span class="o">:</span> <span class="n">STOP_BREAK</span><span class="p">);</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_config_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cfg_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_flags</span> <span class="o">&amp;</span> <span class="n">UART_CONFIG_TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PORT_MSM</span><span class="p">;</span>
		<span class="n">msm_hs_request_port</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  Handle CTS changes (Called from interrupt handler) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_handle_delta_cts_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* clear interrupt */</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_CTS</span><span class="p">);</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">cts</span><span class="o">++</span><span class="p">;</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* clear the IOCTL TIOCMIWAIT if called */</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">delta_msr_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* check if the TX path is flushed, and if so clock off</span>
<span class="cm"> * returns 0 did not clock off, need to retry (still sending final byte)</span>
<span class="cm"> *        -1 did not clock off, do not retry</span>
<span class="cm"> *         1 if we clocked off</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hs_check_clock_off_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sr_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>

	<span class="cm">/* Cancel if tx tty buffer is not empty, dma is in flight,</span>
<span class="cm">	 * or tx fifo is not empty, or rx fifo is not empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">!=</span> <span class="n">MSM_HS_CLK_REQUEST_OFF</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">tx_buf</span><span class="p">)</span> <span class="o">||</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">dma_in_flight</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">&amp;</span> <span class="n">UARTDM_ISR_TXLEV_BMSK</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">&amp;</span> <span class="n">UARTDM_ISR_RXLEV_BMSK</span><span class="p">))</span>  <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure the uart is finished with the last byte */</span>
	<span class="n">sr_status</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_SR_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sr_status</span> <span class="o">&amp;</span> <span class="n">UARTDM_SR_TXEMT_BMSK</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* retry */</span>

	<span class="cm">/* Make sure forced RXSTALE flush complete */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_req_off_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CLK_REQ_OFF_START</span>:
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_req_off_state</span> <span class="o">=</span> <span class="n">CLK_REQ_OFF_RXSTALE_ISSUED</span><span class="p">;</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">FORCE_STALE_EVENT</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* RXSTALE flush not complete - retry */</span>
	<span class="k">case</span> <span class="n">CLK_REQ_OFF_RXSTALE_ISSUED</span>:
	<span class="k">case</span> <span class="n">CLK_REQ_OFF_FLUSH_ISSUED</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* RXSTALE flush not complete - retry */</span>
	<span class="k">case</span> <span class="n">CLK_REQ_OFF_RXSTALE_FLUSHED</span>:
		<span class="k">break</span><span class="p">;</span>  <span class="cm">/* continue */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">!=</span> <span class="n">FLUSH_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_NONE</span><span class="p">)</span>
			<span class="n">msm_hs_stop_rx_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* come back later to really clock off */</span>
	<span class="p">}</span>

	<span class="cm">/* we really want to clock off */</span>
	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">=</span> <span class="n">MSM_HS_CLK_OFF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_low_power_rx_wakeup</span><span class="p">(</span><span class="n">msm_uport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">msm_hs_clk_off_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_hs_port</span><span class="p">,</span>
						     <span class="n">clk_off_timer</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msm_hs_check_clock_off_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hrtimer_forward_now</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_delay</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">HRTIMER_RESTART</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">msm_hs_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isr_status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_tx</span> <span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_rx</span> <span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">isr_status</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MISR_ADDR</span><span class="p">);</span>

	<span class="cm">/* Uart RX starting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isr_status</span> <span class="o">&amp;</span> <span class="n">UARTDM_ISR_RXLEV_BMSK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_ISR_RXLEV_BMSK</span><span class="p">;</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Stale rx interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isr_status</span> <span class="o">&amp;</span> <span class="n">UARTDM_ISR_RXSTALE_BMSK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">STALE_EVENT_DISABLE</span><span class="p">);</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_STALE_INT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_req_off_state</span> <span class="o">==</span> <span class="n">CLK_REQ_OFF_RXSTALE_ISSUED</span><span class="p">)</span>
			<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_req_off_state</span> <span class="o">=</span>
					<span class="n">CLK_REQ_OFF_FLUSH_ISSUED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rx</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">=</span> <span class="n">FLUSH_DATA_READY</span><span class="p">;</span>
			<span class="n">msm_dmov_stop_cmd</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_rx_channel</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* tx ready interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isr_status</span> <span class="o">&amp;</span> <span class="n">UARTDM_ISR_TX_READY_BMSK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear  TX Ready */</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">CLEAR_TX_READY</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">==</span> <span class="n">MSM_HS_CLK_REQUEST_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">|=</span> <span class="n">UARTDM_ISR_TXLEV_BMSK</span><span class="p">;</span>
			<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span>
				     <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Complete DMA TX transactions and submit new transactions */</span>
		<span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_count</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">UART_XMIT_SIZE</span><span class="p">;</span>

		<span class="n">tx</span><span class="o">-&gt;</span><span class="n">dma_in_flight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">uport</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span> <span class="o">+=</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_ready_int_en</span><span class="p">)</span>
			<span class="n">msm_hs_submit_tx_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_chars_pending</span><span class="p">(</span><span class="n">tx_buf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">WAKEUP_CHARS</span><span class="p">)</span>
			<span class="n">uart_write_wakeup</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isr_status</span> <span class="o">&amp;</span> <span class="n">UARTDM_ISR_TXLEV_BMSK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TX FIFO is empty */</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_ISR_TXLEV_BMSK</span><span class="p">;</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msm_hs_check_clock_off_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">))</span>
			<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_timer</span><span class="p">,</span>
				      <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_delay</span><span class="p">,</span>
				      <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Change in CTS interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isr_status</span> <span class="o">&amp;</span> <span class="n">UARTDM_ISR_DELTA_CTS_BMSK</span><span class="p">)</span>
		<span class="n">msm_hs_handle_delta_cts_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">msm_hs_request_clock_off_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">==</span> <span class="n">MSM_HS_CLK_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">=</span> <span class="n">MSM_HS_CLK_REQUEST_OFF</span><span class="p">;</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_req_off_state</span> <span class="o">=</span> <span class="n">CLK_REQ_OFF_START</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_low_power_rx_wakeup</span><span class="p">(</span><span class="n">msm_uport</span><span class="p">))</span>
			<span class="n">set_rfr_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">|=</span> <span class="n">UARTDM_ISR_TXLEV_BMSK</span><span class="p">;</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * msm_hs_request_clock_off - request to (i.e. asynchronously) turn off uart</span>
<span class="cm"> * clock once pending TX is flushed and Rx DMA command is terminated.</span>
<span class="cm"> * @uport: uart_port structure for the device instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This functions puts the device into a partially active low power mode. It</span>
<span class="cm"> * waits to complete all pending tx transactions, flushes ongoing Rx DMA</span>
<span class="cm"> * command and terminates UART side Rx transaction, puts UART HW in non DMA</span>
<span class="cm"> * mode and then clocks off the device. A client calls this when no UART</span>
<span class="cm"> * data is expected. msm_request_clock_on() must be called before any further</span>
<span class="cm"> * UART can be sent or received.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">msm_hs_request_clock_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">msm_hs_request_clock_off_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">msm_hs_request_clock_on_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MSM_HS_CLK_OFF</span>:
		<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
		<span class="cm">/* fall-through */</span>
	<span class="k">case</span> <span class="n">MSM_HS_CLK_REQUEST_OFF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_STOP</span> <span class="o">||</span>
		    <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_RX</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_DMEN_ADDR</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="n">UARTDM_RX_DM_EN_BMSK</span><span class="p">;</span>
			<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_DMEN_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">hrtimer_try_to_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_timer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_SHUTDOWN</span><span class="p">)</span>
			<span class="n">msm_hs_start_rx_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_low_power_rx_wakeup</span><span class="p">(</span><span class="n">msm_uport</span><span class="p">))</span>
			<span class="n">set_rfr_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_STOP</span><span class="p">)</span>
			<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">FLUSH_IGNORE</span><span class="p">;</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">=</span> <span class="n">MSM_HS_CLK_ON</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSM_HS_CLK_ON</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MSM_HS_CLK_PORT_OFF</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * msm_hs_request_clock_on - Switch the device from partially active low</span>
<span class="cm"> * power mode to fully active (i.e. clock on) mode.</span>
<span class="cm"> * @uport: uart_port structure for the device.</span>
<span class="cm"> *</span>
<span class="cm"> * This function switches on the input clock, puts UART HW into DMA mode</span>
<span class="cm"> * and enqueues an Rx DMA command if the device was in partially active</span>
<span class="cm"> * mode. It has no effect if called with the device in inactive state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">msm_hs_request_clock_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">msm_hs_request_clock_on_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">msm_hs_rx_wakeup_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">==</span> <span class="n">MSM_HS_CLK_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ignore the first irq - it is a pending irq that occurred</span>
<span class="cm">		 * before enable_irq() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">ignore</span><span class="p">)</span>
			<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">wakeup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wakeup</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* the uart was clocked off during an rx, wake up and</span>
<span class="cm">		 * optionally inject char into tty rx */</span>
		<span class="n">msm_hs_request_clock_on_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">inject_rx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tty</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>
			<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span>
					     <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">rx_to_inject</span><span class="p">,</span>
					     <span class="n">TTY_NORMAL</span><span class="p">);</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">msm_hs_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">tty_work</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">msm_hs_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PORT_MSM</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;MSM_HS_UART&quot;</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Called when port is opened */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hs_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rfr_level</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_tx</span> <span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_rx</span> <span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">;</span>

	<span class="n">rfr_level</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">fifosize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfr_level</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">rfr_level</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">dma_base</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_buf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">UART_XMIT_SIZE</span><span class="p">,</span>
				      <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="cm">/* do not let tty layer execute RX in global workqueue, use a</span>
<span class="cm">	 * dedicated workqueue managed by this driver */</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">low_latency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* turn on uart clk */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">msm_hs_init_clk_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Turning uartclk failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_msm_hs_init_clk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set auto RFR Level */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR1_ADDR</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_MR1_AUTO_RFR_LEVEL1_BMSK</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UARTDM_MR1_AUTO_RFR_LEVEL0_BMSK</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UARTDM_MR1_AUTO_RFR_LEVEL1_BMSK</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rfr_level</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UARTDM_MR1_AUTO_RFR_LEVEL0_BMSK</span> <span class="o">&amp;</span> <span class="n">rfr_level</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_MR1_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Make sure RXSTALE count is non-zero */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">msm_hs_read</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IPR_ADDR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="mh">0x1f</span> <span class="o">&amp;</span> <span class="n">UARTDM_IPR_STALE_LSB_BMSK</span><span class="p">;</span>
		<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IPR_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable Data Mover Mode */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">UARTDM_TX_DM_EN_BMSK</span> <span class="o">|</span> <span class="n">UARTDM_RX_DM_EN_BMSK</span><span class="p">;</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_DMEN_ADDR</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Reset TX */</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_TX</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_RX</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_ERROR_STATUS</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_BREAK_INT</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_STALE_INT</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RESET_CTS</span><span class="p">);</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">RFR_LOW</span><span class="p">);</span>
	<span class="cm">/* Turn on Uart Receiver */</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CR_RX_EN_BMSK</span><span class="p">);</span>

	<span class="cm">/* Turn on Uart Transmitter */</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CR_TX_EN_BMSK</span><span class="p">);</span>

	<span class="cm">/* Initialize the tx */</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">tx_ready_int_en</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">dma_in_flight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">.</span><span class="n">complete_func</span> <span class="o">=</span> <span class="n">msm_hs_dmov_tx_callback</span><span class="p">;</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">.</span><span class="n">execute_func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">CMD_LC</span> <span class="o">|</span>
	    <span class="n">CMD_DST_CRCI</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_tx_crci</span><span class="p">)</span> <span class="o">|</span> <span class="n">CMD_MODE_BOX</span><span class="p">;</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">src_dst_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSM_UARTDM_BURST_SIZE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
					   <span class="o">|</span> <span class="p">(</span><span class="n">MSM_UARTDM_BURST_SIZE</span><span class="p">);</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">row_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSM_UARTDM_BURST_SIZE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">dst_row_addr</span> <span class="o">=</span>
	    <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">.</span><span class="n">mapbase</span> <span class="o">+</span> <span class="n">UARTDM_TF_ADDR</span><span class="p">;</span>


	<span class="cm">/* Turn on Uart Receive */</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">.</span><span class="n">complete_func</span> <span class="o">=</span> <span class="n">msm_hs_dmov_rx_callback</span><span class="p">;</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">.</span><span class="n">execute_func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">CMD_LC</span> <span class="o">|</span>
	    <span class="n">CMD_SRC_CRCI</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_rx_crci</span><span class="p">)</span> <span class="o">|</span> <span class="n">CMD_MODE_BOX</span><span class="p">;</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">src_dst_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSM_UARTDM_BURST_SIZE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
					   <span class="o">|</span> <span class="p">(</span><span class="n">MSM_UARTDM_BURST_SIZE</span><span class="p">);</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">row_offset</span> <span class="o">=</span>  <span class="n">MSM_UARTDM_BURST_SIZE</span><span class="p">;</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">src_row_addr</span> <span class="o">=</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">mapbase</span> <span class="o">+</span> <span class="n">UARTDM_RF_ADDR</span><span class="p">;</span>


	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">|=</span> <span class="n">UARTDM_ISR_RXSTALE_BMSK</span><span class="p">;</span>
	<span class="cm">/* Enable reading the current CTS, no harm even if CTS is ignored */</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">|=</span> <span class="n">UARTDM_ISR_CURRENT_CTS_BMSK</span><span class="p">;</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_TFWR_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* TXLEV on empty TX fifo */</span>


	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">msm_hs_isr</span><span class="p">,</span> <span class="n">IRQF_TRIGGER_HIGH</span><span class="p">,</span>
			  <span class="s">&quot;msm_hs_uart&quot;</span><span class="p">,</span> <span class="n">msm_uport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Request msm_hs_uart IRQ failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_request_irq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_low_power_rx_wakeup</span><span class="p">(</span><span class="n">msm_uport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span>
				  <span class="n">msm_hs_rx_wakeup_isr</span><span class="p">,</span>
				  <span class="n">IRQF_TRIGGER_FALLING</span><span class="p">,</span>
				  <span class="s">&quot;msm_hs_rx_wakeup&quot;</span><span class="p">,</span> <span class="n">msm_uport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Request msm_hs_rx_wakeup IRQ failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">msm_uport</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_request_irq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_RFWR_ADDR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">msm_hs_start_rx_locked</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;set active error:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_request_irq:</span>
<span class="nl">err_msm_hs_init_clk:</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">dma_base</span><span class="p">,</span>
				<span class="n">UART_XMIT_SIZE</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize tx and rx data structures */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">uartdm_init_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">msm_hs_tx</span> <span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_rx</span> <span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">;</span>

	<span class="cm">/* Allocate the command pointer. Needs to be 64 bit aligned */</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dmov_box</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr_ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_tx_command_ptr_ptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">mapped_cmd_ptr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="n">dmov_box</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">mapped_cmd_ptr_ptr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">tx</span><span class="o">-&gt;</span><span class="n">command_ptr_ptr</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">tx</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">.</span><span class="n">cmdptr</span> <span class="o">=</span> <span class="n">DMOV_CMD_ADDR</span><span class="p">(</span><span class="n">tx</span><span class="o">-&gt;</span><span class="n">mapped_cmd_ptr_ptr</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">pool</span> <span class="o">=</span> <span class="n">dma_pool_create</span><span class="p">(</span><span class="s">&quot;rx_buffer_pool&quot;</span><span class="p">,</span> <span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				   <span class="n">UARTDM_RX_BUF_SIZE</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(): cannot allocate rx_buffer_pool&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_dma_pool_create</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">dma_pool_alloc</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">rbuffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(): cannot allocate rx-&gt;buffer&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_dma_pool_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate the command pointer. Needs to be 64 bit aligned */</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dmov_box</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(): cannot allocate rx-&gt;command_ptr&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_rx_command_ptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr_ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s(): cannot allocate rx-&gt;command_ptr_ptr&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_rx_command_ptr_ptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="p">((</span><span class="n">UARTDM_RX_BUF_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					 <span class="p">(</span><span class="n">UARTDM_RX_BUF_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="o">-&gt;</span><span class="n">dst_row_addr</span> <span class="o">=</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">rbuffer</span><span class="p">;</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">mapped_cmd_ptr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="n">dmov_box</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="o">*</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr_ptr</span> <span class="o">=</span> <span class="n">CMD_PTR_LP</span> <span class="o">|</span> <span class="n">DMOV_CMD_ADDR</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">mapped_cmd_ptr</span><span class="p">);</span>

	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">cmdptr_dmaaddr</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr_ptr</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">rx</span><span class="o">-&gt;</span><span class="n">xfer</span><span class="p">.</span><span class="n">cmdptr</span> <span class="o">=</span> <span class="n">DMOV_CMD_ADDR</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">cmdptr_dmaaddr</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">tty_work</span><span class="p">,</span> <span class="n">msm_hs_tty_flip_buffer_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">err_rx_command_ptr_ptr:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rx</span><span class="o">-&gt;</span><span class="n">command_ptr</span><span class="p">);</span>
<span class="nl">err_rx_command_ptr:</span>
	<span class="n">dma_pool_free</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">pool</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span>
						<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">rbuffer</span><span class="p">);</span>
<span class="nl">err_dma_pool_alloc:</span>
	<span class="n">dma_pool_destroy</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">pool</span><span class="p">);</span>
<span class="nl">err_dma_pool_create:</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">mapped_cmd_ptr_ptr</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">mapped_cmd_ptr</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">dmov_box</span><span class="p">),</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">command_ptr_ptr</span><span class="p">);</span>
<span class="nl">err_tx_command_ptr_ptr:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">command_ptr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">msm_hs_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">resource</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">msm_serial_hs_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span>
						<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">UARTDM_NR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Invalid plaform device ID = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msm_uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q_uart_port</span><span class="p">[</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="n">uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">;</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">resource</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">resource</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">mapbase</span> <span class="o">=</span> <span class="n">resource</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irq_set_irq_wake</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rx_wakeup_irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rx_wakeup_irq</span><span class="p">;</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">inject_rx</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">inject_rx_on_wakeup</span><span class="p">;</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">rx_to_inject</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">rx_to_inject</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irq_set_irq_wake</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">exit_lpm_cb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">exit_lpm_cb</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">exit_lpm_cb</span><span class="p">;</span>

	<span class="n">resource</span> <span class="o">=</span> <span class="n">platform_get_resource_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_DMA</span><span class="p">,</span>
						<span class="s">&quot;uartdm_channels&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">resource</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_tx_channel</span> <span class="o">=</span> <span class="n">resource</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_rx_channel</span> <span class="o">=</span> <span class="n">resource</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>

	<span class="n">resource</span> <span class="o">=</span> <span class="n">platform_get_resource_byname</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_DMA</span><span class="p">,</span>
						<span class="s">&quot;uartdm_crci&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">resource</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_tx_crci</span> <span class="o">=</span> <span class="n">resource</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">dma_rx_crci</span> <span class="o">=</span> <span class="n">resource</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">iotype</span> <span class="o">=</span> <span class="n">UPIO_MEM</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">fifosize</span> <span class="o">=</span> <span class="n">UART_FIFOSIZE</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_hs_ops</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UPF_BOOT_AUTOCONF</span><span class="p">;</span>
	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">uartclk</span> <span class="o">=</span> <span class="n">UARTCLK</span><span class="p">;</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;uartdm_clk&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uartdm_init_port</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">=</span> <span class="n">MSM_HS_CLK_PORT_OFF</span><span class="p">;</span>
	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span>
		     <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">msm_hs_clk_off_retry</span><span class="p">;</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_off_delay</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">);</span>  <span class="cm">/* 1ms */</span>

	<span class="n">uport</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">uart_add_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_hs_driver</span><span class="p">,</span> <span class="n">uport</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">msm_serial_hs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Init all UARTS as non-configured */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UARTDM_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">q_uart_port</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">uport</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PORT_UNKNOWN</span><span class="p">;</span>

	<span class="n">msm_hs_workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;msm_serial_hs&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">msm_hs_workqueue</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_hs_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s failed to load</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_uart_register_driver</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_serial_hs_platform_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s failed to load</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_platform_driver_register</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">err_platform_driver_register:</span>
	<span class="n">uart_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_hs_driver</span><span class="p">);</span>
<span class="nl">err_uart_register_driver:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">msm_hs_workqueue</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">msm_serial_hs_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Called by the upper layer when port is closed.</span>
<span class="cm"> *     - Disables the port</span>
<span class="cm"> *     - Unhook the ISR</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_hs_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">uport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="n">UARTDM_TO_MSM</span><span class="p">(</span><span class="n">uport</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">&lt;</span> <span class="n">FLUSH_STOP</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">clk_enable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="cm">/* Disable the transmitter */</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CR_TX_DISABLE_BMSK</span><span class="p">);</span>
	<span class="cm">/* Disable the receiver */</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_CR_ADDR</span><span class="p">,</span> <span class="n">UARTDM_CR_RX_DISABLE_BMSK</span><span class="p">);</span>

	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_set_suspended</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Free the interrupt */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">msm_uport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_low_power_rx_wakeup</span><span class="p">(</span><span class="n">msm_uport</span><span class="p">))</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx_wakeup</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">msm_uport</span><span class="p">);</span>

	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msm_hs_write</span><span class="p">(</span><span class="n">uport</span><span class="p">,</span> <span class="n">UARTDM_IMR_ADDR</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">imr_reg</span><span class="p">);</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">flush</span> <span class="o">==</span> <span class="n">FLUSH_SHUTDOWN</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>  <span class="cm">/* to balance local clk_enable() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">!=</span> <span class="n">MSM_HS_CLK_OFF</span><span class="p">)</span>
		<span class="n">clk_disable</span><span class="p">(</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>  <span class="cm">/* to balance clk_state */</span>
	<span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">clk_state</span> <span class="o">=</span> <span class="n">MSM_HS_CLK_PORT_OFF</span><span class="p">;</span>

	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">dma_base</span><span class="p">,</span>
			 <span class="n">UART_XMIT_SIZE</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uport</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">tty_work</span><span class="p">))</span>
		<span class="n">msm_hs_tty_flip_buffer_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">.</span><span class="n">tty_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">msm_serial_hs_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">msm_hs_workqueue</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">msm_hs_workqueue</span><span class="p">);</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_serial_hs_platform_driver</span><span class="p">);</span>
	<span class="n">uart_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_hs_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">msm_serial_hs_exit</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hs_runtime_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * returning success from idle results in runtime suspend to be</span>
<span class="cm">	 * called</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hs_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span>
						    <span class="n">platform_device</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q_uart_port</span><span class="p">[</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="n">msm_hs_request_clock_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_hs_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span>
						    <span class="n">platform_device</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">msm_hs_port</span> <span class="o">*</span><span class="n">msm_uport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q_uart_port</span><span class="p">[</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="n">msm_hs_request_clock_off</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_uport</span><span class="o">-&gt;</span><span class="n">uport</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define msm_hs_runtime_idle NULL</span>
<span class="cp">#define msm_hs_runtime_resume NULL</span>
<span class="cp">#define msm_hs_runtime_suspend NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">msm_hs_dev_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">runtime_suspend</span> <span class="o">=</span> <span class="n">msm_hs_runtime_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_resume</span>  <span class="o">=</span> <span class="n">msm_hs_runtime_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_idle</span>    <span class="o">=</span> <span class="n">msm_hs_runtime_idle</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">msm_serial_hs_platform_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">msm_hs_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">msm_hs_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;msm_serial_hs&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pm</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">msm_hs_dev_pm_ops</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_driver</span> <span class="n">msm_hs_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver_name</span> <span class="o">=</span> <span class="s">&quot;msm_serial_hs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span> <span class="o">=</span> <span class="s">&quot;ttyHS&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">UARTDM_NR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cons</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_ops</span> <span class="n">msm_hs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">tx_empty</span> <span class="o">=</span> <span class="n">msm_hs_tx_empty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mctrl</span> <span class="o">=</span> <span class="n">msm_hs_set_mctrl_locked</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_mctrl</span> <span class="o">=</span> <span class="n">msm_hs_get_mctrl_locked</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_tx</span> <span class="o">=</span> <span class="n">msm_hs_stop_tx_locked</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_tx</span> <span class="o">=</span> <span class="n">msm_hs_start_tx_locked</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_rx</span> <span class="o">=</span> <span class="n">msm_hs_stop_rx_locked</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_ms</span> <span class="o">=</span> <span class="n">msm_hs_enable_ms_locked</span><span class="p">,</span>
	<span class="p">.</span><span class="n">break_ctl</span> <span class="o">=</span> <span class="n">msm_hs_break_ctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">startup</span> <span class="o">=</span> <span class="n">msm_hs_startup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">msm_hs_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span> <span class="o">=</span> <span class="n">msm_hs_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="n">msm_hs_pm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">msm_hs_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">config_port</span> <span class="o">=</span> <span class="n">msm_hs_config_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_port</span> <span class="o">=</span> <span class="n">msm_hs_release_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">request_port</span> <span class="o">=</span> <span class="n">msm_hs_request_port</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;High Speed UART Driver for the MSM chipset&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;1.2&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
