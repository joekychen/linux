<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › serial › ucc_uart.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ucc_uart.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Freescale QUICC Engine UART device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Timur Tabi &lt;timur@freescale.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2007 Freescale Semiconductor, Inc.  This file is licensed under</span>
<span class="cm"> * the terms of the GNU General Public License version 2.  This program</span>
<span class="cm"> * is licensed &quot;as is&quot; without any warranty of any kind, whether express</span>
<span class="cm"> * or implied.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver adds support for UART devices via Freescale&#39;s QUICC Engine</span>
<span class="cm"> * found on some Freescale SOCs.</span>
<span class="cm"> *</span>
<span class="cm"> * If Soft-UART support is needed but not already present, then this driver</span>
<span class="cm"> * will request and upload the &quot;Soft-UART&quot; microcode upon probe.  The</span>
<span class="cm"> * filename of the microcode should be fsl_qe_ucode_uart_X_YZ.bin, where &quot;X&quot;</span>
<span class="cm"> * is the name of the SOC (e.g. 8323), and YZ is the revision of the SOC,</span>
<span class="cm"> * (e.g. &quot;11&quot; for 1.1).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/serial.h&gt;</span>
<span class="cp">#include &lt;linux/serial_core.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>

<span class="cp">#include &lt;linux/fs_uart_pd.h&gt;</span>
<span class="cp">#include &lt;asm/ucc_slow.h&gt;</span>

<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;asm/reg.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The GUMR flag for Soft UART.  This would normally be defined in qe.h,</span>
<span class="cm"> * but Soft-UART is a hack and we want to keep everything related to it in</span>
<span class="cm"> * this file.</span>
<span class="cm"> */</span>
<span class="cp">#define UCC_SLOW_GUMR_H_SUART   	0x00004000      </span><span class="cm">/* Soft-UART */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * soft_uart is 1 if we need to use Soft-UART mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">soft_uart</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * firmware_loaded is 1 if the firmware has been loaded, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">firmware_loaded</span><span class="p">;</span>

<span class="cm">/* Enable this macro to configure all serial ports in internal loopback</span>
<span class="cm">   mode */</span>
<span class="cm">/* #define LOOPBACK */</span>

<span class="cm">/* The major and minor device numbers are defined in</span>
<span class="cm"> * http://www.lanana.org/docs/device-list/devices-2.6+.txt.  For the QE</span>
<span class="cm"> * UART, we have major number 204 and minor numbers 46 - 49, which are the</span>
<span class="cm"> * same as for the CPM2.  This decision was made because no Freescale part</span>
<span class="cm"> * has both a CPM and a QE.</span>
<span class="cm"> */</span>
<span class="cp">#define SERIAL_QE_MAJOR 204</span>
<span class="cp">#define SERIAL_QE_MINOR 46</span>

<span class="cm">/* Since we only have minor numbers 46 - 49, there is a hard limit of 4 ports */</span>
<span class="cp">#define UCC_MAX_UART    4</span>

<span class="cm">/* The number of buffer descriptors for receiving characters. */</span>
<span class="cp">#define RX_NUM_FIFO     4</span>

<span class="cm">/* The number of buffer descriptors for transmitting characters. */</span>
<span class="cp">#define TX_NUM_FIFO     4</span>

<span class="cm">/* The maximum size of the character buffer for a single RX BD. */</span>
<span class="cp">#define RX_BUF_SIZE     32</span>

<span class="cm">/* The maximum size of the character buffer for a single TX BD. */</span>
<span class="cp">#define TX_BUF_SIZE     32</span>

<span class="cm">/*</span>
<span class="cm"> * The number of jiffies to wait after receiving a close command before the</span>
<span class="cm"> * device is actually closed.  This allows the last few characters to be</span>
<span class="cm"> * sent over the wire.</span>
<span class="cm"> */</span>
<span class="cp">#define UCC_WAIT_CLOSING 100</span>

<span class="k">struct</span> <span class="n">ucc_uart_pram</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ucc_slow_pram</span> <span class="n">common</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">res1</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>     	<span class="cm">/* reserved */</span>
	<span class="n">__be16</span> <span class="n">maxidl</span><span class="p">;</span>  	<span class="cm">/* Maximum idle chars */</span>
	<span class="n">__be16</span> <span class="n">idlc</span><span class="p">;</span>    	<span class="cm">/* temp idle counter */</span>
	<span class="n">__be16</span> <span class="n">brkcr</span><span class="p">;</span>   	<span class="cm">/* Break count register */</span>
	<span class="n">__be16</span> <span class="n">parec</span><span class="p">;</span>   	<span class="cm">/* receive parity error counter */</span>
	<span class="n">__be16</span> <span class="n">frmec</span><span class="p">;</span>   	<span class="cm">/* receive framing error counter */</span>
	<span class="n">__be16</span> <span class="n">nosec</span><span class="p">;</span>   	<span class="cm">/* receive noise counter */</span>
	<span class="n">__be16</span> <span class="n">brkec</span><span class="p">;</span>   	<span class="cm">/* receive break condition counter */</span>
	<span class="n">__be16</span> <span class="n">brkln</span><span class="p">;</span>   	<span class="cm">/* last received break length */</span>
	<span class="n">__be16</span> <span class="n">uaddr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* UART address character 1 &amp; 2 */</span>
	<span class="n">__be16</span> <span class="n">rtemp</span><span class="p">;</span>   	<span class="cm">/* Temp storage */</span>
	<span class="n">__be16</span> <span class="n">toseq</span><span class="p">;</span>   	<span class="cm">/* Transmit out of sequence char */</span>
	<span class="n">__be16</span> <span class="n">cchars</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>       <span class="cm">/* control characters 1-8 */</span>
	<span class="n">__be16</span> <span class="n">rccm</span><span class="p">;</span>    	<span class="cm">/* receive control character mask */</span>
	<span class="n">__be16</span> <span class="n">rccr</span><span class="p">;</span>    	<span class="cm">/* receive control character register */</span>
	<span class="n">__be16</span> <span class="n">rlbc</span><span class="p">;</span>    	<span class="cm">/* receive last break character */</span>
	<span class="n">__be16</span> <span class="n">res2</span><span class="p">;</span>    	<span class="cm">/* reserved */</span>
	<span class="n">__be32</span> <span class="n">res3</span><span class="p">;</span>    	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">u8</span> <span class="n">res4</span><span class="p">;</span>		<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">u8</span> <span class="n">res5</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>     	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">__be32</span> <span class="n">res6</span><span class="p">;</span>    	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">__be32</span> <span class="n">res7</span><span class="p">;</span>    	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">__be32</span> <span class="n">res8</span><span class="p">;</span>    	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">__be32</span> <span class="n">res9</span><span class="p">;</span>    	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">__be32</span> <span class="n">res10</span><span class="p">;</span>   	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">__be32</span> <span class="n">res11</span><span class="p">;</span>   	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">__be32</span> <span class="n">res12</span><span class="p">;</span>   	<span class="cm">/* reserved, should be cleared */</span>
	<span class="n">__be32</span> <span class="n">res13</span><span class="p">;</span>   	<span class="cm">/* reserved, should be cleared */</span>
<span class="cm">/* The rest is for Soft-UART only */</span>
	<span class="n">__be16</span> <span class="n">supsmr</span><span class="p">;</span>  	<span class="cm">/* 0x90, Shadow UPSMR */</span>
	<span class="n">__be16</span> <span class="n">res92</span><span class="p">;</span>   	<span class="cm">/* 0x92, reserved, initialize to 0 */</span>
	<span class="n">__be32</span> <span class="n">rx_state</span><span class="p">;</span>	<span class="cm">/* 0x94, RX state, initialize to 0 */</span>
	<span class="n">__be32</span> <span class="n">rx_cnt</span><span class="p">;</span>  	<span class="cm">/* 0x98, RX count, initialize to 0 */</span>
	<span class="n">u8</span> <span class="n">rx_length</span><span class="p">;</span>   	<span class="cm">/* 0x9C, Char length, set to 1+CL+PEN+1+SL */</span>
	<span class="n">u8</span> <span class="n">rx_bitmark</span><span class="p">;</span>  	<span class="cm">/* 0x9D, reserved, initialize to 0 */</span>
	<span class="n">u8</span> <span class="n">rx_temp_dlst_qe</span><span class="p">;</span>     <span class="cm">/* 0x9E, reserved, initialize to 0 */</span>
	<span class="n">u8</span> <span class="n">res14</span><span class="p">[</span><span class="mh">0xBC</span> <span class="o">-</span> <span class="mh">0x9F</span><span class="p">];</span>  <span class="cm">/* reserved */</span>
	<span class="n">__be32</span> <span class="n">dump_ptr</span><span class="p">;</span>	<span class="cm">/* 0xBC, Dump pointer */</span>
	<span class="n">__be32</span> <span class="n">rx_frame_rem</span><span class="p">;</span>    <span class="cm">/* 0xC0, reserved, initialize to 0 */</span>
	<span class="n">u8</span> <span class="n">rx_frame_rem_size</span><span class="p">;</span>   <span class="cm">/* 0xC4, reserved, initialize to 0 */</span>
	<span class="n">u8</span> <span class="n">tx_mode</span><span class="p">;</span>     	<span class="cm">/* 0xC5, mode, 0=AHDLC, 1=UART */</span>
	<span class="n">__be16</span> <span class="n">tx_state</span><span class="p">;</span>	<span class="cm">/* 0xC6, TX state */</span>
	<span class="n">u8</span> <span class="n">res15</span><span class="p">[</span><span class="mh">0xD0</span> <span class="o">-</span> <span class="mh">0xC8</span><span class="p">];</span>  <span class="cm">/* reserved */</span>
	<span class="n">__be32</span> <span class="n">resD0</span><span class="p">;</span>   	<span class="cm">/* 0xD0, reserved, initialize to 0 */</span>
	<span class="n">u8</span> <span class="n">resD4</span><span class="p">;</span>       	<span class="cm">/* 0xD4, reserved, initialize to 0 */</span>
	<span class="n">__be16</span> <span class="n">resD5</span><span class="p">;</span>   	<span class="cm">/* 0xD5, reserved, initialize to 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* SUPSMR definitions, for Soft-UART only */</span>
<span class="cp">#define UCC_UART_SUPSMR_SL      	0x8000</span>
<span class="cp">#define UCC_UART_SUPSMR_RPM_MASK	0x6000</span>
<span class="cp">#define UCC_UART_SUPSMR_RPM_ODD 	0x0000</span>
<span class="cp">#define UCC_UART_SUPSMR_RPM_LOW 	0x2000</span>
<span class="cp">#define UCC_UART_SUPSMR_RPM_EVEN	0x4000</span>
<span class="cp">#define UCC_UART_SUPSMR_RPM_HIGH	0x6000</span>
<span class="cp">#define UCC_UART_SUPSMR_PEN     	0x1000</span>
<span class="cp">#define UCC_UART_SUPSMR_TPM_MASK	0x0C00</span>
<span class="cp">#define UCC_UART_SUPSMR_TPM_ODD 	0x0000</span>
<span class="cp">#define UCC_UART_SUPSMR_TPM_LOW 	0x0400</span>
<span class="cp">#define UCC_UART_SUPSMR_TPM_EVEN	0x0800</span>
<span class="cp">#define UCC_UART_SUPSMR_TPM_HIGH	0x0C00</span>
<span class="cp">#define UCC_UART_SUPSMR_FRZ     	0x0100</span>
<span class="cp">#define UCC_UART_SUPSMR_UM_MASK 	0x00c0</span>
<span class="cp">#define UCC_UART_SUPSMR_UM_NORMAL       0x0000</span>
<span class="cp">#define UCC_UART_SUPSMR_UM_MAN_MULTI    0x0040</span>
<span class="cp">#define UCC_UART_SUPSMR_UM_AUTO_MULTI   0x00c0</span>
<span class="cp">#define UCC_UART_SUPSMR_CL_MASK 	0x0030</span>
<span class="cp">#define UCC_UART_SUPSMR_CL_8    	0x0030</span>
<span class="cp">#define UCC_UART_SUPSMR_CL_7    	0x0020</span>
<span class="cp">#define UCC_UART_SUPSMR_CL_6    	0x0010</span>
<span class="cp">#define UCC_UART_SUPSMR_CL_5    	0x0000</span>

<span class="cp">#define UCC_UART_TX_STATE_AHDLC 	0x00</span>
<span class="cp">#define UCC_UART_TX_STATE_UART  	0x01</span>
<span class="cp">#define UCC_UART_TX_STATE_X1    	0x00</span>
<span class="cp">#define UCC_UART_TX_STATE_X16   	0x80</span>

<span class="cp">#define UCC_UART_PRAM_ALIGNMENT 0x100</span>

<span class="cp">#define UCC_UART_SIZE_OF_BD     UCC_SLOW_SIZE_OF_BD</span>
<span class="cp">#define NUM_CONTROL_CHARS       8</span>

<span class="cm">/* Private per-port data structure */</span>
<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ucc_slow</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uccp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ucc_uart_pram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uccup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ucc_slow_info</span> <span class="n">us_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ucc_slow_private</span> <span class="o">*</span><span class="n">us_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ucc_num</span><span class="p">;</span>   <span class="cm">/* First ucc is 0, not 1 */</span>

	<span class="n">u16</span> <span class="n">rx_nrfifos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rx_fifosize</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_nrfifos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tx_fifosize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait_closing</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qe_bd</span> <span class="o">*</span><span class="n">rx_bd_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qe_bd</span> <span class="o">*</span><span class="n">rx_cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qe_bd</span> <span class="o">*</span><span class="n">tx_bd_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qe_bd</span> <span class="o">*</span><span class="n">tx_cur</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tx_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rx_buf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bd_virt</span><span class="p">;</span>  	<span class="cm">/* virtual address of the BD buffers */</span>
	<span class="n">dma_addr_t</span> <span class="n">bd_dma_addr</span><span class="p">;</span> <span class="cm">/* bus address of the BD buffers */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bd_size</span><span class="p">;</span>   <span class="cm">/* size of BD buffer space */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_driver</span> <span class="n">ucc_uart_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>  	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver_name</span>    <span class="o">=</span> <span class="s">&quot;ucc_uart&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_name</span>       <span class="o">=</span> <span class="s">&quot;ttyQE&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">major</span>  	<span class="o">=</span> <span class="n">SERIAL_QE_MAJOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">minor</span>  	<span class="o">=</span> <span class="n">SERIAL_QE_MINOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nr</span>     	<span class="o">=</span> <span class="n">UCC_MAX_UART</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Virtual to physical address translation.</span>
<span class="cm"> *</span>
<span class="cm"> * Given the virtual address for a character buffer, this function returns</span>
<span class="cm"> * the physical (DMA) equivalent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">dma_addr_t</span> <span class="nf">cpu2qe_addr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_virt</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_virt</span> <span class="o">+</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_size</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_dma_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_virt</span><span class="p">);</span>

	<span class="cm">/* something nasty happened */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: addr=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Physical to virtual address translation.</span>
<span class="cm"> *</span>
<span class="cm"> * Given the physical (DMA) address for a character buffer, this function</span>
<span class="cm"> * returns the virtual equivalent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">qe2cpu_addr</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_dma_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_dma_addr</span> <span class="o">+</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_size</span><span class="p">))))</span>
		<span class="k">return</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_virt</span> <span class="o">+</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_dma_addr</span><span class="p">);</span>

	<span class="cm">/* something nasty happened */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: addr=%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return 1 if the QE is done transmitting all buffers for this port</span>
<span class="cm"> *</span>
<span class="cm"> * This function scans each BD in sequence.  If we find a BD that is not</span>
<span class="cm"> * ready (READY=1), then we return 0 indicating that the QE is still sending</span>
<span class="cm"> * data.  If we reach the last BD (WRAP=1), then we know we&#39;ve scanned</span>
<span class="cm"> * the entire list, and all BDs are done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">qe_uart_tx_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">qe_bd</span> <span class="o">*</span><span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BD_SC_READY</span><span class="p">)</span>
			<span class="cm">/* This BD is not done, so return &quot;not done&quot; */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BD_SC_WRAP</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * This BD is done and it&#39;s the last one, so return</span>
<span class="cm">			 * &quot;done&quot;</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">bdp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the modem control lines</span>
<span class="cm"> *</span>
<span class="cm"> * Although the QE can control the modem control lines (e.g. CTS), we</span>
<span class="cm"> * don&#39;t need that support. This function must exist, however, otherwise</span>
<span class="cm"> * the kernel will panic.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qe_uart_set_mctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mctrl</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the current modem control line status</span>
<span class="cm"> *</span>
<span class="cm"> * Although the QE can control the modem control lines (e.g. CTS), this</span>
<span class="cm"> * driver currently doesn&#39;t support that, so we always return Carrier</span>
<span class="cm"> * Detect, Data Set Ready, and Clear To Send.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">qe_uart_get_mctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">TIOCM_CAR</span> <span class="o">|</span> <span class="n">TIOCM_DSR</span> <span class="o">|</span> <span class="n">TIOCM_CTS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable the transmit interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Although this function is called &quot;stop_tx&quot;, it does not actually stop</span>
<span class="cm"> * transmission of data.  Instead, it tells the QE to not generate an</span>
<span class="cm"> * interrupt when the UCC is finished sending characters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">clrbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">uccm</span><span class="p">,</span> <span class="n">UCC_UART_UCCE_TX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transmit as many characters to the HW as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will attempt to stuff of all the characters from the</span>
<span class="cm"> * kernel&#39;s transmit buffer into TX BDs.</span>
<span class="cm"> *</span>
<span class="cm"> * A return value of non-zero indicates that it successfully stuffed all</span>
<span class="cm"> * characters from the kernel buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * A return value of zero indicates that there are still characters in the</span>
<span class="cm"> * kernel&#39;s buffer that have not been transmitted, but there are no more BDs</span>
<span class="cm"> * available.  This function should be called again after a BD has been made</span>
<span class="cm"> * available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qe_uart_tx_pump</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qe_bd</span> <span class="o">*</span><span class="n">bdp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">circ_buf</span> <span class="o">*</span><span class="n">xmit</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>

	<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_cur</span><span class="p">;</span>

	<span class="cm">/* Handle xon/xoff */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">x_char</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Pick next descriptor and fill from buffer */</span>
		<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_cur</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">qe2cpu_addr</span><span class="p">(</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">);</span>

		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">x_char</span><span class="p">;</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">setbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">BD_SC_READY</span><span class="p">);</span>
		<span class="cm">/* Get next BD. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BD_SC_WRAP</span><span class="p">)</span>
			<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bdp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_cur</span> <span class="o">=</span> <span class="n">bdp</span><span class="p">;</span>

		<span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">xmit</span><span class="p">)</span> <span class="o">||</span> <span class="n">uart_tx_stopped</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">qe_uart_stop_tx</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Pick next descriptor and fill from buffer */</span>
	<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_cur</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BD_SC_READY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">!=</span> <span class="n">xmit</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">qe2cpu_addr</span><span class="p">(</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_fifosize</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xmit</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">];</span>
			<span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UART_XMIT_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">setbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">BD_SC_READY</span><span class="p">);</span>

		<span class="cm">/* Get next BD. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BD_SC_WRAP</span><span class="p">)</span>
			<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bdp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_cur</span> <span class="o">=</span> <span class="n">bdp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_chars_pending</span><span class="p">(</span><span class="n">xmit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">WAKEUP_CHARS</span><span class="p">)</span>
		<span class="n">uart_write_wakeup</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">xmit</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* The kernel buffer is empty, so turn off TX interrupts.  We</span>
<span class="cm">		   don&#39;t need to be told when the QE is finished transmitting</span>
<span class="cm">		   the data. */</span>
		<span class="n">qe_uart_stop_tx</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start transmitting data</span>
<span class="cm"> *</span>
<span class="cm"> * This function will start transmitting any available data, if the port</span>
<span class="cm"> * isn&#39;t already transmitting data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_start_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="cm">/* If we currently are transmitting, then just return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">uccm</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UCC_UART_UCCE_TX</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Otherwise, pump the port and start transmission */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qe_uart_tx_pump</span><span class="p">(</span><span class="n">qe_port</span><span class="p">))</span>
		<span class="n">setbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">uccm</span><span class="p">,</span> <span class="n">UCC_UART_UCCE_TX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop transmitting data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_stop_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">clrbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">uccm</span><span class="p">,</span> <span class="n">UCC_UART_UCCE_RX</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Enable status change interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t support status change interrupts, but we need to define this</span>
<span class="cm"> * function otherwise the kernel will panic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_enable_ms</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* Start or stop sending  break signal</span>
<span class="cm"> *</span>
<span class="cm"> * This function controls the sending of a break signal.  If break_state=1,</span>
<span class="cm"> * then we start sending a break signal.  If break_state=0, then we stop</span>
<span class="cm"> * sending the break signal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_break_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">break_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">break_state</span><span class="p">)</span>
		<span class="n">ucc_slow_stop_tx</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_private</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ucc_slow_restart_tx</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ISR helper function for receiving character.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the ISR to handling receiving characters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_int_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">,</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">tty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qe_bd</span> <span class="o">*</span><span class="n">bdp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flg</span><span class="p">;</span>

	<span class="cm">/* Just loop through the closed BDs and copy the characters into</span>
<span class="cm">	 * the buffer.</span>
<span class="cm">	 */</span>
	<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_cur</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

		<span class="cm">/* If this one is empty, then we assume we&#39;ve read them all */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_EMPTY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* get number of characters, and check space in RX buffer */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

		<span class="cm">/* If we don&#39;t have enough room in RX buffer for the entire BD,</span>
<span class="cm">		 * then we try later, which will be the next RX interrupt.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tty_buffer_request_room</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ucc-uart: no room in RX buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* get pointer */</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">qe2cpu_addr</span><span class="p">(</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">);</span>

		<span class="cm">/* loop through the buffer */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">;</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">rx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">flg</span> <span class="o">=</span> <span class="n">TTY_NORMAL</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">status</span> <span class="o">&amp;</span>
			    <span class="p">(</span><span class="n">BD_SC_BR</span> <span class="o">|</span> <span class="n">BD_SC_FR</span> <span class="o">|</span> <span class="n">BD_SC_PR</span> <span class="o">|</span> <span class="n">BD_SC_OV</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">handle_error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uart_handle_sysrq_char</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

<span class="nl">error_return:</span>
			<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">flg</span><span class="p">);</span>

		<span class="p">}</span>

		<span class="cm">/* This BD is ready to be used again. Clear status. get next */</span>
		<span class="n">clrsetbits_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">BD_SC_BR</span> <span class="o">|</span> <span class="n">BD_SC_FR</span> <span class="o">|</span> <span class="n">BD_SC_PR</span> <span class="o">|</span>
			<span class="n">BD_SC_OV</span> <span class="o">|</span> <span class="n">BD_SC_ID</span><span class="p">,</span> <span class="n">BD_SC_EMPTY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BD_SC_WRAP</span><span class="p">)</span>
			<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bdp</span><span class="o">++</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/* Write back buffer pointer */</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_cur</span> <span class="o">=</span> <span class="n">bdp</span><span class="p">;</span>

	<span class="cm">/* Activate BH processing */</span>
	<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Error processing */</span>

<span class="nl">handle_error:</span>
	<span class="cm">/* Statistics */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_BR</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">brk</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_PR</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">parity</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_FR</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">frame</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_OV</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">overrun</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Mask out ignored conditions */</span>
	<span class="n">status</span> <span class="o">&amp;=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">read_status_mask</span><span class="p">;</span>

	<span class="cm">/* Handle the remaining ones */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_BR</span><span class="p">)</span>
		<span class="n">flg</span> <span class="o">=</span> <span class="n">TTY_BREAK</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_PR</span><span class="p">)</span>
		<span class="n">flg</span> <span class="o">=</span> <span class="n">TTY_PARITY</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_FR</span><span class="p">)</span>
		<span class="n">flg</span> <span class="o">=</span> <span class="n">TTY_FRAME</span><span class="p">;</span>

	<span class="cm">/* Overrun does not affect the current character ! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">BD_SC_OV</span><span class="p">)</span>
		<span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TTY_OVERRUN</span><span class="p">);</span>
<span class="cp">#ifdef SUPPORT_SYSRQ</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">sysrq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Interrupt handler</span>
<span class="cm"> *</span>
<span class="cm"> * This interrupt handler is called after a BD is processed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">qe_uart_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ucc_slow</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uccp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">events</span><span class="p">;</span>

	<span class="cm">/* Clear the interrupts */</span>
	<span class="n">events</span> <span class="o">=</span> <span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">ucce</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">ucce</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">UCC_UART_UCCE_BRKE</span><span class="p">)</span>
		<span class="n">uart_handle_break</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">UCC_UART_UCCE_RX</span><span class="p">)</span>
		<span class="n">qe_uart_int_rx</span><span class="p">(</span><span class="n">qe_port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">UCC_UART_UCCE_TX</span><span class="p">)</span>
		<span class="n">qe_uart_tx_pump</span><span class="p">(</span><span class="n">qe_port</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">events</span> <span class="o">?</span> <span class="n">IRQ_HANDLED</span> <span class="o">:</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize buffer descriptors</span>
<span class="cm"> *</span>
<span class="cm"> * This function initializes all of the RX and TX buffer descriptors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_initbd</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bd_virt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qe_bd</span> <span class="o">*</span><span class="n">bdp</span><span class="p">;</span>

	<span class="cm">/* Set the physical address of the host memory buffers in the buffer</span>
<span class="cm">	 * descriptors, and the virtual address for us to work with.</span>
<span class="cm">	 */</span>
	<span class="n">bd_virt</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_virt</span><span class="p">;</span>
	<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_cur</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_nrfifos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">BD_SC_EMPTY</span> <span class="o">|</span> <span class="n">BD_SC_INTRPT</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">cpu2qe_addr</span><span class="p">(</span><span class="n">bd_virt</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">));</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bd_virt</span> <span class="o">+=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_fifosize</span><span class="p">;</span>
		<span class="n">bdp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* */</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">BD_SC_WRAP</span> <span class="o">|</span> <span class="n">BD_SC_EMPTY</span> <span class="o">|</span> <span class="n">BD_SC_INTRPT</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">cpu2qe_addr</span><span class="p">(</span><span class="n">bd_virt</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">));</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set the physical address of the host memory</span>
<span class="cm">	 * buffers in the buffer descriptors, and the</span>
<span class="cm">	 * virtual address for us to work with.</span>
<span class="cm">	 */</span>
	<span class="n">bd_virt</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_virt</span> <span class="o">+</span>
		<span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_nrfifos</span> <span class="o">*</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_fifosize</span><span class="p">);</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_cur</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
	<span class="n">bdp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_nrfifos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">BD_SC_INTRPT</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">cpu2qe_addr</span><span class="p">(</span><span class="n">bd_virt</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">));</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bd_virt</span> <span class="o">+=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_fifosize</span><span class="p">;</span>
		<span class="n">bdp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Loopback requires the preamble bit to be set on the first TX BD */</span>
<span class="cp">#ifdef LOOPBACK</span>
	<span class="n">setbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_cur</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">BD_SC_P</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">BD_SC_WRAP</span> <span class="o">|</span> <span class="n">BD_SC_INTRPT</span><span class="p">);</span>
	<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">cpu2qe_addr</span><span class="p">(</span><span class="n">bd_virt</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">));</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize a UCC for UART.</span>
<span class="cm"> *</span>
<span class="cm"> * This function configures a given UCC to be used as a UART device. Basic</span>
<span class="cm"> * UCC initialization is handled in qe_uart_request_port().  This function</span>
<span class="cm"> * does all the UART-specific stuff.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_init_ucc</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cecr_subblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ucc_slow</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uccp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ucc_uart_pram</span> <span class="o">*</span><span class="n">uccup</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccup</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* First, disable TX and RX in the UCC */</span>
	<span class="n">ucc_slow_disable</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_private</span><span class="p">,</span> <span class="n">COMM_DIR_RX_AND_TX</span><span class="p">);</span>

	<span class="cm">/* Program the UCC UART parameter RAM */</span>
	<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">rbmr</span><span class="p">,</span> <span class="n">UCC_BMR_GBL</span> <span class="o">|</span> <span class="n">UCC_BMR_BO_BE</span><span class="p">);</span>
	<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">tbmr</span><span class="p">,</span> <span class="n">UCC_BMR_GBL</span> <span class="o">|</span> <span class="n">UCC_BMR_BO_BE</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">mrblr</span><span class="p">,</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_fifosize</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">maxidl</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">brkcr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">parec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">frmec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">nosec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">brkec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">uaddr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">uaddr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">toseq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">cchars</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mh">0xC000</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rccm</span><span class="p">,</span> <span class="mh">0xc0ff</span><span class="p">);</span>

	<span class="cm">/* Configure the GUMR registers for UART */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soft_uart</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Soft-UART requires a 1X multiplier for TX */</span>
		<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_l</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_L_MODE_MASK</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_L_TDCR_MASK</span> <span class="o">|</span>
			<span class="n">UCC_SLOW_GUMR_L_RDCR_MASK</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_L_MODE_UART</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_L_TDCR_1</span> <span class="o">|</span>
			<span class="n">UCC_SLOW_GUMR_L_RDCR_16</span><span class="p">);</span>

		<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_h</span><span class="p">,</span> <span class="n">UCC_SLOW_GUMR_H_RFW</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_H_TRX</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_H_TTX</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_l</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_L_MODE_MASK</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_L_TDCR_MASK</span> <span class="o">|</span>
			<span class="n">UCC_SLOW_GUMR_L_RDCR_MASK</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_L_MODE_UART</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_L_TDCR_16</span> <span class="o">|</span>
			<span class="n">UCC_SLOW_GUMR_L_RDCR_16</span><span class="p">);</span>

		<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_h</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_H_TRX</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_H_TTX</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_H_RFW</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef LOOPBACK</span>
	<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_l</span><span class="p">,</span> <span class="n">UCC_SLOW_GUMR_L_DIAG_MASK</span><span class="p">,</span>
		<span class="n">UCC_SLOW_GUMR_L_DIAG_LOOP</span><span class="p">);</span>
	<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_h</span><span class="p">,</span>
		<span class="n">UCC_SLOW_GUMR_H_CTSP</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_H_RSYN</span><span class="p">,</span>
		<span class="n">UCC_SLOW_GUMR_H_CDS</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Disable rx interrupts  and clear all pending events.  */</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">uccm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">ucce</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">udsr</span><span class="p">,</span> <span class="mh">0x7e7e</span><span class="p">);</span>

	<span class="cm">/* Initialize UPSMR */</span>
	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">upsmr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">soft_uart</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">supsmr</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">);</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">res92</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rx_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rx_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rx_bitmark</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rx_length</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">dump_ptr</span><span class="p">,</span> <span class="mh">0x4000</span><span class="p">);</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rx_temp_dlst_qe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rx_frame_rem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rx_frame_rem_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Soft-UART requires TX to be 1X */</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">tx_mode</span><span class="p">,</span>
			<span class="n">UCC_UART_TX_STATE_UART</span> <span class="o">|</span> <span class="n">UCC_UART_TX_STATE_X1</span><span class="p">);</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">tx_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">resD4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">resD5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Set UART mode.</span>
<span class="cm">		 * Enable receive and transmit.</span>
<span class="cm">		 */</span>

		<span class="cm">/* From the microcode errata:</span>
<span class="cm">		 * 1.GUMR_L register, set mode=0010 (QMC).</span>
<span class="cm">		 * 2.Set GUMR_H[17] bit. (UART/AHDLC mode).</span>
<span class="cm">		 * 3.Set GUMR_H[19:20] (Transparent mode)</span>
<span class="cm">		 * 4.Clear GUMR_H[26] (RFW)</span>
<span class="cm">		 * ...</span>
<span class="cm">		 * 6.Receiver must use 16x over sampling</span>
<span class="cm">		 */</span>
		<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_l</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_L_MODE_MASK</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_L_TDCR_MASK</span> <span class="o">|</span>
			<span class="n">UCC_SLOW_GUMR_L_RDCR_MASK</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_L_MODE_QMC</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_L_TDCR_16</span> <span class="o">|</span>
			<span class="n">UCC_SLOW_GUMR_L_RDCR_16</span><span class="p">);</span>

		<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_h</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_H_RFW</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_H_RSYN</span><span class="p">,</span>
			<span class="n">UCC_SLOW_GUMR_H_SUART</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_H_TRX</span> <span class="o">|</span>
			<span class="n">UCC_SLOW_GUMR_H_TTX</span> <span class="o">|</span> <span class="n">UCC_SLOW_GUMR_H_TFL</span><span class="p">);</span>

<span class="cp">#ifdef LOOPBACK</span>
		<span class="n">clrsetbits_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_l</span><span class="p">,</span> <span class="n">UCC_SLOW_GUMR_L_DIAG_MASK</span><span class="p">,</span>
				<span class="n">UCC_SLOW_GUMR_L_DIAG_LOOP</span><span class="p">);</span>
		<span class="n">clrbits32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">gumr_h</span><span class="p">,</span> <span class="n">UCC_SLOW_GUMR_H_CTSP</span> <span class="o">|</span>
			  <span class="n">UCC_SLOW_GUMR_H_CDS</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">cecr_subblock</span> <span class="o">=</span> <span class="n">ucc_slow_get_qe_cr_subblock</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">ucc_num</span><span class="p">);</span>
		<span class="n">qe_issue_cmd</span><span class="p">(</span><span class="n">QE_INIT_TX_RX</span><span class="p">,</span> <span class="n">cecr_subblock</span><span class="p">,</span>
			<span class="n">QE_CR_PROTOCOL_UNSPECIFIED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cecr_subblock</span> <span class="o">=</span> <span class="n">ucc_slow_get_qe_cr_subblock</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">ucc_num</span><span class="p">);</span>
		<span class="n">qe_issue_cmd</span><span class="p">(</span><span class="n">QE_INIT_TX_RX</span><span class="p">,</span> <span class="n">cecr_subblock</span><span class="p">,</span>
			<span class="n">QE_CR_PROTOCOL_UART</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize the port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qe_uart_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re using Soft-UART mode, then we need to make sure the</span>
<span class="cm">	 * firmware has been uploaded first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soft_uart</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">firmware_loaded</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Soft-UART firmware not uploaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qe_uart_initbd</span><span class="p">(</span><span class="n">qe_port</span><span class="p">);</span>
	<span class="n">qe_uart_init_ucc</span><span class="p">(</span><span class="n">qe_port</span><span class="p">);</span>

	<span class="cm">/* Install interrupt handler. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">qe_uart_int</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;ucc-uart&quot;</span><span class="p">,</span>
		<span class="n">qe_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not claim IRQ %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Startup rx-int */</span>
	<span class="n">setbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">uccm</span><span class="p">,</span> <span class="n">UCC_UART_UCCE_RX</span><span class="p">);</span>
	<span class="n">ucc_slow_enable</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_private</span><span class="p">,</span> <span class="n">COMM_DIR_RX_AND_TX</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Shutdown the port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ucc_slow</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uccp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

	<span class="cm">/* Disable RX and TX */</span>

	<span class="cm">/* Wait for all the BDs marked sent */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qe_uart_tx_empty</span><span class="p">(</span><span class="n">port</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;shutdown timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">wait_closing</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Wait a bit longer */</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">wait_closing</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Stop uarts */</span>
	<span class="n">ucc_slow_disable</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_private</span><span class="p">,</span> <span class="n">COMM_DIR_RX_AND_TX</span><span class="p">);</span>
	<span class="n">clrbits16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">uccm</span><span class="p">,</span> <span class="n">UCC_UART_UCCE_TX</span> <span class="o">|</span> <span class="n">UCC_UART_UCCE_RX</span><span class="p">);</span>

	<span class="cm">/* Shut them really down and reinit buffer descriptors */</span>
	<span class="n">ucc_slow_graceful_stop_tx</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_private</span><span class="p">);</span>
	<span class="n">qe_uart_initbd</span><span class="p">(</span><span class="n">qe_port</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the serial port parameters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_set_termios</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">termios</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ktermios</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ucc_slow</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uccp</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">baud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">upsmr</span> <span class="o">=</span> <span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">upsmr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ucc_uart_pram</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">uccup</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccup</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">supsmr</span> <span class="o">=</span> <span class="n">in_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">supsmr</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">char_length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* 1 + CL + PEN + 1 + SL */</span>

	<span class="cm">/* Character length programmed into the mode register is the</span>
<span class="cm">	 * sum of: 1 start bit, number of data bits, 0 or 1 parity bit,</span>
<span class="cm">	 * 1 or 2 stop bits, minus 1.</span>
<span class="cm">	 * The value &#39;bits&#39; counts this for us.</span>
<span class="cm">	 */</span>

	<span class="cm">/* byte size */</span>
	<span class="n">upsmr</span> <span class="o">&amp;=</span> <span class="n">UCC_UART_UPSMR_CL_MASK</span><span class="p">;</span>
	<span class="n">supsmr</span> <span class="o">&amp;=</span> <span class="n">UCC_UART_SUPSMR_CL_MASK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CSIZE</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CS5</span>:
		<span class="n">upsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_UPSMR_CL_5</span><span class="p">;</span>
		<span class="n">supsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_SUPSMR_CL_5</span><span class="p">;</span>
		<span class="n">char_length</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS6</span>:
		<span class="n">upsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_UPSMR_CL_6</span><span class="p">;</span>
		<span class="n">supsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_SUPSMR_CL_6</span><span class="p">;</span>
		<span class="n">char_length</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CS7</span>:
		<span class="n">upsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_UPSMR_CL_7</span><span class="p">;</span>
		<span class="n">supsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_SUPSMR_CL_7</span><span class="p">;</span>
		<span class="n">char_length</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>	<span class="cm">/* case CS8 */</span>
		<span class="n">upsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_UPSMR_CL_8</span><span class="p">;</span>
		<span class="n">supsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_SUPSMR_CL_8</span><span class="p">;</span>
		<span class="n">char_length</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If CSTOPB is set, we want two stop bits */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CSTOPB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">upsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_UPSMR_SL</span><span class="p">;</span>
		<span class="n">supsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_SUPSMR_SL</span><span class="p">;</span>
		<span class="n">char_length</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/* + SL */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">PARENB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">upsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_UPSMR_PEN</span><span class="p">;</span>
		<span class="n">supsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_SUPSMR_PEN</span><span class="p">;</span>
		<span class="n">char_length</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/* + PEN */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">PARODD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">upsmr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UCC_UART_UPSMR_RPM_MASK</span> <span class="o">|</span>
				   <span class="n">UCC_UART_UPSMR_TPM_MASK</span><span class="p">);</span>
			<span class="n">upsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_UPSMR_RPM_EVEN</span> <span class="o">|</span>
				<span class="n">UCC_UART_UPSMR_TPM_EVEN</span><span class="p">;</span>
			<span class="n">supsmr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UCC_UART_SUPSMR_RPM_MASK</span> <span class="o">|</span>
				    <span class="n">UCC_UART_SUPSMR_TPM_MASK</span><span class="p">);</span>
			<span class="n">supsmr</span> <span class="o">|=</span> <span class="n">UCC_UART_SUPSMR_RPM_EVEN</span> <span class="o">|</span>
				<span class="n">UCC_UART_SUPSMR_TPM_EVEN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up parity check flag</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">=</span> <span class="n">BD_SC_EMPTY</span> <span class="o">|</span> <span class="n">BD_SC_OV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;</span> <span class="n">INPCK</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">|=</span> <span class="n">BD_SC_FR</span> <span class="o">|</span> <span class="n">BD_SC_PR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BRKINT</span> <span class="o">|</span> <span class="n">PARMRK</span><span class="p">))</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">|=</span> <span class="n">BD_SC_BR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Characters to ignore</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;</span> <span class="n">IGNPAR</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">|=</span> <span class="n">BD_SC_PR</span> <span class="o">|</span> <span class="n">BD_SC_FR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;</span> <span class="n">IGNBRK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">|=</span> <span class="n">BD_SC_BR</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;re ignore parity and break indicators, ignore</span>
<span class="cm">		 * overruns too.  (For real raw support).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_iflag</span> <span class="o">&amp;</span> <span class="n">IGNPAR</span><span class="p">)</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ignore_status_mask</span> <span class="o">|=</span> <span class="n">BD_SC_OV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * !!! ignore all characters if CREAD is not set</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span> <span class="o">&amp;</span> <span class="n">CREAD</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">read_status_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BD_SC_EMPTY</span><span class="p">;</span>

	<span class="n">baud</span> <span class="o">=</span> <span class="n">uart_get_baud_rate</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">termios</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">115200</span><span class="p">);</span>

	<span class="cm">/* Do we really need a spinlock here? */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Update the per-port timeout. */</span>
	<span class="n">uart_update_timeout</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">termios</span><span class="o">-&gt;</span><span class="n">c_cflag</span><span class="p">,</span> <span class="n">baud</span><span class="p">);</span>

	<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccp</span><span class="o">-&gt;</span><span class="n">upsmr</span><span class="p">,</span> <span class="n">upsmr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soft_uart</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">supsmr</span><span class="p">,</span> <span class="n">supsmr</span><span class="p">);</span>
		<span class="n">out_8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uccup</span><span class="o">-&gt;</span><span class="n">rx_length</span><span class="p">,</span> <span class="n">char_length</span><span class="p">);</span>

		<span class="cm">/* Soft-UART requires a 1X multiplier for TX */</span>
		<span class="n">qe_setbrg</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">rx_clock</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">qe_setbrg</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">tx_clock</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">qe_setbrg</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">rx_clock</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">qe_setbrg</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">tx_clock</span><span class="p">,</span> <span class="n">baud</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return a pointer to a string that describes what kind of port this is.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">qe_uart_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="s">&quot;QE&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate any memory and I/O resources required by the port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qe_uart_request_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ucc_slow_info</span> <span class="o">*</span><span class="n">us_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ucc_slow_private</span> <span class="o">*</span><span class="n">uccs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_size</span><span class="p">,</span> <span class="n">tx_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bd_virt</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">bd_dma_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ucc_slow_init</span><span class="p">(</span><span class="n">us_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uccs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not initialize UCC%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">ucc_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_private</span> <span class="o">=</span> <span class="n">uccs</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccp</span> <span class="o">=</span> <span class="n">uccs</span><span class="o">-&gt;</span><span class="n">us_regs</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">uccup</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ucc_uart_pram</span> <span class="o">*</span><span class="p">)</span> <span class="n">uccs</span><span class="o">-&gt;</span><span class="n">us_pram</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_bd_base</span> <span class="o">=</span> <span class="n">uccs</span><span class="o">-&gt;</span><span class="n">rx_bd</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_bd_base</span> <span class="o">=</span> <span class="n">uccs</span><span class="o">-&gt;</span><span class="n">tx_bd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate the transmit and receive data buffers.</span>
<span class="cm">	 */</span>

	<span class="n">rx_size</span> <span class="o">=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_nrfifos</span> <span class="o">*</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_fifosize</span><span class="p">);</span>
	<span class="n">tx_size</span> <span class="o">=</span> <span class="n">L1_CACHE_ALIGN</span><span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_nrfifos</span> <span class="o">*</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_fifosize</span><span class="p">);</span>

	<span class="n">bd_virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_size</span> <span class="o">+</span> <span class="n">tx_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bd_dma_addr</span><span class="p">,</span>
		<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bd_virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not allocate buffer descriptors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_virt</span> <span class="o">=</span> <span class="n">bd_virt</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_dma_addr</span> <span class="o">=</span> <span class="n">bd_dma_addr</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_size</span> <span class="o">=</span> <span class="n">rx_size</span> <span class="o">+</span> <span class="n">tx_size</span><span class="p">;</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="n">bd_virt</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_buf</span> <span class="o">+</span> <span class="n">rx_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Configure the port.</span>
<span class="cm"> *</span>
<span class="cm"> * We say we&#39;re a CPM-type port because that&#39;s mostly true.  Once the device</span>
<span class="cm"> * is configured, this driver operates almost identically to the CPM serial</span>
<span class="cm"> * driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_config_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UART_CONFIG_TYPE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">PORT_CPM</span><span class="p">;</span>
		<span class="n">qe_uart_request_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release any memory and I/O resources that were allocated in</span>
<span class="cm"> * qe_uart_request_port().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qe_uart_release_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ucc_slow_private</span> <span class="o">*</span><span class="n">uccs</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_private</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_size</span><span class="p">,</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_virt</span><span class="p">,</span>
			  <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">bd_dma_addr</span><span class="p">);</span>

	<span class="n">ucc_slow_free</span><span class="p">(</span><span class="n">uccs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Verify that the data in serial_struct is suitable for this device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qe_uart_verify_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">serial_struct</span> <span class="o">*</span><span class="n">ser</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ser</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PORT_UNKNOWN</span> <span class="o">&amp;&amp;</span> <span class="n">ser</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">PORT_CPM</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ser</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ser</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">nr_irqs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ser</span><span class="o">-&gt;</span><span class="n">baud_base</span> <span class="o">&lt;</span> <span class="mi">9600</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* UART operations</span>
<span class="cm"> *</span>
<span class="cm"> * Details on these functions can be found in Documentation/serial/driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">uart_ops</span> <span class="n">qe_uart_pops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">tx_empty</span>       <span class="o">=</span> <span class="n">qe_uart_tx_empty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_mctrl</span>      <span class="o">=</span> <span class="n">qe_uart_set_mctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_mctrl</span>      <span class="o">=</span> <span class="n">qe_uart_get_mctrl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_tx</span>	<span class="o">=</span> <span class="n">qe_uart_stop_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">start_tx</span>       <span class="o">=</span> <span class="n">qe_uart_start_tx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop_rx</span>	<span class="o">=</span> <span class="n">qe_uart_stop_rx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">enable_ms</span>      <span class="o">=</span> <span class="n">qe_uart_enable_ms</span><span class="p">,</span>
	<span class="p">.</span><span class="n">break_ctl</span>      <span class="o">=</span> <span class="n">qe_uart_break_ctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">startup</span>	<span class="o">=</span> <span class="n">qe_uart_startup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>       <span class="o">=</span> <span class="n">qe_uart_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_termios</span>    <span class="o">=</span> <span class="n">qe_uart_set_termios</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span>   	<span class="o">=</span> <span class="n">qe_uart_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release_port</span>   <span class="o">=</span> <span class="n">qe_uart_release_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">request_port</span>   <span class="o">=</span> <span class="n">qe_uart_request_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">config_port</span>    <span class="o">=</span> <span class="n">qe_uart_config_port</span><span class="p">,</span>
	<span class="p">.</span><span class="n">verify_port</span>    <span class="o">=</span> <span class="n">qe_uart_verify_port</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Obtain the SOC model number and revision level</span>
<span class="cm"> *</span>
<span class="cm"> * This function parses the device tree to obtain the SOC model.  It then</span>
<span class="cm"> * reads the SVR register to the revision.</span>
<span class="cm"> *</span>
<span class="cm"> * The device tree stores the SOC model two different ways.</span>
<span class="cm"> *</span>
<span class="cm"> * The new way is:</span>
<span class="cm"> *</span>
<span class="cm"> *      	cpu@0 {</span>
<span class="cm"> *      		compatible = &quot;PowerPC,8323&quot;;</span>
<span class="cm"> *      		device_type = &quot;cpu&quot;;</span>
<span class="cm"> *      		...</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The old way is:</span>
<span class="cm"> *      	 PowerPC,8323@0 {</span>
<span class="cm"> *      		device_type = &quot;cpu&quot;;</span>
<span class="cm"> *      		...</span>
<span class="cm"> *</span>
<span class="cm"> * This code first checks the new way, and then the old way.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">soc_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rev_h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rev_l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">soc_string</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">svr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">soc</span><span class="p">;</span>

	<span class="cm">/* Find the CPU node */</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;cpu&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Find the compatible property */</span>
	<span class="n">soc_string</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;compatible&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">soc_string</span><span class="p">)</span>
		<span class="cm">/* No compatible property, so try the name. */</span>
		<span class="n">soc_string</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/* Extract the SOC number from the &quot;PowerPC,&quot; string */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sscanf</span><span class="p">(</span><span class="n">soc_string</span><span class="p">,</span> <span class="s">&quot;PowerPC,%u&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">soc</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">soc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Get the revision from the SVR */</span>
	<span class="n">svr</span> <span class="o">=</span> <span class="n">mfspr</span><span class="p">(</span><span class="n">SPRN_SVR</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rev_h</span> <span class="o">=</span> <span class="p">(</span><span class="n">svr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rev_l</span> <span class="o">=</span> <span class="n">svr</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">soc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * requst_firmware_nowait() callback function</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the kernel when a firmware is made available,</span>
<span class="cm"> * or if it times out waiting for the firmware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">uart_firmware_cont</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qe_firmware</span> <span class="o">*</span><span class="n">firmware</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">firmware</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">qe_firmware</span> <span class="o">*</span><span class="p">)</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firmware</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">!=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qe_upload_firmware</span><span class="p">(</span><span class="n">firmware</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not load firmware</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">firmware_loaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ucc_uart_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">iprop</span><span class="p">;</span>      <span class="cm">/* Integer OF properties */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sprop</span><span class="p">;</span>      <span class="cm">/* String OF properties */</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine if we need Soft-UART mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;soft-uart&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;using Soft-UART mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">soft_uart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are using Soft-UART, determine if we need to upload the</span>
<span class="cm">	 * firmware, too.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soft_uart</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qe_firmware_info</span> <span class="o">*</span><span class="n">qe_fw_info</span><span class="p">;</span>

		<span class="n">qe_fw_info</span> <span class="o">=</span> <span class="n">qe_get_firmware_info</span><span class="p">();</span>

		<span class="cm">/* Check if the firmware has been uploaded. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qe_fw_info</span> <span class="o">&amp;&amp;</span> <span class="n">strstr</span><span class="p">(</span><span class="n">qe_fw_info</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="s">&quot;Soft-UART&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">firmware_loaded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">soc</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rev_h</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rev_l</span><span class="p">;</span>

			<span class="n">soc</span> <span class="o">=</span> <span class="n">soc_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rev_h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rev_l</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">soc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unknown CPU model</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;fsl_qe_ucode_uart_%u_%u%u.bin&quot;</span><span class="p">,</span>
				<span class="n">soc</span><span class="p">,</span> <span class="n">rev_h</span><span class="p">,</span> <span class="n">rev_l</span><span class="p">);</span>

			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;waiting for firmware %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">filename</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * We call request_firmware_nowait instead of</span>
<span class="cm">			 * request_firmware so that the driver can load and</span>
<span class="cm">			 * initialize the ports without holding up the rest of</span>
<span class="cm">			 * the kernel.  If hotplug support is enabled in the</span>
<span class="cm">			 * kernel, then we use it.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">request_firmware_nowait</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span>
				<span class="n">FW_ACTION_HOTPLUG</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">uart_firmware_cont</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;could not load firmware %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">filename</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">qe_port</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uart_qe_port</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qe_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t allocate QE port structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Search for IRQ and mapbase */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">of_address_to_resource</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;missing &#39;reg&#39; property in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid &#39;reg&#39; property in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">mapbase</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>

	<span class="cm">/* Get the UCC number (device ID) */</span>
	<span class="cm">/* UCCs are numbered 1-7 */</span>
	<span class="n">iprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;cell-index&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;device-id&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iprop</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;UCC is unspecified in &quot;</span>
				<span class="s">&quot;device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">iprop</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">iprop</span> <span class="o">&gt;</span> <span class="n">UCC_MAX_NUM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no support for UCC%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">iprop</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">ucc_num</span> <span class="o">=</span> <span class="o">*</span><span class="n">iprop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the future, we should not require the BRG to be specified in the</span>
<span class="cm">	 * device tree.  If no clock-source is specified, then just pick a BRG</span>
<span class="cm">	 * to use.  This requires a new QE library function that manages BRG</span>
<span class="cm">	 * assignments.</span>
<span class="cm">	 */</span>

	<span class="n">sprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;rx-clock-name&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;missing rx-clock-name in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">rx_clock</span> <span class="o">=</span> <span class="n">qe_clock_source</span><span class="p">(</span><span class="n">sprop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">rx_clock</span> <span class="o">&lt;</span> <span class="n">QE_BRG1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">rx_clock</span> <span class="o">&gt;</span> <span class="n">QE_BRG16</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rx-clock-name must be a BRG for UART</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef LOOPBACK</span>
	<span class="cm">/* In internal loopback mode, TX and RX must use the same clock */</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">tx_clock</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">rx_clock</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">sprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;tx-clock-name&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;missing tx-clock-name in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">tx_clock</span> <span class="o">=</span> <span class="n">qe_clock_source</span><span class="p">(</span><span class="n">sprop</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">tx_clock</span> <span class="o">&lt;</span> <span class="n">QE_BRG1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">tx_clock</span> <span class="o">&gt;</span> <span class="n">QE_BRG16</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;tx-clock-name must be a BRG for UART</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the port number, numbered 0-3 */</span>
	<span class="n">iprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;port-number&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;missing port-number in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">line</span> <span class="o">=</span> <span class="o">*</span><span class="n">iprop</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">line</span> <span class="o">&gt;=</span> <span class="n">UCC_MAX_UART</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;port-number must be 0-%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">UCC_MAX_UART</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">irq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not map IRQ for UCC%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">ucc_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Newer device trees have an &quot;fsl,qe&quot; compatible property for the QE</span>
<span class="cm">	 * node, but we still need to support older device trees.</span>
<span class="cm">	 */</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_compatible_node</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;fsl,qe&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_type</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;qe&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not find &#39;qe&#39; node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">iprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;brg-frequency&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		       <span class="s">&quot;missing brg-frequency in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_np</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">iprop</span><span class="p">)</span>
		<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">uartclk</span> <span class="o">=</span> <span class="o">*</span><span class="n">iprop</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Older versions of U-Boot do not initialize the brg-frequency</span>
<span class="cm">		 * property, so in this case we assume the BRG frequency is</span>
<span class="cm">		 * half the QE bus frequency.</span>
<span class="cm">		 */</span>
		<span class="n">iprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;bus-frequency&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iprop</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;missing QE bus-frequency in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_np</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">iprop</span><span class="p">)</span>
			<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">uartclk</span> <span class="o">=</span> <span class="o">*</span><span class="n">iprop</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;invalid QE bus-frequency in device tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_np</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qe_uart_pops</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">iotype</span> <span class="o">=</span> <span class="n">UPIO_MEM</span><span class="p">;</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_nrfifos</span> <span class="o">=</span> <span class="n">TX_NUM_FIFO</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_fifosize</span> <span class="o">=</span> <span class="n">TX_BUF_SIZE</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_nrfifos</span> <span class="o">=</span> <span class="n">RX_NUM_FIFO</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_fifosize</span> <span class="o">=</span> <span class="n">RX_BUF_SIZE</span><span class="p">;</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">wait_closing</span> <span class="o">=</span> <span class="n">UCC_WAIT_CLOSING</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">fifosize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UPF_BOOT_AUTOCONF</span> <span class="o">|</span> <span class="n">UPF_IOREMAP</span><span class="p">;</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">ucc_num</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">ucc_num</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="n">phys_addr_t</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">rx_bd_ring_len</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">rx_nrfifos</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">tx_bd_ring_len</span> <span class="o">=</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">tx_nrfifos</span><span class="p">;</span>

	<span class="cm">/* Make sure ucc_slow_init() initializes both TX and RX */</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">init_tx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">us_info</span><span class="p">.</span><span class="n">init_rx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Add the port to the uart sub-system.  This will cause</span>
<span class="cm">	 * qe_uart_config_port() to be called, so the us_info structure must</span>
<span class="cm">	 * be initialized.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_add_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucc_uart_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not add /dev/ttyQE%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">line</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_np</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">qe_port</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;UCC%u assigned to /dev/ttyQE%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">ucc_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">line</span><span class="p">);</span>

	<span class="cm">/* Display the mknod command for this device */</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mknod command is &#39;mknod /dev/ttyQE%u c %u %u&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">line</span><span class="p">,</span> <span class="n">SERIAL_QE_MAJOR</span><span class="p">,</span>
	       <span class="n">SERIAL_QE_MINOR</span> <span class="o">+</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">line</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_np:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">qe_port</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ucc_uart_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uart_qe_port</span> <span class="o">*</span><span class="n">qe_port</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;removing /dev/ttyQE%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">line</span><span class="p">);</span>

	<span class="n">uart_remove_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucc_uart_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qe_port</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">qe_port</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">ucc_uart_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="s">&quot;serial&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;ucc_uart&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">ucc_uart_match</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ucc_uart_of_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ucc_uart&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span>    <span class="o">=</span> <span class="n">ucc_uart_match</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>  	<span class="o">=</span> <span class="n">ucc_uart_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> 	<span class="o">=</span> <span class="n">ucc_uart_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ucc_uart_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Freescale QUICC Engine UART device driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifdef LOOPBACK</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;ucc-uart: Using loopback mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">uart_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucc_uart_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ucc-uart: could not register UART driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucc_uart_of_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;ucc-uart: could not register platform driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ucc_uart_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;Freescale QUICC Engine UART device driver unloading</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucc_uart_of_driver</span><span class="p">);</span>
	<span class="n">uart_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucc_uart_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ucc_uart_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ucc_uart_exit</span><span class="p">);</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Freescale QUICC Engine (QE) UART&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Timur Tabi &lt;timur@freescale.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_CHARDEV_MAJOR</span><span class="p">(</span><span class="n">SERIAL_QE_MAJOR</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
