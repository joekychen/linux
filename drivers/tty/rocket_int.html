<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › rocket_int.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rocket_int.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * rocket_int.h --- internal header file for rocket.c</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Theodore Ts&#39;o, Copyright 1997.</span>
<span class="cm"> * Copyright 1997 Comtrol Corporation.  </span>
<span class="cm"> * </span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Definition of the types in rcktpt_type</span>
<span class="cm"> */</span>
<span class="cp">#define ROCKET_TYPE_NORMAL	0</span>
<span class="cp">#define ROCKET_TYPE_MODEM	1</span>
<span class="cp">#define ROCKET_TYPE_MODEMII	2</span>
<span class="cp">#define ROCKET_TYPE_MODEMIII	3</span>
<span class="cp">#define ROCKET_TYPE_PC104       4</span>

<span class="cp">#include &lt;linux/mutex.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Byte_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ByteIO_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Word_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">WordIO_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">DWordIO_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Note!  Normally the Linux I/O macros already take care of</span>
<span class="cm"> * byte-swapping the I/O instructions.  However, all accesses using</span>
<span class="cm"> * sOutDW aren&#39;t really 32-bit accesses, but should be handled in byte</span>
<span class="cm"> * order.  Hence the use of the cpu_to_le32() macro to byte-swap</span>
<span class="cm"> * things to no-op the byte swapping done by the big-endian outl()</span>
<span class="cm"> * instruction.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sOutB</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef ROCKET_DEBUG_IO</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;sOutB(%x, %x)...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">outb_p</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sOutW</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef ROCKET_DEBUG_IO</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;sOutW(%x, %x)...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">outw_p</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">out32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">,</span> <span class="n">Byte_t</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">value</span> <span class="o">=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#ifdef ROCKET_DEBUG_IO</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;out32(%x, %lx)...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">outl_p</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">sInB</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inb_p</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">sInW</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">inw_p</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is used to move arrays of bytes so byte swapping isn&#39;t appropriate. */</span>
<span class="cp">#define sOutStrW(port, addr, count) if (count) outsw(port, addr, count)</span>
<span class="cp">#define sInStrW(port, addr, count) if (count) insw(port, addr, count)</span>

<span class="cp">#define CTL_SIZE 8</span>
<span class="cp">#define AIOP_CTL_SIZE 4</span>
<span class="cp">#define CHAN_AIOP_SIZE 8</span>
<span class="cp">#define MAX_PORTS_PER_AIOP 8</span>
<span class="cp">#define MAX_AIOPS_PER_BOARD 4</span>
<span class="cp">#define MAX_PORTS_PER_BOARD 32</span>

<span class="cm">/* Bus type ID */</span>
<span class="cp">#define	isISA	0</span>
<span class="cp">#define	isPCI	1</span>
<span class="cp">#define	isMC	2</span>

<span class="cm">/* Controller ID numbers */</span>
<span class="cp">#define CTLID_NULL  -1		</span><span class="cm">/* no controller exists */</span><span class="cp"></span>
<span class="cp">#define CTLID_0001  0x0001	</span><span class="cm">/* controller release 1 */</span><span class="cp"></span>

<span class="cm">/* AIOP ID numbers, identifies AIOP type implementing channel */</span>
<span class="cp">#define AIOPID_NULL -1		</span><span class="cm">/* no AIOP or channel exists */</span><span class="cp"></span>
<span class="cp">#define AIOPID_0001 0x0001	</span><span class="cm">/* AIOP release 1 */</span><span class="cp"></span>

<span class="cm">/************************************************************************</span>
<span class="cm"> Global Register Offsets - Direct Access - Fixed values</span>
<span class="cm">************************************************************************/</span>

<span class="cp">#define _CMD_REG   0x38		</span><span class="cm">/* Command Register            8    Write */</span><span class="cp"></span>
<span class="cp">#define _INT_CHAN  0x39		</span><span class="cm">/* Interrupt Channel Register  8    Read */</span><span class="cp"></span>
<span class="cp">#define _INT_MASK  0x3A		</span><span class="cm">/* Interrupt Mask Register     8    Read / Write */</span><span class="cp"></span>
<span class="cp">#define _UNUSED    0x3B		</span><span class="cm">/* Unused                      8 */</span><span class="cp"></span>
<span class="cp">#define _INDX_ADDR 0x3C		</span><span class="cm">/* Index Register Address      16   Write */</span><span class="cp"></span>
<span class="cp">#define _INDX_DATA 0x3E		</span><span class="cm">/* Index Register Data         8/16 Read / Write */</span><span class="cp"></span>

<span class="cm">/************************************************************************</span>
<span class="cm"> Channel Register Offsets for 1st channel in AIOP - Direct Access</span>
<span class="cm">************************************************************************/</span>
<span class="cp">#define _TD0       0x00		</span><span class="cm">/* Transmit Data               16   Write */</span><span class="cp"></span>
<span class="cp">#define _RD0       0x00		</span><span class="cm">/* Receive Data                16   Read */</span><span class="cp"></span>
<span class="cp">#define _CHN_STAT0 0x20		</span><span class="cm">/* Channel Status              8/16 Read / Write */</span><span class="cp"></span>
<span class="cp">#define _FIFO_CNT0 0x10		</span><span class="cm">/* Transmit/Receive FIFO Count 16   Read */</span><span class="cp"></span>
<span class="cp">#define _INT_ID0   0x30		</span><span class="cm">/* Interrupt Identification    8    Read */</span><span class="cp"></span>

<span class="cm">/************************************************************************</span>
<span class="cm"> Tx Control Register Offsets - Indexed - External - Fixed</span>
<span class="cm">************************************************************************/</span>
<span class="cp">#define _TX_ENBLS  0x980	</span><span class="cm">/* Tx Processor Enables Register 8 Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXCMP1    0x988	</span><span class="cm">/* Transmit Compare Value #1     8 Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXCMP2    0x989	</span><span class="cm">/* Transmit Compare Value #2     8 Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXREP1B1  0x98A	</span><span class="cm">/* Tx Replace Value #1 - Byte 1  8 Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXREP1B2  0x98B	</span><span class="cm">/* Tx Replace Value #1 - Byte 2  8 Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXREP2    0x98C	</span><span class="cm">/* Transmit Replace Value #2     8 Read / Write */</span><span class="cp"></span>

<span class="cm">/************************************************************************</span>
<span class="cm">Memory Controller Register Offsets - Indexed - External - Fixed</span>
<span class="cm">************************************************************************/</span>
<span class="cp">#define _RX_FIFO    0x000	</span><span class="cm">/* Rx FIFO */</span><span class="cp"></span>
<span class="cp">#define _TX_FIFO    0x800	</span><span class="cm">/* Tx FIFO */</span><span class="cp"></span>
<span class="cp">#define _RXF_OUTP   0x990	</span><span class="cm">/* Rx FIFO OUT pointer        16 Read / Write */</span><span class="cp"></span>
<span class="cp">#define _RXF_INP    0x992	</span><span class="cm">/* Rx FIFO IN pointer         16 Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXF_OUTP   0x994	</span><span class="cm">/* Tx FIFO OUT pointer        8  Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXF_INP    0x995	</span><span class="cm">/* Tx FIFO IN pointer         8  Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXP_CNT    0x996	</span><span class="cm">/* Tx Priority Count          8  Read / Write */</span><span class="cp"></span>
<span class="cp">#define _TXP_PNTR   0x997	</span><span class="cm">/* Tx Priority Pointer        8  Read / Write */</span><span class="cp"></span>

<span class="cp">#define PRI_PEND    0x80	</span><span class="cm">/* Priority data pending (bit7, Tx pri cnt) */</span><span class="cp"></span>
<span class="cp">#define TXFIFO_SIZE 255		</span><span class="cm">/* size of Tx FIFO */</span><span class="cp"></span>
<span class="cp">#define RXFIFO_SIZE 1023	</span><span class="cm">/* size of Rx FIFO */</span><span class="cp"></span>

<span class="cm">/************************************************************************</span>
<span class="cm">Tx Priority Buffer - Indexed - External - Fixed</span>
<span class="cm">************************************************************************/</span>
<span class="cp">#define _TXP_BUF    0x9C0	</span><span class="cm">/* Tx Priority Buffer  32  Bytes   Read / Write */</span><span class="cp"></span>
<span class="cp">#define TXP_SIZE    0x20	</span><span class="cm">/* 32 bytes */</span><span class="cp"></span>

<span class="cm">/************************************************************************</span>
<span class="cm">Channel Register Offsets - Indexed - Internal - Fixed</span>
<span class="cm">************************************************************************/</span>

<span class="cp">#define _TX_CTRL    0xFF0	</span><span class="cm">/* Transmit Control               16  Write */</span><span class="cp"></span>
<span class="cp">#define _RX_CTRL    0xFF2	</span><span class="cm">/* Receive Control                 8  Write */</span><span class="cp"></span>
<span class="cp">#define _BAUD       0xFF4	</span><span class="cm">/* Baud Rate                      16  Write */</span><span class="cp"></span>
<span class="cp">#define _CLK_PRE    0xFF6	</span><span class="cm">/* Clock Prescaler                 8  Write */</span><span class="cp"></span>

<span class="cp">#define STMBREAK   0x08		</span><span class="cm">/* BREAK */</span><span class="cp"></span>
<span class="cp">#define STMFRAME   0x04		</span><span class="cm">/* framing error */</span><span class="cp"></span>
<span class="cp">#define STMRCVROVR 0x02		</span><span class="cm">/* receiver over run error */</span><span class="cp"></span>
<span class="cp">#define STMPARITY  0x01		</span><span class="cm">/* parity error */</span><span class="cp"></span>
<span class="cp">#define STMERROR   (STMBREAK | STMFRAME | STMPARITY)</span>
<span class="cp">#define STMBREAKH   0x800	</span><span class="cm">/* BREAK */</span><span class="cp"></span>
<span class="cp">#define STMFRAMEH   0x400	</span><span class="cm">/* framing error */</span><span class="cp"></span>
<span class="cp">#define STMRCVROVRH 0x200	</span><span class="cm">/* receiver over run error */</span><span class="cp"></span>
<span class="cp">#define STMPARITYH  0x100	</span><span class="cm">/* parity error */</span><span class="cp"></span>
<span class="cp">#define STMERRORH   (STMBREAKH | STMFRAMEH | STMPARITYH)</span>

<span class="cp">#define CTS_ACT   0x20		</span><span class="cm">/* CTS input asserted */</span><span class="cp"></span>
<span class="cp">#define DSR_ACT   0x10		</span><span class="cm">/* DSR input asserted */</span><span class="cp"></span>
<span class="cp">#define CD_ACT    0x08		</span><span class="cm">/* CD input asserted */</span><span class="cp"></span>
<span class="cp">#define TXFIFOMT  0x04		</span><span class="cm">/* Tx FIFO is empty */</span><span class="cp"></span>
<span class="cp">#define TXSHRMT   0x02		</span><span class="cm">/* Tx shift register is empty */</span><span class="cp"></span>
<span class="cp">#define RDA       0x01		</span><span class="cm">/* Rx data available */</span><span class="cp"></span>
<span class="cp">#define DRAINED (TXFIFOMT | TXSHRMT)	</span><span class="cm">/* indicates Tx is drained */</span><span class="cp"></span>

<span class="cp">#define STATMODE  0x8000	</span><span class="cm">/* status mode enable bit */</span><span class="cp"></span>
<span class="cp">#define RXFOVERFL 0x2000	</span><span class="cm">/* receive FIFO overflow */</span><span class="cp"></span>
<span class="cp">#define RX2MATCH  0x1000	</span><span class="cm">/* receive compare byte 2 match */</span><span class="cp"></span>
<span class="cp">#define RX1MATCH  0x0800	</span><span class="cm">/* receive compare byte 1 match */</span><span class="cp"></span>
<span class="cp">#define RXBREAK   0x0400	</span><span class="cm">/* received BREAK */</span><span class="cp"></span>
<span class="cp">#define RXFRAME   0x0200	</span><span class="cm">/* received framing error */</span><span class="cp"></span>
<span class="cp">#define RXPARITY  0x0100	</span><span class="cm">/* received parity error */</span><span class="cp"></span>
<span class="cp">#define STATERROR (RXBREAK | RXFRAME | RXPARITY)</span>

<span class="cp">#define CTSFC_EN  0x80		</span><span class="cm">/* CTS flow control enable bit */</span><span class="cp"></span>
<span class="cp">#define RTSTOG_EN 0x40		</span><span class="cm">/* RTS toggle enable bit */</span><span class="cp"></span>
<span class="cp">#define TXINT_EN  0x10		</span><span class="cm">/* transmit interrupt enable */</span><span class="cp"></span>
<span class="cp">#define STOP2     0x08		</span><span class="cm">/* enable 2 stop bits (0 = 1 stop) */</span><span class="cp"></span>
<span class="cp">#define PARITY_EN 0x04		</span><span class="cm">/* enable parity (0 = no parity) */</span><span class="cp"></span>
<span class="cp">#define EVEN_PAR  0x02		</span><span class="cm">/* even parity (0 = odd parity) */</span><span class="cp"></span>
<span class="cp">#define DATA8BIT  0x01		</span><span class="cm">/* 8 bit data (0 = 7 bit data) */</span><span class="cp"></span>

<span class="cp">#define SETBREAK  0x10		</span><span class="cm">/* send break condition (must clear) */</span><span class="cp"></span>
<span class="cp">#define LOCALLOOP 0x08		</span><span class="cm">/* local loopback set for test */</span><span class="cp"></span>
<span class="cp">#define SET_DTR   0x04		</span><span class="cm">/* assert DTR */</span><span class="cp"></span>
<span class="cp">#define SET_RTS   0x02		</span><span class="cm">/* assert RTS */</span><span class="cp"></span>
<span class="cp">#define TX_ENABLE 0x01		</span><span class="cm">/* enable transmitter */</span><span class="cp"></span>

<span class="cp">#define RTSFC_EN  0x40		</span><span class="cm">/* RTS flow control enable */</span><span class="cp"></span>
<span class="cp">#define RXPROC_EN 0x20		</span><span class="cm">/* receive processor enable */</span><span class="cp"></span>
<span class="cp">#define TRIG_NO   0x00		</span><span class="cm">/* Rx FIFO trigger level 0 (no trigger) */</span><span class="cp"></span>
<span class="cp">#define TRIG_1    0x08		</span><span class="cm">/* trigger level 1 char */</span><span class="cp"></span>
<span class="cp">#define TRIG_1_2  0x10		</span><span class="cm">/* trigger level 1/2 */</span><span class="cp"></span>
<span class="cp">#define TRIG_7_8  0x18		</span><span class="cm">/* trigger level 7/8 */</span><span class="cp"></span>
<span class="cp">#define TRIG_MASK 0x18		</span><span class="cm">/* trigger level mask */</span><span class="cp"></span>
<span class="cp">#define SRCINT_EN 0x04		</span><span class="cm">/* special Rx condition interrupt enable */</span><span class="cp"></span>
<span class="cp">#define RXINT_EN  0x02		</span><span class="cm">/* Rx interrupt enable */</span><span class="cp"></span>
<span class="cp">#define MCINT_EN  0x01		</span><span class="cm">/* modem change interrupt enable */</span><span class="cp"></span>

<span class="cp">#define RXF_TRIG  0x20		</span><span class="cm">/* Rx FIFO trigger level interrupt */</span><span class="cp"></span>
<span class="cp">#define TXFIFO_MT 0x10		</span><span class="cm">/* Tx FIFO empty interrupt */</span><span class="cp"></span>
<span class="cp">#define SRC_INT   0x08		</span><span class="cm">/* special receive condition interrupt */</span><span class="cp"></span>
<span class="cp">#define DELTA_CD  0x04		</span><span class="cm">/* CD change interrupt */</span><span class="cp"></span>
<span class="cp">#define DELTA_CTS 0x02		</span><span class="cm">/* CTS change interrupt */</span><span class="cp"></span>
<span class="cp">#define DELTA_DSR 0x01		</span><span class="cm">/* DSR change interrupt */</span><span class="cp"></span>

<span class="cp">#define REP1W2_EN 0x10		</span><span class="cm">/* replace byte 1 with 2 bytes enable */</span><span class="cp"></span>
<span class="cp">#define IGN2_EN   0x08		</span><span class="cm">/* ignore byte 2 enable */</span><span class="cp"></span>
<span class="cp">#define IGN1_EN   0x04		</span><span class="cm">/* ignore byte 1 enable */</span><span class="cp"></span>
<span class="cp">#define COMP2_EN  0x02		</span><span class="cm">/* compare byte 2 enable */</span><span class="cp"></span>
<span class="cp">#define COMP1_EN  0x01		</span><span class="cm">/* compare byte 1 enable */</span><span class="cp"></span>

<span class="cp">#define RESET_ALL 0x80		</span><span class="cm">/* reset AIOP (all channels) */</span><span class="cp"></span>
<span class="cp">#define TXOVERIDE 0x40		</span><span class="cm">/* Transmit software off override */</span><span class="cp"></span>
<span class="cp">#define RESETUART 0x20		</span><span class="cm">/* reset channel&#39;s UART */</span><span class="cp"></span>
<span class="cp">#define RESTXFCNT 0x10		</span><span class="cm">/* reset channel&#39;s Tx FIFO count register */</span><span class="cp"></span>
<span class="cp">#define RESRXFCNT 0x08		</span><span class="cm">/* reset channel&#39;s Rx FIFO count register */</span><span class="cp"></span>

<span class="cp">#define INTSTAT0  0x01		</span><span class="cm">/* AIOP 0 interrupt status */</span><span class="cp"></span>
<span class="cp">#define INTSTAT1  0x02		</span><span class="cm">/* AIOP 1 interrupt status */</span><span class="cp"></span>
<span class="cp">#define INTSTAT2  0x04		</span><span class="cm">/* AIOP 2 interrupt status */</span><span class="cp"></span>
<span class="cp">#define INTSTAT3  0x08		</span><span class="cm">/* AIOP 3 interrupt status */</span><span class="cp"></span>

<span class="cp">#define INTR_EN   0x08		</span><span class="cm">/* allow interrupts to host */</span><span class="cp"></span>
<span class="cp">#define INT_STROB 0x04		</span><span class="cm">/* strobe and clear interrupt line (EOI) */</span><span class="cp"></span>

<span class="cm">/**************************************************************************</span>
<span class="cm"> MUDBAC remapped for PCI</span>
<span class="cm">**************************************************************************/</span>

<span class="cp">#define _CFG_INT_PCI  0x40</span>
<span class="cp">#define _PCI_INT_FUNC 0x3A</span>

<span class="cp">#define PCI_STROB 0x2000	</span><span class="cm">/* bit 13 of int aiop register */</span><span class="cp"></span>
<span class="cp">#define INTR_EN_PCI   0x0010	</span><span class="cm">/* allow interrupts to host */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for Universal PCI board registers</span>
<span class="cm"> */</span>
<span class="cp">#define _PCI_9030_INT_CTRL	0x4c          </span><span class="cm">/* Offsets from BAR1 */</span><span class="cp"></span>
<span class="cp">#define _PCI_9030_GPIO_CTRL	0x54</span>
<span class="cp">#define PCI_INT_CTRL_AIOP	0x0001</span>
<span class="cp">#define PCI_GPIO_CTRL_8PORT	0x4000</span>
<span class="cp">#define _PCI_9030_RING_IND	0xc0          </span><span class="cm">/* Offsets from BAR1 */</span><span class="cp"></span>

<span class="cp">#define CHAN3_EN  0x08		</span><span class="cm">/* enable AIOP 3 */</span><span class="cp"></span>
<span class="cp">#define CHAN2_EN  0x04		</span><span class="cm">/* enable AIOP 2 */</span><span class="cp"></span>
<span class="cp">#define CHAN1_EN  0x02		</span><span class="cm">/* enable AIOP 1 */</span><span class="cp"></span>
<span class="cp">#define CHAN0_EN  0x01		</span><span class="cm">/* enable AIOP 0 */</span><span class="cp"></span>
<span class="cp">#define FREQ_DIS  0x00</span>
<span class="cp">#define FREQ_274HZ 0x60</span>
<span class="cp">#define FREQ_137HZ 0x50</span>
<span class="cp">#define FREQ_69HZ  0x40</span>
<span class="cp">#define FREQ_34HZ  0x30</span>
<span class="cp">#define FREQ_17HZ  0x20</span>
<span class="cp">#define FREQ_9HZ   0x10</span>
<span class="cp">#define PERIODIC_ONLY 0x80	</span><span class="cm">/* only PERIODIC interrupt */</span><span class="cp"></span>

<span class="cp">#define CHANINT_EN 0x0100	</span><span class="cm">/* flags to enable/disable channel ints */</span><span class="cp"></span>

<span class="cp">#define RDATASIZE 72</span>
<span class="cp">#define RREGDATASIZE 52</span>

<span class="cm">/*</span>
<span class="cm"> * AIOP interrupt bits for ISA/PCI boards and UPCI boards.</span>
<span class="cm"> */</span>
<span class="cp">#define AIOP_INTR_BIT_0		0x0001</span>
<span class="cp">#define AIOP_INTR_BIT_1		0x0002</span>
<span class="cp">#define AIOP_INTR_BIT_2		0x0004</span>
<span class="cp">#define AIOP_INTR_BIT_3		0x0008</span>

<span class="cp">#define AIOP_INTR_BITS ( \</span>
<span class="cp">	AIOP_INTR_BIT_0 \</span>
<span class="cp">	| AIOP_INTR_BIT_1 \</span>
<span class="cp">	| AIOP_INTR_BIT_2 \</span>
<span class="cp">	| AIOP_INTR_BIT_3)</span>

<span class="cp">#define UPCI_AIOP_INTR_BIT_0	0x0004</span>
<span class="cp">#define UPCI_AIOP_INTR_BIT_1	0x0020</span>
<span class="cp">#define UPCI_AIOP_INTR_BIT_2	0x0100</span>
<span class="cp">#define UPCI_AIOP_INTR_BIT_3	0x0800</span>

<span class="cp">#define UPCI_AIOP_INTR_BITS ( \</span>
<span class="cp">	UPCI_AIOP_INTR_BIT_0 \</span>
<span class="cp">	| UPCI_AIOP_INTR_BIT_1 \</span>
<span class="cp">	| UPCI_AIOP_INTR_BIT_2 \</span>
<span class="cp">	| UPCI_AIOP_INTR_BIT_3)</span>

<span class="cm">/* Controller level information structure */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">CtlID</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">CtlNum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">BusType</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boardType</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">isUPCI</span><span class="p">;</span>
	<span class="n">WordIO_t</span> <span class="n">PCIIO</span><span class="p">;</span>
	<span class="n">WordIO_t</span> <span class="n">PCIIO2</span><span class="p">;</span>
	<span class="n">ByteIO_t</span> <span class="n">MBaseIO</span><span class="p">;</span>
	<span class="n">ByteIO_t</span> <span class="n">MReg1IO</span><span class="p">;</span>
	<span class="n">ByteIO_t</span> <span class="n">MReg2IO</span><span class="p">;</span>
	<span class="n">ByteIO_t</span> <span class="n">MReg3IO</span><span class="p">;</span>
	<span class="n">Byte_t</span> <span class="n">MReg2</span><span class="p">;</span>
	<span class="n">Byte_t</span> <span class="n">MReg3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">NumAiop</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">AltChanRingIndicator</span><span class="p">;</span>
	<span class="n">ByteIO_t</span> <span class="n">UPCIRingInd</span><span class="p">;</span>
	<span class="n">WordIO_t</span> <span class="n">AiopIO</span><span class="p">[</span><span class="n">AIOP_CTL_SIZE</span><span class="p">];</span>
	<span class="n">ByteIO_t</span> <span class="n">AiopIntChanIO</span><span class="p">[</span><span class="n">AIOP_CTL_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">AiopID</span><span class="p">[</span><span class="n">AIOP_CTL_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">AiopNumChan</span><span class="p">[</span><span class="n">AIOP_CTL_SIZE</span><span class="p">];</span>
	<span class="n">Word_t</span> <span class="o">*</span><span class="n">AiopIntrBits</span><span class="p">;</span>
<span class="p">}</span> <span class="n">CONTROLLER_T</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">CONTROLLER_T</span> <span class="n">CONTROLLER_t</span><span class="p">;</span>

<span class="cm">/* Channel level information structure */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">CONTROLLER_T</span> <span class="o">*</span><span class="n">CtlP</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">AiopNum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ChanID</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ChanNum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rtsToggle</span><span class="p">;</span>

	<span class="n">ByteIO_t</span> <span class="n">Cmd</span><span class="p">;</span>
	<span class="n">ByteIO_t</span> <span class="n">IntChan</span><span class="p">;</span>
	<span class="n">ByteIO_t</span> <span class="n">IntMask</span><span class="p">;</span>
	<span class="n">DWordIO_t</span> <span class="n">IndexAddr</span><span class="p">;</span>
	<span class="n">WordIO_t</span> <span class="n">IndexData</span><span class="p">;</span>

	<span class="n">WordIO_t</span> <span class="n">TxRxData</span><span class="p">;</span>
	<span class="n">WordIO_t</span> <span class="n">ChanStat</span><span class="p">;</span>
	<span class="n">WordIO_t</span> <span class="n">TxRxCount</span><span class="p">;</span>
	<span class="n">ByteIO_t</span> <span class="n">IntID</span><span class="p">;</span>

	<span class="n">Word_t</span> <span class="n">TxFIFO</span><span class="p">;</span>
	<span class="n">Word_t</span> <span class="n">TxFIFOPtrs</span><span class="p">;</span>
	<span class="n">Word_t</span> <span class="n">RxFIFO</span><span class="p">;</span>
	<span class="n">Word_t</span> <span class="n">RxFIFOPtrs</span><span class="p">;</span>
	<span class="n">Word_t</span> <span class="n">TxPrioCnt</span><span class="p">;</span>
	<span class="n">Word_t</span> <span class="n">TxPrioPtr</span><span class="p">;</span>
	<span class="n">Word_t</span> <span class="n">TxPrioBuf</span><span class="p">;</span>

	<span class="n">Byte_t</span> <span class="n">R</span><span class="p">[</span><span class="n">RREGDATASIZE</span><span class="p">];</span>

	<span class="n">Byte_t</span> <span class="n">BaudDiv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Byte_t</span> <span class="n">TxControl</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Byte_t</span> <span class="n">RxControl</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Byte_t</span> <span class="n">TxEnables</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Byte_t</span> <span class="n">TxCompare</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Byte_t</span> <span class="n">TxReplace1</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">Byte_t</span> <span class="n">TxReplace2</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">CHANNEL_T</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">CHANNEL_T</span> <span class="n">CHANNEL_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">CHANNEL_T</span> <span class="o">*</span><span class="n">CHANPTR_T</span><span class="p">;</span>

<span class="cp">#define InterfaceModeRS232  0x00</span>
<span class="cp">#define InterfaceModeRS422  0x08</span>
<span class="cp">#define InterfaceModeRS485  0x10</span>
<span class="cp">#define InterfaceModeRS232T 0x18</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sClrBreak</span>
<span class="cm">Purpose:  Stop sending a transmit BREAK signal</span>
<span class="cm">Call:     sClrBreak(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sClrBreak(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] &amp;= ~SETBREAK; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sClrDTR</span>
<span class="cm">Purpose:  Clr the DTR output</span>
<span class="cm">Call:     sClrDTR(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sClrDTR(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] &amp;= ~SET_DTR; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sClrRTS</span>
<span class="cm">Purpose:  Clr the RTS output</span>
<span class="cm">Call:     sClrRTS(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sClrRTS(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   if ((ChP)-&gt;rtsToggle) break; \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] &amp;= ~SET_RTS; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sClrTxXOFF</span>
<span class="cm">Purpose:  Clear any existing transmit software flow control off condition</span>
<span class="cm">Call:     sClrTxXOFF(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sClrTxXOFF(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   sOutB((ChP)-&gt;Cmd,TXOVERIDE | (Byte_t)(ChP)-&gt;ChanNum); \</span>
<span class="cp">   sOutB((ChP)-&gt;Cmd,(Byte_t)(ChP)-&gt;ChanNum); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sCtlNumToCtlPtr</span>
<span class="cm">Purpose:  Convert a controller number to controller structure pointer</span>
<span class="cm">Call:     sCtlNumToCtlPtr(CtlNum)</span>
<span class="cm">          int CtlNum; Controller number</span>
<span class="cm">Return:   CONTROLLER_T *: Ptr to controller structure</span>
<span class="cm">*/</span>
<span class="cp">#define sCtlNumToCtlPtr(CTLNUM) &amp;sController[CTLNUM]</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sControllerEOI</span>
<span class="cm">Purpose:  Strobe the MUDBAC&#39;s End Of Interrupt bit.</span>
<span class="cm">Call:     sControllerEOI(CtlP)</span>
<span class="cm">          CONTROLLER_T *CtlP; Ptr to controller structure</span>
<span class="cm">*/</span>
<span class="cp">#define sControllerEOI(CTLP) sOutB((CTLP)-&gt;MReg2IO,(CTLP)-&gt;MReg2 | INT_STROB)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sPCIControllerEOI</span>
<span class="cm">Purpose:  Strobe the PCI End Of Interrupt bit.</span>
<span class="cm">          For the UPCI boards, toggle the AIOP interrupt enable bit</span>
<span class="cm">	  (this was taken from the Windows driver).</span>
<span class="cm">Call:     sPCIControllerEOI(CtlP)</span>
<span class="cm">          CONTROLLER_T *CtlP; Ptr to controller structure</span>
<span class="cm">*/</span>
<span class="cp">#define sPCIControllerEOI(CTLP) \</span>
<span class="cp">do { \</span>
<span class="cp">    if ((CTLP)-&gt;isUPCI) { \</span>
<span class="cp">	Word_t w = sInW((CTLP)-&gt;PCIIO); \</span>
<span class="cp">	sOutW((CTLP)-&gt;PCIIO, (w ^ PCI_INT_CTRL_AIOP)); \</span>
<span class="cp">	sOutW((CTLP)-&gt;PCIIO, w); \</span>
<span class="cp">    } \</span>
<span class="cp">    else { \</span>
<span class="cp">	sOutW((CTLP)-&gt;PCIIO, PCI_STROB); \</span>
<span class="cp">    } \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sDisAiop</span>
<span class="cm">Purpose:  Disable I/O access to an AIOP</span>
<span class="cm">Call:     sDisAiop(CltP)</span>
<span class="cm">          CONTROLLER_T *CtlP; Ptr to controller structure</span>
<span class="cm">          int AiopNum; Number of AIOP on controller</span>
<span class="cm">*/</span>
<span class="cp">#define sDisAiop(CTLP,AIOPNUM) \</span>
<span class="cp">do { \</span>
<span class="cp">   (CTLP)-&gt;MReg3 &amp;= sBitMapClrTbl[AIOPNUM]; \</span>
<span class="cp">   sOutB((CTLP)-&gt;MReg3IO,(CTLP)-&gt;MReg3); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sDisCTSFlowCtl</span>
<span class="cm">Purpose:  Disable output flow control using CTS</span>
<span class="cm">Call:     sDisCTSFlowCtl(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sDisCTSFlowCtl(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] &amp;= ~CTSFC_EN; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sDisIXANY</span>
<span class="cm">Purpose:  Disable IXANY Software Flow Control</span>
<span class="cm">Call:     sDisIXANY(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sDisIXANY(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;R[0x0e] = 0x86; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0x0c]); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: DisParity</span>
<span class="cm">Purpose:  Disable parity</span>
<span class="cm">Call:     sDisParity(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: Function sSetParity() can be used in place of functions sEnParity(),</span>
<span class="cm">          sDisParity(), sSetOddParity(), and sSetEvenParity().</span>
<span class="cm">*/</span>
<span class="cp">#define sDisParity(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] &amp;= ~PARITY_EN; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sDisRTSToggle</span>
<span class="cm">Purpose:  Disable RTS toggle</span>
<span class="cm">Call:     sDisRTSToggle(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sDisRTSToggle(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] &amp;= ~RTSTOG_EN; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">   (ChP)-&gt;rtsToggle = 0; \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sDisRxFIFO</span>
<span class="cm">Purpose:  Disable Rx FIFO</span>
<span class="cm">Call:     sDisRxFIFO(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sDisRxFIFO(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;R[0x32] = 0x0a; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0x30]); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sDisRxStatusMode</span>
<span class="cm">Purpose:  Disable the Rx status mode</span>
<span class="cm">Call:     sDisRxStatusMode(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: This takes the channel out of the receive status mode.  All</span>
<span class="cm">          subsequent reads of receive data using sReadRxWord() will return</span>
<span class="cm">          two data bytes.</span>
<span class="cm">*/</span>
<span class="cp">#define sDisRxStatusMode(ChP) sOutW((ChP)-&gt;ChanStat,0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sDisTransmit</span>
<span class="cm">Purpose:  Disable transmit</span>
<span class="cm">Call:     sDisTransmit(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">          This disables movement of Tx data from the Tx FIFO into the 1 byte</span>
<span class="cm">          Tx buffer.  Therefore there could be up to a 2 byte latency</span>
<span class="cm">          between the time sDisTransmit() is called and the transmit buffer</span>
<span class="cm">          and transmit shift register going completely empty.</span>
<span class="cm">*/</span>
<span class="cp">#define sDisTransmit(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] &amp;= ~TX_ENABLE; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sDisTxSoftFlowCtl</span>
<span class="cm">Purpose:  Disable Tx Software Flow Control</span>
<span class="cm">Call:     sDisTxSoftFlowCtl(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sDisTxSoftFlowCtl(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;R[0x06] = 0x8a; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0x04]); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnAiop</span>
<span class="cm">Purpose:  Enable I/O access to an AIOP</span>
<span class="cm">Call:     sEnAiop(CltP)</span>
<span class="cm">          CONTROLLER_T *CtlP; Ptr to controller structure</span>
<span class="cm">          int AiopNum; Number of AIOP on controller</span>
<span class="cm">*/</span>
<span class="cp">#define sEnAiop(CTLP,AIOPNUM) \</span>
<span class="cp">do { \</span>
<span class="cp">   (CTLP)-&gt;MReg3 |= sBitMapSetTbl[AIOPNUM]; \</span>
<span class="cp">   sOutB((CTLP)-&gt;MReg3IO,(CTLP)-&gt;MReg3); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnCTSFlowCtl</span>
<span class="cm">Purpose:  Enable output flow control using CTS</span>
<span class="cm">Call:     sEnCTSFlowCtl(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sEnCTSFlowCtl(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] |= CTSFC_EN; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnIXANY</span>
<span class="cm">Purpose:  Enable IXANY Software Flow Control</span>
<span class="cm">Call:     sEnIXANY(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sEnIXANY(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;R[0x0e] = 0x21; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0x0c]); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: EnParity</span>
<span class="cm">Purpose:  Enable parity</span>
<span class="cm">Call:     sEnParity(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: Function sSetParity() can be used in place of functions sEnParity(),</span>
<span class="cm">          sDisParity(), sSetOddParity(), and sSetEvenParity().</span>

<span class="cm">Warnings: Before enabling parity odd or even parity should be chosen using</span>
<span class="cm">          functions sSetOddParity() or sSetEvenParity().</span>
<span class="cm">*/</span>
<span class="cp">#define sEnParity(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] |= PARITY_EN; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnRTSToggle</span>
<span class="cm">Purpose:  Enable RTS toggle</span>
<span class="cm">Call:     sEnRTSToggle(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: This function will disable RTS flow control and clear the RTS</span>
<span class="cm">          line to allow operation of RTS toggle.</span>
<span class="cm">*/</span>
<span class="cp">#define sEnRTSToggle(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;RxControl[2] &amp;= ~RTSFC_EN; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;RxControl); \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] |= RTSTOG_EN; \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] &amp;= ~SET_RTS; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">   (ChP)-&gt;rtsToggle = 1; \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnRxFIFO</span>
<span class="cm">Purpose:  Enable Rx FIFO</span>
<span class="cm">Call:     sEnRxFIFO(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sEnRxFIFO(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;R[0x32] = 0x08; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0x30]); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnRxProcessor</span>
<span class="cm">Purpose:  Enable the receive processor</span>
<span class="cm">Call:     sEnRxProcessor(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: This function is used to start the receive processor.  When</span>
<span class="cm">          the channel is in the reset state the receive processor is not</span>
<span class="cm">          running.  This is done to prevent the receive processor from</span>
<span class="cm">          executing invalid microcode instructions prior to the</span>
<span class="cm">          downloading of the microcode.</span>

<span class="cm">Warnings: This function must be called after valid microcode has been</span>
<span class="cm">          downloaded to the AIOP, and it must not be called before the</span>
<span class="cm">          microcode has been downloaded.</span>
<span class="cm">*/</span>
<span class="cp">#define sEnRxProcessor(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;RxControl[2] |= RXPROC_EN; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;RxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnRxStatusMode</span>
<span class="cm">Purpose:  Enable the Rx status mode</span>
<span class="cm">Call:     sEnRxStatusMode(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: This places the channel in the receive status mode.  All subsequent</span>
<span class="cm">          reads of receive data using sReadRxWord() will return a data byte</span>
<span class="cm">          in the low word and a status byte in the high word.</span>

<span class="cm">*/</span>
<span class="cp">#define sEnRxStatusMode(ChP) sOutW((ChP)-&gt;ChanStat,STATMODE)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnTransmit</span>
<span class="cm">Purpose:  Enable transmit</span>
<span class="cm">Call:     sEnTransmit(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sEnTransmit(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] |= TX_ENABLE; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sEnTxSoftFlowCtl</span>
<span class="cm">Purpose:  Enable Tx Software Flow Control</span>
<span class="cm">Call:     sEnTxSoftFlowCtl(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sEnTxSoftFlowCtl(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;R[0x06] = 0xc5; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0x04]); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sGetAiopIntStatus</span>
<span class="cm">Purpose:  Get the AIOP interrupt status</span>
<span class="cm">Call:     sGetAiopIntStatus(CtlP,AiopNum)</span>
<span class="cm">          CONTROLLER_T *CtlP; Ptr to controller structure</span>
<span class="cm">          int AiopNum; AIOP number</span>
<span class="cm">Return:   Byte_t: The AIOP interrupt status.  Bits 0 through 7</span>
<span class="cm">                         represent channels 0 through 7 respectively.  If a</span>
<span class="cm">                         bit is set that channel is interrupting.</span>
<span class="cm">*/</span>
<span class="cp">#define sGetAiopIntStatus(CTLP,AIOPNUM) sInB((CTLP)-&gt;AiopIntChanIO[AIOPNUM])</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sGetAiopNumChan</span>
<span class="cm">Purpose:  Get the number of channels supported by an AIOP</span>
<span class="cm">Call:     sGetAiopNumChan(CtlP,AiopNum)</span>
<span class="cm">          CONTROLLER_T *CtlP; Ptr to controller structure</span>
<span class="cm">          int AiopNum; AIOP number</span>
<span class="cm">Return:   int: The number of channels supported by the AIOP</span>
<span class="cm">*/</span>
<span class="cp">#define sGetAiopNumChan(CTLP,AIOPNUM) (CTLP)-&gt;AiopNumChan[AIOPNUM]</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sGetChanIntID</span>
<span class="cm">Purpose:  Get a channel&#39;s interrupt identification byte</span>
<span class="cm">Call:     sGetChanIntID(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Return:   Byte_t: The channel interrupt ID.  Can be any</span>
<span class="cm">             combination of the following flags:</span>
<span class="cm">                RXF_TRIG:     Rx FIFO trigger level interrupt</span>
<span class="cm">                TXFIFO_MT:    Tx FIFO empty interrupt</span>
<span class="cm">                SRC_INT:      Special receive condition interrupt</span>
<span class="cm">                DELTA_CD:     CD change interrupt</span>
<span class="cm">                DELTA_CTS:    CTS change interrupt</span>
<span class="cm">                DELTA_DSR:    DSR change interrupt</span>
<span class="cm">*/</span>
<span class="cp">#define sGetChanIntID(ChP) (sInB((ChP)-&gt;IntID) &amp; (RXF_TRIG | TXFIFO_MT | SRC_INT | DELTA_CD | DELTA_CTS | DELTA_DSR))</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sGetChanNum</span>
<span class="cm">Purpose:  Get the number of a channel within an AIOP</span>
<span class="cm">Call:     sGetChanNum(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Return:   int: Channel number within AIOP, or NULLCHAN if channel does</span>
<span class="cm">               not exist.</span>
<span class="cm">*/</span>
<span class="cp">#define sGetChanNum(ChP) (ChP)-&gt;ChanNum</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sGetChanStatus</span>
<span class="cm">Purpose:  Get the channel status</span>
<span class="cm">Call:     sGetChanStatus(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Return:   Word_t: The channel status.  Can be any combination of</span>
<span class="cm">             the following flags:</span>
<span class="cm">                LOW BYTE FLAGS</span>
<span class="cm">                CTS_ACT:      CTS input asserted</span>
<span class="cm">                DSR_ACT:      DSR input asserted</span>
<span class="cm">                CD_ACT:       CD input asserted</span>
<span class="cm">                TXFIFOMT:     Tx FIFO is empty</span>
<span class="cm">                TXSHRMT:      Tx shift register is empty</span>
<span class="cm">                RDA:          Rx data available</span>

<span class="cm">                HIGH BYTE FLAGS</span>
<span class="cm">                STATMODE:     status mode enable bit</span>
<span class="cm">                RXFOVERFL:    receive FIFO overflow</span>
<span class="cm">                RX2MATCH:     receive compare byte 2 match</span>
<span class="cm">                RX1MATCH:     receive compare byte 1 match</span>
<span class="cm">                RXBREAK:      received BREAK</span>
<span class="cm">                RXFRAME:      received framing error</span>
<span class="cm">                RXPARITY:     received parity error</span>
<span class="cm">Warnings: This function will clear the high byte flags in the Channel</span>
<span class="cm">          Status Register.</span>
<span class="cm">*/</span>
<span class="cp">#define sGetChanStatus(ChP) sInW((ChP)-&gt;ChanStat)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sGetChanStatusLo</span>
<span class="cm">Purpose:  Get the low byte only of the channel status</span>
<span class="cm">Call:     sGetChanStatusLo(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Return:   Byte_t: The channel status low byte.  Can be any combination</span>
<span class="cm">             of the following flags:</span>
<span class="cm">                CTS_ACT:      CTS input asserted</span>
<span class="cm">                DSR_ACT:      DSR input asserted</span>
<span class="cm">                CD_ACT:       CD input asserted</span>
<span class="cm">                TXFIFOMT:     Tx FIFO is empty</span>
<span class="cm">                TXSHRMT:      Tx shift register is empty</span>
<span class="cm">                RDA:          Rx data available</span>
<span class="cm">*/</span>
<span class="cp">#define sGetChanStatusLo(ChP) sInB((ByteIO_t)(ChP)-&gt;ChanStat)</span>

<span class="cm">/**********************************************************************</span>
<span class="cm"> * Get RI status of channel</span>
<span class="cm"> * Defined as a function in rocket.c   -aes</span>
<span class="cm"> */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define sGetChanRI(ChP) ((ChP)-&gt;CtlP-&gt;AltChanRingIndicator ? \</span>
<span class="c">                          (sInB((ByteIO_t)((ChP)-&gt;ChanStat+8)) &amp; DSR_ACT) : \</span>
<span class="c">                            (((ChP)-&gt;CtlP-&gt;boardType == ROCKET_TYPE_PC104) ? \</span>
<span class="c">                               (!(sInB((ChP)-&gt;CtlP-&gt;AiopIO[3]) &amp; sBitMapSetTbl[(ChP)-&gt;ChanNum])) : \</span>
<span class="c">                             0))</span>
<span class="cp">#endif</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sGetControllerIntStatus</span>
<span class="cm">Purpose:  Get the controller interrupt status</span>
<span class="cm">Call:     sGetControllerIntStatus(CtlP)</span>
<span class="cm">          CONTROLLER_T *CtlP; Ptr to controller structure</span>
<span class="cm">Return:   Byte_t: The controller interrupt status in the lower 4</span>
<span class="cm">                         bits.  Bits 0 through 3 represent AIOP&#39;s 0</span>
<span class="cm">                         through 3 respectively.  If a bit is set that</span>
<span class="cm">                         AIOP is interrupting.  Bits 4 through 7 will</span>
<span class="cm">                         always be cleared.</span>
<span class="cm">*/</span>
<span class="cp">#define sGetControllerIntStatus(CTLP) (sInB((CTLP)-&gt;MReg1IO) &amp; 0x0f)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sPCIGetControllerIntStatus</span>
<span class="cm">Purpose:  Get the controller interrupt status</span>
<span class="cm">Call:     sPCIGetControllerIntStatus(CtlP)</span>
<span class="cm">          CONTROLLER_T *CtlP; Ptr to controller structure</span>
<span class="cm">Return:   unsigned char: The controller interrupt status in the lower 4</span>
<span class="cm">                         bits and bit 4.  Bits 0 through 3 represent AIOP&#39;s 0</span>
<span class="cm">                         through 3 respectively. Bit 4 is set if the int </span>
<span class="cm">			 was generated from periodic. If a bit is set the</span>
<span class="cm">			 AIOP is interrupting.</span>
<span class="cm">*/</span>
<span class="cp">#define sPCIGetControllerIntStatus(CTLP) \</span>
<span class="cp">	((CTLP)-&gt;isUPCI ? \</span>
<span class="cp">	  (sInW((CTLP)-&gt;PCIIO2) &amp; UPCI_AIOP_INTR_BITS) : \</span>
<span class="cp">	  ((sInW((CTLP)-&gt;PCIIO) &gt;&gt; 8) &amp; AIOP_INTR_BITS))</span>

<span class="cm">/***************************************************************************</span>

<span class="cm">Function: sGetRxCnt</span>
<span class="cm">Purpose:  Get the number of data bytes in the Rx FIFO</span>
<span class="cm">Call:     sGetRxCnt(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Return:   int: The number of data bytes in the Rx FIFO.</span>
<span class="cm">Comments: Byte read of count register is required to obtain Rx count.</span>

<span class="cm">*/</span>
<span class="cp">#define sGetRxCnt(ChP) sInW((ChP)-&gt;TxRxCount)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sGetTxCnt</span>
<span class="cm">Purpose:  Get the number of data bytes in the Tx FIFO</span>
<span class="cm">Call:     sGetTxCnt(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Return:   Byte_t: The number of data bytes in the Tx FIFO.</span>
<span class="cm">Comments: Byte read of count register is required to obtain Tx count.</span>

<span class="cm">*/</span>
<span class="cp">#define sGetTxCnt(ChP) sInB((ByteIO_t)(ChP)-&gt;TxRxCount)</span>

<span class="cm">/*****************************************************************************</span>
<span class="cm">Function: sGetTxRxDataIO</span>
<span class="cm">Purpose:  Get the I/O address of a channel&#39;s TxRx Data register</span>
<span class="cm">Call:     sGetTxRxDataIO(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Return:   WordIO_t: I/O address of a channel&#39;s TxRx Data register</span>
<span class="cm">*/</span>
<span class="cp">#define sGetTxRxDataIO(ChP) (ChP)-&gt;TxRxData</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sInitChanDefaults</span>
<span class="cm">Purpose:  Initialize a channel structure to it&#39;s default state.</span>
<span class="cm">Call:     sInitChanDefaults(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to the channel structure</span>
<span class="cm">Comments: This function must be called once for every channel structure</span>
<span class="cm">          that exists before any other SSCI calls can be made.</span>

<span class="cm">*/</span>
<span class="cp">#define sInitChanDefaults(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;CtlP = NULLCTLPTR; \</span>
<span class="cp">   (ChP)-&gt;AiopNum = NULLAIOP; \</span>
<span class="cp">   (ChP)-&gt;ChanID = AIOPID_NULL; \</span>
<span class="cp">   (ChP)-&gt;ChanNum = NULLCHAN; \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sResetAiopByNum</span>
<span class="cm">Purpose:  Reset the AIOP by number</span>
<span class="cm">Call:     sResetAiopByNum(CTLP,AIOPNUM)</span>
<span class="cm">	CONTROLLER_T CTLP; Ptr to controller structure</span>
<span class="cm">	AIOPNUM; AIOP index </span>
<span class="cm">*/</span>
<span class="cp">#define sResetAiopByNum(CTLP,AIOPNUM) \</span>
<span class="cp">do { \</span>
<span class="cp">   sOutB((CTLP)-&gt;AiopIO[(AIOPNUM)]+_CMD_REG,RESET_ALL); \</span>
<span class="cp">   sOutB((CTLP)-&gt;AiopIO[(AIOPNUM)]+_CMD_REG,0x0); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSendBreak</span>
<span class="cm">Purpose:  Send a transmit BREAK signal</span>
<span class="cm">Call:     sSendBreak(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sSendBreak(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] |= SETBREAK; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetBaud</span>
<span class="cm">Purpose:  Set baud rate</span>
<span class="cm">Call:     sSetBaud(ChP,Divisor)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">          Word_t Divisor; 16 bit baud rate divisor for channel</span>
<span class="cm">*/</span>
<span class="cp">#define sSetBaud(ChP,DIVISOR) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;BaudDiv[2] = (Byte_t)(DIVISOR); \</span>
<span class="cp">   (ChP)-&gt;BaudDiv[3] = (Byte_t)((DIVISOR) &gt;&gt; 8); \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;BaudDiv); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetData7</span>
<span class="cm">Purpose:  Set data bits to 7</span>
<span class="cm">Call:     sSetData7(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sSetData7(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] &amp;= ~DATA8BIT; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetData8</span>
<span class="cm">Purpose:  Set data bits to 8</span>
<span class="cm">Call:     sSetData8(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sSetData8(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] |= DATA8BIT; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetDTR</span>
<span class="cm">Purpose:  Set the DTR output</span>
<span class="cm">Call:     sSetDTR(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sSetDTR(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] |= SET_DTR; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetEvenParity</span>
<span class="cm">Purpose:  Set even parity</span>
<span class="cm">Call:     sSetEvenParity(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: Function sSetParity() can be used in place of functions sEnParity(),</span>
<span class="cm">          sDisParity(), sSetOddParity(), and sSetEvenParity().</span>

<span class="cm">Warnings: This function has no effect unless parity is enabled with function</span>
<span class="cm">          sEnParity().</span>
<span class="cm">*/</span>
<span class="cp">#define sSetEvenParity(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] |= EVEN_PAR; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetOddParity</span>
<span class="cm">Purpose:  Set odd parity</span>
<span class="cm">Call:     sSetOddParity(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: Function sSetParity() can be used in place of functions sEnParity(),</span>
<span class="cm">          sDisParity(), sSetOddParity(), and sSetEvenParity().</span>

<span class="cm">Warnings: This function has no effect unless parity is enabled with function</span>
<span class="cm">          sEnParity().</span>
<span class="cm">*/</span>
<span class="cp">#define sSetOddParity(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] &amp;= ~EVEN_PAR; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetRTS</span>
<span class="cm">Purpose:  Set the RTS output</span>
<span class="cm">Call:     sSetRTS(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sSetRTS(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   if ((ChP)-&gt;rtsToggle) break; \</span>
<span class="cp">   (ChP)-&gt;TxControl[3] |= SET_RTS; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetRxTrigger</span>
<span class="cm">Purpose:  Set the Rx FIFO trigger level</span>
<span class="cm">Call:     sSetRxProcessor(ChP,Level)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">          Byte_t Level; Number of characters in Rx FIFO at which the</span>
<span class="cm">             interrupt will be generated.  Can be any of the following flags:</span>

<span class="cm">             TRIG_NO:   no trigger</span>
<span class="cm">             TRIG_1:    1 character in FIFO</span>
<span class="cm">             TRIG_1_2:  FIFO 1/2 full</span>
<span class="cm">             TRIG_7_8:  FIFO 7/8 full</span>
<span class="cm">Comments: An interrupt will be generated when the trigger level is reached</span>
<span class="cm">          only if function sEnInterrupt() has been called with flag</span>
<span class="cm">          RXINT_EN set.  The RXF_TRIG flag in the Interrupt Idenfification</span>
<span class="cm">          register will be set whenever the trigger level is reached</span>
<span class="cm">          regardless of the setting of RXINT_EN.</span>

<span class="cm">*/</span>
<span class="cp">#define sSetRxTrigger(ChP,LEVEL) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;RxControl[2] &amp;= ~TRIG_MASK; \</span>
<span class="cp">   (ChP)-&gt;RxControl[2] |= LEVEL; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;RxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetStop1</span>
<span class="cm">Purpose:  Set stop bits to 1</span>
<span class="cm">Call:     sSetStop1(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sSetStop1(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] &amp;= ~STOP2; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetStop2</span>
<span class="cm">Purpose:  Set stop bits to 2</span>
<span class="cm">Call:     sSetStop2(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">*/</span>
<span class="cp">#define sSetStop2(ChP) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;TxControl[2] |= STOP2; \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,(ChP)-&gt;TxControl); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetTxXOFFChar</span>
<span class="cm">Purpose:  Set the Tx XOFF flow control character</span>
<span class="cm">Call:     sSetTxXOFFChar(ChP,Ch)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">          Byte_t Ch; The value to set the Tx XOFF character to</span>
<span class="cm">*/</span>
<span class="cp">#define sSetTxXOFFChar(ChP,CH) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;R[0x07] = (CH); \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0x04]); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sSetTxXONChar</span>
<span class="cm">Purpose:  Set the Tx XON flow control character</span>
<span class="cm">Call:     sSetTxXONChar(ChP,Ch)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">          Byte_t Ch; The value to set the Tx XON character to</span>
<span class="cm">*/</span>
<span class="cp">#define sSetTxXONChar(ChP,CH) \</span>
<span class="cp">do { \</span>
<span class="cp">   (ChP)-&gt;R[0x0b] = (CH); \</span>
<span class="cp">   out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0x08]); \</span>
<span class="cp">} while (0)</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sStartRxProcessor</span>
<span class="cm">Purpose:  Start a channel&#39;s receive processor</span>
<span class="cm">Call:     sStartRxProcessor(ChP)</span>
<span class="cm">          CHANNEL_T *ChP; Ptr to channel structure</span>
<span class="cm">Comments: This function is used to start a Rx processor after it was</span>
<span class="cm">          stopped with sStopRxProcessor() or sStopSWInFlowCtl().  It</span>
<span class="cm">          will restart both the Rx processor and software input flow control.</span>

<span class="cm">*/</span>
<span class="cp">#define sStartRxProcessor(ChP) out32((ChP)-&gt;IndexAddr,&amp;(ChP)-&gt;R[0])</span>

<span class="cm">/***************************************************************************</span>
<span class="cm">Function: sWriteTxByte</span>
<span class="cm">Purpose:  Write a transmit data byte to a channel.</span>
<span class="cm">          ByteIO_t io: Channel transmit register I/O address.  This can</span>
<span class="cm">                           be obtained with sGetTxRxDataIO().</span>
<span class="cm">          Byte_t Data; The transmit data byte.</span>
<span class="cm">Warnings: This function writes the data byte without checking to see if</span>
<span class="cm">          sMaxTxSize is exceeded in the Tx FIFO.</span>
<span class="cm">*/</span>
<span class="cp">#define sWriteTxByte(IO,DATA) sOutB(IO,DATA)</span>

<span class="cm">/*</span>
<span class="cm"> * Begin Linux specific definitions for the Rocketport driver</span>
<span class="cm"> *</span>
<span class="cm"> * This code is Copyright Theodore Ts&#39;o, 1995-1997</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">r_port</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">magic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">line</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Don&#39;t yet match the ASY_ flags!! */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">board</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">aiop</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chan</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">CONTROLLER_t</span> <span class="o">*</span><span class="n">ctlp</span><span class="p">;</span>
	<span class="n">CHANNEL_t</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">intmask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xmit_fifo_room</span><span class="p">;</span>	<span class="cm">/* room in xmit fifo */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">xmit_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xmit_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xmit_tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xmit_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cd_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ignore_status_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">read_status_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cps</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">completion</span> <span class="n">close_wait</span><span class="p">;</span>	<span class="cm">/* Not yet matching the core */</span>
	<span class="n">spinlock_t</span> <span class="n">slock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">write_mtx</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define RPORT_MAGIC 0x525001</span>

<span class="cp">#define NUM_BOARDS 8</span>
<span class="cp">#define MAX_RP_PORTS (32*NUM_BOARDS)</span>

<span class="cm">/*</span>
<span class="cm"> * The size of the xmit buffer is 1 page, or 4096 bytes</span>
<span class="cm"> */</span>
<span class="cp">#define XMIT_BUF_SIZE 4096</span>

<span class="cm">/* number of characters left in xmit buffer before we ask for more */</span>
<span class="cp">#define WAKEUP_CHARS 256</span>

<span class="cm">/*</span>
<span class="cm"> * Assigned major numbers for the Comtrol Rocketport</span>
<span class="cm"> */</span>
<span class="cp">#define TTY_ROCKET_MAJOR	46</span>
<span class="cp">#define CUA_ROCKET_MAJOR	47</span>

<span class="cp">#ifdef PCI_VENDOR_ID_RP</span>
<span class="cp">#undef PCI_VENDOR_ID_RP</span>
<span class="cp">#undef PCI_DEVICE_ID_RP8OCTA</span>
<span class="cp">#undef PCI_DEVICE_ID_RP8INTF</span>
<span class="cp">#undef PCI_DEVICE_ID_RP16INTF</span>
<span class="cp">#undef PCI_DEVICE_ID_RP32INTF</span>
<span class="cp">#undef PCI_DEVICE_ID_URP8OCTA</span>
<span class="cp">#undef PCI_DEVICE_ID_URP8INTF</span>
<span class="cp">#undef PCI_DEVICE_ID_URP16INTF</span>
<span class="cp">#undef PCI_DEVICE_ID_CRP16INTF</span>
<span class="cp">#undef PCI_DEVICE_ID_URP32INTF</span>
<span class="cp">#endif</span>

<span class="cm">/*  Comtrol PCI Vendor ID */</span>
<span class="cp">#define PCI_VENDOR_ID_RP		0x11fe</span>

<span class="cm">/*  Comtrol Device ID&#39;s */</span>
<span class="cp">#define PCI_DEVICE_ID_RP32INTF		0x0001	</span><span class="cm">/* Rocketport 32 port w/external I/F     */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP8INTF		0x0002	</span><span class="cm">/* Rocketport 8 port w/external I/F      */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP16INTF		0x0003	</span><span class="cm">/* Rocketport 16 port w/external I/F     */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP4QUAD		0x0004	</span><span class="cm">/* Rocketport 4 port w/quad cable        */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP8OCTA		0x0005	</span><span class="cm">/* Rocketport 8 port w/octa cable        */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP8J		0x0006	</span><span class="cm">/* Rocketport 8 port w/RJ11 connectors   */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP4J		0x0007	</span><span class="cm">/* Rocketport 4 port w/RJ11 connectors   */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP8SNI		0x0008	</span><span class="cm">/* Rocketport 8 port w/ DB78 SNI (Siemens) connector */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP16SNI		0x0009	</span><span class="cm">/* Rocketport 16 port w/ DB78 SNI (Siemens) connector   */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RPP4		0x000A	</span><span class="cm">/* Rocketport Plus 4 port                */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RPP8		0x000B	</span><span class="cm">/* Rocketport Plus 8 port                */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP6M		0x000C	</span><span class="cm">/* RocketModem 6 port                    */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP4M		0x000D	</span><span class="cm">/* RocketModem 4 port                    */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP2_232           0x000E	</span><span class="cm">/* Rocketport Plus 2 port RS232          */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_RP2_422           0x000F	</span><span class="cm">/* Rocketport Plus 2 port RS422          */</span><span class="cp"> </span>

<span class="cm">/* Universal PCI boards  */</span>
<span class="cp">#define PCI_DEVICE_ID_URP32INTF		0x0801	</span><span class="cm">/* Rocketport UPCI 32 port w/external I/F */</span><span class="cp"> </span>
<span class="cp">#define PCI_DEVICE_ID_URP8INTF		0x0802	</span><span class="cm">/* Rocketport UPCI 8 port w/external I/F  */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_URP16INTF		0x0803	</span><span class="cm">/* Rocketport UPCI 16 port w/external I/F */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_URP8OCTA		0x0805	</span><span class="cm">/* Rocketport UPCI 8 port w/octa cable    */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_UPCI_RM3_8PORT    0x080C	</span><span class="cm">/* Rocketmodem III 8 port                 */</span><span class="cp"></span>
<span class="cp">#define PCI_DEVICE_ID_UPCI_RM3_4PORT    0x080D	</span><span class="cm">/* Rocketmodem III 4 port                 */</span><span class="cp"></span>

<span class="cm">/* Compact PCI device */</span> 
<span class="cp">#define PCI_DEVICE_ID_CRP16INTF		0x0903	</span><span class="cm">/* Rocketport Compact PCI 16 port w/external I/F */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
