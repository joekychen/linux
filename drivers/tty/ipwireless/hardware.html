<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › ipwireless › hardware.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>hardware.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IPWireless 3G PCMCIA Network Driver</span>
<span class="cm"> *</span>
<span class="cm"> * Original code</span>
<span class="cm"> *   by Stephen Blackheath &lt;stephen@blacksapphire.com&gt;,</span>
<span class="cm"> *      Ben Martel &lt;benm@symmetric.co.nz&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyrighted as follows:</span>
<span class="cm"> *   Copyright (C) 2004 by Symmetric Systems Ltd (NZ)</span>
<span class="cm"> *</span>
<span class="cm"> * Various driver changes and rewrites, port to new kernels</span>
<span class="cm"> *   Copyright (C) 2006-2007 Jiri Kosina</span>
<span class="cm"> *</span>
<span class="cm"> * Misc code cleanups and updates</span>
<span class="cm"> *   Copyright (C) 2007 David Sterba</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;hardware.h&quot;</span>
<span class="cp">#include &quot;setup_protocol.h&quot;</span>
<span class="cp">#include &quot;network.h&quot;</span>
<span class="cp">#include &quot;main.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ipw_send_setup_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">handle_received_SETUP_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">ipw</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">is_last</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ipwireless_setup_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">handle_received_CTRL_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/*#define TIMING_DIAGNOSTICS*/</span>

<span class="cp">#ifdef TIMING_DIAGNOSTICS</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timing_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_report_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">read_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">read_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_timing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timing_stats</span><span class="p">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_read_timing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timing_stats</span><span class="p">.</span><span class="n">read_time</span> <span class="o">+=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">);</span>
	<span class="n">timing_stats</span><span class="p">.</span><span class="n">read_bytes</span> <span class="o">+=</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">report_timing</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_write_timing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timing_stats</span><span class="p">.</span><span class="n">write_time</span> <span class="o">+=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">);</span>
	<span class="n">timing_stats</span><span class="p">.</span><span class="n">write_bytes</span> <span class="o">+=</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">report_timing</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">report_timing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">since</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">timing_stats</span><span class="p">.</span><span class="n">last_report_time</span><span class="p">;</span>

	<span class="cm">/* If it&#39;s been more than one second... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">since</span> <span class="o">&gt;=</span> <span class="n">HZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="p">(</span><span class="n">timing_stats</span><span class="p">.</span><span class="n">last_report_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">timing_stats</span><span class="p">.</span><span class="n">last_report_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
			       <span class="s">&quot;: %u us elapsed - read %lu bytes in %u us, wrote %lu bytes in %u us</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">since</span><span class="p">),</span>
			       <span class="n">timing_stats</span><span class="p">.</span><span class="n">read_bytes</span><span class="p">,</span>
			       <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">timing_stats</span><span class="p">.</span><span class="n">read_time</span><span class="p">),</span>
			       <span class="n">timing_stats</span><span class="p">.</span><span class="n">write_bytes</span><span class="p">,</span>
			       <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">timing_stats</span><span class="p">.</span><span class="n">write_time</span><span class="p">));</span>

		<span class="n">timing_stats</span><span class="p">.</span><span class="n">read_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">timing_stats</span><span class="p">.</span><span class="n">write_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">timing_stats</span><span class="p">.</span><span class="n">read_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">timing_stats</span><span class="p">.</span><span class="n">write_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">start_timing</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_read_timing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_write_timing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Imported IPW definitions */</span>

<span class="cp">#define LL_MTU_V1 318</span>
<span class="cp">#define LL_MTU_V2 250</span>
<span class="cp">#define LL_MTU_MAX (LL_MTU_V1 &gt; LL_MTU_V2 ? LL_MTU_V1 : LL_MTU_V2)</span>

<span class="cp">#define PRIO_DATA  2</span>
<span class="cp">#define PRIO_CTRL  1</span>
<span class="cp">#define PRIO_SETUP 0</span>

<span class="cm">/* Addresses */</span>
<span class="cp">#define ADDR_SETUP_PROT 0</span>

<span class="cm">/* Protocol ids */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Identifier for the Com Data protocol */</span>
	<span class="n">TL_PROTOCOLID_COM_DATA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

	<span class="cm">/* Identifier for the Com Control protocol */</span>
	<span class="n">TL_PROTOCOLID_COM_CTRL</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* Identifier for the Setup protocol */</span>
	<span class="n">TL_PROTOCOLID_SETUP</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="cm">/* Number of bytes in NL packet header (cannot do</span>
<span class="cm"> * sizeof(nl_packet_header) since it&#39;s a bitfield) */</span>
<span class="cp">#define NL_FIRST_PACKET_HEADER_SIZE        3</span>

<span class="cm">/* Number of bytes in NL packet header (cannot do</span>
<span class="cm"> * sizeof(nl_packet_header) since it&#39;s a bitfield) */</span>
<span class="cp">#define NL_FOLLOWING_PACKET_HEADER_SIZE    1</span>

<span class="k">struct</span> <span class="n">nl_first_packet_header</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">protocol</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">address</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">packet_rank</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">length_lsb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">length_msb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nl_packet_header</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">protocol</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">address</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">packet_rank</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Value of &#39;packet_rank&#39; above */</span>
<span class="cp">#define NL_INTERMEDIATE_PACKET    0x0</span>
<span class="cp">#define NL_LAST_PACKET            0x1</span>
<span class="cp">#define NL_FIRST_PACKET           0x2</span>

<span class="k">union</span> <span class="n">nl_packet</span> <span class="p">{</span>
	<span class="cm">/* Network packet header of the first packet (a special case) */</span>
	<span class="k">struct</span> <span class="n">nl_first_packet_header</span> <span class="n">hdr_first</span><span class="p">;</span>
	<span class="cm">/* Network packet header of the following packets (if any) */</span>
	<span class="k">struct</span> <span class="n">nl_packet_header</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="cm">/* Complete network packet (header + data) */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rawpkt</span><span class="p">[</span><span class="n">LL_MTU_MAX</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="cp">#define HW_VERSION_UNKNOWN -1</span>
<span class="cp">#define HW_VERSION_1 1</span>
<span class="cp">#define HW_VERSION_2 2</span>

<span class="cm">/* IPW I/O ports */</span>
<span class="cp">#define IOIER 0x00		</span><span class="cm">/* Interrupt Enable Register */</span><span class="cp"></span>
<span class="cp">#define IOIR  0x02		</span><span class="cm">/* Interrupt Source/ACK register */</span><span class="cp"></span>
<span class="cp">#define IODCR 0x04		</span><span class="cm">/* Data Control Register */</span><span class="cp"></span>
<span class="cp">#define IODRR 0x06		</span><span class="cm">/* Data Read Register */</span><span class="cp"></span>
<span class="cp">#define IODWR 0x08		</span><span class="cm">/* Data Write Register */</span><span class="cp"></span>
<span class="cp">#define IOESR 0x0A		</span><span class="cm">/* Embedded Driver Status Register */</span><span class="cp"></span>
<span class="cp">#define IORXR 0x0C		</span><span class="cm">/* Rx Fifo Register (Host to Embedded) */</span><span class="cp"></span>
<span class="cp">#define IOTXR 0x0E		</span><span class="cm">/* Tx Fifo Register (Embedded to Host) */</span><span class="cp"></span>

<span class="cm">/* I/O ports and bit definitions for version 1 of the hardware */</span>

<span class="cm">/* IER bits*/</span>
<span class="cp">#define IER_RXENABLED   0x1</span>
<span class="cp">#define IER_TXENABLED   0x2</span>

<span class="cm">/* ISR bits */</span>
<span class="cp">#define IR_RXINTR       0x1</span>
<span class="cp">#define IR_TXINTR       0x2</span>

<span class="cm">/* DCR bits */</span>
<span class="cp">#define DCR_RXDONE      0x1</span>
<span class="cp">#define DCR_TXDONE      0x2</span>
<span class="cp">#define DCR_RXRESET     0x4</span>
<span class="cp">#define DCR_TXRESET     0x8</span>

<span class="cm">/* I/O ports and bit definitions for version 2 of the hardware */</span>

<span class="k">struct</span> <span class="n">MEMCCR</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_config_option</span><span class="p">;</span>	<span class="cm">/* PCCOR: Configuration Option Register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_config_and_status</span><span class="p">;</span>	<span class="cm">/* PCCSR: Configuration and Status Register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_pin_replacement</span><span class="p">;</span>	<span class="cm">/* PCPRR: Pin Replacemant Register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_socket_and_copy</span><span class="p">;</span>	<span class="cm">/* PCSCR: Socket and Copy Register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_ext_status</span><span class="p">;</span>		<span class="cm">/* PCESR: Extendend Status Register */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">reg_io_base</span><span class="p">;</span>		<span class="cm">/* PCIOB: I/O Base Register */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">MEMINFREG</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">memreg_tx_old</span><span class="p">;</span>	<span class="cm">/* TX Register (R/W) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">memreg_rx_done</span><span class="p">;</span>	<span class="cm">/* RXDone Register (R/W) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">pad2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">memreg_rx</span><span class="p">;</span>	<span class="cm">/* RX Register (R/W) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">pad3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">memreg_pc_interrupt_ack</span><span class="p">;</span>	<span class="cm">/* PC intr Ack Register (W) */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">pad4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">memreg_card_present</span><span class="p">;</span><span class="cm">/* Mask for Host to check (R) for</span>
<span class="cm">					   * CARD_PRESENT_VALUE */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">memreg_tx_new</span><span class="p">;</span>	<span class="cm">/* TX2 (new) Register (R/W) */</span>
<span class="p">};</span>

<span class="cp">#define CARD_PRESENT_VALUE (0xBEEFCAFEUL)</span>

<span class="cp">#define MEMTX_TX                       0x0001</span>
<span class="cp">#define MEMRX_RX                       0x0001</span>
<span class="cp">#define MEMRX_RX_DONE                  0x0001</span>
<span class="cp">#define MEMRX_PCINTACKK                0x0001</span>

<span class="cp">#define NL_NUM_OF_PRIORITIES       3</span>
<span class="cp">#define NL_NUM_OF_PROTOCOLS        3</span>
<span class="cp">#define NL_NUM_OF_ADDRESSES        NO_OF_IPW_CHANNELS</span>

<span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base_port</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">hw_version</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ll_mtu</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">initializing</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">init_loops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">setup_timer</span><span class="p">;</span>

	<span class="cm">/* Flag if hw is ready to send next packet */</span>
	<span class="kt">int</span> <span class="n">tx_ready</span><span class="p">;</span>
	<span class="cm">/* Count of pending packets to be sent */</span>
	<span class="kt">int</span> <span class="n">tx_queued</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tx_queue</span><span class="p">[</span><span class="n">NL_NUM_OF_PRIORITIES</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">rx_bytes_queued</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_queue</span><span class="p">;</span>
	<span class="cm">/* Pool of rx_packet structures that are not currently used. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_pool</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_pool_size</span><span class="p">;</span>
	<span class="cm">/* True if reception of data is blocked while userspace processes it. */</span>
	<span class="kt">int</span> <span class="n">blocking_rx</span><span class="p">;</span>
	<span class="cm">/* True if there is RX data ready on the hardware. */</span>
	<span class="kt">int</span> <span class="n">rx_ready</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">last_memtx_serial</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Newer versions of the V2 card firmware send serial numbers in the</span>
<span class="cm">	 * MemTX register. &#39;serial_number_detected&#39; is set true when we detect</span>
<span class="cm">	 * a non-zero serial number (indicating the new firmware).  Thereafter,</span>
<span class="cm">	 * the driver can safely ignore the Timer Recovery re-sends to avoid</span>
<span class="cm">	 * out-of-sync problems.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">serial_number_detected</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work_rx</span><span class="p">;</span>

	<span class="cm">/* True if we are to send the set-up data to the hardware. */</span>
	<span class="kt">int</span> <span class="n">to_setup</span><span class="p">;</span>

	<span class="cm">/* Card has been removed */</span>
	<span class="kt">int</span> <span class="n">removed</span><span class="p">;</span>
	<span class="cm">/* Saved irq value when we disable the interrupt. */</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="cm">/* True if this driver is shutting down. */</span>
	<span class="kt">int</span> <span class="n">shutting_down</span><span class="p">;</span>
	<span class="cm">/* Modem control lines */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">control_lines</span><span class="p">[</span><span class="n">NL_NUM_OF_ADDRESSES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">*</span><span class="n">packet_assembler</span><span class="p">[</span><span class="n">NL_NUM_OF_ADDRESSES</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tasklet</span><span class="p">;</span>

	<span class="cm">/* The handle for the network layer, for the sending of events to it. */</span>
	<span class="k">struct</span> <span class="n">ipw_network</span> <span class="o">*</span><span class="n">network</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">MEMINFREG</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">memory_info_regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">MEMCCR</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">memregs_CCR</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reboot_callback</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">reboot_callback_data</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">memreg_tx</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Packet info structure for tx packets.</span>
<span class="cm"> * Note: not all the fields defined here are required for all protocols</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>
	<span class="cm">/* channel idx + 1 */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dest_addr</span><span class="p">;</span>
	<span class="cm">/* SETUP, CTRL or DATA */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="cm">/* Length of data block, which starts at the end of this structure */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">length</span><span class="p">;</span>
	<span class="cm">/* Sending state */</span>
	<span class="cm">/* Offset of where we&#39;ve sent up to so far */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="cm">/* Count of packet fragments, starting at 0 */</span>
	<span class="kt">int</span> <span class="n">fragment_count</span><span class="p">;</span>

	<span class="cm">/* Called after packet is sent and before is freed */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">packet_callback</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">packet_length</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">callback_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Signals from DTE */</span>
<span class="cp">#define COMCTRL_RTS	0</span>
<span class="cp">#define COMCTRL_DTR	1</span>

<span class="cm">/* Signals from DCE */</span>
<span class="cp">#define COMCTRL_CTS	2</span>
<span class="cp">#define COMCTRL_DCD	3</span>
<span class="cp">#define COMCTRL_DSR	4</span>
<span class="cp">#define COMCTRL_RI	5</span>

<span class="k">struct</span> <span class="n">ipw_control_packet_body</span> <span class="p">{</span>
	<span class="cm">/* DTE signal or DCE signal */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sig_no</span><span class="p">;</span>
	<span class="cm">/* 0: set signal, 1: clear signal */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">ipw_control_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipw_control_packet_body</span> <span class="n">body</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">data_type</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nl_packet_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nl_packet_header</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;     &quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">packet_rank</span> <span class="o">&amp;</span> <span class="n">NL_FIRST_PACKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TL_PROTOCOLID_COM_DATA</span>:	<span class="k">return</span> <span class="s">&quot;DATA &quot;</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TL_PROTOCOLID_COM_CTRL</span>:	<span class="k">return</span> <span class="s">&quot;CTRL &quot;</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TL_PROTOCOLID_SETUP</span>:	<span class="k">return</span> <span class="s">&quot;SETUP&quot;</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="k">return</span> <span class="s">&quot;???? &quot;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="s">&quot;     &quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DUMP_MAX_BYTES 64</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_data_bytes</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">prefix</span><span class="p">[</span><span class="mi">56</span><span class="p">];</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">IPWIRELESS_PCCARD_NAME</span> <span class="s">&quot;: %s %s &quot;</span><span class="p">,</span>
			<span class="n">type</span><span class="p">,</span> <span class="n">data_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">));</span>
	<span class="n">print_hex_dump_bytes</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span>
			<span class="n">length</span> <span class="o">&lt;</span> <span class="n">DUMP_MAX_BYTES</span> <span class="o">?</span> <span class="n">length</span> <span class="o">:</span> <span class="n">DUMP_MAX_BYTES</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swap_packet_bitfield_to_le</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * transform bits from aa.bbb.ccc to ccc.bbb.aa</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xc0</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x38</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x07</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swap_packet_bitfield_from_le</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * transform bits from ccc.bbb.aa to aa.bbb.ccc</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xe0</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x1c</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">|=</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x03</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_send_fragment</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">start_timing</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ll_mtu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipwireless_debug</span><span class="p">)</span>
		<span class="n">dump_data_bytes</span><span class="p">(</span><span class="s">&quot;send&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">swap_packet_bitfield_to_le</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="n">length</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODWR</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">__le16</span> <span class="n">raw_data</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
				<span class="n">d</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">raw_data</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODWR</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">outw</span><span class="p">(</span><span class="n">DCR_TXDONE</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODCR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outw</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="n">length</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">__le16</span> <span class="n">raw_data</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
				<span class="n">d</span> <span class="o">|=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">raw_data</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">outw</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="mh">0xDEAD</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">MEMRX_RX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_rx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">end_write_timing</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">fragment_data_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">data_left</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">header_size</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nl_packet</span> <span class="n">pkt</span><span class="p">;</span>

	<span class="n">header_size</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">fragment_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="o">?</span> <span class="n">NL_FIRST_PACKET_HEADER_SIZE</span>
	    <span class="o">:</span> <span class="n">NL_FOLLOWING_PACKET_HEADER_SIZE</span><span class="p">;</span>
	<span class="n">fragment_data_len</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ll_mtu</span> <span class="o">-</span> <span class="n">header_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_left</span> <span class="o">&lt;</span> <span class="n">fragment_data_len</span><span class="p">)</span>
		<span class="n">fragment_data_len</span> <span class="o">=</span> <span class="n">data_left</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * hdr_first is now in machine bitfield order, which will be swapped</span>
<span class="cm">	 * to le just before it goes to hw</span>
<span class="cm">	 */</span>
	<span class="n">pkt</span><span class="p">.</span><span class="n">hdr_first</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="n">pkt</span><span class="p">.</span><span class="n">hdr_first</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">dest_addr</span><span class="p">;</span>
	<span class="n">pkt</span><span class="p">.</span><span class="n">hdr_first</span><span class="p">.</span><span class="n">packet_rank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* First packet? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">fragment_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pkt</span><span class="p">.</span><span class="n">hdr_first</span><span class="p">.</span><span class="n">packet_rank</span> <span class="o">|=</span> <span class="n">NL_FIRST_PACKET</span><span class="p">;</span>
		<span class="n">pkt</span><span class="p">.</span><span class="n">hdr_first</span><span class="p">.</span><span class="n">length_lsb</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">pkt</span><span class="p">.</span><span class="n">hdr_first</span><span class="p">.</span><span class="n">length_msb</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">rawpkt</span> <span class="o">+</span> <span class="n">header_size</span><span class="p">,</span>
	       <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">packet</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_tx_packet</span><span class="p">)</span> <span class="o">+</span>
	       <span class="n">packet</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">fragment_data_len</span><span class="p">);</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">fragment_data_len</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">fragment_count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Last packet? (May also be first packet.) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">pkt</span><span class="p">.</span><span class="n">hdr_first</span><span class="p">.</span><span class="n">packet_rank</span> <span class="o">|=</span> <span class="n">NL_LAST_PACKET</span><span class="p">;</span>
	<span class="n">do_send_fragment</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">rawpkt</span><span class="p">,</span> <span class="n">header_size</span> <span class="o">+</span> <span class="n">fragment_data_len</span><span class="p">);</span>

	<span class="cm">/* If this packet has unsent data, then re-queue it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Re-queue it at the head of the highest priority queue so</span>
<span class="cm">		 * it goes before all other packets</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queued</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">packet_callback</span><span class="p">)</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">packet_callback</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback_data</span><span class="p">,</span>
					<span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipw_setup_hardware</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset RX FIFO */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">DCR_RXRESET</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODCR</span><span class="p">);</span>
		<span class="cm">/* SB: Reset TX FIFO */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">DCR_TXRESET</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODCR</span><span class="p">);</span>

		<span class="cm">/* Enable TX and RX interrupts. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">IER_TXENABLED</span> <span class="o">|</span> <span class="n">IER_RXENABLED</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IOIER</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set INTRACK bit (bit 0), which means we must explicitly</span>
<span class="cm">		 * acknowledge interrupts by clearing bit 2 of reg_config_and_status.</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memregs_CCR</span><span class="o">-&gt;</span><span class="n">reg_config_and_status</span><span class="p">);</span>

		<span class="n">csr</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memregs_CCR</span><span class="o">-&gt;</span><span class="n">reg_config_and_status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If &#39;packet&#39; is NULL, then this function allocates a new packet, setting its</span>
<span class="cm"> * length to 0 and ensuring it has the specified minimum amount of free space.</span>
<span class="cm"> *</span>
<span class="cm"> * If &#39;packet&#39; is not NULL, then this function enlarges it if it doesn&#39;t</span>
<span class="cm"> * have the specified minimum amount of free space.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">*</span><span class="nf">pool_allocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">minimum_free_space</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool_size</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">int</span> <span class="n">min_capacity</span> <span class="o">=</span>
				<span class="n">ipwireless_ppp_mru</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">network</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">new_capacity</span><span class="p">;</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">new_capacity</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">minimum_free_space</span> <span class="o">&gt;</span> <span class="n">min_capacity</span>
				 <span class="o">?</span> <span class="n">minimum_free_space</span>
				 <span class="o">:</span> <span class="n">min_capacity</span><span class="p">);</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">)</span>
					<span class="o">+</span> <span class="n">new_capacity</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">new_capacity</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="n">minimum_free_space</span> <span class="o">&gt;</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">*</span><span class="n">old_packet</span> <span class="o">=</span> <span class="n">packet</span><span class="p">;</span>

		<span class="n">packet</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">old_packet</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="n">minimum_free_space</span><span class="p">,</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">old_packet</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">old_packet</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">)</span>
					<span class="o">+</span> <span class="n">old_packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">old_packet</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="n">minimum_free_space</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">old_packet</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">packet</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pool_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool_size</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool_size</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_received_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">is_last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span> <span class="o">=</span> <span class="n">address</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Discard packet if channel index is out of range. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">channel_idx</span> <span class="o">&gt;=</span> <span class="n">NL_NUM_OF_ADDRESSES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
		       <span class="s">&quot;: data packet has bad address %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * -&gt;packet_assembler is safe to touch unlocked, this is the only place</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">TL_PROTOCOLID_COM_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">**</span><span class="n">assem</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">packet_assembler</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Create a new packet, or assembler already contains one</span>
<span class="cm">		 * enlarge it by &#39;length&#39; bytes.</span>
<span class="cm">		 */</span>
		<span class="p">(</span><span class="o">*</span><span class="n">assem</span><span class="p">)</span> <span class="o">=</span> <span class="n">pool_allocate</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">*</span><span class="n">assem</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">assem</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
				<span class="s">&quot;: no memory for incomming data packet, dropped!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="n">assem</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">assem</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">channel_idx</span> <span class="o">=</span> <span class="n">channel_idx</span><span class="p">;</span>

		<span class="cm">/* Append this packet data onto existing data. */</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">assem</span><span class="p">)</span> <span class="o">+</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">)</span>
				<span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">assem</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">assem</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_last</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="o">*</span><span class="n">assem</span><span class="p">;</span>
			<span class="o">*</span><span class="n">assem</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="cm">/* Count queued DATA bytes only */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_bytes_queued</span> <span class="o">+=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If it&#39;s a CTRL packet, don&#39;t assemble, just queue it. */</span>
		<span class="n">packet</span> <span class="o">=</span> <span class="n">pool_allocate</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
				<span class="s">&quot;: no memory for incomming ctrl packet, dropped!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">channel_idx</span> <span class="o">=</span> <span class="n">channel_idx</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">packet</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">),</span>
				<span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
		<span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the last packet, then send the assembled packet on to the</span>
<span class="cm">	 * network layer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">);</span>
		<span class="cm">/* Block reception of incoming packets if queue is full. */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">blocking_rx</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_bytes_queued</span> <span class="o">&gt;=</span> <span class="n">IPWIRELESS_RX_QUEUE_SIZE</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">work_rx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Workqueue callback</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipw_receive_data_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work_rx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span>
	    <span class="n">container_of</span><span class="p">(</span><span class="n">work_rx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipw_hardware</span><span class="p">,</span> <span class="n">work_rx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span>
			<span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">shutting_down</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note: ipwireless_network_packet_received must be called in a</span>
<span class="cm">		 * process context (i.e. via schedule_work) because the tty</span>
<span class="cm">		 * output code can sleep in the tty_flip_buffer_push call.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">TL_PROTOCOLID_COM_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">network</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* If the network hasn&#39;t been disconnected. */</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * This must run unlocked due to tty processing</span>
<span class="cm">				 * and mutex locking</span>
<span class="cm">				 */</span>
				<span class="n">ipwireless_network_packet_received</span><span class="p">(</span>
						<span class="n">hw</span><span class="o">-&gt;</span><span class="n">network</span><span class="p">,</span>
						<span class="n">packet</span><span class="o">-&gt;</span><span class="n">channel_idx</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">packet</span>
						<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">),</span>
						<span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Count queued DATA bytes only */</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_bytes_queued</span> <span class="o">-=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is safe to be called locked, callchain does</span>
<span class="cm">			 * not block</span>
<span class="cm">			 */</span>
			<span class="n">handle_received_CTRL_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">channel_idx</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">packet</span>
					<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_rx_packet</span><span class="p">),</span>
					<span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pool_free</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unblock reception of incoming packets if queue is no longer</span>
<span class="cm">		 * full.</span>
<span class="cm">		 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">blocking_rx</span> <span class="o">=</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_bytes_queued</span> <span class="o">&gt;=</span> <span class="n">IPWIRELESS_RX_QUEUE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">shutting_down</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_received_CTRL_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ipw_control_packet_body</span> <span class="o">*</span><span class="n">body</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipw_control_packet_body</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">changed_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_control_packet_body</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
		       <span class="s">&quot;: control packet was %d bytes - wrong size!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">body</span><span class="o">-&gt;</span><span class="n">sig_no</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMCTRL_CTS</span>:
		<span class="n">changed_mask</span> <span class="o">=</span> <span class="n">IPW_CONTROL_LINE_CTS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMCTRL_DCD</span>:
		<span class="n">changed_mask</span> <span class="o">=</span> <span class="n">IPW_CONTROL_LINE_DCD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMCTRL_DSR</span>:
		<span class="n">changed_mask</span> <span class="o">=</span> <span class="n">IPW_CONTROL_LINE_DSR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMCTRL_RI</span>:
		<span class="n">changed_mask</span> <span class="o">=</span> <span class="n">IPW_CONTROL_LINE_RI</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">changed_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">body</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span> <span class="o">|=</span> <span class="n">changed_mask</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">changed_mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">network</span><span class="p">)</span>
			<span class="n">ipwireless_network_notify_control_line_change</span><span class="p">(</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">network</span><span class="p">,</span>
					<span class="n">channel_idx</span><span class="p">,</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">],</span>
					<span class="n">changed_mask</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_received_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">union</span> <span class="n">nl_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protocol</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">protocol</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">address</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_last</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">packet_rank</span> <span class="o">&amp;</span> <span class="n">NL_LAST_PACKET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">packet_rank</span> <span class="o">&amp;</span> <span class="n">NL_FIRST_PACKET</span><span class="p">)</span>
		<span class="n">header_length</span> <span class="o">=</span> <span class="n">NL_FIRST_PACKET_HEADER_SIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">header_length</span> <span class="o">=</span> <span class="n">NL_FOLLOWING_PACKET_HEADER_SIZE</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">rawpkt</span> <span class="o">+</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="n">data_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TL_PROTOCOLID_COM_DATA</span>:
	<span class="k">case</span> <span class="n">TL_PROTOCOLID_COM_CTRL</span>:
		<span class="n">queue_received_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_len</span><span class="p">,</span>
				<span class="n">is_last</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TL_PROTOCOLID_SETUP</span>:
		<span class="n">handle_received_SETUP_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_len</span><span class="p">,</span>
				<span class="n">is_last</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">acknowledge_data_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_1</span><span class="p">)</span>
		<span class="n">outw</span><span class="p">(</span><span class="n">DCR_RXDONE</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODCR</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">MEMRX_PCINTACKK</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_pc_interrupt_ack</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve a packet from the IPW hardware.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_receive_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pkt</span><span class="p">[</span><span class="n">LL_MTU_MAX</span><span class="p">];</span>

	<span class="n">start_timing</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODRR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ll_mtu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
			       <span class="s">&quot;: received a packet of %u bytes - longer than the MTU!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">DCR_RXDONE</span> <span class="o">|</span> <span class="n">DCR_RXRESET</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODCR</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__le16</span> <span class="n">raw_data</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IODRR</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">data</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_data</span><span class="p">);</span>

			<span class="n">pkt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
			<span class="n">pkt</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ll_mtu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
			       <span class="s">&quot;: received a packet of %u bytes - longer than the MTU!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">writew</span><span class="p">(</span><span class="n">MEMRX_PCINTACKK</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_pc_interrupt_ack</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__le16</span> <span class="n">raw_data</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">data</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_data</span><span class="p">);</span>

			<span class="n">pkt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
			<span class="n">pkt</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">acknowledge_data_read</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">swap_packet_bitfield_from_le</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipwireless_debug</span><span class="p">)</span>
		<span class="n">dump_data_bytes</span><span class="p">(</span><span class="s">&quot;recv&quot;</span><span class="p">,</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">handle_received_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="k">union</span> <span class="n">nl_packet</span> <span class="o">*</span><span class="p">)</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">end_read_timing</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_current_packet_priority</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re initializing, don&#39;t send anything of higher priority than</span>
<span class="cm">	 * PRIO_SETUP.  The network layer therefore need not care about</span>
<span class="cm">	 * hardware initialization - any of its stuff will simply be queued</span>
<span class="cm">	 * until setup is complete.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">to_setup</span> <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">initializing</span>
			<span class="o">?</span> <span class="n">PRIO_SETUP</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">NL_NUM_OF_PRIORITIES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return 1 if something has been received from hw</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_packets_from_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_ready</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">blocking_rx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">received</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_ready</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">do_receive_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">received</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send pending packet up to given priority, prioritize SETUP data until</span>
<span class="cm"> * hardware is fully setup.</span>
<span class="cm"> *</span>
<span class="cm"> * return 1 if more packets can be sent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_pending_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority_limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">more_to_send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queued</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_ready</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Pick a packet */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">priority</span> <span class="o">&lt;</span> <span class="n">priority_limit</span><span class="p">;</span> <span class="n">priority</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">priority</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">packet</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span>
						<span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">priority</span><span class="p">],</span>
						<span class="k">struct</span> <span class="n">ipw_tx_packet</span><span class="p">,</span>
						<span class="n">queue</span><span class="p">);</span>

				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queued</span><span class="o">--</span><span class="p">;</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>

				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Send */</span>
		<span class="n">do_send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>

		<span class="cm">/* Check if more to send */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">priority</span> <span class="o">&lt;</span> <span class="n">priority_limit</span><span class="p">;</span> <span class="n">priority</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">priority</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">more_to_send</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">more_to_send</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">more_to_send</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send and receive all queued packets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipwireless_do_tasklet</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="p">)</span> <span class="n">hw_</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">shutting_down</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">to_setup</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Initial setup data sent to hardware</span>
<span class="cm">		 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">to_setup</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">ipw_setup_hardware</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">ipw_send_setup_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">send_pending_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">get_packets_from_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">priority_limit</span> <span class="o">=</span> <span class="n">get_current_packet_priority</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">again</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">again</span> <span class="o">=</span> <span class="n">send_pending_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">priority_limit</span><span class="p">);</span>
			<span class="n">again</span> <span class="o">|=</span> <span class="n">get_packets_from_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">again</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return true if the card is physically present.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_card_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">inw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IOIR</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_card_present</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">CARD_PRESENT_VALUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ipwireless_handle_v1_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">irqn</span><span class="p">;</span>

	<span class="n">irqn</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IOIR</span><span class="p">);</span>

	<span class="cm">/* Check if card is present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irqn</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">irqn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/* Transmit complete. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqn</span> <span class="o">&amp;</span> <span class="n">IR_TXINTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ack</span> <span class="o">|=</span> <span class="n">IR_TXINTR</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Received data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqn</span> <span class="o">&amp;</span> <span class="n">IR_RXINTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ack</span> <span class="o">|=</span> <span class="n">IR_RXINTR</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_ready</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ack</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IOIR</span><span class="p">);</span>
			<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">acknowledge_pcmcia_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">csr</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memregs_CCR</span><span class="o">-&gt;</span><span class="n">reg_config_and_status</span><span class="p">);</span>

	<span class="n">csr</span> <span class="o">&amp;=</span> <span class="mh">0xfffd</span><span class="p">;</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memregs_CCR</span><span class="o">-&gt;</span><span class="n">reg_config_and_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ipwireless_handle_v2_v3_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_repeat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">try_mem_tx_old</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>

	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">memtx</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">memtx_serial</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">memrxdone</span> <span class="o">=</span>
		<span class="n">readw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_rx_done</span><span class="p">);</span>

	<span class="n">try_mem_tx_old</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check whether the interrupt was generated by ipwireless card */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">memtx</span> <span class="o">&amp;</span> <span class="n">MEMTX_TX</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">memrxdone</span> <span class="o">&amp;</span> <span class="n">MEMRX_RX_DONE</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* check if the card uses memreg_tx_old register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_tx_new</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memtx</span> <span class="o">=</span> <span class="n">readw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_tx_old</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memtx</span> <span class="o">&amp;</span> <span class="n">MEMTX_TX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
					<span class="s">&quot;: Using memreg_tx_old</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span> <span class="o">=</span>
					<span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_tx_old</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if the card is physically present. Note that while it is</span>
<span class="cm">	 * powering up, it appears not to be present.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_card_present</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">acknowledge_pcmcia_interrupt</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memtx_serial</span> <span class="o">=</span> <span class="n">memtx</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="mh">0xff00</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memtx</span> <span class="o">&amp;</span> <span class="n">MEMTX_TX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">memtx_serial</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">serial_number_detected</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memtx_serial</span> <span class="o">!=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">last_memtx_serial</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">last_memtx_serial</span> <span class="o">=</span> <span class="n">memtx_serial</span><span class="p">;</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_ready</span><span class="o">++</span><span class="p">;</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">rx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="cm">/* Ignore &#39;Timer Recovery&#39; duplicates. */</span>
				<span class="n">rx_repeat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If a non-zero serial number is seen, then enable</span>
<span class="cm">			 * serial number checking.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memtx_serial</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">serial_number_detected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
					<span class="s">&quot;: memreg_tx serial num detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_ready</span><span class="o">++</span><span class="p">;</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">rx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memrxdone</span> <span class="o">&amp;</span> <span class="n">MEMRX_RX_DONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_rx_done</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">tx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx</span><span class="p">)</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">MEMRX_PCINTACKK</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_pc_interrupt_ack</span><span class="p">);</span>

	<span class="n">acknowledge_pcmcia_interrupt</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx</span> <span class="o">||</span> <span class="n">rx</span><span class="p">)</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_repeat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_tx_new</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">serial_number_detected</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
					<span class="s">&quot;: spurious interrupt - new_tx mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
					<span class="s">&quot;: no valid memreg_tx value - switching to the old memreg_tx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span> <span class="o">=</span>
					<span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_tx_old</span><span class="p">;</span>
				<span class="n">try_mem_tx_old</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
					<span class="s">&quot;: spurious interrupt - old_tx mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">try_mem_tx_old</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">ipwireless_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_dev</span> <span class="o">*</span><span class="n">ipw</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipw</span><span class="o">-&gt;</span><span class="n">hardware</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ipwireless_handle_v1_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">ipw</span><span class="o">-&gt;</span><span class="n">hardware</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">ipwireless_handle_v2_v3_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">ipw</span><span class="o">-&gt;</span><span class="n">hardware</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_packets_to_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">priority_limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">priority_limit</span> <span class="o">=</span> <span class="n">get_current_packet_priority</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">send_pending_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">priority_limit</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">priority</span><span class="p">]);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queued</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">flush_packets_to_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Create data packet, non-atomic allocation */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_data_packet</span><span class="p">(</span><span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dest_addr</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_tx_packet</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">,</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">dest_addr</span> <span class="o">=</span> <span class="n">dest_addr</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">data_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">packet</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc_ctrl_packet</span><span class="p">(</span><span class="kt">int</span> <span class="n">header_size</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dest_addr</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">protocol</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sig_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * sig_no is located right after ipw_tx_packet struct in every</span>
<span class="cm">	 * CTRL or SETUP packets, we can use ipw_control_packet as a</span>
<span class="cm">	 * common struct</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ipw_control_packet</span> <span class="o">*</span><span class="n">packet</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">header_size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dest_addr</span> <span class="o">=</span> <span class="n">dest_addr</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">header_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_tx_packet</span><span class="p">);</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">sig_no</span> <span class="o">=</span> <span class="n">sig_no</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">packet</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ipwireless_send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">),</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">callback_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

	<span class="n">packet</span> <span class="o">=</span> <span class="n">alloc_data_packet</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="p">(</span><span class="n">channel_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
			<span class="n">TL_PROTOCOLID_COM_DATA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">packet_callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">callback_data</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">packet</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_tx_packet</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span>
			<span class="n">length</span><span class="p">);</span>

	<span class="n">send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_DATA</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_control_line</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_control_packet</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">protocolid</span> <span class="o">=</span> <span class="n">TL_PROTOCOLID_COM_CTRL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">==</span> <span class="n">PRIO_SETUP</span><span class="p">)</span>
		<span class="n">protocolid</span> <span class="o">=</span> <span class="n">TL_PROTOCOLID_SETUP</span><span class="p">;</span>

	<span class="n">packet</span> <span class="o">=</span> <span class="n">alloc_ctrl_packet</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_control_packet</span><span class="p">),</span>
			<span class="p">(</span><span class="n">channel_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">protocolid</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_control_packet_body</span><span class="p">);</span>
	<span class="n">packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_DTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span> <span class="o">|=</span> <span class="n">IPW_CONTROL_LINE_DTR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IPW_CONTROL_LINE_DTR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">set_control_line</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">channel_idx</span><span class="p">,</span> <span class="n">COMCTRL_DTR</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_RTS</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span> <span class="o">|=</span> <span class="n">IPW_CONTROL_LINE_RTS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IPW_CONTROL_LINE_RTS</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">set_control_line</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">channel_idx</span><span class="p">,</span> <span class="n">COMCTRL_RTS</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ipwireless_set_DTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">set_DTR</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_CTRL</span><span class="p">,</span> <span class="n">channel_idx</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ipwireless_set_RTS</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">set_RTS</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_CTRL</span><span class="p">,</span> <span class="n">channel_idx</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ipw_setup_get_version_query_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tl_setup_get_version_qry</span> <span class="n">body</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipw_setup_config_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tl_setup_config_msg</span> <span class="n">body</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipw_setup_config_done_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tl_setup_config_done_msg</span> <span class="n">body</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipw_setup_open_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tl_setup_open_msg</span> <span class="n">body</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipw_setup_info_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tl_setup_info_msg</span> <span class="n">body</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipw_setup_reboot_msg_ack</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">TlSetupRebootMsgAck</span> <span class="n">body</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This handles the actual initialization of the card */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__handle_setup_get_version_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_setup_config_packet</span> <span class="o">*</span><span class="n">config_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipw_setup_config_done_packet</span> <span class="o">*</span><span class="n">config_done_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipw_setup_open_packet</span> <span class="o">*</span><span class="n">open_packet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipw_setup_info_packet</span> <span class="o">*</span><span class="n">info_packet</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span><span class="p">;</span>

	<span class="cm">/* generate config packet */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;=</span> <span class="n">NL_NUM_OF_ADDRESSES</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">config_packet</span> <span class="o">=</span> <span class="n">alloc_ctrl_packet</span><span class="p">(</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_setup_config_packet</span><span class="p">),</span>
				<span class="n">ADDR_SETUP_PROT</span><span class="p">,</span>
				<span class="n">TL_PROTOCOLID_SETUP</span><span class="p">,</span>
				<span class="n">TL_SETUP_SIGNO_CONFIG_MSG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">config_packet</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_nomem</span><span class="p">;</span>
		<span class="n">config_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tl_setup_config_msg</span><span class="p">);</span>
		<span class="n">config_packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">port_no</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
		<span class="n">config_packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">prio_data</span> <span class="o">=</span> <span class="n">PRIO_DATA</span><span class="p">;</span>
		<span class="n">config_packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">prio_ctrl</span> <span class="o">=</span> <span class="n">PRIO_CTRL</span><span class="p">;</span>
		<span class="n">send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">config_done_packet</span> <span class="o">=</span> <span class="n">alloc_ctrl_packet</span><span class="p">(</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_setup_config_done_packet</span><span class="p">),</span>
			<span class="n">ADDR_SETUP_PROT</span><span class="p">,</span>
			<span class="n">TL_PROTOCOLID_SETUP</span><span class="p">,</span>
			<span class="n">TL_SETUP_SIGNO_CONFIG_DONE_MSG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">config_done_packet</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_nomem</span><span class="p">;</span>
	<span class="n">config_done_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tl_setup_config_done_msg</span><span class="p">);</span>
	<span class="n">send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config_done_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>

	<span class="cm">/* generate open packet */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;=</span> <span class="n">NL_NUM_OF_ADDRESSES</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">open_packet</span> <span class="o">=</span> <span class="n">alloc_ctrl_packet</span><span class="p">(</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_setup_open_packet</span><span class="p">),</span>
				<span class="n">ADDR_SETUP_PROT</span><span class="p">,</span>
				<span class="n">TL_PROTOCOLID_SETUP</span><span class="p">,</span>
				<span class="n">TL_SETUP_SIGNO_OPEN_MSG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">open_packet</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit_nomem</span><span class="p">;</span>
		<span class="n">open_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tl_setup_open_msg</span><span class="p">);</span>
		<span class="n">open_packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">port_no</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
		<span class="n">send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">open_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">channel_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">channel_idx</span> <span class="o">&lt;</span> <span class="n">NL_NUM_OF_ADDRESSES</span><span class="p">;</span> <span class="n">channel_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">set_DTR</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span><span class="p">,</span> <span class="n">channel_idx</span><span class="p">,</span>
			<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span> <span class="o">&amp;</span>
			 <span class="n">IPW_CONTROL_LINE_DTR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
					<span class="s">&quot;: error setting DTR (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">set_RTS</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span><span class="p">,</span> <span class="n">channel_idx</span><span class="p">,</span>
			<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">control_lines</span> <span class="p">[</span><span class="n">channel_idx</span><span class="p">]</span> <span class="o">&amp;</span>
			 <span class="n">IPW_CONTROL_LINE_RTS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
					<span class="s">&quot;: error setting RTS (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * For NDIS we assume that we are using sync PPP frames, for COM async.</span>
<span class="cm">	 * This driver uses NDIS mode too. We don&#39;t bother with translation</span>
<span class="cm">	 * from async -&gt; sync PPP.</span>
<span class="cm">	 */</span>
	<span class="n">info_packet</span> <span class="o">=</span> <span class="n">alloc_ctrl_packet</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_setup_info_packet</span><span class="p">),</span>
			<span class="n">ADDR_SETUP_PROT</span><span class="p">,</span>
			<span class="n">TL_PROTOCOLID_SETUP</span><span class="p">,</span>
			<span class="n">TL_SETUP_SIGNO_INFO_MSG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info_packet</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit_nomem</span><span class="p">;</span>
	<span class="n">info_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tl_setup_info_msg</span><span class="p">);</span>
	<span class="n">info_packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">driver_type</span> <span class="o">=</span> <span class="n">NDISWAN_DRIVER</span><span class="p">;</span>
	<span class="n">info_packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">major_version</span> <span class="o">=</span> <span class="n">NDISWAN_DRIVER_MAJOR_VERSION</span><span class="p">;</span>
	<span class="n">info_packet</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">minor_version</span> <span class="o">=</span> <span class="n">NDISWAN_DRIVER_MINOR_VERSION</span><span class="p">;</span>
	<span class="n">send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>

	<span class="cm">/* Initialization is now complete, so we clear the &#39;to_setup&#39; flag */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">to_setup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">exit_nomem:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
			<span class="s">&quot;: not enough memory to alloc control packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">to_setup</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_setup_get_version_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vers_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">setup_timer</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">initializing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span> <span class="s">&quot;: card is ready.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vers_no</span> <span class="o">==</span> <span class="n">TL_SETUP_VERSION</span><span class="p">)</span>
		<span class="n">__handle_setup_get_version_rsp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
				<span class="s">&quot;: invalid hardware version no %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">vers_no</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipw_send_setup_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_setup_get_version_query_packet</span> <span class="o">*</span><span class="n">ver_packet</span><span class="p">;</span>

	<span class="n">ver_packet</span> <span class="o">=</span> <span class="n">alloc_ctrl_packet</span><span class="p">(</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_setup_get_version_query_packet</span><span class="p">),</span>
			<span class="n">ADDR_SETUP_PROT</span><span class="p">,</span> <span class="n">TL_PROTOCOLID_SETUP</span><span class="p">,</span>
			<span class="n">TL_SETUP_SIGNO_GET_VERSION_QRY</span><span class="p">);</span>
	<span class="n">ver_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tl_setup_get_version_qry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Response is handled in handle_received_SETUP_packet</span>
<span class="cm">	 */</span>
	<span class="n">send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ver_packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_received_SETUP_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">is_last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">union</span> <span class="n">ipw_setup_rx_msg</span> <span class="o">*</span><span class="n">rx_msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">union</span> <span class="n">ipw_setup_rx_msg</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">!=</span> <span class="n">ADDR_SETUP_PROT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
		       <span class="s">&quot;: setup packet has bad address %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rx_msg</span><span class="o">-&gt;</span><span class="n">sig_no</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TL_SETUP_SIGNO_GET_VERSION_RSP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">to_setup</span><span class="p">)</span>
			<span class="n">handle_setup_get_version_rsp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					<span class="n">rx_msg</span><span class="o">-&gt;</span><span class="n">version_rsp_msg</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TL_SETUP_SIGNO_OPEN_MSG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ipwireless_debug</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel_idx</span> <span class="o">=</span> <span class="n">rx_msg</span><span class="o">-&gt;</span><span class="n">open_msg</span><span class="p">.</span><span class="n">port_no</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
			       <span class="s">&quot;: OPEN_MSG [channel %u] reply received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">channel_idx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TL_SETUP_SIGNO_INFO_MSG_ACK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ipwireless_debug</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
			       <span class="s">&quot;: card successfully configured as NDISWAN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TL_SETUP_SIGNO_REBOOT_MSG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">to_setup</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
			       <span class="s">&quot;: Setup not completed - ignoring reboot msg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ipw_setup_reboot_msg_ack</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
			       <span class="s">&quot;: Acknowledging REBOOT message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">packet</span> <span class="o">=</span> <span class="n">alloc_ctrl_packet</span><span class="p">(</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_setup_reboot_msg_ack</span><span class="p">),</span>
					<span class="n">ADDR_SETUP_PROT</span><span class="p">,</span> <span class="n">TL_PROTOCOLID_SETUP</span><span class="p">,</span>
					<span class="n">TL_SETUP_SIGNO_REBOOT_MSG_ACK</span><span class="p">);</span>
			<span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">TlSetupRebootMsgAck</span><span class="p">);</span>
			<span class="n">send_packet</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PRIO_SETUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">reboot_callback</span><span class="p">)</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">reboot_callback</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">reboot_callback_data</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
		       <span class="s">&quot;: unknown setup message %u received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">rx_msg</span><span class="o">-&gt;</span><span class="n">sig_no</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_close_hardware</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irqn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable TX and RX interrupts. */</span>
		<span class="n">outw</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IOIER</span><span class="p">);</span>

		<span class="cm">/* Acknowledge any outstanding interrupt requests */</span>
		<span class="n">irqn</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IOIR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqn</span> <span class="o">&amp;</span> <span class="n">IR_TXINTR</span><span class="p">)</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">IR_TXINTR</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IOIR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irqn</span> <span class="o">&amp;</span> <span class="n">IR_RXINTR</span><span class="p">)</span>
			<span class="n">outw</span><span class="p">(</span><span class="n">IR_RXINTR</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">+</span> <span class="n">IOIR</span><span class="p">);</span>

		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="nf">ipwireless_hardware_create</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">initializing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_bytes_queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">last_memtx_serial</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NL_NUM_OF_PRIORITIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">ipwireless_do_tasklet</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hw</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">work_rx</span><span class="p">,</span> <span class="n">ipw_receive_data_work</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">setup_timer</span><span class="p">,</span> <span class="n">ipwireless_setup_timer</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hw</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ipwireless_init_hardware_v1</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base_port</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">attr_memory</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">common_memory</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">is_v2_card</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">reboot_callback</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">reboot_callback_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">base_port</span> <span class="o">=</span> <span class="n">base_port</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_v2_card</span> <span class="o">?</span> <span class="n">HW_VERSION_2</span> <span class="o">:</span> <span class="n">HW_VERSION_1</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ll_mtu</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_1</span> <span class="o">?</span> <span class="n">LL_MTU_V1</span> <span class="o">:</span> <span class="n">LL_MTU_V2</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">memregs_CCR</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">MEMCCR</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">attr_memory</span> <span class="o">+</span> <span class="mh">0x200</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">MEMINFREG</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">common_memory</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_tx_new</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">reboot_callback</span> <span class="o">=</span> <span class="n">reboot_callback</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">reboot_callback_data</span> <span class="o">=</span> <span class="n">reboot_callback_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ipwireless_init_hardware_v2_v3</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">initializing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">init_loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
	       <span class="s">&quot;: waiting for card to start up...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ipwireless_setup_timer</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipwireless_setup_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">init_loops</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">init_loops</span> <span class="o">==</span> <span class="n">TL_SETUP_MAX_VERSION_QRY</span> <span class="o">&amp;&amp;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_version</span> <span class="o">==</span> <span class="n">HW_VERSION_2</span> <span class="o">&amp;&amp;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_tx_new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
				<span class="s">&quot;: failed to startup using TX2, trying TX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">memreg_tx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">memory_info_regs</span><span class="o">-&gt;</span><span class="n">memreg_tx_old</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">init_loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Give up after a certain number of retries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">init_loops</span> <span class="o">==</span> <span class="n">TL_SETUP_MAX_VERSION_QRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">IPWIRELESS_PCCARD_NAME</span>
		       <span class="s">&quot;: card failed to start up!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">initializing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Do not attempt to write to the board if it is not present. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_card_present</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">to_setup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tasklet</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">setup_timer</span><span class="p">,</span>
			<span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">TL_SETUP_VERSION_QRY_TMO</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop any interrupts from executing so that, once this function returns,</span>
<span class="cm"> * other layers of the driver can be sure they won&#39;t get any more callbacks.</span>
<span class="cm"> * Thus must be called on a proper process context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipwireless_stop_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">shutting_down</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Tell everyone we are going down. */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">shutting_down</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">setup_timer</span><span class="p">);</span>

		<span class="cm">/* Prevent the hardware from sending any more interrupts */</span>
		<span class="n">do_close_hardware</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ipwireless_hardware_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipw_rx_packet</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipw_tx_packet</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="o">*</span><span class="n">tq</span><span class="p">;</span>

	<span class="n">ipwireless_stop_interrupts</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">work_rx</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NL_NUM_OF_ADDRESSES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">packet_assembler</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">packet_assembler</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NL_NUM_OF_PRIORITIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">rx_pool</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Associate the specified network with this hardware, so it will receive events</span>
<span class="cm"> * from it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipwireless_associate_network</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipw_hardware</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ipw_network</span> <span class="o">*</span><span class="n">network</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">network</span> <span class="o">=</span> <span class="n">network</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
