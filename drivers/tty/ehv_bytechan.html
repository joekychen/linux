<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › tty › ehv_bytechan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ehv_bytechan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* ePAPR hypervisor byte channel device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2009-2011 Freescale Semiconductor, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Timur Tabi &lt;timur@freescale.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licensed under the terms of the GNU General Public License</span>
<span class="cm"> * version 2.  This program is licensed &quot;as is&quot; without any warranty of any</span>
<span class="cm"> * kind, whether express or implied.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver support three distinct interfaces, all of which are related to</span>
<span class="cm"> * ePAPR hypervisor byte channels.</span>
<span class="cm"> *</span>
<span class="cm"> * 1) An early-console (udbg) driver.  This provides early console output</span>
<span class="cm"> * through a byte channel.  The byte channel handle must be specified in a</span>
<span class="cm"> * Kconfig option.</span>
<span class="cm"> *</span>
<span class="cm"> * 2) A normal console driver.  Output is sent to the byte channel designated</span>
<span class="cm"> * for stdout in the device tree.  The console driver is for handling kernel</span>
<span class="cm"> * printk calls.</span>
<span class="cm"> *</span>
<span class="cm"> * 3) A tty driver, which is used to handle user-space input and output.  The</span>
<span class="cm"> * byte channel used for the console is designated as the default tty.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;asm/epapr_hcalls.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/console.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/tty_flip.h&gt;</span>
<span class="cp">#include &lt;linux/circ_buf.h&gt;</span>
<span class="cp">#include &lt;asm/udbg.h&gt;</span>

<span class="cm">/* The size of the transmit circular buffer.  This must be a power of two. */</span>
<span class="cp">#define BUF_SIZE	2048</span>

<span class="cm">/* Per-byte channel private data */</span>
<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_port</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_irq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_irq</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>	<span class="cm">/* lock for transmit buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>	<span class="cm">/* transmit circular buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>	<span class="cm">/* circular buffer head */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>	<span class="cm">/* circular buffer tail */</span>

	<span class="kt">int</span> <span class="n">tx_irq_enabled</span><span class="p">;</span>	<span class="cm">/* true == TX interrupt is enabled */</span>
<span class="p">};</span>

<span class="cm">/* Array of byte channel objects */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bcs</span><span class="p">;</span>

<span class="cm">/* Byte channel handle for stdout (and stdin), taken from device tree */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stdout_bc</span><span class="p">;</span>

<span class="cm">/* Virtual IRQ for the byte channel handle for stdin, taken from device tree */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stdout_irq</span><span class="p">;</span>

<span class="cm">/**************************** SUPPORT FUNCTIONS ****************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Enable the transmit interrupt</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike a serial device, byte channels have no mechanism for disabling their</span>
<span class="cm"> * own receive or transmit interrupts.  To emulate that feature, we toggle</span>
<span class="cm"> * the IRQ in the kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * We cannot just blindly call enable_irq() or disable_irq(), because these</span>
<span class="cm"> * calls are reference counted.  This means that we cannot call enable_irq()</span>
<span class="cm"> * if interrupts are already enabled.  This can happen in two situations:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. The tty layer makes two back-to-back calls to ehv_bc_tty_write()</span>
<span class="cm"> * 2. A transmit interrupt occurs while executing ehv_bc_tx_dequeue()</span>
<span class="cm"> *</span>
<span class="cm"> * To work around this, we keep a flag to tell us if the IRQ is enabled or not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_tx_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span><span class="p">);</span>
		<span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">disable_tx_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span><span class="p">);</span>
		<span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find the byte channel handle to use for the console</span>
<span class="cm"> *</span>
<span class="cm"> * The byte channel to be used for the console is specified via a &quot;stdout&quot;</span>
<span class="cm"> * property in the /chosen node.</span>
<span class="cm"> *</span>
<span class="cm"> * For compatible with legacy device trees, we also look for a &quot;stdout&quot; alias.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_console_handle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="o">*</span><span class="n">np2</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sprop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">iprop</span><span class="p">;</span>

	<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/chosen&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="p">)</span>
		<span class="n">sprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;stdout-path&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span> <span class="o">||</span> <span class="o">!</span><span class="n">sprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_name</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;aliases&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="p">)</span>
			<span class="n">sprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;stdout&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We don&#39;t care what the aliased node is actually called.  We only</span>
<span class="cm">	 * care if it&#39;s compatible with &quot;epapr,hv-byte-channel&quot;, because that</span>
<span class="cm">	 * indicates that it&#39;s a byte channel node.  We use a temporary</span>
<span class="cm">	 * variable, &#39;np2&#39;, because we can&#39;t release &#39;np&#39; until we&#39;re done with</span>
<span class="cm">	 * &#39;sprop&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">np2</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="n">sprop</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">np2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;ehv-bc: stdout node &#39;%s&#39; does not exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sprop</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is it a byte channel? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;epapr,hv-byte-channel&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stdout_irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stdout_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ehv-bc: no &#39;interrupts&#39; property in %s node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sprop</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The &#39;hv-handle&#39; property contains the handle for this byte channel.</span>
<span class="cm">	 */</span>
	<span class="n">iprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;hv-handle&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ehv-bc: no &#39;hv-handle&#39; property in %s node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">stdout_bc</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">iprop</span><span class="p">);</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*************************** EARLY CONSOLE DRIVER ***************************/</span>

<span class="cp">#ifdef CONFIG_PPC_EARLY_DEBUG_EHV_BC</span>

<span class="cm">/*</span>
<span class="cm"> * send a byte to a byte channel, wait if necessary</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends a byte to a byte channel, and it waits and</span>
<span class="cm"> * retries if the byte channel is full.  It returns if the character</span>
<span class="cm"> * has been sent, or if some error has occurred.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">byte_channel_spin_send</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ev_byte_channel_send</span><span class="p">(</span><span class="n">CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">EV_EAGAIN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The udbg subsystem calls this function to display a single character.</span>
<span class="cm"> * We convert CR to a CR/LF.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehv_bc_udbg_putc</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">byte_channel_spin_send</span><span class="p">(</span><span class="sc">&#39;\r&#39;</span><span class="p">);</span>

	<span class="n">byte_channel_spin_send</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * early console initialization</span>
<span class="cm"> *</span>
<span class="cm"> * PowerPC kernels support an early printk console, also known as udbg.</span>
<span class="cm"> * This function must be called via the ppc_md.init_early function pointer.</span>
<span class="cm"> * At this point, the device tree has been unflattened, so we can obtain the</span>
<span class="cm"> * byte channel handle for stdout.</span>
<span class="cm"> *</span>
<span class="cm"> * We only support displaying of characters (putc).  We do not support</span>
<span class="cm"> * keyboard input.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">udbg_init_ehv_bc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_count</span><span class="p">,</span> <span class="n">tx_count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Verify the byte channel handle */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ev_byte_channel_poll</span><span class="p">(</span><span class="n">CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">rx_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">udbg_putc</span> <span class="o">=</span> <span class="n">ehv_bc_udbg_putc</span><span class="p">;</span>
	<span class="n">register_early_udbg_console</span><span class="p">();</span>

	<span class="n">udbg_printf</span><span class="p">(</span><span class="s">&quot;ehv-bc: early console using byte channel handle %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/****************************** CONSOLE DRIVER ******************************/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="n">ehv_bc_driver</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Byte channel console sending worker function.</span>
<span class="cm"> *</span>
<span class="cm"> * For consoles, if the output buffer is full, we should just spin until it</span>
<span class="cm"> * clears.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehv_bc_console_byte_channel_send</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">EV_BYTE_CHANNEL_MAX_BYTES</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ev_byte_channel_send</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">EV_EAGAIN</span><span class="p">);</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">s</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * write a string to the console</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets called to write a string from the kernel, typically from</span>
<span class="cm"> * a printk().  This function spins until all data is written.</span>
<span class="cm"> *</span>
<span class="cm"> * We copy the data to a temporary buffer because we need to insert a \r in</span>
<span class="cm"> * front of every \n.  It&#39;s more efficient to copy the data to the buffer than</span>
<span class="cm"> * it is to make multiple hcalls for each character or each newline.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehv_bc_console_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">s2</span><span class="p">[</span><span class="n">EV_BYTE_CHANNEL_MAX_BYTES</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
			<span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\r&#39;</span><span class="p">;</span>

		<span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">EV_BYTE_CHANNEL_MAX_BYTES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ehv_bc_console_byte_channel_send</span><span class="p">(</span><span class="n">stdout_bc</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
		<span class="n">ehv_bc_console_byte_channel_send</span><span class="p">(</span><span class="n">stdout_bc</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When /dev/console is opened, the kernel iterates the console list looking</span>
<span class="cm"> * for one with -&gt;device and then calls that method. On success, it expects</span>
<span class="cm"> * the passed-in int* to contain the minor number to use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_driver</span> <span class="o">*</span><span class="nf">ehv_bc_console_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">console</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">co</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ehv_bc_driver</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">console</span> <span class="n">ehv_bc_console</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;ttyEHV&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">ehv_bc_console_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">device</span>		<span class="o">=</span> <span class="n">ehv_bc_console_device</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">CON_PRINTBUFFER</span> <span class="o">|</span> <span class="n">CON_ENABLED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Console initialization</span>
<span class="cm"> *</span>
<span class="cm"> * This is the first function that is called after the device tree is</span>
<span class="cm"> * available, so here is where we determine the byte channel handle and IRQ for</span>
<span class="cm"> * stdout/stdin, even though that information is used by the tty and character</span>
<span class="cm"> * drivers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ehv_bc_console_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">find_console_handle</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ehv-bc: stdout is not a byte channel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PPC_EARLY_DEBUG_EHV_BC</span>
	<span class="cm">/* Print a friendly warning if the user chose the wrong byte channel</span>
<span class="cm">	 * handle for udbg.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stdout_bc</span> <span class="o">!=</span> <span class="n">CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;ehv-bc: udbg handle %u is not the stdout handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">CONFIG_PPC_EARLY_DEBUG_EHV_BC_HANDLE</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* add_preferred_console() must be called before register_console(),</span>
<span class="cm">	   otherwise it won&#39;t work.  However, we don&#39;t want to enumerate all the</span>
<span class="cm">	   byte channels here, either, since we only care about one. */</span>

	<span class="n">add_preferred_console</span><span class="p">(</span><span class="n">ehv_bc_console</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ehv_bc_console</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">register_console</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehv_bc_console</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ehv-bc: registered console driver for byte channel %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">stdout_bc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">console_initcall</span><span class="p">(</span><span class="n">ehv_bc_console_init</span><span class="p">);</span>

<span class="cm">/******************************** TTY DRIVER ********************************/</span>

<span class="cm">/*</span>
<span class="cm"> * byte channel receive interupt handler</span>
<span class="cm"> *</span>
<span class="cm"> * This ISR is called whenever data is available on a byte channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ehv_bc_tty_rx_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rx_count</span><span class="p">,</span> <span class="n">tx_count</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">EV_BYTE_CHANNEL_MAX_BYTES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* ttys could be NULL during a hangup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ttys</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="cm">/* Find out how much data needs to be read, and then ask the TTY layer</span>
<span class="cm">	 * if it can handle that much.  We want to ensure that every byte we</span>
<span class="cm">	 * read from the byte channel will be accepted by the TTY layer.</span>
<span class="cm">	 */</span>
	<span class="n">ev_byte_channel_poll</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_count</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">tty_buffer_request_room</span><span class="p">(</span><span class="n">ttys</span><span class="p">,</span> <span class="n">rx_count</span><span class="p">);</span>

	<span class="cm">/* &#39;count&#39; is the maximum amount of data the TTY layer can accept at</span>
<span class="cm">	 * this time.  However, during testing, I was never able to get &#39;count&#39;</span>
<span class="cm">	 * to be less than &#39;rx_count&#39;.  I&#39;m not sure whether I&#39;m calling it</span>
<span class="cm">	 * correctly.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

		<span class="cm">/* Read some data from the byte channel.  This function will</span>
<span class="cm">		 * never return more than EV_BYTE_CHANNEL_MAX_BYTES bytes.</span>
<span class="cm">		 */</span>
		<span class="n">ev_byte_channel_receive</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

		<span class="cm">/* &#39;len&#39; is now the amount of data that&#39;s been received. &#39;len&#39;</span>
<span class="cm">		 * can&#39;t be zero, and most likely it&#39;s equal to one.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Pass the received data to the tty layer. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tty_insert_flip_string</span><span class="p">(</span><span class="n">ttys</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="cm">/* &#39;ret&#39; is the number of bytes that the TTY layer accepted.</span>
<span class="cm">		 * If it&#39;s not equal to &#39;len&#39;, then it means the buffer is</span>
<span class="cm">		 * full, which should never happen.  If it does happen, we can</span>
<span class="cm">		 * exit gracefully, but we drop the last &#39;len - ret&#39; characters</span>
<span class="cm">		 * that we read from the byte channel.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">count</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tell the tty layer that we&#39;re done. */</span>
	<span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="n">ttys</span><span class="p">);</span>

	<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">ttys</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dequeue the transmit buffer to the hypervisor</span>
<span class="cm"> *</span>
<span class="cm"> * This function, which can be called in interrupt context, dequeues as much</span>
<span class="cm"> * data as possible from the transmit buffer to the byte channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehv_bc_tx_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
			    <span class="n">CIRC_CNT_TO_END</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">),</span>
			    <span class="n">EV_BYTE_CHANNEL_MAX_BYTES</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ev_byte_channel_send</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>

		<span class="cm">/* &#39;len&#39; is valid only if the return code is 0 or EV_EAGAIN */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">||</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">EV_EAGAIN</span><span class="p">))</span>
			<span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BUF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">count</span> <span class="o">=</span> <span class="n">CIRC_CNT</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CIRC_CNT</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we haven&#39;t emptied the buffer, then enable the TX IRQ.</span>
<span class="cm">		 * We&#39;ll get an interrupt when there&#39;s more room in the</span>
<span class="cm">		 * hypervisor&#39;s output buffer.</span>
<span class="cm">		 */</span>
		<span class="n">enable_tx_interrupt</span><span class="p">(</span><span class="n">bc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">disable_tx_interrupt</span><span class="p">(</span><span class="n">bc</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * byte channel transmit interupt handler</span>
<span class="cm"> *</span>
<span class="cm"> * This ISR is called whenever space becomes available for transmitting</span>
<span class="cm"> * characters on a byte channel.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ehv_bc_tty_tx_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span> <span class="o">=</span> <span class="n">tty_port_tty_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="n">ehv_bc_tx_dequeue</span><span class="p">(</span><span class="n">bc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ttys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_wakeup</span><span class="p">(</span><span class="n">ttys</span><span class="p">);</span>
		<span class="n">tty_kref_put</span><span class="p">(</span><span class="n">ttys</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called when the tty layer has data for us send.  We store</span>
<span class="cm"> * the data first in a circular buffer, and then dequeue as much of that data</span>
<span class="cm"> * as possible.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t need to worry about whether there is enough room in the buffer for</span>
<span class="cm"> * all the data.  The purpose of ehv_bc_tty_write_room() is to tell the tty</span>
<span class="cm"> * layer how much data it can safely send to us.  We guarantee that</span>
<span class="cm"> * ehv_bc_tty_write_room() will never lie, so the tty layer will never send us</span>
<span class="cm"> * too much data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehv_bc_tty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">ttys</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">CIRC_SPACE_TO_END</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BUF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">s</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehv_bc_tx_dequeue</span><span class="p">(</span><span class="n">bc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function can be called multiple times for a given tty_struct, which is</span>
<span class="cm"> * why we initialize bc-&gt;ttys in ehv_bc_tty_port_activate() instead.</span>
<span class="cm"> *</span>
<span class="cm"> * The tty layer will still call this function even if the device was not</span>
<span class="cm"> * registered (i.e. tty_register_device() was not called).  This happens</span>
<span class="cm"> * because tty_register_device() is optional and some legacy drivers don&#39;t</span>
<span class="cm"> * use it.  So we need to check for that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehv_bc_tty_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcs</span><span class="p">[</span><span class="n">ttys</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tty_port_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">ttys</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Amazingly, if ehv_bc_tty_open() returns an error code, the tty layer will</span>
<span class="cm"> * still call this function to close the tty device.  So we can&#39;t assume that</span>
<span class="cm"> * the tty port has been initialized.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehv_bc_tty_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcs</span><span class="p">[</span><span class="n">ttys</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">tty_port_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span> <span class="n">ttys</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the amount of space in the output buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This is actually a contract between the driver and the tty layer outlining</span>
<span class="cm"> * how much write room the driver can guarantee will be sent OR BUFFERED.  This</span>
<span class="cm"> * driver MUST honor the return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehv_bc_tty_write_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">ttys</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">CIRC_SPACE</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop sending data to the tty layer</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when the tty layer&#39;s input buffers are getting full,</span>
<span class="cm"> * so the driver should stop sending it data.  The easiest way to do this is to</span>
<span class="cm"> * disable the RX IRQ, which will prevent ehv_bc_tty_rx_isr() from being</span>
<span class="cm"> * called.</span>
<span class="cm"> *</span>
<span class="cm"> * The hypervisor will continue to queue up any incoming data.  If there is any</span>
<span class="cm"> * data in the queue when the RX interrupt is enabled, we&#39;ll immediately get an</span>
<span class="cm"> * RX interrupt.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehv_bc_tty_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">ttys</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Resume sending data to the tty layer</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after previously calling ehv_bc_tty_throttle().  The</span>
<span class="cm"> * tty layer&#39;s input buffers now have more room, so the driver can resume</span>
<span class="cm"> * sending it data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehv_bc_tty_unthrottle</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">ttys</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="cm">/* If there is any data in the queue when the RX interrupt is enabled,</span>
<span class="cm">	 * we&#39;ll immediately get an RX interrupt.</span>
<span class="cm">	 */</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehv_bc_tty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">ttys</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="n">ehv_bc_tx_dequeue</span><span class="p">(</span><span class="n">bc</span><span class="p">);</span>
	<span class="n">tty_port_hangup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * TTY driver operations</span>
<span class="cm"> *</span>
<span class="cm"> * If we could ask the hypervisor how much data is still in the TX buffer, or</span>
<span class="cm"> * at least how big the TX buffers are, then we could implement the</span>
<span class="cm"> * .wait_until_sent and .chars_in_buffer functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_operations</span> <span class="n">ehv_bc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">ehv_bc_tty_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">ehv_bc_tty_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">ehv_bc_tty_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_room</span>	<span class="o">=</span> <span class="n">ehv_bc_tty_write_room</span><span class="p">,</span>
	<span class="p">.</span><span class="n">throttle</span>	<span class="o">=</span> <span class="n">ehv_bc_tty_throttle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unthrottle</span>	<span class="o">=</span> <span class="n">ehv_bc_tty_unthrottle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hangup</span>		<span class="o">=</span> <span class="n">ehv_bc_tty_hangup</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * initialize the TTY port</span>
<span class="cm"> *</span>
<span class="cm"> * This function will only be called once, no matter how many times</span>
<span class="cm"> * ehv_bc_tty_open() is called.  That&#39;s why we register the ISR here, and also</span>
<span class="cm"> * why we initialize tty_struct-related variables here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehv_bc_tty_port_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">ttys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehv_bc_data</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ttys</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">bc</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span><span class="p">,</span> <span class="n">ehv_bc_tty_rx_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ehv-bc&quot;</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not request rx irq %u (ret=%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* request_irq also enables the IRQ */</span>
	<span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span><span class="p">,</span> <span class="n">ehv_bc_tty_tx_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ehv-bc&quot;</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not request tx irq %u (ret=%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The TX IRQ is enabled only when we can&#39;t write all the data to the</span>
<span class="cm">	 * byte channel at once, so by default it&#39;s disabled.</span>
<span class="cm">	 */</span>
	<span class="n">disable_tx_interrupt</span><span class="p">(</span><span class="n">bc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehv_bc_tty_port_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_port</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehv_bc_data</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tty_port_operations</span> <span class="n">ehv_bc_tty_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">activate</span> <span class="o">=</span> <span class="n">ehv_bc_tty_port_activate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">ehv_bc_tty_port_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ehv_bc_tty_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">iprop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">iprop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;hv-handle&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iprop</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no &#39;hv-handle&#39; property in %s node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We already told the console layer that the index for the console</span>
<span class="cm">	 * device is zero, so we need to make sure that we use that index when</span>
<span class="cm">	 * we probe the console byte channel node.</span>
<span class="cm">	 */</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">iprop</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="n">stdout_bc</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="n">bc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">bc</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">bc</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bc</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no &#39;interrupts&#39; property in %s node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">tty_register_device</span><span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not register tty (ret=%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tty_port_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="n">bc</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ehv_bc_tty_port_ops</span><span class="p">;</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;registered /dev/%s%u for byte channel %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ehv_bc_driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">irq_dispose_mapping</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span><span class="p">);</span>
	<span class="n">irq_dispose_mapping</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehv_bc_data</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ehv_bc_tty_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehv_bc_data</span> <span class="o">*</span><span class="n">bc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">tty_unregister_device</span><span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">,</span> <span class="n">bc</span> <span class="o">-</span> <span class="n">bcs</span><span class="p">);</span>

	<span class="n">irq_dispose_mapping</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">tx_irq</span><span class="p">);</span>
	<span class="n">irq_dispose_mapping</span><span class="p">(</span><span class="n">bc</span><span class="o">-&gt;</span><span class="n">rx_irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">ehv_bc_tty_of_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;epapr,hv-byte-channel&quot;</span> <span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ehv_bc_tty_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ehv-bc&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">ehv_bc_tty_of_ids</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">ehv_bc_tty_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">ehv_bc_tty_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ehv_bc_init - ePAPR hypervisor byte channel driver initialization</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when this module is loaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ehv_bc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Number of elements in bcs[] */</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ePAPR hypervisor byte channel driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Count the number of byte channels */</span>
	<span class="n">for_each_compatible_node</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;epapr,hv-byte-channel&quot;</span><span class="p">)</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* The array index of an element in bcs[] is the same as the tty index</span>
<span class="cm">	 * for that element.  If you know the address of an element in the</span>
<span class="cm">	 * array, then you can use pointer math (e.g. &quot;bc - bcs&quot;) to get its</span>
<span class="cm">	 * tty index.</span>
<span class="cm">	 */</span>
	<span class="n">bcs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehv_bc_data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ehv_bc_driver</span> <span class="o">=</span> <span class="n">alloc_tty_driver</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ehv_bc_driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehv_bc_driver</span><span class="o">-&gt;</span><span class="n">driver_name</span> <span class="o">=</span> <span class="s">&quot;ehv-bc&quot;</span><span class="p">;</span>
	<span class="n">ehv_bc_driver</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">ehv_bc_console</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="n">ehv_bc_driver</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">TTY_DRIVER_TYPE_CONSOLE</span><span class="p">;</span>
	<span class="n">ehv_bc_driver</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">SYSTEM_TYPE_CONSOLE</span><span class="p">;</span>
	<span class="n">ehv_bc_driver</span><span class="o">-&gt;</span><span class="n">init_termios</span> <span class="o">=</span> <span class="n">tty_std_termios</span><span class="p">;</span>
	<span class="n">ehv_bc_driver</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">TTY_DRIVER_REAL_RAW</span> <span class="o">|</span> <span class="n">TTY_DRIVER_DYNAMIC_DEV</span><span class="p">;</span>
	<span class="n">tty_set_operations</span><span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ehv_bc_ops</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tty_register_driver</span><span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ehv-bc: could not register tty driver (ret=%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehv_bc_tty_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ehv-bc: could not register platform driver (ret=%i)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">);</span>
		<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bcs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * ehv_bc_exit - ePAPR hypervisor byte channel driver termination</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when this driver is unloaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ehv_bc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tty_unregister_driver</span><span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">);</span>
	<span class="n">put_tty_driver</span><span class="p">(</span><span class="n">ehv_bc_driver</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bcs</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ehv_bc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ehv_bc_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Timur Tabi &lt;timur@freescale.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;ePAPR hypervisor byte channel driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
