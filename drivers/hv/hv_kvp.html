<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › hv › hv_kvp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hv_kvp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * An implementation of key value pair (KVP) functionality for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2010, Novell, Inc.</span>
<span class="cm"> * Author : K. Y. Srinivasan &lt;ksrinivasan@novell.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published</span>
<span class="cm"> * by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/nls.h&gt;</span>
<span class="cp">#include &lt;linux/connector.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/hyperv.h&gt;</span>



<span class="cm">/*</span>
<span class="cm"> * Global state maintained for transaction that is being processed.</span>
<span class="cm"> * Note that only one transaction can be active at any point in time.</span>
<span class="cm"> *</span>
<span class="cm"> * This state is set when we receive a request from the host; we</span>
<span class="cm"> * cleanup this state when the transaction is completed - when we respond</span>
<span class="cm"> * to the host with the key value.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">active</span><span class="p">;</span> <span class="cm">/* transaction status - active or not */</span>
	<span class="kt">int</span> <span class="n">recv_len</span><span class="p">;</span> <span class="cm">/* number of bytes received. */</span>
	<span class="k">struct</span> <span class="n">hv_kvp_msg</span>  <span class="o">*</span><span class="n">kvp_msg</span><span class="p">;</span> <span class="cm">/* current message */</span>
	<span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">recv_channel</span><span class="p">;</span> <span class="cm">/* chn we got the request */</span>
	<span class="n">u64</span> <span class="n">recv_req_id</span><span class="p">;</span> <span class="cm">/* request ID. */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">kvp_context</span><span class="p">;</span> <span class="cm">/* for the channel callback */</span>
<span class="p">}</span> <span class="n">kvp_transaction</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">kvp_send_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">dummy</span><span class="p">);</span>

<span class="cp">#define TIMEOUT_FIRED 1</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">kvp_respond_to_host</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">kvp_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">dummy</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">kvp_register</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">kvp_work</span><span class="p">,</span> <span class="n">kvp_work_func</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">kvp_sendkey_work</span><span class="p">,</span> <span class="n">kvp_send_key</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cb_id</span> <span class="n">kvp_id</span> <span class="o">=</span> <span class="p">{</span> <span class="n">CN_KVP_IDX</span><span class="p">,</span> <span class="n">CN_KVP_VAL</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">kvp_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;kvp_kernel_module&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u8</span> <span class="o">*</span><span class="n">recv_buffer</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Register the kernel component with the user-level daemon.</span>
<span class="cm"> * As part of this registration, pass the LIC version number.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">kvp_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">cn_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="n">kvp_msg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">version</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kvp_msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">version</span> <span class="o">=</span> <span class="n">kvp_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_register</span><span class="p">.</span><span class="n">version</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span>  <span class="n">CN_KVP_IDX</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">CN_KVP_VAL</span><span class="p">;</span>

		<span class="n">kvp_msg</span><span class="o">-&gt;</span><span class="n">kvp_hdr</span><span class="p">.</span><span class="n">operation</span> <span class="o">=</span> <span class="n">KVP_OP_REGISTER</span><span class="p">;</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">HV_DRV_VERSION</span><span class="p">);</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span><span class="p">);</span>
		<span class="n">cn_netlink_send</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">kvp_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the timer fires, the user-mode component has not responded;</span>
<span class="cm">	 * process the pending transaction.</span>
<span class="cm">	 */</span>
	<span class="n">kvp_respond_to_host</span><span class="p">(</span><span class="s">&quot;Unknown key&quot;</span><span class="p">,</span> <span class="s">&quot;Guest timed out&quot;</span><span class="p">,</span> <span class="n">TIMEOUT_FIRED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback when data is received from user mode.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">kvp_cn_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">cn_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlink_skb_parms</span> <span class="o">*</span><span class="n">nsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="n">message</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_kvp_msg_enumerate</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">kvp_hdr</span><span class="p">.</span><span class="n">operation</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVP_OP_REGISTER</span>:
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;KVP: user-mode registering done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kvp_register</span><span class="p">();</span>
		<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">hv_kvp_onchannelcallback</span><span class="p">(</span><span class="n">kvp_transaction</span><span class="p">.</span><span class="n">kvp_context</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_enum_data</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Complete the transaction by forwarding the key value</span>
<span class="cm">		 * to the host. But first, cancel the timeout.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvp_work</span><span class="p">))</span>
			<span class="n">kvp_respond_to_host</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
					 <span class="n">data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
					<span class="o">!</span><span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">key</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">kvp_send_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cn_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="n">message</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="n">in_msg</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">operation</span> <span class="o">=</span> <span class="n">kvp_transaction</span><span class="p">.</span><span class="n">kvp_msg</span><span class="o">-&gt;</span><span class="n">kvp_hdr</span><span class="p">.</span><span class="n">operation</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">kvp_transaction</span><span class="p">.</span><span class="n">kvp_msg</span><span class="o">-&gt;</span><span class="n">kvp_hdr</span><span class="p">.</span><span class="n">pool</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">val32</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">val64</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span><span class="p">)</span> <span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">idx</span> <span class="o">=</span>  <span class="n">CN_KVP_IDX</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">CN_KVP_VAL</span><span class="p">;</span>

	<span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">message</span><span class="o">-&gt;</span><span class="n">kvp_hdr</span><span class="p">.</span><span class="n">operation</span> <span class="o">=</span> <span class="n">operation</span><span class="p">;</span>
	<span class="n">message</span><span class="o">-&gt;</span><span class="n">kvp_hdr</span><span class="p">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>
	<span class="n">in_msg</span> <span class="o">=</span> <span class="n">kvp_transaction</span><span class="p">.</span><span class="n">kvp_msg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The key/value strings sent from the host are encoded in</span>
<span class="cm">	 * in utf16; convert it to utf8 strings.</span>
<span class="cm">	 * The host assures us that the utf16 strings will not exceed</span>
<span class="cm">	 * the max lengths specified. We will however, reserve room</span>
<span class="cm">	 * for the string terminating character - in the utf16s_utf8s()</span>
<span class="cm">	 * function we limit the size of the buffer where the converted</span>
<span class="cm">	 * string is placed to HV_KVP_EXCHANGE_MAX_*_SIZE -1 to gaurantee</span>
<span class="cm">	 * that the strings can be properly terminated!</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">kvp_hdr</span><span class="p">.</span><span class="n">operation</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVP_OP_SET</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">REG_SZ</span>:
			<span class="cm">/*</span>
<span class="cm">			 * The value is a string - utf16 encoding.</span>
<span class="cm">			 */</span>
			<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value_size</span> <span class="o">=</span>
				<span class="n">utf16s_to_utf8s</span><span class="p">(</span>
				<span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span><span class="p">)</span><span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
				<span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value_size</span><span class="p">,</span>
				<span class="n">UTF16_LITTLE_ENDIAN</span><span class="p">,</span>
				<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
				<span class="n">HV_KVP_EXCHANGE_MAX_VALUE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_U32</span>:
			<span class="cm">/*</span>
<span class="cm">			 * The value is a 32 bit scalar.</span>
<span class="cm">			 * We save this as a utf8 string.</span>
<span class="cm">			 */</span>
			<span class="n">val32</span> <span class="o">=</span> <span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value_u32</span><span class="p">;</span>
			<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value_size</span> <span class="o">=</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
					<span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">val32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">REG_U64</span>:
			<span class="cm">/*</span>
<span class="cm">			 * The value is a 64 bit scalar.</span>
<span class="cm">			 * We save this as a utf8 string.</span>
<span class="cm">			 */</span>
			<span class="n">val64</span> <span class="o">=</span> <span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value_u64</span><span class="p">;</span>
			<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value_size</span> <span class="o">=</span>
				<span class="n">sprintf</span><span class="p">(</span><span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
					<span class="s">&quot;%llu&quot;</span><span class="p">,</span> <span class="n">val64</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="k">case</span> <span class="n">KVP_OP_GET</span>:
		<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">key_size</span> <span class="o">=</span>
			<span class="n">utf16s_to_utf8s</span><span class="p">(</span>
			<span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span><span class="p">)</span><span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
			<span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">key_size</span><span class="p">,</span>
			<span class="n">UTF16_LITTLE_ENDIAN</span><span class="p">,</span>
			<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_set</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
			<span class="n">HV_KVP_EXCHANGE_MAX_KEY_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">KVP_OP_DELETE</span>:
		<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_delete</span><span class="p">.</span><span class="n">key_size</span> <span class="o">=</span>
			<span class="n">utf16s_to_utf8s</span><span class="p">(</span>
			<span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span><span class="p">)</span><span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_delete</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
			<span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_delete</span><span class="p">.</span><span class="n">key_size</span><span class="p">,</span>
			<span class="n">UTF16_LITTLE_ENDIAN</span><span class="p">,</span>
			<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_delete</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
			<span class="n">HV_KVP_EXCHANGE_MAX_KEY_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">KVP_OP_ENUMERATE</span>:
		<span class="n">message</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_enum_data</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span>
			<span class="n">in_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_enum_data</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span><span class="p">);</span>
	<span class="n">cn_netlink_send</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send a response back to the host.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">kvp_respond_to_host</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hv_kvp_msg</span>  <span class="o">*</span><span class="n">kvp_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hv_kvp_exchg_msg_value</span>  <span class="o">*</span><span class="n">kvp_data</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">key_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmsg_hdr</span> <span class="o">*</span><span class="n">icmsghdrp</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">keylen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">valuelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">buf_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">req_id</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a transaction is not active; log and return.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kvp_transaction</span><span class="p">.</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is a spurious call!</span>
<span class="cm">		 */</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;KVP: Transaction not active</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Copy the global state for completing the transaction. Note that</span>
<span class="cm">	 * only one transaction can be active at a time.</span>
<span class="cm">	 */</span>

	<span class="n">buf_len</span> <span class="o">=</span> <span class="n">kvp_transaction</span><span class="p">.</span><span class="n">recv_len</span><span class="p">;</span>
	<span class="n">channel</span> <span class="o">=</span> <span class="n">kvp_transaction</span><span class="p">.</span><span class="n">recv_channel</span><span class="p">;</span>
	<span class="n">req_id</span> <span class="o">=</span> <span class="n">kvp_transaction</span><span class="p">.</span><span class="n">recv_req_id</span><span class="p">;</span>

	<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">icmsghdrp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmsg_hdr</span> <span class="o">*</span><span class="p">)</span>
			<span class="o">&amp;</span><span class="n">recv_buffer</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbuspipe_hdr</span><span class="p">)];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">channel</span><span class="o">-&gt;</span><span class="n">onchannel_callback</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have raced with util driver being unloaded;</span>
<span class="cm">		 * silently return.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * If the error parameter is set, terminate the host&#39;s enumeration</span>
<span class="cm">	 * on this pool.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Something failed or the we have timedout;</span>
<span class="cm">		 * terminate the current  host-side iteration.</span>
<span class="cm">		 */</span>
		<span class="n">icmsghdrp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">HV_S_CONT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">response_done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">icmsghdrp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">HV_S_OK</span><span class="p">;</span>

	<span class="n">kvp_msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="p">)</span>
			<span class="o">&amp;</span><span class="n">recv_buffer</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbuspipe_hdr</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">icmsg_hdr</span><span class="p">)];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">kvp_transaction</span><span class="p">.</span><span class="n">kvp_msg</span><span class="o">-&gt;</span><span class="n">kvp_hdr</span><span class="p">.</span><span class="n">operation</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">KVP_OP_GET</span>:
		<span class="n">kvp_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvp_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_get</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">copy_value</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">KVP_OP_SET</span>:
	<span class="k">case</span> <span class="n">KVP_OP_DELETE</span>:
		<span class="k">goto</span> <span class="n">response_done</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kvp_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kvp_msg</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">.</span><span class="n">kvp_enum_data</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="n">key_name</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The windows host expects the key/value pair to be encoded</span>
<span class="cm">	 * in utf16. Ensure that the key/value size reported to the host</span>
<span class="cm">	 * will be less than or equal to the MAX size (including the</span>
<span class="cm">	 * terminating character).</span>
<span class="cm">	 */</span>
	<span class="n">keylen</span> <span class="o">=</span> <span class="n">utf8s_to_utf16s</span><span class="p">(</span><span class="n">key_name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">key_name</span><span class="p">),</span> <span class="n">UTF16_HOST_ENDIAN</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">kvp_data</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
				<span class="p">(</span><span class="n">HV_KVP_EXCHANGE_MAX_KEY_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">kvp_data</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">keylen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* utf16 encoding */</span>

<span class="nl">copy_value:</span>
	<span class="n">valuelen</span> <span class="o">=</span> <span class="n">utf8s_to_utf16s</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">UTF16_HOST_ENDIAN</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">kvp_data</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span>
				<span class="p">(</span><span class="n">HV_KVP_EXCHANGE_MAX_VALUE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">kvp_data</span><span class="o">-&gt;</span><span class="n">value_size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">valuelen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* utf16 encoding */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the utf8s to utf16s conversion failed; notify host</span>
<span class="cm">	 * of the error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">keylen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">valuelen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">icmsghdrp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">HV_E_FAIL</span><span class="p">;</span>

	<span class="n">kvp_data</span><span class="o">-&gt;</span><span class="n">value_type</span> <span class="o">=</span> <span class="n">REG_SZ</span><span class="p">;</span> <span class="cm">/* all our values are strings */</span>

<span class="nl">response_done:</span>
	<span class="n">icmsghdrp</span><span class="o">-&gt;</span><span class="n">icflags</span> <span class="o">=</span> <span class="n">ICMSGHDRFLAG_TRANSACTION</span> <span class="o">|</span> <span class="n">ICMSGHDRFLAG_RESPONSE</span><span class="p">;</span>

	<span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">recv_buffer</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">req_id</span><span class="p">,</span>
				<span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This callback is invoked when we get a KVP message from the host.</span>
<span class="cm"> * The host ensures that only one KVP transaction can be active at a time.</span>
<span class="cm"> * KVP implementation in Linux needs to forward the key to a user-mde</span>
<span class="cm"> * component to retrive the corresponding value. Consequently, we cannot</span>
<span class="cm"> * respond to the host in the conext of this callback. Since the host</span>
<span class="cm"> * guarantees that at most only one transaction can be active at a time,</span>
<span class="cm"> * we stash away the transaction state in a set of global variables.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">hv_kvp_onchannelcallback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vmbus_channel</span> <span class="o">*</span><span class="n">channel</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">recvlen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">requestid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="n">kvp_msg</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">icmsg_hdr</span> <span class="o">*</span><span class="n">icmsghdrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">icmsg_negotiate</span> <span class="o">*</span><span class="n">negop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kvp_transaction</span><span class="p">.</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We will defer processing this callback once</span>
<span class="cm">		 * the current transaction is complete.</span>
<span class="cm">		 */</span>
		<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">kvp_context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmbus_recvpacket</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">recv_buffer</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recvlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">requestid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">recvlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">icmsghdrp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">icmsg_hdr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">recv_buffer</span><span class="p">[</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbuspipe_hdr</span><span class="p">)];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">icmsghdrp</span><span class="o">-&gt;</span><span class="n">icmsgtype</span> <span class="o">==</span> <span class="n">ICMSGTYPE_NEGOTIATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vmbus_prep_negotiate_resp</span><span class="p">(</span><span class="n">icmsghdrp</span><span class="p">,</span> <span class="n">negop</span><span class="p">,</span>
				 <span class="n">recv_buffer</span><span class="p">,</span> <span class="n">MAX_SRV_VER</span><span class="p">,</span> <span class="n">MAX_SRV_VER</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kvp_msg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">hv_kvp_msg</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">recv_buffer</span><span class="p">[</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vmbuspipe_hdr</span><span class="p">)</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">icmsg_hdr</span><span class="p">)];</span>

			<span class="cm">/*</span>
<span class="cm">			 * Stash away this global state for completing the</span>
<span class="cm">			 * transaction; note transactions are serialized.</span>
<span class="cm">			 */</span>

			<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">recv_len</span> <span class="o">=</span> <span class="n">recvlen</span><span class="p">;</span>
			<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">recv_channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
			<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">recv_req_id</span> <span class="o">=</span> <span class="n">requestid</span><span class="p">;</span>
			<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">kvp_msg</span> <span class="o">=</span> <span class="n">kvp_msg</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Get the information from the</span>
<span class="cm">			 * user-mode component.</span>
<span class="cm">			 * component. This transaction will be</span>
<span class="cm">			 * completed when we get the value from</span>
<span class="cm">			 * the user-mode component.</span>
<span class="cm">			 * Set a timeout to deal with</span>
<span class="cm">			 * user-mode not responding.</span>
<span class="cm">			 */</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvp_sendkey_work</span><span class="p">);</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvp_work</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>

			<span class="k">return</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="n">icmsghdrp</span><span class="o">-&gt;</span><span class="n">icflags</span> <span class="o">=</span> <span class="n">ICMSGHDRFLAG_TRANSACTION</span>
			<span class="o">|</span> <span class="n">ICMSGHDRFLAG_RESPONSE</span><span class="p">;</span>

		<span class="n">vmbus_sendpacket</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">recv_buffer</span><span class="p">,</span>
				       <span class="n">recvlen</span><span class="p">,</span> <span class="n">requestid</span><span class="p">,</span>
				       <span class="n">VM_PKT_DATA_INBAND</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">hv_kvp_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">hv_util_service</span> <span class="o">*</span><span class="n">srv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cn_add_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvp_id</span><span class="p">,</span> <span class="n">kvp_name</span><span class="p">,</span> <span class="n">kvp_cn_callback</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">recv_buffer</span> <span class="o">=</span> <span class="n">srv</span><span class="o">-&gt;</span><span class="n">recv_buffer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When this driver loads, the user level daemon that</span>
<span class="cm">	 * processes the host requests may not yet be running.</span>
<span class="cm">	 * Defer processing channel callbacks until the daemon</span>
<span class="cm">	 * has registered.</span>
<span class="cm">	 */</span>
	<span class="n">kvp_transaction</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hv_kvp_deinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cn_del_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvp_id</span><span class="p">);</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvp_work</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvp_sendkey_work</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
