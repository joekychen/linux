<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › acpi › acpica › utmisc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>utmisc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Module Name: utmisc - common utility procedures</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2000 - 2012, Intel Corp.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</span>
<span class="cm"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</span>
<span class="cm"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</span>
<span class="cm"> *    including a substantially similar Disclaimer requirement for further</span>
<span class="cm"> *    binary redistribution.</span>
<span class="cm"> * 3. Neither the names of the above-listed copyright holders nor the names</span>
<span class="cm"> *    of any contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="cm"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGES.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;acpi/acpi.h&gt;</span>
<span class="cp">#include &quot;accommon.h&quot;</span>
<span class="cp">#include &quot;acnamesp.h&quot;</span>

<span class="cp">#define _COMPONENT          ACPI_UTILITIES</span>
<span class="n">ACPI_MODULE_NAME</span><span class="p">(</span><span class="s">&quot;utmisc&quot;</span><span class="p">)</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_validate_exception</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Status       - The acpi_status code to be formatted</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      A string containing the exception text. NULL if exception is</span>
<span class="cm"> *              not valid.</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: This function validates and translates an ACPI exception into</span>
<span class="cm"> *              an ASCII string.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">acpi_ut_validate_exception</span><span class="p">(</span><span class="n">acpi_status</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sub_status</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">exception</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_ENTRY</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Status is composed of two parts, a &quot;type&quot; and an actual code</span>
<span class="cm">	 */</span>
	<span class="n">sub_status</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">AE_CODE_MASK</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">AE_CODE_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AE_CODE_ENVIRONMENTAL</span>:

		<span class="k">if</span> <span class="p">(</span><span class="n">sub_status</span> <span class="o">&lt;=</span> <span class="n">AE_CODE_ENV_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exception</span> <span class="o">=</span> <span class="n">acpi_gbl_exception_names_env</span><span class="p">[</span><span class="n">sub_status</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CODE_PROGRAMMER</span>:

		<span class="k">if</span> <span class="p">(</span><span class="n">sub_status</span> <span class="o">&lt;=</span> <span class="n">AE_CODE_PGM_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exception</span> <span class="o">=</span> <span class="n">acpi_gbl_exception_names_pgm</span><span class="p">[</span><span class="n">sub_status</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CODE_ACPI_TABLES</span>:

		<span class="k">if</span> <span class="p">(</span><span class="n">sub_status</span> <span class="o">&lt;=</span> <span class="n">AE_CODE_TBL_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exception</span> <span class="o">=</span> <span class="n">acpi_gbl_exception_names_tbl</span><span class="p">[</span><span class="n">sub_status</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CODE_AML</span>:

		<span class="k">if</span> <span class="p">(</span><span class="n">sub_status</span> <span class="o">&lt;=</span> <span class="n">AE_CODE_AML_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exception</span> <span class="o">=</span> <span class="n">acpi_gbl_exception_names_aml</span><span class="p">[</span><span class="n">sub_status</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CODE_CONTROL</span>:

		<span class="k">if</span> <span class="p">(</span><span class="n">sub_status</span> <span class="o">&lt;=</span> <span class="n">AE_CODE_CTRL_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exception</span> <span class="o">=</span> <span class="n">acpi_gbl_exception_names_ctrl</span><span class="p">[</span><span class="n">sub_status</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="p">,</span> <span class="n">exception</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_is_pci_root_bridge</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Id              - The HID/CID in string format</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      TRUE if the Id is a match for a PCI/PCI-Express Root Bridge</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Determine if the input ID is a PCI Root Bridge ID.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u8</span> <span class="n">acpi_ut_is_pci_root_bridge</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if this is a PCI root bridge.</span>
<span class="cm">	 * ACPI 3.0+: check for a PCI Express root also.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ACPI_STRCMP</span><span class="p">(</span><span class="n">id</span><span class="p">,</span>
			  <span class="n">PCI_ROOT_HID_STRING</span><span class="p">))</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">ACPI_STRCMP</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">PCI_EXPRESS_ROOT_HID_STRING</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_is_aml_table</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Table               - An ACPI table</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      TRUE if table contains executable AML; FALSE otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Check ACPI Signature for a table that contains AML code.</span>
<span class="cm"> *              Currently, these are DSDT,SSDT,PSDT. All other table types are</span>
<span class="cm"> *              data tables that do not contain AML code.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u8</span> <span class="n">acpi_ut_is_aml_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* These are the only tables that contain executable AML */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_COMPARE_NAME</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_SIG_DSDT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">ACPI_COMPARE_NAME</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_SIG_PSDT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">ACPI_COMPARE_NAME</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_SIG_SSDT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_allocate_owner_id</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  owner_id        - Where the new owner ID is returned</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Allocate a table or method owner ID. The owner ID is used to</span>
<span class="cm"> *              track objects created by the table or method, to be deleted</span>
<span class="cm"> *              when the method exits or the table is unloaded.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span> <span class="n">acpi_ut_allocate_owner_id</span><span class="p">(</span><span class="n">acpi_owner_id</span> <span class="o">*</span> <span class="n">owner_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE</span><span class="p">(</span><span class="n">ut_allocate_owner_id</span><span class="p">);</span>

	<span class="cm">/* Guard against multiple allocations of ID to the same location */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">owner_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="s">&quot;Owner ID [0x%2.2X] already exists&quot;</span><span class="p">,</span>
			    <span class="o">*</span><span class="n">owner_id</span><span class="p">));</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_ALREADY_EXISTS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Mutex for the global ID mask */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_ut_acquire_mutex</span><span class="p">(</span><span class="n">ACPI_MTX_CACHES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find a free owner ID, cycle through all possible IDs on repeated</span>
<span class="cm">	 * allocations. (ACPI_NUM_OWNERID_MASKS + 1) because first index may have</span>
<span class="cm">	 * to be scanned twice.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">acpi_gbl_last_owner_id_index</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ACPI_NUM_OWNERID_MASKS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">ACPI_NUM_OWNERID_MASKS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Wraparound to start of mask array */</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">acpi_gbl_next_owner_id_offset</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_owner_id_mask</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">ACPI_UINT32_MAX</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/* There are no free IDs in this mask */</span>

				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">acpi_gbl_owner_id_mask</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Found a free ID. The actual ID is the bit index plus one,</span>
<span class="cm">				 * making zero an invalid Owner ID. Save this as the last ID</span>
<span class="cm">				 * allocated and update the global ID mask.</span>
<span class="cm">				 */</span>
				<span class="n">acpi_gbl_owner_id_mask</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">);</span>

				<span class="n">acpi_gbl_last_owner_id_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">j</span><span class="p">;</span>
				<span class="n">acpi_gbl_next_owner_id_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Construct encoded ID from the index and bit position</span>
<span class="cm">				 *</span>
<span class="cm">				 * Note: Last [j].k (bit 255) is never used and is marked</span>
<span class="cm">				 * permanently allocated (prevents +1 overflow)</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">owner_id</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">acpi_owner_id</span><span class="p">)</span> <span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ACPI_MUL_32</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>

				<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_VALUES</span><span class="p">,</span>
						  <span class="s">&quot;Allocated OwnerId: %2.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">owner_id</span><span class="p">));</span>
				<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">acpi_gbl_next_owner_id_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All owner_ids have been allocated. This typically should</span>
<span class="cm">	 * not happen since the IDs are reused after deallocation. The IDs are</span>
<span class="cm">	 * allocated upon table load (one per table) and method execution, and</span>
<span class="cm">	 * they are released when a table is unloaded or a method completes</span>
<span class="cm">	 * execution.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If this error happens, there may be very deep nesting of invoked control</span>
<span class="cm">	 * methods, or there may be a bug where the IDs are not released.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">AE_OWNER_ID_LIMIT</span><span class="p">;</span>
	<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
		    <span class="s">&quot;Could not allocate new OwnerId (255 max), AE_OWNER_ID_LIMIT&quot;</span><span class="p">));</span>

      <span class="nl">exit:</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">acpi_ut_release_mutex</span><span class="p">(</span><span class="n">ACPI_MTX_CACHES</span><span class="p">);</span>
	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_release_owner_id</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  owner_id_ptr        - Pointer to a previously allocated owner_iD</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None. No error is returned because we are either exiting a</span>
<span class="cm"> *              control method or unloading a table. Either way, we would</span>
<span class="cm"> *              ignore any error anyway.</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Release a table or method owner ID.  Valid IDs are 1 - 255</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span> <span class="n">acpi_ut_release_owner_id</span><span class="p">(</span><span class="n">acpi_owner_id</span> <span class="o">*</span> <span class="n">owner_id_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_owner_id</span> <span class="n">owner_id</span> <span class="o">=</span> <span class="o">*</span><span class="n">owner_id_ptr</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bit</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE_U32</span><span class="p">(</span><span class="n">ut_release_owner_id</span><span class="p">,</span> <span class="n">owner_id</span><span class="p">);</span>

	<span class="cm">/* Always clear the input owner_id (zero is an invalid ID) */</span>

	<span class="o">*</span><span class="n">owner_id_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Zero is not a valid owner_iD */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owner_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="s">&quot;Invalid OwnerId: 0x%2.2X&quot;</span><span class="p">,</span> <span class="n">owner_id</span><span class="p">));</span>
		<span class="n">return_VOID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mutex for the global ID mask */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_ut_acquire_mutex</span><span class="p">(</span><span class="n">ACPI_MTX_CACHES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">return_VOID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Normalize the ID to zero */</span>

	<span class="n">owner_id</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Decode ID to index/offset pair */</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">ACPI_DIV_32</span><span class="p">(</span><span class="n">owner_id</span><span class="p">);</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ACPI_MOD_32</span><span class="p">(</span><span class="n">owner_id</span><span class="p">);</span>

	<span class="cm">/* Free the owner ID only if it is valid */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_owner_id_mask</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_gbl_owner_id_mask</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">^=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			    <span class="s">&quot;Release of non-allocated OwnerId: 0x%2.2X&quot;</span><span class="p">,</span>
			    <span class="n">owner_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">acpi_ut_release_mutex</span><span class="p">(</span><span class="n">ACPI_MTX_CACHES</span><span class="p">);</span>
	<span class="n">return_VOID</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_strupr (strupr)</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  src_string      - The source string to convert</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Convert string to uppercase</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This is not a POSIX function, so it appears here, not in utclib.c</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span> <span class="n">acpi_ut_strupr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">src_string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_ENTRY</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Walk entire string, uppercasing the letters */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="o">=</span> <span class="n">src_string</span><span class="p">;</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span> <span class="n">string</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">ACPI_TOUPPER</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_print_string</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  String          - Null terminated ASCII string</span>
<span class="cm"> *              max_length      - Maximum output length</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Dump an ASCII string with support for ACPI-defined escape</span>
<span class="cm"> *              sequences.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span> <span class="n">acpi_ut_print_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="n">u8</span> <span class="n">max_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;&lt;</span><span class="se">\&quot;</span><span class="s">NULL STRING PTR</span><span class="se">\&quot;</span><span class="s">&gt;&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_length</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Escape sequences */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x07</span>:
			<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">a&quot;</span><span class="p">);</span>	<span class="cm">/* BELL */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x08</span>:
			<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">b&quot;</span><span class="p">);</span>	<span class="cm">/* BACKSPACE */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x0C</span>:
			<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">f&quot;</span><span class="p">);</span>	<span class="cm">/* FORMFEED */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x0A</span>:
			<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span>	<span class="cm">/* LINEFEED */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x0D</span>:
			<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">r&quot;</span><span class="p">);</span>	<span class="cm">/* CARRIAGE RETURN */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x09</span>:
			<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">t&quot;</span><span class="p">);</span>	<span class="cm">/* HORIZONTAL TAB */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x0B</span>:
			<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">v&quot;</span><span class="p">);</span>	<span class="cm">/* VERTICAL TAB */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="sc">&#39;\&#39;&#39;</span>:	<span class="cm">/* Single Quote */</span>
		<span class="k">case</span> <span class="sc">&#39;\&quot;&#39;</span>:	<span class="cm">/* Double Quote */</span>
		<span class="k">case</span> <span class="sc">&#39;\\&#39;</span>:	<span class="cm">/* Backslash */</span>
			<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">%c&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>

			<span class="cm">/* Check for printable character or hex escape */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_IS_PRINT</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
				<span class="cm">/* This is a normal character */</span>

				<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* All others will be Hex escapes */</span>

				<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">x%2.2X&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">max_length</span> <span class="o">&amp;&amp;</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_dword_byte_swap</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Value           - Value to be converted</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      u32 integer with bytes swapped</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Convert a 32-bit value to big-endian (swap the bytes)</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u32</span> <span class="n">acpi_ut_dword_byte_swap</span><span class="p">(</span><span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">in</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_ENTRY</span><span class="p">();</span>

	<span class="n">in</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">out</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">out</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">out</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">out</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_set_integer_width</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Revision            From DSDT header</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Set the global integer bit width based upon the revision</span>
<span class="cm"> *              of the DSDT.  For Revision 1 and 0, Integers are 32 bits.</span>
<span class="cm"> *              For Revision 2 and above, Integers are 64 bits.  Yes, this</span>
<span class="cm"> *              makes a difference.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span> <span class="n">acpi_ut_set_integer_width</span><span class="p">(</span><span class="n">u8</span> <span class="n">revision</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* 32-bit case */</span>

		<span class="n">acpi_gbl_integer_bit_width</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">acpi_gbl_integer_nybble_width</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">acpi_gbl_integer_byte_width</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* 64-bit case (ACPI 2.0+) */</span>

		<span class="n">acpi_gbl_integer_bit_width</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">acpi_gbl_integer_nybble_width</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">acpi_gbl_integer_byte_width</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef ACPI_DEBUG_OUTPUT</span>
<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_display_init_pathname</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Type                - Object type of the node</span>
<span class="cm"> *              obj_handle          - Handle whose pathname will be displayed</span>
<span class="cm"> *              Path                - Additional path string to be appended.</span>
<span class="cm"> *                                      (NULL if no extra path)</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      acpi_status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Display full pathname of an object, DEBUG ONLY</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span>
<span class="n">acpi_ut_display_init_pathname</span><span class="p">(</span><span class="n">u8</span> <span class="n">type</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">acpi_namespace_node</span> <span class="o">*</span><span class="n">obj_handle</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_ENTRY</span><span class="p">();</span>

	<span class="cm">/* Only print the path if the appropriate debug level is enabled */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">acpi_dbg_level</span> <span class="o">&amp;</span> <span class="n">ACPI_LV_INIT_NAMES</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the full pathname to the node */</span>

	<span class="n">buffer</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">ACPI_ALLOCATE_LOCAL_BUFFER</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_ns_handle_to_pathname</span><span class="p">(</span><span class="n">obj_handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Print what we&#39;re doing */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ACPI_TYPE_METHOD</span>:
		<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;Executing  &quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;Initializing &quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Print the object type and pathname */</span>

	<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;%-12s %s&quot;</span><span class="p">,</span>
		       <span class="n">acpi_ut_get_type_name</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>

	<span class="cm">/* Extra path is used to append names like _STA, _INI, etc. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;.%s&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">acpi_os_printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ACPI_FREE</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_valid_acpi_char</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Char            - The character to be examined</span>
<span class="cm"> *              Position        - Byte position (0-3)</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      TRUE if the character is valid, FALSE otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Check for a valid ACPI character. Must be one of:</span>
<span class="cm"> *              1) Upper case alpha</span>
<span class="cm"> *              2) numeric</span>
<span class="cm"> *              3) underscore</span>
<span class="cm"> *</span>
<span class="cm"> *              We allow a &#39;!&#39; as the last character because of the ASF! table</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u8</span> <span class="n">acpi_ut_valid_acpi_char</span><span class="p">(</span><span class="kt">char</span> <span class="n">character</span><span class="p">,</span> <span class="n">u32</span> <span class="n">position</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span><span class="p">)</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">character</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/* Allow a &#39;!&#39; in the last position */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">==</span> <span class="sc">&#39;!&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">position</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_valid_acpi_name</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Name            - The name to be examined</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      TRUE if the name is valid, FALSE otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Check for a valid ACPI name.  Each character must be one of:</span>
<span class="cm"> *              1) Upper case alpha</span>
<span class="cm"> *              2) numeric</span>
<span class="cm"> *              3) underscore</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u8</span> <span class="n">acpi_ut_valid_acpi_name</span><span class="p">(</span><span class="n">u32</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_ENTRY</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ACPI_NAME_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_ut_valid_acpi_char</span>
		    <span class="p">((</span><span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">))[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_repair_name</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Name            - The ACPI name to be repaired</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Repaired version of the name</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Repair an ACPI name: Change invalid characters to &#39;*&#39; and</span>
<span class="cm"> *              return the new name.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_name</span> <span class="n">acpi_ut_repair_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">new_name</span><span class="p">[</span><span class="n">ACPI_NAME_SIZE</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ACPI_NAME_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Replace a bad character with something printable, yet technically</span>
<span class="cm">		 * still invalid. This prevents any collisions with existing &quot;good&quot;</span>
<span class="cm">		 * names in the namespace.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_ut_valid_acpi_char</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">new_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;*&#39;</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">new_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_strtoul64</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  String          - Null terminated string</span>
<span class="cm"> *              Base            - Radix of the string: 16 or ACPI_ANY_BASE;</span>
<span class="cm"> *                                ACPI_ANY_BASE means &#39;in behalf of to_integer&#39;</span>
<span class="cm"> *              ret_integer     - Where the converted integer is returned</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status and Converted value</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Convert a string into an unsigned value. Performs either a</span>
<span class="cm"> *              32-bit or 64-bit conversion, depending on the current mode</span>
<span class="cm"> *              of the interpreter.</span>
<span class="cm"> *              NOTE: Does not support Octal strings, not needed.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span> <span class="n">acpi_ut_strtoul64</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="n">u32</span> <span class="n">base</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span> <span class="n">ret_integer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">this_digit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">return_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">quotient</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dividend</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">to_integer_op</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="n">ACPI_ANY_BASE</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mode32</span> <span class="o">=</span> <span class="p">(</span><span class="n">acpi_gbl_integer_byte_width</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">valid_digits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">sign_of0x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">term</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE_STR</span><span class="p">(</span><span class="n">ut_stroul64</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ACPI_ANY_BASE</span>:
	<span class="k">case</span> <span class="mi">16</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* Invalid Base */</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_BAD_PARAMETER</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip over any white space in the buffer */</span>

	<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ACPI_IS_SPACE</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="o">||</span> <span class="o">*</span><span class="n">string</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">string</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_integer_op</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Base equal to ACPI_ANY_BASE means &#39;to_integer operation case&#39;.</span>
<span class="cm">		 * We need to determine if it is decimal or hexadecimal.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">string</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ACPI_TOLOWER</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">string</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sign_of0x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">base</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

			<span class="cm">/* Skip over the leading &#39;0x&#39; */</span>
			<span class="n">string</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">base</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Any string left? Check that &#39;0x&#39; is not followed by white space. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="o">||</span> <span class="n">ACPI_IS_SPACE</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="o">||</span> <span class="o">*</span><span class="n">string</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">to_integer_op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">all_done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perform a 32-bit or 64-bit conversion, depending upon the current</span>
<span class="cm">	 * execution mode of the interpreter</span>
<span class="cm">	 */</span>
	<span class="n">dividend</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode32</span><span class="p">)</span> <span class="o">?</span> <span class="n">ACPI_UINT32_MAX</span> <span class="o">:</span> <span class="n">ACPI_UINT64_MAX</span><span class="p">;</span>

	<span class="cm">/* Main loop: convert the string to a 32- or 64-bit integer */</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_IS_DIGIT</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* Convert ASCII 0-9 to Decimal value */</span>

			<span class="n">this_digit</span> <span class="o">=</span> <span class="p">((</span><span class="n">u8</span><span class="p">)</span> <span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Digit is out of range; possible in to_integer case only */</span>

			<span class="n">term</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">this_digit</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">ACPI_TOUPPER</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_IS_XDIGIT</span><span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">this_digit</span><span class="p">))</span> <span class="p">{</span>

				<span class="cm">/* Convert ASCII Hex char to value */</span>

				<span class="n">this_digit</span> <span class="o">=</span> <span class="n">this_digit</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">term</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">to_integer_op</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">valid_digits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">this_digit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			   <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sign_of0x</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Skip zeros */</span>
			<span class="n">string</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">valid_digits</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sign_of0x</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">valid_digits</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span>
				  <span class="o">||</span> <span class="p">((</span><span class="n">valid_digits</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mode32</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is to_integer operation case.</span>
<span class="cm">			 * No any restrictions for string-to-integer conversion,</span>
<span class="cm">			 * see ACPI spec.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Divide the digit into the correct position */</span>

		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">acpi_ut_short_divide</span><span class="p">((</span><span class="n">dividend</span> <span class="o">-</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">this_digit</span><span class="p">),</span>
					   <span class="n">base</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quotient</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">return_value</span> <span class="o">&gt;</span> <span class="n">quotient</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">to_integer_op</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">return_value</span> <span class="o">*=</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">return_value</span> <span class="o">+=</span> <span class="n">this_digit</span><span class="p">;</span>
		<span class="n">string</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All done, normal exit */</span>

      <span class="nl">all_done:</span>

	<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_EXEC</span><span class="p">,</span> <span class="s">&quot;Converted value: %8.8X%8.8X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">ACPI_FORMAT_UINT64</span><span class="p">(</span><span class="n">return_value</span><span class="p">)));</span>

	<span class="o">*</span><span class="n">ret_integer</span> <span class="o">=</span> <span class="n">return_value</span><span class="p">;</span>
	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>

      <span class="nl">error_exit:</span>
	<span class="cm">/* Base was set/validated above */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_BAD_DECIMAL_CONSTANT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_BAD_HEX_CONSTANT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_create_update_state_and_push</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Object          - Object to be added to the new state</span>
<span class="cm"> *              Action          - Increment/Decrement</span>
<span class="cm"> *              state_list      - List the state will be added to</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Create a new state and push it</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span>
<span class="n">acpi_ut_create_update_state_and_push</span><span class="p">(</span><span class="k">union</span> <span class="n">acpi_operand_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">action</span><span class="p">,</span>
				     <span class="k">union</span> <span class="n">acpi_generic_state</span> <span class="o">**</span><span class="n">state_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">acpi_generic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_ENTRY</span><span class="p">();</span>

	<span class="cm">/* Ignore null objects; these are expected */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">acpi_ut_create_update_state</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">action</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">AE_NO_MEMORY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">acpi_ut_push_generic_state</span><span class="p">(</span><span class="n">state_list</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ut_walk_package_tree</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  source_object       - The package to walk</span>
<span class="cm"> *              target_object       - Target object (if package is being copied)</span>
<span class="cm"> *              walk_callback       - Called once for each package element</span>
<span class="cm"> *              Context             - Passed to the callback function</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Walk through a package</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span>
<span class="n">acpi_ut_walk_package_tree</span><span class="p">(</span><span class="k">union</span> <span class="n">acpi_operand_object</span> <span class="o">*</span> <span class="n">source_object</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">target_object</span><span class="p">,</span>
			  <span class="n">acpi_pkg_callback</span> <span class="n">walk_callback</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">AE_OK</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">acpi_generic_state</span> <span class="o">*</span><span class="n">state_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">acpi_generic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">this_index</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">acpi_operand_object</span> <span class="o">*</span><span class="n">this_source_obj</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE</span><span class="p">(</span><span class="n">ut_walk_package_tree</span><span class="p">);</span>

	<span class="n">state</span> <span class="o">=</span> <span class="n">acpi_ut_create_pkg_state</span><span class="p">(</span><span class="n">source_object</span><span class="p">,</span> <span class="n">target_object</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_NO_MEMORY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Get one element of the package */</span>

		<span class="n">this_index</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">pkg</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
		<span class="n">this_source_obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">acpi_operand_object</span> <span class="o">*</span><span class="p">)</span>
		    <span class="n">state</span><span class="o">-&gt;</span><span class="n">pkg</span><span class="p">.</span><span class="n">source_object</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">this_index</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for:</span>
<span class="cm">		 * 1) An uninitialized package element.  It is completely</span>
<span class="cm">		 *    legal to declare a package and leave it uninitialized</span>
<span class="cm">		 * 2) Not an internal object - can be a namespace node instead</span>
<span class="cm">		 * 3) Any type other than a package.  Packages are handled in else</span>
<span class="cm">		 *    case below.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">this_source_obj</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">ACPI_GET_DESCRIPTOR_TYPE</span><span class="p">(</span><span class="n">this_source_obj</span><span class="p">)</span> <span class="o">!=</span>
		     <span class="n">ACPI_DESC_TYPE_OPERAND</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">this_source_obj</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_PACKAGE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">walk_callback</span><span class="p">(</span><span class="n">ACPI_COPY_TYPE_SIMPLE</span><span class="p">,</span>
					  <span class="n">this_source_obj</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">state</span><span class="o">-&gt;</span><span class="n">pkg</span><span class="p">.</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">pkg</span><span class="p">.</span><span class="n">index</span> <span class="o">&gt;=</span>
			       <span class="n">state</span><span class="o">-&gt;</span><span class="n">pkg</span><span class="p">.</span><span class="n">source_object</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We&#39;ve handled all of the objects at this level,  This means</span>
<span class="cm">				 * that we have just completed a package.  That package may</span>
<span class="cm">				 * have contained one or more packages itself.</span>
<span class="cm">				 *</span>
<span class="cm">				 * Delete this state and pop the previous state (package).</span>
<span class="cm">				 */</span>
				<span class="n">acpi_ut_delete_generic_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
				<span class="n">state</span> <span class="o">=</span> <span class="n">acpi_ut_pop_generic_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state_list</span><span class="p">);</span>

				<span class="cm">/* Finished when there are no more states */</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * We have handled all of the objects in the top level</span>
<span class="cm">					 * package just add the length of the package objects</span>
<span class="cm">					 * and exit</span>
<span class="cm">					 */</span>
					<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Go back up a level and move the index past the just</span>
<span class="cm">				 * completed package object.</span>
<span class="cm">				 */</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">pkg</span><span class="p">.</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* This is a subobject of type package */</span>

			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">walk_callback</span><span class="p">(</span><span class="n">ACPI_COPY_TYPE_PACKAGE</span><span class="p">,</span>
					  <span class="n">this_source_obj</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Push the current state and create a new one</span>
<span class="cm">			 * The callback above returned a new target package object.</span>
<span class="cm">			 */</span>
			<span class="n">acpi_ut_push_generic_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state_list</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">acpi_ut_create_pkg_state</span><span class="p">(</span><span class="n">this_source_obj</span><span class="p">,</span>
							 <span class="n">state</span><span class="o">-&gt;</span><span class="n">pkg</span><span class="p">.</span>
							 <span class="n">this_target_obj</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/* Free any stacked Update State objects */</span>

				<span class="k">while</span> <span class="p">(</span><span class="n">state_list</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">state</span> <span class="o">=</span>
					    <span class="n">acpi_ut_pop_generic_state</span>
					    <span class="p">(</span><span class="o">&amp;</span><span class="n">state_list</span><span class="p">);</span>
					<span class="n">acpi_ut_delete_generic_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_NO_MEMORY</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We should never get here */</span>

	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_AML_INTERNAL</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
