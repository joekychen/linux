<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › acpi › acpica › psparse.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>psparse.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Module Name: psparse - Parser top level AML parse routines</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2000 - 2012, Intel Corp.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</span>
<span class="cm"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</span>
<span class="cm"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</span>
<span class="cm"> *    including a substantially similar Disclaimer requirement for further</span>
<span class="cm"> *    binary redistribution.</span>
<span class="cm"> * 3. Neither the names of the above-listed copyright holders nor the names</span>
<span class="cm"> *    of any contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="cm"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGES.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Parse the AML and build an operation tree as most interpreters,</span>
<span class="cm"> * like Perl, do.  Parsing is done by hand rather than with a YACC</span>
<span class="cm"> * generated parser to tightly constrain stack and dynamic memory</span>
<span class="cm"> * usage.  At the same time, parsing is kept flexible and the code</span>
<span class="cm"> * fairly compact by parsing based on a list of AML opcode</span>
<span class="cm"> * templates in aml_op_info[]</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;acpi/acpi.h&gt;</span>
<span class="cp">#include &quot;accommon.h&quot;</span>
<span class="cp">#include &quot;acparser.h&quot;</span>
<span class="cp">#include &quot;acdispat.h&quot;</span>
<span class="cp">#include &quot;amlcode.h&quot;</span>
<span class="cp">#include &quot;acinterp.h&quot;</span>

<span class="cp">#define _COMPONENT          ACPI_PARSER</span>
<span class="n">ACPI_MODULE_NAME</span><span class="p">(</span><span class="s">&quot;psparse&quot;</span><span class="p">)</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ps_get_opcode_size</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Opcode          - An AML opcode</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Size of the opcode, in bytes (1 or 2)</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Get the size of the current opcode.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>
<span class="n">u32</span> <span class="n">acpi_ps_get_opcode_size</span><span class="p">(</span><span class="n">u32</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* Extended (2-byte) opcode if &gt; 255 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&gt;</span> <span class="mh">0x00FF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Otherwise, just a single byte opcode */</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ps_peek_opcode</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  parser_state        - A parser state object</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Next AML opcode</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u16</span> <span class="n">acpi_ps_peek_opcode</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_parse_state</span> <span class="o">*</span> <span class="n">parser_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">aml</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">opcode</span><span class="p">;</span>

	<span class="n">aml</span> <span class="o">=</span> <span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">aml</span><span class="p">;</span>
	<span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">ACPI_GET8</span><span class="p">(</span><span class="n">aml</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">AML_EXTENDED_OP_PREFIX</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Extended opcode, get the second opcode byte */</span>

		<span class="n">aml</span><span class="o">++</span><span class="p">;</span>
		<span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">ACPI_GET8</span><span class="p">(</span><span class="n">aml</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">opcode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ps_complete_this_op</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  walk_state      - Current State</span>
<span class="cm"> *              Op              - Op to complete</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Perform any cleanup at the completion of an Op.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span>
<span class="n">acpi_ps_complete_this_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_walk_state</span> <span class="o">*</span> <span class="n">walk_state</span><span class="p">,</span>
			 <span class="k">union</span> <span class="n">acpi_parse_object</span> <span class="o">*</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">acpi_parse_object</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">acpi_parse_object</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">acpi_opcode_info</span> <span class="o">*</span><span class="n">parent_info</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">acpi_parse_object</span> <span class="o">*</span><span class="n">replacement_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">AE_OK</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE_PTR</span><span class="p">(</span><span class="n">ps_complete_this_op</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

	<span class="cm">/* Check for null Op, can happen if AML code is corrupt */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>	<span class="cm">/* OK for now */</span>
	<span class="p">}</span>

	<span class="cm">/* Delete this op and the subtree below it if asked to */</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">parse_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_PARSE_TREE_MASK</span><span class="p">)</span> <span class="o">!=</span>
	     <span class="n">ACPI_PARSE_DELETE_TREE</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">op_info</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">AML_CLASS_ARGUMENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure that we only delete this subtree */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">arg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Nothing more to do */</span>

			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if we need to replace the operator and its subtree</span>
<span class="cm">		 * with a return value op (placeholder op)</span>
<span class="cm">		 */</span>
		<span class="n">parent_info</span> <span class="o">=</span>
		    <span class="n">acpi_ps_get_opcode_info</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span>
					    <span class="n">aml_opcode</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">parent_info</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">AML_CLASS_CONTROL</span>:
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">AML_CLASS_CREATE</span>:

			<span class="cm">/*</span>
<span class="cm">			 * These opcodes contain term_arg operands. The current</span>
<span class="cm">			 * op must be replaced by a placeholder return op</span>
<span class="cm">			 */</span>
			<span class="n">replacement_op</span> <span class="o">=</span>
			    <span class="n">acpi_ps_alloc_op</span><span class="p">(</span><span class="n">AML_INT_RETURN_VALUE_OP</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">replacement_op</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">AE_NO_MEMORY</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">AML_CLASS_NAMED_OBJECT</span>:

			<span class="cm">/*</span>
<span class="cm">			 * These opcodes contain term_arg operands. The current</span>
<span class="cm">			 * op must be replaced by a placeholder return op</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span>
			     <span class="n">AML_REGION_OP</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span>
				<span class="n">AML_DATA_REGION_OP</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span>
				<span class="n">AML_BUFFER_OP</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span>
				<span class="n">AML_PACKAGE_OP</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span>
				<span class="n">AML_BANK_FIELD_OP</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span>
				<span class="n">AML_VAR_PACKAGE_OP</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">replacement_op</span> <span class="o">=</span>
				    <span class="n">acpi_ps_alloc_op</span><span class="p">(</span><span class="n">AML_INT_RETURN_VALUE_OP</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">replacement_op</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">status</span> <span class="o">=</span> <span class="n">AE_NO_MEMORY</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span>
			    <span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span>
				 <span class="n">AML_NAME_OP</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">pass_number</span> <span class="o">&lt;=</span>
				    <span class="n">ACPI_IMODE_LOAD_PASS2</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span> <span class="n">AML_BUFFER_OP</span><span class="p">)</span>
				    <span class="o">||</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span> <span class="n">AML_PACKAGE_OP</span><span class="p">)</span>
				    <span class="o">||</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">aml_opcode</span> <span class="o">==</span>
					<span class="n">AML_VAR_PACKAGE_OP</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">replacement_op</span> <span class="o">=</span>
					    <span class="n">acpi_ps_alloc_op</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span>
							     <span class="n">aml_opcode</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">replacement_op</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">status</span> <span class="o">=</span> <span class="n">AE_NO_MEMORY</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">named</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span>
						    <span class="n">op</span><span class="o">-&gt;</span><span class="n">named</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
						<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">named</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span>
						    <span class="n">op</span><span class="o">-&gt;</span><span class="n">named</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>

			<span class="n">replacement_op</span> <span class="o">=</span>
			    <span class="n">acpi_ps_alloc_op</span><span class="p">(</span><span class="n">AML_INT_RETURN_VALUE_OP</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">replacement_op</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">AE_NO_MEMORY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* We must unlink this op from the parent tree */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* This op is the first in the list */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">replacement_op</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span>
				    <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
				<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span>
				    <span class="n">replacement_op</span><span class="p">;</span>
				<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span>
				    <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Search the parent list */</span>

		<span class="k">else</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/* Traverse all siblings in the parent&#39;s argument list */</span>

				<span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">replacement_op</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span>
						    <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
						<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">value</span><span class="p">.</span>
						    <span class="n">arg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
						<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span>
						    <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
						<span class="n">prev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span>
						    <span class="n">replacement_op</span><span class="p">;</span>
						<span class="n">replacement_op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span>
						    <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
						<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">prev</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span>
						    <span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
						<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">prev</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

      <span class="nl">cleanup:</span>

	<span class="cm">/* Now we can actually delete the subtree rooted at Op */</span>

	<span class="n">acpi_ps_delete_parse_tree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ps_next_parse_state</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  walk_state          - Current state</span>
<span class="cm"> *              Op                  - Current parse op</span>
<span class="cm"> *              callback_status     - Status from previous operation</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Update the parser state based upon the return exception from</span>
<span class="cm"> *              the parser callback.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span>
<span class="n">acpi_ps_next_parse_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_walk_state</span> <span class="o">*</span><span class="n">walk_state</span><span class="p">,</span>
			 <span class="k">union</span> <span class="n">acpi_parse_object</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
			 <span class="n">acpi_status</span> <span class="n">callback_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_parse_state</span> <span class="o">*</span><span class="n">parser_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">parser_state</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">AE_CTRL_PENDING</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE_PTR</span><span class="p">(</span><span class="n">ps_next_parse_state</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">callback_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AE_CTRL_TERMINATE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * A control method was terminated via a RETURN statement.</span>
<span class="cm">		 * The walk of this method is complete.</span>
<span class="cm">		 */</span>
		<span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">aml</span> <span class="o">=</span> <span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">aml_end</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AE_CTRL_TERMINATE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CTRL_BREAK</span>:

		<span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">aml</span> <span class="o">=</span> <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">aml_last_while</span><span class="p">;</span>
		<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">control_state</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AE_CTRL_BREAK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CTRL_CONTINUE</span>:

		<span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">aml</span> <span class="o">=</span> <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">aml_last_while</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AE_CTRL_CONTINUE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CTRL_PENDING</span>:

		<span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">aml</span> <span class="o">=</span> <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">aml_last_while</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	case AE_CTRL_SKIP:</span>

<span class="c">		parser_state-&gt;aml = parser_state-&gt;scope-&gt;parse_scope.pkg_end;</span>
<span class="c">		status = AE_OK;</span>
<span class="c">		break;</span>
<span class="cp">#endif</span>

	<span class="k">case</span> <span class="n">AE_CTRL_TRUE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Predicate of an IF was true, and we are at the matching ELSE.</span>
<span class="cm">		 * Just close out this package</span>
<span class="cm">		 */</span>
		<span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">aml</span> <span class="o">=</span> <span class="n">acpi_ps_get_next_package_end</span><span class="p">(</span><span class="n">parser_state</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AE_CTRL_PENDING</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CTRL_FALSE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Either an IF/WHILE Predicate was false or we encountered a BREAK</span>
<span class="cm">		 * opcode.  In both cases, we do not execute the rest of the</span>
<span class="cm">		 * package;  We simply close out the parent (finishing the walk of</span>
<span class="cm">		 * this branch of the tree) and continue execution at the parent</span>
<span class="cm">		 * level.</span>
<span class="cm">		 */</span>
		<span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">aml</span> <span class="o">=</span> <span class="n">parser_state</span><span class="o">-&gt;</span><span class="n">scope</span><span class="o">-&gt;</span><span class="n">parse_scope</span><span class="p">.</span><span class="n">pkg_end</span><span class="p">;</span>

		<span class="cm">/* In the case of a BREAK, just force a predicate (if any) to FALSE */</span>

		<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">control_state</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AE_CTRL_END</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">AE_CTRL_TRANSFER</span>:

		<span class="cm">/* A method call (invocation) -- transfer control */</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">AE_CTRL_TRANSFER</span><span class="p">;</span>
		<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">prev_op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
		<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_call_op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
		<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_call_node</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>

		<span class="cm">/* Will return value (if any) be used by the caller? */</span>

		<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">return_used</span> <span class="o">=</span>
		    <span class="n">acpi_ds_is_result_used</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">walk_state</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">callback_status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">callback_status</span> <span class="o">&amp;</span> <span class="n">AE_CODE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_CODE_CONTROL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">AE_OK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ps_parse_aml</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  walk_state      - Current state</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Parse raw AML and return a tree of ops</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span> <span class="n">acpi_ps_parse_aml</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_walk_state</span> <span class="o">*</span><span class="n">walk_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_thread_state</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_thread_state</span> <span class="o">*</span><span class="n">prev_walk_list</span> <span class="o">=</span> <span class="n">acpi_gbl_current_walk_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_walk_state</span> <span class="o">*</span><span class="n">previous_walk_state</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE</span><span class="p">(</span><span class="n">ps_parse_aml</span><span class="p">);</span>

	<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_PARSE</span><span class="p">,</span>
			  <span class="s">&quot;Entered with WalkState=%p Aml=%p size=%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">walk_state</span><span class="p">,</span> <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">parser_state</span><span class="p">.</span><span class="n">aml</span><span class="p">,</span>
			  <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">parser_state</span><span class="p">.</span><span class="n">aml_size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">parser_state</span><span class="p">.</span><span class="n">aml</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_NULL_OBJECT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Create and initialize a new thread state */</span>

	<span class="kr">thread</span> <span class="o">=</span> <span class="n">acpi_ut_create_thread_state</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_desc</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Executing a control method - additional cleanup */</span>

			<span class="n">acpi_ds_terminate_control_method</span><span class="p">(</span>
				<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_desc</span><span class="p">,</span> <span class="n">walk_state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">acpi_ds_delete_walk_state</span><span class="p">(</span><span class="n">walk_state</span><span class="p">);</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_NO_MEMORY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">walk_state</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If executing a method, the starting sync_level is this method&#39;s</span>
<span class="cm">	 * sync_level</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">walk_state</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">current_sync_level</span> <span class="o">=</span>
		    <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_desc</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">.</span><span class="n">sync_level</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">acpi_ds_push_walk_state</span><span class="p">(</span><span class="n">walk_state</span><span class="p">,</span> <span class="kr">thread</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This global allows the AML debugger to get a handle to the currently</span>
<span class="cm">	 * executing control method.</span>
<span class="cm">	 */</span>
	<span class="n">acpi_gbl_current_walk_list</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Execute the walk loop as long as there is a valid Walk State.  This</span>
<span class="cm">	 * handles nested control method invocations without recursion.</span>
<span class="cm">	 */</span>
	<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_PARSE</span><span class="p">,</span> <span class="s">&quot;State=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">walk_state</span><span class="p">));</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">AE_OK</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">walk_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The parse_loop executes AML until the method terminates</span>
<span class="cm">			 * or calls another method.</span>
<span class="cm">			 */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_ps_parse_loop</span><span class="p">(</span><span class="n">walk_state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_PARSE</span><span class="p">,</span>
				  <span class="s">&quot;Completed one call to walk loop, %s State=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">acpi_format_exception</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">walk_state</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">AE_CTRL_TRANSFER</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * A method call was detected.</span>
<span class="cm">			 * Transfer control to the called control method</span>
<span class="cm">			 */</span>
			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">acpi_ds_call_control_method</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="n">walk_state</span><span class="p">,</span>
							<span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span>
				    <span class="n">acpi_ds_method_error</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">walk_state</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the transfer to the new method method call worked, a new walk</span>
<span class="cm">			 * state was created -- get it</span>
<span class="cm">			 */</span>
			<span class="n">walk_state</span> <span class="o">=</span> <span class="n">acpi_ds_get_current_walk_state</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">AE_CTRL_TERMINATE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">AE_OK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">!=</span> <span class="n">AE_OK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_desc</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* Either the method parse or actual execution failed */</span>

			<span class="n">ACPI_ERROR_METHOD</span><span class="p">(</span><span class="s">&quot;Method parse/execution failed&quot;</span><span class="p">,</span>
					  <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_node</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					  <span class="n">status</span><span class="p">);</span>

			<span class="cm">/* Check for possible multi-thread reentrancy problem */</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="n">AE_ALREADY_EXISTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_desc</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">.</span>
			       <span class="n">info_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_METHOD_SERIALIZED</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Method is not serialized and tried to create an object</span>
<span class="cm">				 * twice. The probable cause is that the method cannot</span>
<span class="cm">				 * handle reentrancy. Mark as &quot;pending serialized&quot; now, and</span>
<span class="cm">				 * then mark &quot;serialized&quot; when the last thread exits.</span>
<span class="cm">				 */</span>
				<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">method_desc</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">.</span><span class="n">info_flags</span> <span class="o">|=</span>
				    <span class="n">ACPI_METHOD_SERIALIZED_PENDING</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* We are done with this walk, move on to the parent if any */</span>

		<span class="n">walk_state</span> <span class="o">=</span> <span class="n">acpi_ds_pop_walk_state</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>

		<span class="cm">/* Reset the current scope to the beginning of scope stack */</span>

		<span class="n">acpi_ds_scope_stack_clear</span><span class="p">(</span><span class="n">walk_state</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we just returned from the execution of a control method or if we</span>
<span class="cm">		 * encountered an error during the method parse phase, there&#39;s lots of</span>
<span class="cm">		 * cleanup to do</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">parse_flags</span> <span class="o">&amp;</span> <span class="n">ACPI_PARSE_MODE_MASK</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">ACPI_PARSE_EXECUTE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">acpi_ds_terminate_control_method</span><span class="p">(</span><span class="n">walk_state</span><span class="o">-&gt;</span>
							 <span class="n">method_desc</span><span class="p">,</span>
							 <span class="n">walk_state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Delete this walk state and all linked control states */</span>

		<span class="n">acpi_ps_cleanup_scope</span><span class="p">(</span><span class="o">&amp;</span><span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">parser_state</span><span class="p">);</span>
		<span class="n">previous_walk_state</span> <span class="o">=</span> <span class="n">walk_state</span><span class="p">;</span>

		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_PARSE</span><span class="p">,</span>
				  <span class="s">&quot;ReturnValue=%p, ImplicitValue=%p State=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">return_desc</span><span class="p">,</span>
				  <span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">implicit_return_obj</span><span class="p">,</span> <span class="n">walk_state</span><span class="p">));</span>

		<span class="cm">/* Check if we have restarted a preempted walk */</span>

		<span class="n">walk_state</span> <span class="o">=</span> <span class="n">acpi_ds_get_current_walk_state</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">walk_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * There is another walk state, restart it.</span>
<span class="cm">				 * If the method return value is not used by the parent,</span>
<span class="cm">				 * The object is deleted</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">return_desc</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * In slack mode execution, if there is no return value</span>
<span class="cm">					 * we should implicitly return zero (0) as a default value.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_enable_interpreter_slack</span> <span class="o">&amp;&amp;</span>
					    <span class="o">!</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span>
					    <span class="n">implicit_return_obj</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">previous_walk_state</span><span class="o">-&gt;</span>
						    <span class="n">implicit_return_obj</span> <span class="o">=</span>
						    <span class="n">acpi_ut_create_integer_object</span>
						    <span class="p">((</span><span class="n">u64</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span>
						    <span class="n">implicit_return_obj</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">return_ACPI_STATUS</span>
							    <span class="p">(</span><span class="n">AE_NO_MEMORY</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span>

					<span class="cm">/* Restart the calling control method */</span>

					<span class="n">status</span> <span class="o">=</span>
					    <span class="n">acpi_ds_restart_control_method</span>
					    <span class="p">(</span><span class="n">walk_state</span><span class="p">,</span>
					     <span class="n">previous_walk_state</span><span class="o">-&gt;</span>
					     <span class="n">implicit_return_obj</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * We have a valid return value, delete any implicit</span>
<span class="cm">					 * return value.</span>
<span class="cm">					 */</span>
					<span class="n">acpi_ds_clear_implicit_return</span>
					    <span class="p">(</span><span class="n">previous_walk_state</span><span class="p">);</span>

					<span class="n">status</span> <span class="o">=</span>
					    <span class="n">acpi_ds_restart_control_method</span>
					    <span class="p">(</span><span class="n">walk_state</span><span class="p">,</span>
					     <span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">return_desc</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">walk_state</span><span class="o">-&gt;</span><span class="n">walk_type</span> <span class="o">|=</span>
					    <span class="n">ACPI_WALK_METHOD_RESTART</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* On error, delete any return object or implicit return */</span>

				<span class="n">acpi_ut_remove_reference</span><span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span>
							 <span class="n">return_desc</span><span class="p">);</span>
				<span class="n">acpi_ds_clear_implicit_return</span>
				    <span class="p">(</span><span class="n">previous_walk_state</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Just completed a 1st-level method, save the final internal return</span>
<span class="cm">		 * value (if any)</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">caller_return_desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">implicit_return_obj</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">caller_return_desc</span><span class="p">)</span> <span class="o">=</span>
				    <span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">implicit_return_obj</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* NULL if no return value */</span>

				<span class="o">*</span><span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">caller_return_desc</span><span class="p">)</span> <span class="o">=</span>
				    <span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">return_desc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">return_desc</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/* Caller doesn&#39;t want it, must delete it */</span>

				<span class="n">acpi_ut_remove_reference</span><span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span>
							 <span class="n">return_desc</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span><span class="n">implicit_return_obj</span><span class="p">)</span> <span class="p">{</span>

				<span class="cm">/* Caller doesn&#39;t want it, must delete it */</span>

				<span class="n">acpi_ut_remove_reference</span><span class="p">(</span><span class="n">previous_walk_state</span><span class="o">-&gt;</span>
							 <span class="n">implicit_return_obj</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">acpi_ds_delete_walk_state</span><span class="p">(</span><span class="n">previous_walk_state</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Normal exit */</span>

	<span class="n">acpi_ex_release_all_mutexes</span><span class="p">(</span><span class="kr">thread</span><span class="p">);</span>
	<span class="n">acpi_ut_delete_generic_state</span><span class="p">(</span><span class="n">ACPI_CAST_PTR</span>
				     <span class="p">(</span><span class="k">union</span> <span class="n">acpi_generic_state</span><span class="p">,</span> <span class="kr">thread</span><span class="p">));</span>
	<span class="n">acpi_gbl_current_walk_list</span> <span class="o">=</span> <span class="n">prev_walk_list</span><span class="p">;</span>
	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
