<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › acpi › acpica › evgpeinit.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>evgpeinit.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Module Name: evgpeinit - System GPE initialization and update</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2000 - 2012, Intel Corp.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</span>
<span class="cm"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</span>
<span class="cm"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</span>
<span class="cm"> *    including a substantially similar Disclaimer requirement for further</span>
<span class="cm"> *    binary redistribution.</span>
<span class="cm"> * 3. Neither the names of the above-listed copyright holders nor the names</span>
<span class="cm"> *    of any contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="cm"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGES.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;acpi/acpi.h&gt;</span>
<span class="cp">#include &quot;accommon.h&quot;</span>
<span class="cp">#include &quot;acevents.h&quot;</span>
<span class="cp">#include &quot;acnamesp.h&quot;</span>

<span class="cp">#define _COMPONENT          ACPI_EVENTS</span>
<span class="n">ACPI_MODULE_NAME</span><span class="p">(</span><span class="s">&quot;evgpeinit&quot;</span><span class="p">)</span>
<span class="cp">#if (!ACPI_REDUCED_HARDWARE)	</span><span class="cm">/* Entire module */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * Note: History of _PRW support in ACPICA</span>
<span class="cm"> *</span>
<span class="cm"> * Originally (2000 - 2010), the GPE initialization code performed a walk of</span>
<span class="cm"> * the entire namespace to execute the _PRW methods and detect all GPEs</span>
<span class="cm"> * capable of waking the system.</span>
<span class="cm"> *</span>
<span class="cm"> * As of 10/2010, the _PRW method execution has been removed since it is</span>
<span class="cm"> * actually unnecessary. The host OS must in fact execute all _PRW methods</span>
<span class="cm"> * in order to identify the device/power-resource dependencies. We now put</span>
<span class="cm"> * the onus on the host OS to identify the wake GPEs as part of this process</span>
<span class="cm"> * and to inform ACPICA of these GPEs via the acpi_setup_gpe_for_wake interface. This</span>
<span class="cm"> * not only reduces the complexity of the ACPICA initialization code, but in</span>
<span class="cm"> * some cases (on systems with very large namespaces) it should reduce the</span>
<span class="cm"> * kernel boot time as well.</span>
<span class="cm"> */</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ev_gpe_initialize</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  None</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Initialize the GPE data structures and the FADT GPE 0/1 blocks</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>
<span class="n">acpi_status</span> <span class="n">acpi_ev_gpe_initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">register_count0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">register_count1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpe_number_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE</span><span class="p">(</span><span class="n">ev_gpe_initialize</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_ut_acquire_mutex</span><span class="p">(</span><span class="n">ACPI_MTX_NAMESPACE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the GPE Block(s) defined in the FADT</span>
<span class="cm">	 *</span>
<span class="cm">	 * Why the GPE register block lengths are divided by 2:  From the ACPI</span>
<span class="cm">	 * Spec, section &quot;General-Purpose Event Registers&quot;, we have:</span>
<span class="cm">	 *</span>
<span class="cm">	 * &quot;Each register block contains two registers of equal length</span>
<span class="cm">	 *  GPEx_STS and GPEx_EN (where x is 0 or 1). The length of the</span>
<span class="cm">	 *  GPE0_STS and GPE0_EN registers is equal to half the GPE0_LEN</span>
<span class="cm">	 *  The length of the GPE1_STS and GPE1_EN registers is equal to</span>
<span class="cm">	 *  half the GPE1_LEN. If a generic register block is not supported</span>
<span class="cm">	 *  then its respective block pointer and block length values in the</span>
<span class="cm">	 *  FADT table contain zeros. The GPE0_LEN and GPE1_LEN do not need</span>
<span class="cm">	 *  to be the same size.&quot;</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine the maximum GPE number for this machine.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: both GPE0 and GPE1 are optional, and either can exist without</span>
<span class="cm">	 * the other.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If EITHER the register length OR the block address are zero, then that</span>
<span class="cm">	 * particular block is not supported.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe0_block_length</span> <span class="o">&amp;&amp;</span>
	    <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">xgpe0_block</span><span class="p">.</span><span class="n">address</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* GPE block 0 exists (has both length and address &gt; 0) */</span>

		<span class="n">register_count0</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe0_block_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

		<span class="n">gpe_number_max</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">register_count0</span> <span class="o">*</span> <span class="n">ACPI_GPE_REGISTER_WIDTH</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Install GPE Block 0 */</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_ev_create_gpe_block</span><span class="p">(</span><span class="n">acpi_gbl_fadt_gpe_device</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">xgpe0_block</span><span class="p">,</span>
						  <span class="n">register_count0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						  <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">sci_interrupt</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">acpi_gbl_gpe_fadt_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ACPI_EXCEPTION</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
					<span class="s">&quot;Could not create GPE Block 0&quot;</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe1_block_length</span> <span class="o">&amp;&amp;</span>
	    <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">xgpe1_block</span><span class="p">.</span><span class="n">address</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* GPE block 1 exists (has both length and address &gt; 0) */</span>

		<span class="n">register_count1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe1_block_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

		<span class="cm">/* Check for GPE0/GPE1 overlap (if both banks exist) */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">register_count0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">gpe_number_max</span> <span class="o">&gt;=</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe1_base</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
				    <span class="s">&quot;GPE0 block (GPE 0 to %u) overlaps the GPE1 block &quot;</span>
				    <span class="s">&quot;(GPE %u to %u) - Ignoring GPE1&quot;</span><span class="p">,</span>
				    <span class="n">gpe_number_max</span><span class="p">,</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe1_base</span><span class="p">,</span>
				    <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe1_base</span> <span class="o">+</span>
				    <span class="p">((</span><span class="n">register_count1</span> <span class="o">*</span>
				      <span class="n">ACPI_GPE_REGISTER_WIDTH</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>

			<span class="cm">/* Ignore GPE1 block by setting the register count to zero */</span>

			<span class="n">register_count1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Install GPE Block 1 */</span>

			<span class="n">status</span> <span class="o">=</span>
			    <span class="n">acpi_ev_create_gpe_block</span><span class="p">(</span><span class="n">acpi_gbl_fadt_gpe_device</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">xgpe1_block</span><span class="p">,</span>
						     <span class="n">register_count1</span><span class="p">,</span>
						     <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe1_base</span><span class="p">,</span>
						     <span class="n">acpi_gbl_FADT</span><span class="p">.</span>
						     <span class="n">sci_interrupt</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">acpi_gbl_gpe_fadt_blocks</span>
						     <span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ACPI_EXCEPTION</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
						<span class="s">&quot;Could not create GPE Block 1&quot;</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * GPE0 and GPE1 do not have to be contiguous in the GPE number</span>
<span class="cm">			 * space. However, GPE0 always starts at GPE number zero.</span>
<span class="cm">			 */</span>
			<span class="n">gpe_number_max</span> <span class="o">=</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">gpe1_base</span> <span class="o">+</span>
			    <span class="p">((</span><span class="n">register_count1</span> <span class="o">*</span> <span class="n">ACPI_GPE_REGISTER_WIDTH</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Exit if there are no GPE registers */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">register_count0</span> <span class="o">+</span> <span class="n">register_count1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* GPEs are not required by ACPI, this is OK */</span>

		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INIT</span><span class="p">,</span>
				  <span class="s">&quot;There are no GPE blocks defined in the FADT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AE_OK</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for Max GPE number out-of-range */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gpe_number_max</span> <span class="o">&gt;</span> <span class="n">ACPI_GPE_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			    <span class="s">&quot;Maximum GPE number from FADT is too large: 0x%X&quot;</span><span class="p">,</span>
			    <span class="n">gpe_number_max</span><span class="p">));</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">AE_BAD_VALUE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

      <span class="nl">cleanup:</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">acpi_ut_release_mutex</span><span class="p">(</span><span class="n">ACPI_MTX_NAMESPACE</span><span class="p">);</span>
	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ev_update_gpes</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  table_owner_id      - ID of the newly-loaded ACPI table</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Check for new GPE methods (_Lxx/_Exx) made available as a</span>
<span class="cm"> *              result of a Load() or load_table() operation. If new GPE</span>
<span class="cm"> *              methods have been installed, register the new methods.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span> <span class="n">acpi_ev_update_gpes</span><span class="p">(</span><span class="n">acpi_owner_id</span> <span class="n">table_owner_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_gpe_xrupt_info</span> <span class="o">*</span><span class="n">gpe_xrupt_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_gpe_block_info</span> <span class="o">*</span><span class="n">gpe_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_gpe_walk_info</span> <span class="n">walk_info</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">AE_OK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find any _Lxx/_Exx GPE methods that have just been loaded.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Any GPEs that correspond to new _Lxx/_Exx methods are immediately</span>
<span class="cm">	 * enabled.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Examine the namespace underneath each gpe_device within the</span>
<span class="cm">	 * gpe_block lists.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_ut_acquire_mutex</span><span class="p">(</span><span class="n">ACPI_MTX_EVENTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">walk_info</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">walk_info</span><span class="p">.</span><span class="n">owner_id</span> <span class="o">=</span> <span class="n">table_owner_id</span><span class="p">;</span>
	<span class="n">walk_info</span><span class="p">.</span><span class="n">execute_by_owner_id</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="cm">/* Walk the interrupt level descriptor list */</span>

	<span class="n">gpe_xrupt_info</span> <span class="o">=</span> <span class="n">acpi_gbl_gpe_xrupt_list_head</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">gpe_xrupt_info</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Walk all Gpe Blocks attached to this interrupt level */</span>

		<span class="n">gpe_block</span> <span class="o">=</span> <span class="n">gpe_xrupt_info</span><span class="o">-&gt;</span><span class="n">gpe_block_list_head</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">gpe_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">walk_info</span><span class="p">.</span><span class="n">gpe_block</span> <span class="o">=</span> <span class="n">gpe_block</span><span class="p">;</span>
			<span class="n">walk_info</span><span class="p">.</span><span class="n">gpe_device</span> <span class="o">=</span> <span class="n">gpe_block</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_ns_walk_namespace</span><span class="p">(</span><span class="n">ACPI_TYPE_METHOD</span><span class="p">,</span>
							<span class="n">walk_info</span><span class="p">.</span><span class="n">gpe_device</span><span class="p">,</span>
							<span class="n">ACPI_UINT32_MAX</span><span class="p">,</span>
							<span class="n">ACPI_NS_WALK_NO_UNLOCK</span><span class="p">,</span>
							<span class="n">acpi_ev_match_gpe_method</span><span class="p">,</span>
							<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">walk_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ACPI_EXCEPTION</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
						<span class="s">&quot;While decoding _Lxx/_Exx methods&quot;</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="n">gpe_block</span> <span class="o">=</span> <span class="n">gpe_block</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">gpe_xrupt_info</span> <span class="o">=</span> <span class="n">gpe_xrupt_info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">walk_info</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_INFO</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="s">&quot;Enabled %u new GPEs&quot;</span><span class="p">,</span> <span class="n">walk_info</span><span class="p">.</span><span class="n">count</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">acpi_ut_release_mutex</span><span class="p">(</span><span class="n">ACPI_MTX_EVENTS</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_ev_match_gpe_method</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Callback from walk_namespace</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Called from acpi_walk_namespace. Expects each object to be a</span>
<span class="cm"> *              control method under the _GPE portion of the namespace.</span>
<span class="cm"> *              Extract the name and GPE type from the object, saving this</span>
<span class="cm"> *              information for quick lookup during GPE dispatch. Allows a</span>
<span class="cm"> *              per-owner_id evaluation if execute_by_owner_id is TRUE in the</span>
<span class="cm"> *              walk_info parameter block.</span>
<span class="cm"> *</span>
<span class="cm"> *              The name of each GPE control method is of the form:</span>
<span class="cm"> *              &quot;_Lxx&quot; or &quot;_Exx&quot;, where:</span>
<span class="cm"> *                  L      - means that the GPE is level triggered</span>
<span class="cm"> *                  E      - means that the GPE is edge triggered</span>
<span class="cm"> *                  xx     - is the GPE number [in HEX]</span>
<span class="cm"> *</span>
<span class="cm"> * If walk_info-&gt;execute_by_owner_id is TRUE, we only execute examine GPE methods</span>
<span class="cm"> * with that owner.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span>
<span class="n">acpi_ev_match_gpe_method</span><span class="p">(</span><span class="n">acpi_handle</span> <span class="n">obj_handle</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">level</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">return_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_namespace_node</span> <span class="o">*</span><span class="n">method_node</span> <span class="o">=</span>
	    <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_namespace_node</span><span class="p">,</span> <span class="n">obj_handle</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">acpi_gpe_walk_info</span> <span class="o">*</span><span class="n">walk_info</span> <span class="o">=</span>
	    <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_gpe_walk_info</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">acpi_gpe_event_info</span> <span class="o">*</span><span class="n">gpe_event_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">gpe_number</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">ACPI_NAME_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE</span><span class="p">(</span><span class="n">ev_match_gpe_method</span><span class="p">);</span>

	<span class="cm">/* Check if requested owner_id matches this owner_id */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">walk_info</span><span class="o">-&gt;</span><span class="n">execute_by_owner_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">method_node</span><span class="o">-&gt;</span><span class="n">owner_id</span> <span class="o">!=</span> <span class="n">walk_info</span><span class="o">-&gt;</span><span class="n">owner_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Match and decode the _Lxx and _Exx GPE method names</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) Extract the method name and null terminate it</span>
<span class="cm">	 */</span>
	<span class="n">ACPI_MOVE_32_TO_32</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">method_node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">integer</span><span class="p">);</span>
	<span class="n">name</span><span class="p">[</span><span class="n">ACPI_NAME_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* 2) Name must begin with an underscore */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>	<span class="cm">/* Ignore this method */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * 3) Edge/Level determination is based on the 2nd character</span>
<span class="cm">	 *    of the method name</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;L&#39;</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">ACPI_GPE_LEVEL_TRIGGERED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="sc">&#39;E&#39;</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">ACPI_GPE_EDGE_TRIGGERED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* Unknown method type, just ignore it */</span>

		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_LOAD</span><span class="p">,</span>
				  <span class="s">&quot;Ignoring unknown GPE method type: %s &quot;</span>
				  <span class="s">&quot;(name not of form _Lxx or _Exx)&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* 4) The last two characters of the name are the hex GPE Number */</span>

	<span class="n">gpe_number</span> <span class="o">=</span> <span class="n">ACPI_STRTOUL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpe_number</span> <span class="o">==</span> <span class="n">ACPI_UINT32_MAX</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Conversion failed; invalid method, just ignore it */</span>

		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_LOAD</span><span class="p">,</span>
				  <span class="s">&quot;Could not extract GPE number from name: %s &quot;</span>
				  <span class="s">&quot;(name is not of form _Lxx or _Exx)&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Ensure that we have a valid GPE number for this GPE block */</span>

	<span class="n">gpe_event_info</span> <span class="o">=</span>
	    <span class="n">acpi_ev_low_get_gpe_info</span><span class="p">(</span><span class="n">gpe_number</span><span class="p">,</span> <span class="n">walk_info</span><span class="o">-&gt;</span><span class="n">gpe_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpe_event_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This gpe_number is not valid for this GPE block, just ignore it.</span>
<span class="cm">		 * However, it may be valid for a different GPE block, since GPE0</span>
<span class="cm">		 * and GPE1 methods both appear under \_GPE.</span>
<span class="cm">		 */</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">gpe_event_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_GPE_DISPATCH_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">ACPI_GPE_DISPATCH_HANDLER</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* If there is already a handler, ignore this GPE method */</span>

		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">gpe_event_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_GPE_DISPATCH_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">ACPI_GPE_DISPATCH_METHOD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there is already a method, ignore this method. But check</span>
<span class="cm">		 * for a type mismatch (if both the _Lxx AND _Exx exist)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="p">(</span><span class="n">gpe_event_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_GPE_XRUPT_TYPE_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
				    <span class="s">&quot;For GPE 0x%.2X, found both _L%2.2X and _E%2.2X methods&quot;</span><span class="p">,</span>
				    <span class="n">gpe_number</span><span class="p">,</span> <span class="n">gpe_number</span><span class="p">,</span> <span class="n">gpe_number</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Disable the GPE in case it&#39;s been enabled already. */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">acpi_hw_low_set_gpe</span><span class="p">(</span><span class="n">gpe_event_info</span><span class="p">,</span> <span class="n">ACPI_GPE_DISABLE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add the GPE information from above to the gpe_event_info block for</span>
<span class="cm">	 * use during dispatch of this GPE.</span>
<span class="cm">	 */</span>
	<span class="n">gpe_event_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ACPI_GPE_DISPATCH_MASK</span><span class="p">);</span>
	<span class="n">gpe_event_info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">type</span> <span class="o">|</span> <span class="n">ACPI_GPE_DISPATCH_METHOD</span><span class="p">);</span>
	<span class="n">gpe_event_info</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">.</span><span class="n">method_node</span> <span class="o">=</span> <span class="n">method_node</span><span class="p">;</span>

	<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_LOAD</span><span class="p">,</span>
			  <span class="s">&quot;Registered GPE method %s as GPE number 0x%.2X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">name</span><span class="p">,</span> <span class="n">gpe_number</span><span class="p">));</span>
	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* !ACPI_REDUCED_HARDWARE */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
