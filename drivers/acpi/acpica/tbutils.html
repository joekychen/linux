<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › acpi › acpica › tbutils.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>tbutils.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Module Name: tbutils   - table utilities</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2000 - 2012, Intel Corp.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions, and the following disclaimer,</span>
<span class="cm"> *    without modification.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</span>
<span class="cm"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</span>
<span class="cm"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</span>
<span class="cm"> *    including a substantially similar Disclaimer requirement for further</span>
<span class="cm"> *    binary redistribution.</span>
<span class="cm"> * 3. Neither the names of the above-listed copyright holders nor the names</span>
<span class="cm"> *    of any contributors may be used to endorse or promote products derived</span>
<span class="cm"> *    from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="cm"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGES.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;acpi/acpi.h&gt;</span>
<span class="cp">#include &quot;accommon.h&quot;</span>
<span class="cp">#include &quot;actables.h&quot;</span>

<span class="cp">#define _COMPONENT          ACPI_TABLES</span>
<span class="n">ACPI_MODULE_NAME</span><span class="p">(</span><span class="s">&quot;tbutils&quot;</span><span class="p">)</span>

<span class="cm">/* Local prototypes */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">acpi_tb_fix_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="n">acpi_size</span> <span class="n">length</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">acpi_tb_cleanup_table_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">out_header</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">header</span><span class="p">);</span>

<span class="k">static</span> <span class="n">acpi_physical_address</span>
<span class="n">acpi_tb_get_root_table_entry</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">table_entry</span><span class="p">,</span> <span class="n">u32</span> <span class="n">table_entry_size</span><span class="p">);</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_check_xsdt</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  address                    - Pointer to the XSDT</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      status</span>
<span class="cm"> *		AE_OK - XSDT is okay</span>
<span class="cm"> *		AE_NO_MEMORY - can&#39;t map XSDT</span>
<span class="cm"> *		AE_INVALID_TABLE_LENGTH - invalid table length</span>
<span class="cm"> *		AE_NULL_ENTRY - XSDT has NULL entry</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: validate XSDT</span>
<span class="cm">******************************************************************************/</span>

<span class="k">static</span> <span class="n">acpi_status</span>
<span class="nf">acpi_tb_check_xsdt</span><span class="p">(</span><span class="n">acpi_physical_address</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">xsdt_entry_address</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">table_entry</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">table_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">table</span> <span class="o">=</span> <span class="n">acpi_os_map_memory</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AE_NO_MEMORY</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="n">acpi_os_unmap_memory</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">AE_INVALID_TABLE_LENGTH</span><span class="p">;</span>

	<span class="n">table</span> <span class="o">=</span> <span class="n">acpi_os_map_memory</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AE_NO_MEMORY</span><span class="p">;</span>

	<span class="cm">/* Calculate the number of tables described in XSDT */</span>
	<span class="n">table_count</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">((</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
	<span class="n">table_entry</span> <span class="o">=</span>
		<span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_MOVE_64_TO_64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xsdt_entry_address</span><span class="p">,</span> <span class="n">table_entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xsdt_entry_address</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* XSDT has NULL entry */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">table_entry</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">acpi_os_unmap_memory</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">AE_NULL_ENTRY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if (!ACPI_REDUCED_HARDWARE)</span>
<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_initialize_facs</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  None</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Create a permanent mapping for the FADT and save it in a global</span>
<span class="cm"> *              for accessing the Global Lock and Firmware Waking Vector</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span> <span class="nf">acpi_tb_initialize_facs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* If Hardware Reduced flag is set, there is no FACS */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_reduced_hardware</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_gbl_FACS</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_get_table_by_index</span><span class="p">(</span><span class="n">ACPI_TABLE_INDEX_FACS</span><span class="p">,</span>
					 <span class="n">ACPI_CAST_INDIRECT_PTR</span><span class="p">(</span><span class="k">struct</span>
								<span class="n">acpi_table_header</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">acpi_gbl_FACS</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* !ACPI_REDUCED_HARDWARE */</span><span class="cp"></span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_tables_loaded</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  None</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      TRUE if required ACPI tables are loaded</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Determine if the minimum required ACPI tables are present</span>
<span class="cm"> *              (FADT, FACS, DSDT)</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u8</span> <span class="nf">acpi_tb_tables_loaded</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">current_table_count</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_fix_string</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  String              - String to be repaired</span>
<span class="cm"> *              Length              - Maximum length</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Replace every non-printable or non-ascii byte in the string</span>
<span class="cm"> *              with a question mark &#39;?&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">acpi_tb_fix_string</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="n">acpi_size</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ACPI_IS_PRINT</span><span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="sc">&#39;?&#39;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">string</span><span class="o">++</span><span class="p">;</span>
		<span class="n">length</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_cleanup_table_header</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  out_header          - Where the cleaned header is returned</span>
<span class="cm"> *              Header              - Input ACPI table header</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Returns the cleaned header in out_header</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Copy the table header and ensure that all &quot;string&quot; fields in</span>
<span class="cm"> *              the header consist of printable characters.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">acpi_tb_cleanup_table_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">out_header</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">header</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ACPI_MEMCPY</span><span class="p">(</span><span class="n">out_header</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">));</span>

	<span class="n">acpi_tb_fix_string</span><span class="p">(</span><span class="n">out_header</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_NAME_SIZE</span><span class="p">);</span>
	<span class="n">acpi_tb_fix_string</span><span class="p">(</span><span class="n">out_header</span><span class="o">-&gt;</span><span class="n">oem_id</span><span class="p">,</span> <span class="n">ACPI_OEM_ID_SIZE</span><span class="p">);</span>
	<span class="n">acpi_tb_fix_string</span><span class="p">(</span><span class="n">out_header</span><span class="o">-&gt;</span><span class="n">oem_table_id</span><span class="p">,</span> <span class="n">ACPI_OEM_TABLE_ID_SIZE</span><span class="p">);</span>
	<span class="n">acpi_tb_fix_string</span><span class="p">(</span><span class="n">out_header</span><span class="o">-&gt;</span><span class="n">asl_compiler_id</span><span class="p">,</span> <span class="n">ACPI_NAME_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_print_table_header</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Address             - Table physical address</span>
<span class="cm"> *              Header              - Table header</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Print an ACPI table header. Special cases for FACS and RSDP.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span>
<span class="nf">acpi_tb_print_table_header</span><span class="p">(</span><span class="n">acpi_physical_address</span> <span class="n">address</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">header</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="n">local_header</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The reason that the Address is cast to a void pointer is so that we</span>
<span class="cm">	 * can use %p which will work properly on both 32-bit and 64-bit hosts.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_COMPARE_NAME</span><span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_SIG_FACS</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* FACS only has signature and length fields */</span>

		<span class="n">ACPI_INFO</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="s">&quot;%4.4s %p %05X&quot;</span><span class="p">,</span>
			   <span class="n">header</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span>
			   <span class="n">header</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ACPI_COMPARE_NAME</span><span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_SIG_RSDP</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* RSDP has no common fields */</span>

		<span class="n">ACPI_MEMCPY</span><span class="p">(</span><span class="n">local_header</span><span class="p">.</span><span class="n">oem_id</span><span class="p">,</span>
			    <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_rsdp</span><span class="p">,</span>
					  <span class="n">header</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">oem_id</span><span class="p">,</span> <span class="n">ACPI_OEM_ID_SIZE</span><span class="p">);</span>
		<span class="n">acpi_tb_fix_string</span><span class="p">(</span><span class="n">local_header</span><span class="p">.</span><span class="n">oem_id</span><span class="p">,</span> <span class="n">ACPI_OEM_ID_SIZE</span><span class="p">);</span>

		<span class="n">ACPI_INFO</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="s">&quot;RSDP %p %05X (v%.2d %6.6s)&quot;</span><span class="p">,</span>
			   <span class="n">ACPI_CAST_PTR</span> <span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span>
			   <span class="p">(</span><span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_rsdp</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span><span class="o">-&gt;</span>
			    <span class="n">revision</span> <span class="o">&gt;</span>
			    <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_rsdp</span><span class="p">,</span>
					       <span class="n">header</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">:</span> <span class="mi">20</span><span class="p">,</span>
			   <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_rsdp</span><span class="p">,</span>
					 <span class="n">header</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">,</span>
			   <span class="n">local_header</span><span class="p">.</span><span class="n">oem_id</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Standard ACPI table with full common header */</span>

		<span class="n">acpi_tb_cleanup_table_header</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local_header</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>

		<span class="n">ACPI_INFO</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			   <span class="s">&quot;%4.4s %p %05X (v%.2d %6.6s %8.8s %08X %4.4s %08X)&quot;</span><span class="p">,</span>
			   <span class="n">local_header</span><span class="p">.</span><span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span>
			   <span class="n">local_header</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">local_header</span><span class="p">.</span><span class="n">revision</span><span class="p">,</span>
			   <span class="n">local_header</span><span class="p">.</span><span class="n">oem_id</span><span class="p">,</span> <span class="n">local_header</span><span class="p">.</span><span class="n">oem_table_id</span><span class="p">,</span>
			   <span class="n">local_header</span><span class="p">.</span><span class="n">oem_revision</span><span class="p">,</span>
			   <span class="n">local_header</span><span class="p">.</span><span class="n">asl_compiler_id</span><span class="p">,</span>
			   <span class="n">local_header</span><span class="p">.</span><span class="n">asl_compiler_revision</span><span class="p">));</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_validate_checksum</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Table               - ACPI table to verify</span>
<span class="cm"> *              Length              - Length of entire table</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Verifies that the table checksums to zero. Optionally returns</span>
<span class="cm"> *              exception on bad checksum.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span> <span class="nf">acpi_tb_verify_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">checksum</span><span class="p">;</span>

	<span class="cm">/* Compute the checksum on the table */</span>

	<span class="n">checksum</span> <span class="o">=</span> <span class="n">acpi_tb_checksum</span><span class="p">(</span><span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">table</span><span class="p">),</span> <span class="n">length</span><span class="p">);</span>

	<span class="cm">/* Checksum ok? (should be zero) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_WARNING</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			      <span class="s">&quot;Incorrect checksum in table [%4.4s] - 0x%2.2X, should be 0x%2.2X&quot;</span><span class="p">,</span>
			      <span class="n">table</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">-</span> <span class="n">checksum</span><span class="p">)));</span>

<span class="cp">#if (ACPI_CHECKSUM_ABORT)</span>

		<span class="k">return</span> <span class="p">(</span><span class="n">AE_BAD_CHECKSUM</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_checksum</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Buffer          - Pointer to memory region to be checked</span>
<span class="cm"> *              Length          - Length of this memory region</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Checksum (u8)</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Calculates circular checksum of memory region.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">u8</span> <span class="nf">acpi_tb_checksum</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="n">buffer</span><span class="o">++</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_check_dsdt_header</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  None</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Quick compare to check validity of the DSDT. This will detect</span>
<span class="cm"> *              if the DSDT has been replaced from outside the OS and/or if</span>
<span class="cm"> *              the DSDT header has been corrupted.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span> <span class="nf">acpi_tb_check_dsdt_header</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/* Compare original length and checksum to current values */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_original_dsdt_header</span><span class="p">.</span><span class="n">length</span> <span class="o">!=</span> <span class="n">acpi_gbl_DSDT</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">||</span>
	    <span class="n">acpi_gbl_original_dsdt_header</span><span class="p">.</span><span class="n">checksum</span> <span class="o">!=</span> <span class="n">acpi_gbl_DSDT</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			    <span class="s">&quot;The DSDT has been corrupted or replaced - old, new headers below&quot;</span><span class="p">));</span>
		<span class="n">acpi_tb_print_table_header</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">acpi_gbl_original_dsdt_header</span><span class="p">);</span>
		<span class="n">acpi_tb_print_table_header</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">acpi_gbl_DSDT</span><span class="p">);</span>

		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			    <span class="s">&quot;Please send DMI info to linux-acpi@vger.kernel.org</span><span class="se">\n</span><span class="s">&quot;</span>
			    <span class="s">&quot;If system does not work as expected, please boot with acpi=copy_dsdt&quot;</span><span class="p">));</span>

		<span class="cm">/* Disable further error messages */</span>

		<span class="n">acpi_gbl_original_dsdt_header</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">acpi_gbl_DSDT</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">acpi_gbl_original_dsdt_header</span><span class="p">.</span><span class="n">checksum</span> <span class="o">=</span>
		    <span class="n">acpi_gbl_DSDT</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_copy_dsdt</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  table_desc          - Installed table to copy</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Implements a subsystem option to copy the DSDT to local memory.</span>
<span class="cm"> *              Some very bad BIOSs are known to either corrupt the DSDT or</span>
<span class="cm"> *              install a new, bad DSDT. This copy works around the problem.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="nf">acpi_tb_copy_dsdt</span><span class="p">(</span><span class="n">u32</span> <span class="n">table_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">new_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_table_desc</span> <span class="o">*</span><span class="n">table_desc</span><span class="p">;</span>

	<span class="n">table_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">tables</span><span class="p">[</span><span class="n">table_index</span><span class="p">];</span>

	<span class="n">new_table</span> <span class="o">=</span> <span class="n">ACPI_ALLOCATE</span><span class="p">(</span><span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="s">&quot;Could not copy DSDT of length 0x%X&quot;</span><span class="p">,</span>
			    <span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ACPI_MEMCPY</span><span class="p">(</span><span class="n">new_table</span><span class="p">,</span> <span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">acpi_tb_delete_table</span><span class="p">(</span><span class="n">table_desc</span><span class="p">);</span>
	<span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">new_table</span><span class="p">;</span>
	<span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ACPI_TABLE_ORIGIN_ALLOCATED</span><span class="p">;</span>

	<span class="n">ACPI_INFO</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
		   <span class="s">&quot;Forced DSDT copy: length 0x%05X copied locally, original unmapped&quot;</span><span class="p">,</span>
		   <span class="n">new_table</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">));</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">new_table</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_install_table</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Address                 - Physical address of DSDT or FACS</span>
<span class="cm"> *              Signature               - Table signature, NULL if no need to</span>
<span class="cm"> *                                        match</span>
<span class="cm"> *              table_index             - Index into root table array</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      None</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Install an ACPI table into the global data structure. The</span>
<span class="cm"> *              table override mechanism is called to allow the host</span>
<span class="cm"> *              OS to replace any table before it is installed in the root</span>
<span class="cm"> *              table array.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="kt">void</span>
<span class="nf">acpi_tb_install_table</span><span class="p">(</span><span class="n">acpi_physical_address</span> <span class="n">address</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span><span class="n">signature</span><span class="p">,</span> <span class="n">u32</span> <span class="n">table_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">final_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_table_desc</span> <span class="o">*</span><span class="n">table_desc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">address</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			    <span class="s">&quot;Null physical address for ACPI table [%s]&quot;</span><span class="p">,</span>
			    <span class="n">signature</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Map just the table header */</span>

	<span class="n">table</span> <span class="o">=</span> <span class="n">acpi_os_map_memory</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			    <span class="s">&quot;Could not map memory for table [%s] at %p&quot;</span><span class="p">,</span>
			    <span class="n">signature</span><span class="p">,</span> <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">address</span><span class="p">)));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If a particular signature is expected (DSDT/FACS), it must match */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">signature</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ACPI_COMPARE_NAME</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">signature</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
			    <span class="s">&quot;Invalid signature 0x%X for ACPI table, expected [%s]&quot;</span><span class="p">,</span>
			    <span class="o">*</span><span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">),</span> <span class="n">signature</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">unmap_and_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the table entry. Set the pointer to NULL, since the</span>
<span class="cm">	 * table is not fully mapped at this time.</span>
<span class="cm">	 */</span>
	<span class="n">table_desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">tables</span><span class="p">[</span><span class="n">table_index</span><span class="p">];</span>

	<span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">pointer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ACPI_TABLE_ORIGIN_MAPPED</span><span class="p">;</span>
	<span class="n">ACPI_MOVE_32_TO_32</span><span class="p">(</span><span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">.</span><span class="n">ascii</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ACPI Table Override:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Before we install the table, let the host OS override it with a new</span>
<span class="cm">	 * one if desired. Any table within the RSDT/XSDT can be replaced,</span>
<span class="cm">	 * including the DSDT which is pointed to by the FADT.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: If the table is overridden, then final_table will contain a</span>
<span class="cm">	 * mapped pointer to the full new table. If the table is not overridden,</span>
<span class="cm">	 * or if there has been a physical override, then the table will be</span>
<span class="cm">	 * fully mapped later (in verify table). In any case, we must</span>
<span class="cm">	 * unmap the header that was mapped above.</span>
<span class="cm">	 */</span>
	<span class="n">final_table</span> <span class="o">=</span> <span class="n">acpi_tb_table_override</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">table_desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">final_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">final_table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>	<span class="cm">/* There was no override */</span>
	<span class="p">}</span>

	<span class="n">acpi_tb_print_table_header</span><span class="p">(</span><span class="n">table_desc</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">final_table</span><span class="p">);</span>

	<span class="cm">/* Set the global integer width (based upon revision of the DSDT) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">table_index</span> <span class="o">==</span> <span class="n">ACPI_TABLE_INDEX_DSDT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_ut_set_integer_width</span><span class="p">(</span><span class="n">final_table</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have a physical override during this early loading of the ACPI</span>
<span class="cm">	 * tables, unmap the table for now. It will be mapped again later when</span>
<span class="cm">	 * it is actually used. This supports very early loading of ACPI tables,</span>
<span class="cm">	 * before virtual memory is fully initialized and running within the</span>
<span class="cm">	 * host OS. Note: A logical override has the ACPI_TABLE_ORIGIN_OVERRIDE</span>
<span class="cm">	 * flag set and will not be deleted below.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">final_table</span> <span class="o">!=</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_tb_delete_table</span><span class="p">(</span><span class="n">table_desc</span><span class="p">);</span>
	<span class="p">}</span>

      <span class="nl">unmap_and_exit:</span>

	<span class="cm">/* Always unmap the table header that we mapped above */</span>

	<span class="n">acpi_os_unmap_memory</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_get_root_table_entry</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  table_entry         - Pointer to the RSDT/XSDT table entry</span>
<span class="cm"> *              table_entry_size    - sizeof 32 or 64 (RSDT or XSDT)</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Physical address extracted from the root table</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: Get one root table entry. Handles 32-bit and 64-bit cases on</span>
<span class="cm"> *              both 32-bit and 64-bit platforms</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:        acpi_physical_address is 32-bit on 32-bit platforms, 64-bit on</span>
<span class="cm"> *              64-bit platforms.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="k">static</span> <span class="n">acpi_physical_address</span>
<span class="nf">acpi_tb_get_root_table_entry</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">table_entry</span><span class="p">,</span> <span class="n">u32</span> <span class="n">table_entry_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">address64</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the table physical address (32-bit for RSDT, 64-bit for XSDT):</span>
<span class="cm">	 * Note: Addresses are 32-bit aligned (not 64) in both RSDT and XSDT</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">table_entry_size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 32-bit platform, RSDT: Return 32-bit table entry</span>
<span class="cm">		 * 64-bit platform, RSDT: Expand 32-bit to 64-bit and return</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">acpi_physical_address</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">table_entry</span><span class="p">)));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 32-bit platform, XSDT: Truncate 64-bit to 32-bit and return</span>
<span class="cm">		 * 64-bit platform, XSDT: Move (unaligned) 64-bit to local,</span>
<span class="cm">		 *  return 64-bit</span>
<span class="cm">		 */</span>
		<span class="n">ACPI_MOVE_64_TO_64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address64</span><span class="p">,</span> <span class="n">table_entry</span><span class="p">);</span>

<span class="cp">#if ACPI_MACHINE_WIDTH == 32</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address64</span> <span class="o">&gt;</span> <span class="n">ACPI_UINT32_MAX</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Will truncate 64-bit address to 32 bits, issue warning */</span>

			<span class="n">ACPI_WARNING</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
				      <span class="s">&quot;64-bit Physical Address in XSDT is too large (0x%8.8X%8.8X),&quot;</span>
				      <span class="s">&quot; truncating&quot;</span><span class="p">,</span>
				      <span class="n">ACPI_FORMAT_UINT64</span><span class="p">(</span><span class="n">address64</span><span class="p">)));</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">acpi_physical_address</span><span class="p">)</span> <span class="p">(</span><span class="n">address64</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * FUNCTION:    acpi_tb_parse_root_table</span>
<span class="cm"> *</span>
<span class="cm"> * PARAMETERS:  Rsdp                    - Pointer to the RSDP</span>
<span class="cm"> *</span>
<span class="cm"> * RETURN:      Status</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION: This function is called to parse the Root System Description</span>
<span class="cm"> *              Table (RSDT or XSDT)</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:        Tables are mapped (not copied) for efficiency. The FACS must</span>
<span class="cm"> *              be mapped and cannot be copied because it contains the actual</span>
<span class="cm"> *              memory location of the ACPI Global Lock.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="n">acpi_status</span> <span class="n">__init</span>
<span class="nf">acpi_tb_parse_root_table</span><span class="p">(</span><span class="n">acpi_physical_address</span> <span class="n">rsdp_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_table_rsdp</span> <span class="o">*</span><span class="n">rsdp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">table_entry_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">table_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_table_header</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
	<span class="n">acpi_physical_address</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">acpi_physical_address</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">rsdt_address</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">table_entry</span><span class="p">;</span>
	<span class="n">acpi_status</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">ACPI_FUNCTION_TRACE</span><span class="p">(</span><span class="n">tb_parse_root_table</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map the entire RSDP and extract the address of the RSDT or XSDT</span>
<span class="cm">	 */</span>
	<span class="n">rsdp</span> <span class="o">=</span> <span class="n">acpi_os_map_memory</span><span class="p">(</span><span class="n">rsdp_address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_rsdp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsdp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_NO_MEMORY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">acpi_tb_print_table_header</span><span class="p">(</span><span class="n">rsdp_address</span><span class="p">,</span>
				   <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">,</span>
						 <span class="n">rsdp</span><span class="p">));</span>

	<span class="cm">/* Differentiate between RSDT and XSDT root tables */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rsdp</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">rsdp</span><span class="o">-&gt;</span><span class="n">xsdt_physical_address</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">acpi_rsdt_forced</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Root table is an XSDT (64-bit physical addresses). We must use the</span>
<span class="cm">		 * XSDT if the revision is &gt; 1 and the XSDT pointer is present, as per</span>
<span class="cm">		 * the ACPI specification.</span>
<span class="cm">		 */</span>
		<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">acpi_physical_address</span><span class="p">)</span> <span class="n">rsdp</span><span class="o">-&gt;</span><span class="n">xsdt_physical_address</span><span class="p">;</span>
		<span class="n">table_entry_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
		<span class="n">rsdt_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">acpi_physical_address</span><span class="p">)</span>
					<span class="n">rsdp</span><span class="o">-&gt;</span><span class="n">rsdt_physical_address</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Root table is an RSDT (32-bit physical addresses) */</span>

		<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="n">acpi_physical_address</span><span class="p">)</span> <span class="n">rsdp</span><span class="o">-&gt;</span><span class="n">rsdt_physical_address</span><span class="p">;</span>
		<span class="n">table_entry_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is not possible to map more than one entry in some environments,</span>
<span class="cm">	 * so unmap the RSDP here before mapping other tables</span>
<span class="cm">	 */</span>
	<span class="n">acpi_os_unmap_memory</span><span class="p">(</span><span class="n">rsdp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_rsdp</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">table_entry_size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acpi_tb_check_xsdt</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="o">==</span> <span class="n">AE_NULL_ENTRY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* XSDT has NULL entry, RSDT is used */</span>
			<span class="n">address</span> <span class="o">=</span> <span class="n">rsdt_address</span><span class="p">;</span>
			<span class="n">table_entry_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
			<span class="n">ACPI_WARNING</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="s">&quot;BIOS XSDT has NULL entry, &quot;</span>
					<span class="s">&quot;using RSDT&quot;</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Map the RSDT/XSDT table header to get the full table length */</span>

	<span class="n">table</span> <span class="o">=</span> <span class="n">acpi_os_map_memory</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_NO_MEMORY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">acpi_tb_print_table_header</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>

	<span class="cm">/* Get the length of the full table, verify length and map entire table */</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="n">acpi_os_unmap_memory</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ACPI_ERROR</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="s">&quot;Invalid length 0x%X in RSDT/XSDT&quot;</span><span class="p">,</span>
			    <span class="n">length</span><span class="p">));</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_INVALID_TABLE_LENGTH</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">table</span> <span class="o">=</span> <span class="n">acpi_os_map_memory</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_NO_MEMORY</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Validate the root table checksum */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_tb_verify_checksum</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">acpi_os_unmap_memory</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
		<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate the number of tables described in the root table */</span>

	<span class="n">table_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)((</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">))</span> <span class="o">/</span>
			    <span class="n">table_entry_size</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * First two entries in the table array are reserved for the DSDT</span>
<span class="cm">	 * and FACS, which are not actually present in the RSDT/XSDT - they</span>
<span class="cm">	 * come from the FADT</span>
<span class="cm">	 */</span>
	<span class="n">table_entry</span> <span class="o">=</span>
	    <span class="n">ACPI_CAST_PTR</span><span class="p">(</span><span class="n">u8</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_table_header</span><span class="p">);</span>
	<span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">current_table_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the root table array from the RSDT/XSDT</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">current_table_count</span> <span class="o">&gt;=</span>
		    <span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">max_table_count</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* There is no more room in the root table array, attempt resize */</span>

			<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_tb_resize_root_table_list</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ACPI_WARNING</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span>
					      <span class="s">&quot;Truncating %u table entries!&quot;</span><span class="p">,</span>
					      <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="p">(</span><span class="n">table_count</span> <span class="o">-</span>
					       <span class="p">(</span><span class="n">acpi_gbl_root_table_list</span><span class="p">.</span>
							  <span class="n">current_table_count</span> <span class="o">-</span>
							  <span class="mi">2</span><span class="p">))));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Get the table physical address (32-bit for RSDT, 64-bit for XSDT) */</span>

		<span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">tables</span><span class="p">[</span><span class="n">acpi_gbl_root_table_list</span><span class="p">.</span>
						<span class="n">current_table_count</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span>
		    <span class="n">acpi_tb_get_root_table_entry</span><span class="p">(</span><span class="n">table_entry</span><span class="p">,</span> <span class="n">table_entry_size</span><span class="p">);</span>

		<span class="n">table_entry</span> <span class="o">+=</span> <span class="n">table_entry_size</span><span class="p">;</span>
		<span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">current_table_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is not possible to map more than one entry in some environments,</span>
<span class="cm">	 * so unmap the root table here before mapping other tables</span>
<span class="cm">	 */</span>
	<span class="n">acpi_os_unmap_memory</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Complete the initialization of the root table array by examining</span>
<span class="cm">	 * the header of each table</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">current_table_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_tb_install_table</span><span class="p">(</span><span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span>
				      <span class="n">address</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* Special case for FADT - get the DSDT and FACS */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_COMPARE_NAME</span>
		    <span class="p">(</span><span class="o">&amp;</span><span class="n">acpi_gbl_root_table_list</span><span class="p">.</span><span class="n">tables</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">signature</span><span class="p">,</span>
		     <span class="n">ACPI_SIG_FADT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">acpi_tb_parse_fadt</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">return_ACPI_STATUS</span><span class="p">(</span><span class="n">AE_OK</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
