<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › acpi › processor_idle.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>processor_idle.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * processor_idle - idle state submodule to the ACPI processor driver</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2001, 2002 Andy Grover &lt;andrew.grover@intel.com&gt;</span>
<span class="cm"> *  Copyright (C) 2001, 2002 Paul Diefenbaugh &lt;paul.s.diefenbaugh@intel.com&gt;</span>
<span class="cm"> *  Copyright (C) 2004, 2005 Dominik Brodowski &lt;linux@brodo.de&gt;</span>
<span class="cm"> *  Copyright (C) 2004  Anil S Keshavamurthy &lt;anil.s.keshavamurthy@intel.com&gt;</span>
<span class="cm"> *  			- Added processor hotplug support</span>
<span class="cm"> *  Copyright (C) 2005  Venkatesh Pallipadi &lt;venkatesh.pallipadi@intel.com&gt;</span>
<span class="cm"> *  			- Added support for C3 on SMP</span>
<span class="cm"> *</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2 of the License, or (at</span>
<span class="cm"> *  your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> *  WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> *  General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License along</span>
<span class="cm"> *  with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/cpufreq.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;	</span><span class="cm">/* need_resched() */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/pm_qos.h&gt;</span>
<span class="cp">#include &lt;linux/clockchips.h&gt;</span>
<span class="cp">#include &lt;linux/cpuidle.h&gt;</span>
<span class="cp">#include &lt;linux/irqflags.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Include the apic definitions for x86 to have the APIC timer related defines</span>
<span class="cm"> * available also for UP (on SMP it gets magically included via linux/smp.h).</span>
<span class="cm"> * asm/acpi.h is not an option, as it would require more include magic. Also</span>
<span class="cm"> * creating an empty asm-ia64/apic.h would just trade pest vs. cholera.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_X86</span>
<span class="cp">#include &lt;asm/apic.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;acpi/acpi_bus.h&gt;</span>
<span class="cp">#include &lt;acpi/processor.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>

<span class="cp">#define PREFIX &quot;ACPI: &quot;</span>

<span class="cp">#define ACPI_PROCESSOR_CLASS            &quot;processor&quot;</span>
<span class="cp">#define _COMPONENT              ACPI_PROCESSOR_COMPONENT</span>
<span class="n">ACPI_MODULE_NAME</span><span class="p">(</span><span class="s">&quot;processor_idle&quot;</span><span class="p">);</span>
<span class="cp">#define PM_TIMER_TICK_NS		(1000000000ULL/PM_TIMER_FREQUENCY)</span>
<span class="cp">#define C2_OVERHEAD			1	</span><span class="cm">/* 1us */</span><span class="cp"></span>
<span class="cp">#define C3_OVERHEAD			1	</span><span class="cm">/* 1us */</span><span class="cp"></span>
<span class="cp">#define PM_TIMER_TICKS_TO_US(p)		(((p) * 1000)/(PM_TIMER_FREQUENCY/1000))</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cstate</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">ACPI_PROCESSOR_MAX_POWER</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_cstate</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0000</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nocst</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">nocst</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0000</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bm_check_disable</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">bm_check_disable</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0000</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">latency_factor</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">latency_factor</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">disabled_by_idle_boot_param</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">boot_option_idle_override</span> <span class="o">==</span> <span class="n">IDLE_POLL</span> <span class="o">||</span>
		<span class="n">boot_option_idle_override</span> <span class="o">==</span> <span class="n">IDLE_FORCE_MWAIT</span> <span class="o">||</span>
		<span class="n">boot_option_idle_override</span> <span class="o">==</span> <span class="n">IDLE_HALT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IBM ThinkPad R40e crashes mysteriously when going into C2 or C3.</span>
<span class="cm"> * For now disable this. Probably a bug somewhere else.</span>
<span class="cm"> *</span>
<span class="cm"> * To skip this limit, boot/load with a large max_cstate limit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_max_cstate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_cstate</span> <span class="o">&gt;</span> <span class="n">ACPI_PROCESSOR_MAX_POWER</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="n">PREFIX</span> <span class="s">&quot;%s detected - limiting to C%ld max_cstate.&quot;</span>
	       <span class="s">&quot; Override with </span><span class="se">\&quot;</span><span class="s">processor.max_cstate=%d</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">ident</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">,</span> <span class="n">ACPI_PROCESSOR_MAX_POWER</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">max_cstate</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Actually this shouldn&#39;t be __cpuinitdata, would be better to fix the</span>
<span class="cm">   callers to only run once -AK */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dmi_system_id</span> <span class="n">__cpuinitdata</span> <span class="n">processor_power_dmi_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">set_max_cstate</span><span class="p">,</span> <span class="s">&quot;Clevo 5600D&quot;</span><span class="p">,</span> <span class="p">{</span>
	  <span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VENDOR</span><span class="p">,</span><span class="s">&quot;Phoenix Technologies LTD&quot;</span><span class="p">),</span>
	  <span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_BIOS_VERSION</span><span class="p">,</span><span class="s">&quot;SHE845M0.86C.0013.D.0302131307&quot;</span><span class="p">)},</span>
	 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">2</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">set_max_cstate</span><span class="p">,</span> <span class="s">&quot;Pavilion zv5000&quot;</span><span class="p">,</span> <span class="p">{</span>
	  <span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;Hewlett-Packard&quot;</span><span class="p">),</span>
	  <span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span><span class="s">&quot;Pavilion zv5000 (DS502A#ABA)&quot;</span><span class="p">)},</span>
	 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">set_max_cstate</span><span class="p">,</span> <span class="s">&quot;Asus L8400B&quot;</span><span class="p">,</span> <span class="p">{</span>
	  <span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_SYS_VENDOR</span><span class="p">,</span> <span class="s">&quot;ASUSTeK Computer Inc.&quot;</span><span class="p">),</span>
	  <span class="n">DMI_MATCH</span><span class="p">(</span><span class="n">DMI_PRODUCT_NAME</span><span class="p">,</span><span class="s">&quot;L8400B series Notebook PC&quot;</span><span class="p">)},</span>
	 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">},</span>
	<span class="p">{},</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Callers should disable interrupts before the call and enable</span>
<span class="cm"> * interrupts after return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">acpi_safe_halt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TS_POLLING</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * TS_POLLING-cleared state must be visible before we</span>
<span class="cm">	 * test NEED_RESCHED:</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">safe_halt</span><span class="p">();</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef ARCH_APICTIMER_STOPS_ON_C3</span>

<span class="cm">/*</span>
<span class="cm"> * Some BIOS implementations switch to C3 in the published C2 state.</span>
<span class="cm"> * This seems to be a common problem on AMD boxen, but other vendors</span>
<span class="cm"> * are affected too. We pick the most conservative approach: we assume</span>
<span class="cm"> * that the local APIC stops in both C2 and C3.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_timer_check_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_processor_power</span> <span class="o">*</span><span class="n">pwr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span> <span class="o">=</span> <span class="n">local_apic_timer_c2_ok</span> <span class="o">?</span> <span class="n">ACPI_STATE_C3</span> <span class="o">:</span> <span class="n">ACPI_STATE_C2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_has</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_data</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span> <span class="n">X86_FEATURE_ARAT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">amd_e400_c1e_detected</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">ACPI_STATE_C1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check, if one of the previous states already marked the lapic</span>
<span class="cm">	 * unstable</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwr</span><span class="o">-&gt;</span><span class="n">timer_broadcast_on_state</span> <span class="o">&lt;</span> <span class="n">state</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">type</span><span class="p">)</span>
		<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">timer_broadcast_on_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__lapic_timer_propagate_broadcast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reason</span><span class="p">;</span>

	<span class="n">reason</span> <span class="o">=</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">timer_broadcast_on_state</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span> <span class="o">?</span>
		<span class="n">CLOCK_EVT_NOTIFY_BROADCAST_ON</span> <span class="o">:</span> <span class="n">CLOCK_EVT_NOTIFY_BROADCAST_OFF</span><span class="p">;</span>

	<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">reason</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_timer_propagate_broadcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">__lapic_timer_propagate_broadcast</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Power(C) State timer broadcast control */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_timer_state_broadcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">broadcast</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">cx</span> <span class="o">-</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">timer_broadcast_on_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reason</span><span class="p">;</span>

		<span class="n">reason</span> <span class="o">=</span> <span class="n">broadcast</span> <span class="o">?</span>  <span class="n">CLOCK_EVT_NOTIFY_BROADCAST_ENTER</span> <span class="o">:</span>
			<span class="n">CLOCK_EVT_NOTIFY_BROADCAST_EXIT</span><span class="p">;</span>
		<span class="n">clockevents_notify</span><span class="p">(</span><span class="n">reason</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_timer_check_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cstate</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_timer_propagate_broadcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lapic_timer_state_broadcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">broadcast</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Suspend / resume control</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">acpi_idle_suspend</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">saved_bm_rld</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">acpi_idle_bm_rld_save</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_read_bit_register</span><span class="p">(</span><span class="n">ACPI_BITREG_BUS_MASTER_RLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saved_bm_rld</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">acpi_idle_bm_rld_restore</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">resumed_bm_rld</span><span class="p">;</span>

	<span class="n">acpi_read_bit_register</span><span class="p">(</span><span class="n">ACPI_BITREG_BUS_MASTER_RLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resumed_bm_rld</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resumed_bm_rld</span> <span class="o">!=</span> <span class="n">saved_bm_rld</span><span class="p">)</span>
		<span class="n">acpi_write_bit_register</span><span class="p">(</span><span class="n">ACPI_BITREG_BUS_MASTER_RLD</span><span class="p">,</span> <span class="n">saved_bm_rld</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">acpi_processor_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_device</span> <span class="o">*</span> <span class="n">device</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_idle_suspend</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">acpi_idle_bm_rld_save</span><span class="p">();</span>
	<span class="n">acpi_idle_suspend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">acpi_processor_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_device</span> <span class="o">*</span> <span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_idle_suspend</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">acpi_idle_bm_rld_restore</span><span class="p">();</span>
	<span class="n">acpi_idle_suspend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_X86)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tsc_check_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">boot_cpu_data</span><span class="p">.</span><span class="n">x86_vendor</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">X86_VENDOR_AMD</span>:
	<span class="k">case</span> <span class="n">X86_VENDOR_INTEL</span>:
		<span class="cm">/*</span>
<span class="cm">		 * AMD Fam10h TSC will tick in all</span>
<span class="cm">		 * C/P/S0/S1 states when this bit is set.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boot_cpu_has</span><span class="p">(</span><span class="n">X86_FEATURE_NONSTOP_TSC</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="cm">/*FALL THROUGH*/</span>
	<span class="nl">default:</span>
		<span class="cm">/* TSC could halt in idle, so notify users */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;</span> <span class="n">ACPI_STATE_C1</span><span class="p">)</span>
			<span class="n">mark_tsc_unstable</span><span class="p">(</span><span class="s">&quot;TSC halts in idle&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tsc_check_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_processor_get_power_info_fadt</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">pblk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* if info is obtained from pblk/fadt, type equals state */</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C2</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">ACPI_STATE_C2</span><span class="p">;</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C3</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">ACPI_STATE_C3</span><span class="p">;</span>

<span class="cp">#ifndef CONFIG_HOTPLUG_CPU</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check for P_LVL2_UP flag before entering C2 and above on</span>
<span class="cm">	 * an SMP system.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_FADT_C2_MP_SUPPORTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* determine C2 and C3 address from pblk */</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C2</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">pblk</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C3</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">pblk</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>

	<span class="cm">/* determine latencies from FADT */</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C2</span><span class="p">].</span><span class="n">latency</span> <span class="o">=</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">C2latency</span><span class="p">;</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C3</span><span class="p">].</span><span class="n">latency</span> <span class="o">=</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">C3latency</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FADT specified C2 latency must be less than or equal to</span>
<span class="cm">	 * 100 microseconds.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">C2latency</span> <span class="o">&gt;</span> <span class="n">ACPI_PROCESSOR_MAX_C2_LATENCY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span>
			<span class="s">&quot;C2 latency too large [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">C2latency</span><span class="p">));</span>
		<span class="cm">/* invalidate C2 */</span>
		<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C2</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * FADT supplied C3 latency must be less than or equal to</span>
<span class="cm">	 * 1000 microseconds.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">C3latency</span> <span class="o">&gt;</span> <span class="n">ACPI_PROCESSOR_MAX_C3_LATENCY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span>
			<span class="s">&quot;C3 latency too large [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">C3latency</span><span class="p">));</span>
		<span class="cm">/* invalidate C3 */</span>
		<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C3</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span>
			  <span class="s">&quot;lvl2[0x%08x] lvl3[0x%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C2</span><span class="p">].</span><span class="n">address</span><span class="p">,</span>
			  <span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C3</span><span class="p">].</span><span class="n">address</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_processor_get_power_info_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C1</span><span class="p">].</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set the first C-State to C1 */</span>
		<span class="cm">/* all processors need to support C1 */</span>
		<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">ACPI_STATE_C1</span><span class="p">;</span>
		<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C1</span><span class="p">].</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C1</span><span class="p">].</span><span class="n">entry_method</span> <span class="o">=</span> <span class="n">ACPI_CSTATE_HALT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* the C0 state only exists as a filler in our array */</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">ACPI_STATE_C0</span><span class="p">].</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_processor_get_power_info_cst</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">current_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_buffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ACPI_ALLOCATE_BUFFER</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="n">cst</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">nocst</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">current_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">acpi_evaluate_object</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">,</span> <span class="s">&quot;_CST&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span> <span class="s">&quot;No _CST, giving up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cst</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>

	<span class="cm">/* There must be at least 2 elements */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cst</span> <span class="o">||</span> <span class="p">(</span><span class="n">cst</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_PACKAGE</span><span class="p">)</span> <span class="o">||</span> <span class="n">cst</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span> <span class="s">&quot;not enough elements in _CST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">cst</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

	<span class="cm">/* Validate number of power states. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">count</span> <span class="o">!=</span> <span class="n">cst</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">PREFIX</span> <span class="s">&quot;count given by _CST is not valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tell driver that at least _CST is supported. */</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">has_cst</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">acpi_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">acpi_power_register</span> <span class="o">*</span><span class="n">reg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="n">cx</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cx</span><span class="p">));</span>

		<span class="n">element</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">cst</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_PACKAGE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_BUFFER</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">acpi_power_register</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">space_id</span> <span class="o">!=</span> <span class="n">ACPI_ADR_SPACE_SYSTEM_IO</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">space_id</span> <span class="o">!=</span> <span class="n">ACPI_ADR_SPACE_FIXED_HARDWARE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* There should be an easy way to extract an integer... */</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_INTEGER</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cx</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some buggy BIOSes won&#39;t list C1 in _CST -</span>
<span class="cm">		 * Let acpi_processor_get_power_info_default() handle them later</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cx</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_STATE_C1</span><span class="p">)</span>
			<span class="n">current_count</span><span class="o">++</span><span class="p">;</span>

		<span class="n">cx</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">reg</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
		<span class="n">cx</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">current_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">cx</span><span class="p">.</span><span class="n">entry_method</span> <span class="o">=</span> <span class="n">ACPI_CSTATE_SYSTEMIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">space_id</span> <span class="o">==</span> <span class="n">ACPI_ADR_SPACE_FIXED_HARDWARE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">acpi_processor_ffh_cstate_probe</span>
					<span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cx</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cx</span><span class="p">.</span><span class="n">entry_method</span> <span class="o">=</span> <span class="n">ACPI_CSTATE_FFH</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ACPI_STATE_C1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * C1 is a special case where FIXED_HARDWARE</span>
<span class="cm">				 * can be handled in non-MWAIT way as well.</span>
<span class="cm">				 * In that case, save this _CST entry info.</span>
<span class="cm">				 * Otherwise, ignore this info and continue.</span>
<span class="cm">				 */</span>
				<span class="n">cx</span><span class="p">.</span><span class="n">entry_method</span> <span class="o">=</span> <span class="n">ACPI_CSTATE_HALT</span><span class="p">;</span>
				<span class="n">snprintf</span><span class="p">(</span><span class="n">cx</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">ACPI_CX_DESC_LEN</span><span class="p">,</span> <span class="s">&quot;ACPI HLT&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ACPI_STATE_C1</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">boot_option_idle_override</span> <span class="o">==</span> <span class="n">IDLE_NOMWAIT</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * In most cases the C1 space_id obtained from</span>
<span class="cm">				 * _CST object is FIXED_HARDWARE access mode.</span>
<span class="cm">				 * But when the option of idle=halt is added,</span>
<span class="cm">				 * the entry_method type should be changed from</span>
<span class="cm">				 * CSTATE_FFH to CSTATE_HALT.</span>
<span class="cm">				 * When the option of idle=nomwait is added,</span>
<span class="cm">				 * the C1 entry_method type should be</span>
<span class="cm">				 * CSTATE_HALT.</span>
<span class="cm">				 */</span>
				<span class="n">cx</span><span class="p">.</span><span class="n">entry_method</span> <span class="o">=</span> <span class="n">ACPI_CSTATE_HALT</span><span class="p">;</span>
				<span class="n">snprintf</span><span class="p">(</span><span class="n">cx</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">ACPI_CX_DESC_LEN</span><span class="p">,</span> <span class="s">&quot;ACPI HLT&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">cx</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">ACPI_CX_DESC_LEN</span><span class="p">,</span> <span class="s">&quot;ACPI IOPORT 0x%x&quot;</span><span class="p">,</span>
				 <span class="n">cx</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ACPI_STATE_C1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cx</span><span class="p">.</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_INTEGER</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cx</span><span class="p">.</span><span class="n">latency</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

		<span class="n">obj</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">package</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_TYPE_INTEGER</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cx</span><span class="p">.</span><span class="n">power</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">integer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>

		<span class="n">current_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">current_count</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">cx</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cx</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * We support total ACPI_PROCESSOR_MAX_POWER - 1</span>
<span class="cm">		 * (From 1 through ACPI_PROCESSOR_MAX_POWER - 1)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_count</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ACPI_PROCESSOR_MAX_POWER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;Limiting number of power states to max (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ACPI_PROCESSOR_MAX_POWER</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;Please increase ACPI_PROCESSOR_MAX_POWER if needed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span> <span class="s">&quot;Found %d power states</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">current_count</span><span class="p">));</span>

	<span class="cm">/* Validate number of power states discovered */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

      <span class="nl">end:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">pointer</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">acpi_processor_power_verify_c3</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">bm_check_flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">bm_control_flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PIIX4 Erratum #18: We don&#39;t support C3 when Type-F (fast)</span>
<span class="cm">	 * DMA transfers are used by any ISA device to avoid livelock.</span>
<span class="cm">	 * Note that we could disable Type-F DMA (as recommended by</span>
<span class="cm">	 * the erratum), but this is known to disrupt certain ISA</span>
<span class="cm">	 * devices thus we take the conservative approach.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errata</span><span class="p">.</span><span class="n">piix4</span><span class="p">.</span><span class="n">fdma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span>
				  <span class="s">&quot;C3 not supported on PIIX4 with Type-F DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* All the logic here assumes flags.bm_check is same across all CPUs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bm_check_flag</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Determine whether bm_check is needed based on CPU  */</span>
		<span class="n">acpi_processor_power_init_bm_check</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">),</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">bm_check_flag</span> <span class="o">=</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_check</span><span class="p">;</span>
		<span class="n">bm_control_flag</span> <span class="o">=</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_control</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_check</span> <span class="o">=</span> <span class="n">bm_check_flag</span><span class="p">;</span>
		<span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_control</span> <span class="o">=</span> <span class="n">bm_control_flag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_check</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_control</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">has_cst</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* bus mastering control is necessary */</span>
				<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span>
					<span class="s">&quot;C3 support requires BM control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Here we enter C3 without bus mastering */</span>
				<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span>
					<span class="s">&quot;C3 support without BM control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * WBINVD should be set in fadt, for C3 state to be</span>
<span class="cm">		 * supported on when bm_check is not required.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_FADT_WBINVD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ACPI_DEBUG_PRINT</span><span class="p">((</span><span class="n">ACPI_DB_INFO</span><span class="p">,</span>
					  <span class="s">&quot;Cache invalidation should work properly&quot;</span>
					  <span class="s">&quot; for C3 to be enabled on SMP systems</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Otherwise we&#39;ve met all of our C3 requirements.</span>
<span class="cm">	 * Normalize the C3 latency to expidite policy.  Enable</span>
<span class="cm">	 * checking of bus mastering status (bm_check) so we can</span>
<span class="cm">	 * use this in our C3 policy</span>
<span class="cm">	 */</span>
	<span class="n">cx</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cx</span><span class="o">-&gt;</span><span class="n">latency_ticks</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">latency</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * On older chipsets, BM_RLD needs to be set</span>
<span class="cm">	 * in order for Bus Master activity to wake the</span>
<span class="cm">	 * system from C3.  Newer chipsets handle DMA</span>
<span class="cm">	 * during C3 automatically and BM_RLD is a NOP.</span>
<span class="cm">	 * In either case, the proper way to</span>
<span class="cm">	 * handle BM_RLD is to set it and leave it set.</span>
<span class="cm">	 */</span>
	<span class="n">acpi_write_bit_register</span><span class="p">(</span><span class="n">ACPI_BITREG_BUS_MASTER_RLD</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_processor_power_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">working</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">timer_broadcast_on_state</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ACPI_PROCESSOR_MAX_POWER</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_cstate</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ACPI_STATE_C1</span>:
			<span class="n">cx</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ACPI_STATE_C2</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cx</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
			<span class="n">cx</span><span class="o">-&gt;</span><span class="n">latency_ticks</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">latency</span><span class="p">;</span> <span class="cm">/* Normalize latency */</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ACPI_STATE_C3</span>:
			<span class="n">acpi_processor_power_verify_c3</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">cx</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">lapic_timer_check_state</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">cx</span><span class="p">);</span>
		<span class="n">tsc_check_state</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="n">working</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lapic_timer_propagate_broadcast</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">working</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_processor_get_power_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>


	<span class="cm">/* NOTE: the idle thread may not be running while calling</span>
<span class="cm">	 * this function */</span>

	<span class="cm">/* Zero initialize all the C-states info. */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">));</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">acpi_processor_get_power_info_cst</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">acpi_processor_get_power_info_fadt</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">acpi_processor_get_power_info_default</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>

	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">acpi_processor_power_verify</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if one state of type C2 or C3 is available, mark this</span>
<span class="cm">	 * CPU as being &quot;idle manageable&quot;</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ACPI_PROCESSOR_MAX_POWER</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">ACPI_STATE_C2</span><span class="p">)</span>
				<span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * acpi_idle_bm_check - checks if bus master activity was detected</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_idle_bm_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bm_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bm_check_disable</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">acpi_read_bit_register</span><span class="p">(</span><span class="n">ACPI_BITREG_BUS_MASTER_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bm_status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bm_status</span><span class="p">)</span>
		<span class="n">acpi_write_bit_register</span><span class="p">(</span><span class="n">ACPI_BITREG_BUS_MASTER_STATUS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * PIIX4 Erratum #18: Note that BM_STS doesn&#39;t always reflect</span>
<span class="cm">	 * the true state of bus mastering activity; forcing us to</span>
<span class="cm">	 * manually check the BMIDEA bit of each IDE channel.</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">errata</span><span class="p">.</span><span class="n">piix4</span><span class="p">.</span><span class="n">bmisx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inb_p</span><span class="p">(</span><span class="n">errata</span><span class="p">.</span><span class="n">piix4</span><span class="p">.</span><span class="n">bmisx</span> <span class="o">+</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">errata</span><span class="p">.</span><span class="n">piix4</span><span class="p">.</span><span class="n">bmisx</span> <span class="o">+</span> <span class="mh">0x0A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span>
			<span class="n">bm_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bm_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * acpi_idle_do_entry - a helper function that does C2 and C3 type entry</span>
<span class="cm"> * @cx: cstate data</span>
<span class="cm"> *</span>
<span class="cm"> * Caller disables interrupt before call and enables interrupt after return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">acpi_idle_do_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t trace irqs off for idle */</span>
	<span class="n">stop_critical_timings</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">==</span> <span class="n">ACPI_CSTATE_FFH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Call into architectural FFH based C-state */</span>
		<span class="n">acpi_processor_ffh_cstate_enter</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">==</span> <span class="n">ACPI_CSTATE_HALT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_safe_halt</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* IO port based C-state */</span>
		<span class="n">inb</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
		<span class="cm">/* Dummy wait op - must do something useless after P_LVL2 read</span>
<span class="cm">		   because chipsets cannot guarantee that STPCLK# signal</span>
<span class="cm">		   gets asserted in time to freeze execution properly. */</span>
		<span class="n">inl</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">xpm_timer_block</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">start_critical_timings</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * acpi_idle_enter_c1 - enters an ACPI C1 state-type</span>
<span class="cm"> * @dev: the target CPU</span>
<span class="cm"> * @drv: cpuidle driver containing cpuidle state info</span>
<span class="cm"> * @index: index of target state</span>
<span class="cm"> *</span>
<span class="cm"> * This is equivalent to the HALT instruction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_idle_enter_c1</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span>  <span class="n">kt1</span><span class="p">,</span> <span class="n">kt2</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">idle_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_state_usage</span> <span class="o">*</span><span class="n">state_usage</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">states_usage</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cpuidle_get_statedata</span><span class="p">(</span><span class="n">state_usage</span><span class="p">);</span>

	<span class="n">pr</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">processors</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_residency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_idle_suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lapic_timer_state_broadcast</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">kt1</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="n">acpi_idle_do_entry</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
	<span class="n">kt2</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="n">idle_time</span> <span class="o">=</span>  <span class="n">ktime_to_us</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">kt2</span><span class="p">,</span> <span class="n">kt1</span><span class="p">));</span>

	<span class="cm">/* Update device last_residency*/</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_residency</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">idle_time</span><span class="p">;</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="n">cx</span><span class="o">-&gt;</span><span class="n">usage</span><span class="o">++</span><span class="p">;</span>
	<span class="n">lapic_timer_state_broadcast</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * acpi_idle_play_dead - enters an ACPI state for long-term idle (i.e. off-lining)</span>
<span class="cm"> * @dev: the target CPU</span>
<span class="cm"> * @index: the index of suggested state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_idle_play_dead</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cpuidle_state_usage</span> <span class="o">*</span><span class="n">state_usage</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">states_usage</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cpuidle_get_statedata</span><span class="p">(</span><span class="n">state_usage</span><span class="p">);</span>

	<span class="n">ACPI_FLUSH_CPU_CACHE</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">==</span> <span class="n">ACPI_CSTATE_HALT</span><span class="p">)</span>
			<span class="n">safe_halt</span><span class="p">();</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">==</span> <span class="n">ACPI_CSTATE_SYSTEMIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inb</span><span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
			<span class="cm">/* See comment in acpi_idle_do_entry() */</span>
			<span class="n">inl</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">xpm_timer_block</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Never reached */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * acpi_idle_enter_simple - enters an ACPI state without BM handling</span>
<span class="cm"> * @dev: the target CPU</span>
<span class="cm"> * @drv: cpuidle driver with cpuidle state information</span>
<span class="cm"> * @index: the index of suggested state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_idle_enter_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_state_usage</span> <span class="o">*</span><span class="n">state_usage</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">states_usage</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cpuidle_get_statedata</span><span class="p">(</span><span class="n">state_usage</span><span class="p">);</span>
	<span class="n">ktime_t</span>  <span class="n">kt1</span><span class="p">,</span> <span class="n">kt2</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">idle_time_ns</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">idle_time</span><span class="p">;</span>

	<span class="n">pr</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">processors</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_residency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_idle_suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">!=</span> <span class="n">ACPI_CSTATE_FFH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TS_POLLING</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * TS_POLLING-cleared state must be visible before we test</span>
<span class="cm">		 * NEED_RESCHED:</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">need_resched</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must be done before busmaster disable as we might need to</span>
<span class="cm">	 * access HPET !</span>
<span class="cm">	 */</span>
	<span class="n">lapic_timer_state_broadcast</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ACPI_STATE_C3</span><span class="p">)</span>
		<span class="n">ACPI_FLUSH_CPU_CACHE</span><span class="p">();</span>

	<span class="n">kt1</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="cm">/* Tell the scheduler that we are going deep-idle: */</span>
	<span class="n">sched_clock_idle_sleep_event</span><span class="p">();</span>
	<span class="n">acpi_idle_do_entry</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>
	<span class="n">kt2</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="n">idle_time_ns</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">kt2</span><span class="p">,</span> <span class="n">kt1</span><span class="p">));</span>
	<span class="n">idle_time</span> <span class="o">=</span> <span class="n">idle_time_ns</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">idle_time</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>

	<span class="cm">/* Update device last_residency*/</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_residency</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">idle_time</span><span class="p">;</span>

	<span class="cm">/* Tell the scheduler how much we idled: */</span>
	<span class="n">sched_clock_idle_wakeup_event</span><span class="p">(</span><span class="n">idle_time_ns</span><span class="p">);</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">!=</span> <span class="n">ACPI_CSTATE_FFH</span><span class="p">)</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>

	<span class="n">cx</span><span class="o">-&gt;</span><span class="n">usage</span><span class="o">++</span><span class="p">;</span>

	<span class="n">lapic_timer_state_broadcast</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cx</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+=</span> <span class="n">idle_time</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">c3_cpu_count</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">c3_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * acpi_idle_enter_bm - enters C3 with proper BM handling</span>
<span class="cm"> * @dev: the target CPU</span>
<span class="cm"> * @drv: cpuidle driver containing state data</span>
<span class="cm"> * @index: the index of suggested state</span>
<span class="cm"> *</span>
<span class="cm"> * If BM is detected, the deepest non-C3 idle state is entered instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_idle_enter_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_state_usage</span> <span class="o">*</span><span class="n">state_usage</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">states_usage</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span> <span class="o">=</span> <span class="n">cpuidle_get_statedata</span><span class="p">(</span><span class="n">state_usage</span><span class="p">);</span>
	<span class="n">ktime_t</span>  <span class="n">kt1</span><span class="p">,</span> <span class="n">kt2</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">idle_time_ns</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">idle_time</span><span class="p">;</span>


	<span class="n">pr</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">processors</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_residency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">bm_sts_skip</span> <span class="o">&amp;&amp;</span> <span class="n">acpi_idle_bm_check</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">safe_state_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">states</span><span class="p">[</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">safe_state_index</span><span class="p">].</span><span class="n">enter</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						<span class="n">drv</span><span class="p">,</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">safe_state_index</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">local_irq_disable</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_idle_suspend</span><span class="p">)</span>
				<span class="n">acpi_safe_halt</span><span class="p">();</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_idle_suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">!=</span> <span class="n">ACPI_CSTATE_FFH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TS_POLLING</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * TS_POLLING-cleared state must be visible before we test</span>
<span class="cm">		 * NEED_RESCHED:</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">need_resched</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">acpi_unlazy_tlb</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>

	<span class="cm">/* Tell the scheduler that we are going deep-idle: */</span>
	<span class="n">sched_clock_idle_sleep_event</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Must be done before busmaster disable as we might need to</span>
<span class="cm">	 * access HPET !</span>
<span class="cm">	 */</span>
	<span class="n">lapic_timer_state_broadcast</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">kt1</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * disable bus master</span>
<span class="cm">	 * bm_check implies we need ARB_DIS</span>
<span class="cm">	 * !bm_check implies we need cache flush</span>
<span class="cm">	 * bm_control implies whether we can do ARB_DIS</span>
<span class="cm">	 *</span>
<span class="cm">	 * That leaves a case where bm_check is set and bm_control is</span>
<span class="cm">	 * not set. In that case we cannot do much, we enter C3</span>
<span class="cm">	 * without doing anything.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_check</span> <span class="o">&amp;&amp;</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_control</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c3_lock</span><span class="p">);</span>
		<span class="n">c3_cpu_count</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Disable bus master arbitration when all CPUs are in C3 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c3_cpu_count</span> <span class="o">==</span> <span class="n">num_online_cpus</span><span class="p">())</span>
			<span class="n">acpi_write_bit_register</span><span class="p">(</span><span class="n">ACPI_BITREG_ARB_DISABLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c3_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_check</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ACPI_FLUSH_CPU_CACHE</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">acpi_idle_do_entry</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>

	<span class="cm">/* Re-enable bus master arbitration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_check</span> <span class="o">&amp;&amp;</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_control</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c3_lock</span><span class="p">);</span>
		<span class="n">acpi_write_bit_register</span><span class="p">(</span><span class="n">ACPI_BITREG_ARB_DISABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">c3_cpu_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c3_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kt2</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="n">idle_time_ns</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">kt2</span><span class="p">,</span> <span class="n">kt1</span><span class="p">));</span>
	<span class="n">idle_time</span> <span class="o">=</span> <span class="n">idle_time_ns</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">idle_time</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>

	<span class="cm">/* Update device last_residency*/</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_residency</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">idle_time</span><span class="p">;</span>

	<span class="cm">/* Tell the scheduler how much we idled: */</span>
	<span class="n">sched_clock_idle_wakeup_event</span><span class="p">(</span><span class="n">idle_time_ns</span><span class="p">);</span>

	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">!=</span> <span class="n">ACPI_CSTATE_FFH</span><span class="p">)</span>
		<span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">TS_POLLING</span><span class="p">;</span>

	<span class="n">cx</span><span class="o">-&gt;</span><span class="n">usage</span><span class="o">++</span><span class="p">;</span>

	<span class="n">lapic_timer_state_broadcast</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cx</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">+=</span> <span class="n">idle_time</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="n">acpi_idle_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;acpi_idle&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * acpi_processor_setup_cpuidle_cx - prepares and configures CPUIDLE</span>
<span class="cm"> * device i.e. per-cpu data</span>
<span class="cm"> *</span>
<span class="cm"> * @pr: the ACPI processor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_processor_setup_cpuidle_cx</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">CPUIDLE_DRIVER_STATE_START</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_state_usage</span> <span class="o">*</span><span class="n">state_usage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power_setup_done</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_cstate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">max_cstate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ACPI_PROCESSOR_MAX_POWER</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_cstate</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">state_usage</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">states_usage</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_STATE_C1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">has_cst</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_FADT_C2_MP_SUPPORTED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">cpuidle_set_statedata</span><span class="p">(</span><span class="n">state_usage</span><span class="p">,</span> <span class="n">cx</span><span class="p">);</span>

		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">CPUIDLE_STATE_MAX</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">state_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * acpi_processor_setup_cpuidle states- prepares and configures cpuidle</span>
<span class="cm"> * global state data i.e. idle routines</span>
<span class="cm"> *</span>
<span class="cm"> * @pr: the ACPI processor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">acpi_processor_setup_cpuidle_states</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">CPUIDLE_DRIVER_STATE_START</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_processor_cx</span> <span class="o">*</span><span class="n">cx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cpuidle_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">acpi_idle_driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power_setup_done</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">safe_state_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CPUIDLE_STATE_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_cstate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">max_cstate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ACPI_PROCESSOR_MAX_POWER</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_cstate</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ACPI_STATE_C1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">has_cst</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ACPI_FADT_C2_MP_SUPPORTED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">states</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">CPUIDLE_NAME_LEN</span><span class="p">,</span> <span class="s">&quot;C%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="n">CPUIDLE_DESC_LEN</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">exit_latency</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">latency</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">target_residency</span> <span class="o">=</span> <span class="n">cx</span><span class="o">-&gt;</span><span class="n">latency</span> <span class="o">*</span> <span class="n">latency_factor</span><span class="p">;</span>

		<span class="n">state</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">ACPI_STATE_C1</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cx</span><span class="o">-&gt;</span><span class="n">entry_method</span> <span class="o">==</span> <span class="n">ACPI_CSTATE_FFH</span><span class="p">)</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span><span class="p">;</span>

			<span class="n">state</span><span class="o">-&gt;</span><span class="n">enter</span> <span class="o">=</span> <span class="n">acpi_idle_enter_c1</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">enter_dead</span> <span class="o">=</span> <span class="n">acpi_idle_play_dead</span><span class="p">;</span>
			<span class="n">drv</span><span class="o">-&gt;</span><span class="n">safe_state_index</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">ACPI_STATE_C2</span>:
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">enter</span> <span class="o">=</span> <span class="n">acpi_idle_enter_simple</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">enter_dead</span> <span class="o">=</span> <span class="n">acpi_idle_play_dead</span><span class="p">;</span>
			<span class="n">drv</span><span class="o">-&gt;</span><span class="n">safe_state_index</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">ACPI_STATE_C3</span>:
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CPUIDLE_FLAG_TIME_VALID</span><span class="p">;</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">enter</span> <span class="o">=</span> <span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">bm_check</span> <span class="o">?</span>
					<span class="n">acpi_idle_enter_bm</span> <span class="o">:</span>
					<span class="n">acpi_idle_enter_simple</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">CPUIDLE_STATE_MAX</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">state_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">acpi_processor_hotplug</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disabled_by_idle_boot_param</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nocst</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power_setup_done</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">cpuidle_pause_and_lock</span><span class="p">();</span>
	<span class="n">cpuidle_disable_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">acpi_processor_get_power_info</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acpi_processor_setup_cpuidle_cx</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cpuidle_enable_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cpuidle_resume_and_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">acpi_processor_cst_has_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">_pr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disabled_by_idle_boot_param</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nocst</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power_setup_done</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIXME:  Design the ACPI notification to make it once per</span>
<span class="cm">	 * system instead of once per-cpu.  This condition is a hack</span>
<span class="cm">	 * to make the code that updates C-States be called once.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cpuidle_get_driver</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">acpi_idle_driver</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">cpuidle_pause_and_lock</span><span class="p">();</span>
		<span class="cm">/* Protect against cpu-hotplug */</span>
		<span class="n">get_online_cpus</span><span class="p">();</span>

		<span class="cm">/* Disable all cpuidle devices */</span>
		<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">_pr</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">processors</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_pr</span> <span class="o">||</span> <span class="o">!</span><span class="n">_pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power_setup_done</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">cpuidle_disable_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Populate Updated C-state information */</span>
		<span class="n">acpi_processor_setup_cpuidle_states</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>

		<span class="cm">/* Enable all cpuidle devices */</span>
		<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">_pr</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">processors</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_pr</span> <span class="o">||</span> <span class="o">!</span><span class="n">_pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power_setup_done</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">acpi_processor_get_power_info</span><span class="p">(</span><span class="n">_pr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">acpi_processor_setup_cpuidle_cx</span><span class="p">(</span><span class="n">_pr</span><span class="p">);</span>
				<span class="n">cpuidle_enable_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">put_online_cpus</span><span class="p">();</span>
		<span class="n">cpuidle_resume_and_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">acpi_processor_registered</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">acpi_processor_power_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">acpi_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">acpi_status</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">first_run</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disabled_by_idle_boot_param</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_run</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dmi_check_system</span><span class="p">(</span><span class="n">processor_power_dmi_table</span><span class="p">);</span>
		<span class="n">max_cstate</span> <span class="o">=</span> <span class="n">acpi_processor_cstate_check</span><span class="p">(</span><span class="n">max_cstate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_cstate</span> <span class="o">&lt;</span> <span class="n">ACPI_C_STATES_MAX</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
			       <span class="s">&quot;ACPI: processor limited to max C-state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">max_cstate</span><span class="p">);</span>
		<span class="n">first_run</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">cst_control</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nocst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span>
		    <span class="n">acpi_os_write_port</span><span class="p">(</span><span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">smi_command</span><span class="p">,</span> <span class="n">acpi_gbl_FADT</span><span class="p">.</span><span class="n">cst_control</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ACPI_FAILURE</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ACPI_EXCEPTION</span><span class="p">((</span><span class="n">AE_INFO</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
					<span class="s">&quot;Notifying BIOS of _CST ability failed&quot;</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">acpi_processor_get_power_info</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>
	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power_setup_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Install the idle handler if processor power management is supported.</span>
<span class="cm">	 * Note that we use previously set idle handler will be used on</span>
<span class="cm">	 * platforms that only support C1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Register acpi_idle_driver if not already registered */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acpi_processor_registered</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">acpi_processor_setup_cpuidle_states</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">cpuidle_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acpi_idle_driver</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;ACPI: %s registered with cpuidle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">acpi_idle_driver</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Register per-cpu cpuidle_device. Cpuidle driver</span>
<span class="cm">		 * must already be registered before registering device</span>
<span class="cm">		 */</span>
		<span class="n">acpi_processor_setup_cpuidle_cx</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">cpuidle_register_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">acpi_processor_registered</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">cpuidle_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acpi_idle_driver</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">acpi_processor_registered</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">acpi_processor_power_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">acpi_processor</span> <span class="o">*</span><span class="n">pr</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">acpi_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disabled_by_idle_boot_param</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpuidle_unregister_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">acpi_processor_registered</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acpi_processor_registered</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cpuidle_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acpi_idle_driver</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">.</span><span class="n">power_setup_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
