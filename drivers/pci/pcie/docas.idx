f | portdrv_core.c | s | 15K | 501 | Chunhe Lan | Chunhe.Lan@freescale.com | 1336404446 |  | PCI: fix uninitialized variable 'cap_mask'  Get rid of these:  drivers/pci/pcie/portdrv_core.c: In function 'pcie_port_device_register': drivers/pci/pcie/portdrv_core.c:275:16: warning: 'cap_mask' may be used uninitialized in this function [-Wuninitialized] drivers/pci/pcie/portdrv_core.c:240:6: note: 'cap_mask' was declared here  In some cases, 'cap_mask' may be not set in pcie_port_platform_notify, holding a garbage value.  Signed-off-by: Chunhe Lan <Chunhe.Lan@freescale.com> Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
d | aer |  | 10 items |  | Rusty Russell | rusty@rustcorp.com.au | 1326409340 |  | module_param: make bool parameters really bool (drivers & misc)  module_param(bool) used to counter-intuitively take an int.  In fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy trick.  It's time to remove the int/unsigned int option.  For this version it'll simply give a warning, but it'll break next kernel version.  Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com> Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
f | Makefile | g | 364B |  | Rafael J. Wysocki | rjw@sisk.pl | 1282682868 |  | PCI: PCIe: Move PCIe PME code to the pcie directory  The PCIe PME code only consists of one file, so it doesn't need to occupy its own directory.  Move it to drivers/pci/pcie/pme.c and remove the contents of drivers/pci/pcie/pme .  Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl> Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
f | portdrv_bus.c | s | 1.2K | 43 | Kenji Kaneshige | kaneshige.kenji@jp.fujitsu.com | 1259970979 |  | PCI: portdrv: remove unnecessary struct pcie_port_data  Remove 'port_type' field in struct pcie_port_data(), because we can get port type information from struct pci_dev. With this change, this patch also does followings:   - Remove struct pcie_port_data because it no longer has any field.  - Remove portdrv private definitions about port type (PCIE_RC_PORT,    PCIE_SW_UPSTREAM_PORT and PCIE_SW_DOWNSTREAM_PORT), and use generic    definitions instead.  Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com> Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
f | aspm.c | s | 27K | 883 | Matthew Garrett | mjg@redhat.com | 1333223396 |  | ASPM: Fix pcie devices with non-pcie children  Since 3.2.12 and 3.3, some systems are failing to boot with a BUG_ON. Some other systems using the pata_jmicron driver fail to boot because no disks are detected.  Passing pcie_aspm=force on the kernel command line works around it.  The cause: commit 4949be16822e ("PCI: ignore pre-1.1 ASPM quirking when ASPM is disabled") changed the behaviour of pcie_aspm_sanity_check() to always return 0 if aspm is disabled, in order to avoid cases where we changed ASPM state on pre-PCIe 1.1 devices.  This skipped the secondary function of pcie_aspm_sanity_check which was to avoid us enabling ASPM on devices that had non-PCIe children, causing trouble later on.  Move the aspm_disabled check so we continue to honour that scenario.  Addresses https://bugzilla.kernel.org/show_bug.cgi?id=42979 and           http://bugs.debian.org/665420  Reported-by: Romain Francoise <romain@orebokech.com> # kernel panic Reported-by: Chris Holland <bandidoirlandes@gmail.com> # disk detection trouble Signed-off-by: Matthew Garrett <mjg@redhat.com> Cc: stable@vger.kernel.org Tested-by: Hatem Masmoudi <hatem.masmoudi@gmail.com> # Dell Latitude E5520 Tested-by: janek <jan0x6c@gmail.com> # pata_jmicron with JMB362/JMB363 [jn: with more symptoms in log message] Signed-off-by: Jonathan Nieder <jrnieder@gmail.com> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | portdrv_acpi.c | s | 1.8K | 53 | Rafael J. Wysocki | rjw@sisk.pl | 1295024141 |  | PCI/ACPI: Request _OSC control once for each root bridge (v3)  Move the evaluation of acpi_pci_osc_control_set() (to request control of PCI Express native features) into acpi_pci_root_add() to avoid calling it many times for the same root complex with the same arguments. Additionally, check if all of the requisite _OSC support bits are set before calling acpi_pci_osc_control_set() for a given root complex.  References: https://bugzilla.kernel.org/show_bug.cgi?id=20232 Reported-by: Ozan Caglayan <ozan@pardus.org.tr> Tested-by: Ozan Caglayan <ozan@pardus.org.tr> Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl> Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
f | portdrv.h | s | 2.2K | 66 | MUNEDA Takahiro | muneda.takahiro@jp.fujitsu.com | 1330028975 |  | PCI: Add pcie_hp=nomsi to disable MSI/MSI-X for pciehp driver  Add a parameter to avoid using MSI/MSI-X for PCIe native hotplug; it's known to be buggy on some platforms.  In my environment, while shutting down, following stack trace is shown sometimes.    irq 16: nobody cared (try booting with the "irqpoll" option)   Pid: 1081, comm: reboot Not tainted 3.2.0 #1   Call Trace:    <IRQ>  [<ffffffff810cec1d>] __report_bad_irq+0x3d/0xe0    [<ffffffff810cee1c>] note_interrupt+0x15c/0x210    [<ffffffff810cc485>] handle_irq_event_percpu+0xb5/0x210    [<ffffffff810cc621>] handle_irq_event+0x41/0x70    [<ffffffff810cf675>] handle_fasteoi_irq+0x55/0xc0    [<ffffffff81015356>] handle_irq+0x46/0xb0    [<ffffffff814fbe9d>] do_IRQ+0x5d/0xe0    [<ffffffff814f146e>] common_interrupt+0x6e/0x6e    [<ffffffff8106b040>] ? __do_softirq+0x60/0x210    [<ffffffff8108aeb1>] ? hrtimer_interrupt+0x151/0x240    [<ffffffff814fb5ec>] call_softirq+0x1c/0x30    [<ffffffff810152d5>] do_softirq+0x65/0xa0    [<ffffffff8106ae9d>] irq_exit+0xbd/0xe0    [<ffffffff814fbf8e>] smp_apic_timer_interrupt+0x6e/0x99    [<ffffffff814f9e5e>] apic_timer_interrupt+0x6e/0x80    <EOI>  [<ffffffff814f0fb1>] ? _raw_spin_unlock_irqrestore+0x11/0x20    [<ffffffff812629fc>] pci_bus_write_config_word+0x6c/0x80    [<ffffffff81266fc2>] pci_intx+0x52/0xa0    [<ffffffff8127de3d>] pci_intx_for_msi+0x1d/0x30   [<ffffffff8127e4fb>] pci_msi_shutdown+0x7b/0x110    [<ffffffff81269d34>] pci_device_shutdown+0x34/0x50    [<ffffffff81326c4f>] device_shutdown+0x2f/0x140    [<ffffffff8107b981>] kernel_restart_prepare+0x31/0x40    [<ffffffff8107b9e6>] kernel_restart+0x16/0x60    [<ffffffff8107bbfd>] sys_reboot+0x1ad/0x220    [<ffffffff814f4b90>] ? do_page_fault+0x1e0/0x460    [<ffffffff811942d0>] ? __sync_filesystem+0x90/0x90    [<ffffffff8105c9aa>] ? __cond_resched+0x2a/0x40    [<ffffffff814ef090>] ? _cond_resched+0x30/0x40    [<ffffffff81169e17>] ? iterate_supers+0xb7/0xd0    [<ffffffff814f9382>] system_call_fastpath+0x16/0x1b   handlers:   [<ffffffff8138a0f0>] usb_hcd_irq   [<ffffffff8138a0f0>] usb_hcd_irq   [<ffffffff8138a0f0>] usb_hcd_irq   Disabling IRQ #16  An un-wanted interrupt is generated when PCI driver switches from MSI/MSI-X to INTx while shutting down the device.  The interrupt does not happen if MSI/MSI-X is not used on the device. I confirmed that this problem does not happen if pcie_hp=nomsi was specified and hotplug operation worked fine as usual.  v2: Automatically disable MSI/MSI-X against following device:     PCI bridge: Integrated Device Technology, Inc. Device 807f (rev 02) v3: Based on the review comment, combile the if statements. v4: Removed module parameter.     Move some code to build pciehp as a module.     Move device specific code to driver/pci/quirks.c. v5: Drop a device specific code until getting a vendor statement.  Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com> Signed-off-by: MUNEDA Takahiro <muneda.takahiro@jp.fujitsu.com> Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
f | portdrv_pci.c | s | 9.0K | 310 | Rafael J. Wysocki | rjw@sisk.pl | 1293137643 |  | PCI/PCIe: Clear Root PME Status bits early during system resume  I noticed that PCI Express PMEs don't work on my Toshiba Portege R500 after the system has been woken up from a sleep state by a PME (through Wake-on-LAN).  After some investigation it turned out that the BIOS didn't clear the Root PME Status bit in the root port that received the wakeup PME and since the Requester ID was also set in the port's Root Status register, any subsequent PMEs didn't trigger interrupts.  This problem can be avoided by clearing the Root PME Status bits in all PCI Express root ports during early resume.  For this purpose, add an early resume routine to the PCIe port driver and make this driver be always registered, even if pci_ports_disable is set (in which case the driver's only function is to provide the early resume callback).  Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl> Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
f | Kconfig | g | 2.1K |  | Matthew Garrett | mjg@redhat.com | 1329499323 |  | PCI: pcie: Add support for setting default ASPM policy  Distributions may wish to provide different defaults for PCIE ASPM depending on their target audience. Provide a configuration option for choosing the default policy.  Signed-off-by: Matthew Garrett <mjg@redhat.com> Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
f | pme.c | s | 11K | 382 | Rafael J. Wysocki | rjw@sisk.pl | 1318608331 |  | PCI / PM: Extend PME polling to all PCI devices  The land of PCI power management is a land of sorrow and ugliness, especially in the area of signaling events by devices.  There are devices that set their PME Status bits, but don't really bother to send a PME message or assert PME#.  There are hardware vendors who don't connect PME# lines to the system core logic (they know who they are).  There are PCI Express Root Ports that don't bother to trigger interrupts when they receive PME messages from the devices below.  There are ACPI BIOSes that forget to provide _PRW methods for devices capable of signaling wakeup.  Finally, there are BIOSes that do provide _PRW methods for such devices, but then don't bother to call Notify() for those devices from the corresponding _Lxx/_Exx GPE-handling methods.  In all of these cases the kernel doesn't have a chance to receive a proper notification that it should wake up a device, so devices stay in low-power states forever.  Worse yet, in some cases they continuously send PME Messages that are silently ignored, because the kernel simply doesn't know that it should clear the device's PME Status bit.  This problem was first observed for "parallel" (non-Express) PCI devices on add-on cards and Matthew Garrett addressed it by adding code that polls PME Status bits of such devices, if they are enabled to signal PME, to the kernel.  Recently, however, it has turned out that PCI Express devices are also affected by this issue and that it is not limited to add-on devices, so it seems necessary to extend the PME polling to all PCI devices, including PCI Express and planar ones.  Still, it would be wasteful to poll the PME Status bits of devices that are known to receive proper PME notifications, so make the kernel (1) poll the PME Status bits of all PCI and PCIe devices enabled to signal PME and (2) disable the PME Status polling for devices for which correct PME notifications are received.  Tested-by: Sarah Sharp <sarah.a.sharp@linux.intel.com> Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl> Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
