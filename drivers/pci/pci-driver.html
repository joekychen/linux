<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › pci › pci-driver.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pci-driver.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/pci/pci-driver.c</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright 2002-2004, 2007 Greg Kroah-Hartman &lt;greg@kroah.com&gt;</span>
<span class="cm"> * (C) Copyright 2007 Novell Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Released under the GPL v2 only.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &quot;pci.h&quot;</span>

<span class="k">struct</span> <span class="n">pci_dynid</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pci_add_dynid - add a new PCI device ID to this driver and re-probe devices</span>
<span class="cm"> * @drv: target pci driver</span>
<span class="cm"> * @vendor: PCI vendor ID</span>
<span class="cm"> * @device: PCI device ID</span>
<span class="cm"> * @subvendor: PCI subvendor ID</span>
<span class="cm"> * @subdevice: PCI subdevice ID</span>
<span class="cm"> * @class: PCI class</span>
<span class="cm"> * @class_mask: PCI class mask</span>
<span class="cm"> * @driver_data: private driver data</span>
<span class="cm"> *</span>
<span class="cm"> * Adds a new dynamic pci device ID to this driver and causes the</span>
<span class="cm"> * driver to probe for all devices again.  @drv must have been</span>
<span class="cm"> * registered prior to calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Does GFP_KERNEL allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_add_dynid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vendor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subvendor</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">subdevice</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class_mask</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">driver_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">dynid</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dynid</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dynid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">vendor</span><span class="p">;</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="n">subvendor</span><span class="p">;</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="n">subdevice</span><span class="p">;</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">class</span><span class="p">;</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">class_mask</span> <span class="o">=</span> <span class="n">class_mask</span><span class="p">;</span>
	<span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">driver_data</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">driver_attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_free_dynids</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dynid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dynid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dynamic device ID manipulation via sysfs is disabled for !CONFIG_HOTPLUG</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_HOTPLUG</span>
<span class="cm">/**</span>
<span class="cm"> * store_new_id - sysfs frontend to pci_add_dynid()</span>
<span class="cm"> * @driver: target device driver</span>
<span class="cm"> * @buf: buffer for scanning device ID data</span>
<span class="cm"> * @count: input size</span>
<span class="cm"> *</span>
<span class="cm"> * Allow PCI IDs to be added to an existing driver via sysfs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_new_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">pdrv</span> <span class="o">=</span> <span class="n">to_pci_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ids</span> <span class="o">=</span> <span class="n">pdrv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">subvendor</span><span class="o">=</span><span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">subdevice</span><span class="o">=</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">class</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">class_mask</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">driver_data</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fields</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">fields</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%x %x %x %x %x %x %lx&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">vendor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subvendor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subdevice</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">class_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fields</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Only accept driver_data values that match an existing id_table</span>
<span class="cm">	   entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">||</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">subvendor</span> <span class="o">||</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">class_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">driver_data</span> <span class="o">==</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ids</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>	<span class="cm">/* No match */</span>
			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_add_dynid</span><span class="p">(</span><span class="n">pdrv</span><span class="p">,</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">subvendor</span><span class="p">,</span> <span class="n">subdevice</span><span class="p">,</span>
			       <span class="n">class</span><span class="p">,</span> <span class="n">class_mask</span><span class="p">,</span> <span class="n">driver_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">new_id</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">store_new_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * store_remove_id - remove a PCI device ID from this driver</span>
<span class="cm"> * @driver: target device driver</span>
<span class="cm"> * @buf: buffer for scanning device ID data</span>
<span class="cm"> * @count: input size</span>
<span class="cm"> *</span>
<span class="cm"> * Removes a dynamic pci device ID to this driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">store_remove_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">pdrv</span> <span class="o">=</span> <span class="n">to_pci_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">__u32</span> <span class="n">vendor</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">subvendor</span> <span class="o">=</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">subdevice</span> <span class="o">=</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">class</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">class_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fields</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">fields</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%x %x %x %x %x %x&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">vendor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subvendor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subdevice</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">class_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fields</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdrv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dynid</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdrv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">vendor</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">device</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">subvendor</span> <span class="o">==</span> <span class="n">PCI_ANY_ID</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">subvendor</span> <span class="o">==</span> <span class="n">subvendor</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">subdevice</span> <span class="o">==</span> <span class="n">PCI_ANY_ID</span> <span class="o">||</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">subdevice</span> <span class="o">==</span> <span class="n">subdevice</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">((</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">^</span> <span class="n">class</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">class_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dynid</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdrv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DRIVER_ATTR</span><span class="p">(</span><span class="n">remove_id</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">store_remove_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">pci_create_newid_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_new_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">driver_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">driver_attr_remove_id</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">driver_attr_new_id</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_remove_newid_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_remove_id</span><span class="p">);</span>
	<span class="n">driver_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">driver_attr_new_id</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* !CONFIG_HOTPLUG */</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pci_create_newid_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">pci_remove_newid_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * pci_match_id - See if a pci device matches a given pci_id table</span>
<span class="cm"> * @ids: array of PCI device id structures to search in</span>
<span class="cm"> * @dev: the PCI device structure to match against.</span>
<span class="cm"> *</span>
<span class="cm"> * Used by a driver to check whether a PCI device present in the</span>
<span class="cm"> * system is in its list of supported devices.  Returns the matching</span>
<span class="cm"> * pci_device_id structure or %NULL if there is no match.</span>
<span class="cm"> *</span>
<span class="cm"> * Deprecated, don&#39;t use this as it will not catch any dynamic ids</span>
<span class="cm"> * that a driver might want to check for.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="nf">pci_match_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ids</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ids</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">||</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">subvendor</span> <span class="o">||</span> <span class="n">ids</span><span class="o">-&gt;</span><span class="n">class_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pci_match_one_device</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">ids</span><span class="p">;</span>
			<span class="n">ids</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_match_device - Tell if a PCI device structure has a matching PCI device id structure</span>
<span class="cm"> * @drv: the PCI driver to match against</span>
<span class="cm"> * @dev: the PCI device structure to match against</span>
<span class="cm"> *</span>
<span class="cm"> * Used by a driver to check whether a PCI device present in the</span>
<span class="cm"> * system is in its list of supported devices.  Returns the matching</span>
<span class="cm"> * pci_device_id structure or %NULL if there is no match.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="nf">pci_match_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dynid</span> <span class="o">*</span><span class="n">dynid</span><span class="p">;</span>

	<span class="cm">/* Look at the dynamic ids first, before the static ones */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dynid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_match_one_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">dynid</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pci_match_id</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">drv_dev_and_id</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">local_pci_probe</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_ddi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">drv_dev_and_id</span> <span class="o">*</span><span class="n">ddi</span> <span class="o">=</span> <span class="n">_ddi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ddi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Unbound PCI devices are always set to disabled and suspended.</span>
<span class="cm">	 * During probe, the device is set to enabled and active and the</span>
<span class="cm">	 * usage count is incremented.  If the driver supports runtime PM,</span>
<span class="cm">	 * it should call pm_runtime_put_noidle() in its probe routine and</span>
<span class="cm">	 * pm_runtime_get_noresume() in its remove routine.</span>
<span class="cm">	 */</span>
	<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">ddi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_set_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_call_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">drv_dev_and_id</span> <span class="n">ddi</span> <span class="o">=</span> <span class="p">{</span> <span class="n">drv</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">id</span> <span class="p">};</span>

	<span class="cm">/* Execute driver initialization on node where the device&#39;s</span>
<span class="cm">	   bus is attached to.  This way the driver likely allocates</span>
<span class="cm">	   its local memory on the right node without any need to</span>
<span class="cm">	   change it. */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">dev_to_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

		<span class="n">get_online_cpus</span><span class="p">();</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_any_and</span><span class="p">(</span><span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">work_on_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">local_pci_probe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddi</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">local_pci_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddi</span><span class="p">);</span>
		<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">local_pci_probe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __pci_device_probe - check if a driver wants to claim a specific PCI device</span>
<span class="cm"> * @drv: driver to call to check if it wants the PCI device</span>
<span class="cm"> * @pci_dev: PCI device being probed</span>
<span class="cm"> * </span>
<span class="cm"> * returns 0 on success, else error.</span>
<span class="cm"> * side-effect: pci_dev-&gt;driver is set to drv when drv claims pci_dev.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__pci_device_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="n">id</span> <span class="o">=</span> <span class="n">pci_match_device</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">pci_call_probe</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="n">drv</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_device_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">;</span>

	<span class="n">drv</span> <span class="o">=</span> <span class="n">to_pci_driver</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_dev_get</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">__pci_device_probe</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_device_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span> <span class="n">drv</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">drv</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
			<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Undo the runtime PM settings in local_pci_probe() */</span>
	<span class="n">pm_runtime_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_set_suspended</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the device is still on, set the power state as &quot;unknown&quot;,</span>
<span class="cm">	 * since it might change by the next time we load the driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">PCI_D0</span><span class="p">)</span>
		<span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="n">PCI_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We would love to complain here if pci_dev-&gt;is_enabled is set, that</span>
<span class="cm">	 * the driver should have called pci_disable_device(), but the</span>
<span class="cm">	 * unfortunate fact is there are too many odd BIOS and bridge setups</span>
<span class="cm">	 * that don&#39;t like drivers doing that all of the time.  </span>
<span class="cm">	 * Oh well, we can dream of sane hardware when we sleep, no matter how</span>
<span class="cm">	 * horrible the crap we have to deal with is when we are awake...</span>
<span class="cm">	 */</span>

	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_device_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_msi_shutdown</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_msix_shutdown</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Turn off Bus Master bit on the device to tell it to not</span>
<span class="cm">	 * continue to do DMA</span>
<span class="cm">	 */</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Devices may be enabled to wake up by runtime PM, but they need not</span>
<span class="cm">	 * be supposed to wake up the system from its &quot;power off&quot; state (e.g.</span>
<span class="cm">	 * ACPI S5).  Therefore disable wakeup for all devices that aren&#39;t</span>
<span class="cm">	 * supposed to wake up the system at this point.  The state argument</span>
<span class="cm">	 * will be ignored by pci_enable_wake().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device_may_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_UNKNOWN</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="cm">/* Auxiliary functions used for system resume and run-time resume. */</span>

<span class="cm">/**</span>
<span class="cm"> * pci_restore_standard_config - restore standard config registers of PCI device</span>
<span class="cm"> * @pci_dev: PCI device to handle</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_restore_standard_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_update_current_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_UNKNOWN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_D0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_pm_default_resume_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_restore_standard_config</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_resume_early</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>

<span class="cm">/*</span>
<span class="cm"> * Default &quot;suspend&quot; method for devices that have no driver provided suspend,</span>
<span class="cm"> * or not even a driver at all (second part).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_pm_set_unknown_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * mark its power state as &quot;unknown&quot;, since we don&#39;t know if</span>
<span class="cm">	 * e.g. the BIOS will change its device state when we suspend.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">PCI_D0</span><span class="p">)</span>
		<span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">=</span> <span class="n">PCI_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Default &quot;resume&quot; method for devices that have no driver provided resume,</span>
<span class="cm"> * or not even a driver at all (second part).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_reenable_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* if the device was enabled before suspend, reenable */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_reenable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the device was busmaster before the suspend, make it busmaster</span>
<span class="cm">	 * again</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">is_busmaster</span><span class="p">)</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_legacy_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span> <span class="n">drv</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_power_t</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_D0</span>
		    <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">,</span>
				<span class="s">&quot;PCI PM: Device state not saved by %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_suspend</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_legacy_suspend_late</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span> <span class="n">drv</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend_late</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_power_t</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend_late</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend_late</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_D0</span>
		    <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">,</span>
				<span class="s">&quot;PCI PM: Device state not saved by %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend_late</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span><span class="p">)</span>
		<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="n">pci_pm_set_unknown_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_legacy_resume_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span> <span class="n">drv</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume_early</span> <span class="o">?</span>
			<span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume_early</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_legacy_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span> <span class="n">drv</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_resume</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume</span> <span class="o">?</span>
			<span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">)</span> <span class="o">:</span> <span class="n">pci_pm_reenable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Auxiliary functions used by the new power management framework */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_pm_default_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_resume</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_bridge</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_pm_default_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Disable non-bridge devices without PM support */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_bridge</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="n">pci_disable_enabled_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">pci_has_legacy_pm_support</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend</span> <span class="o">||</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">suspend_late</span> <span class="o">||</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume</span>
		<span class="o">||</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">resume_early</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Legacy PM support is used by default, so warn if the new framework is</span>
<span class="cm">	 * supported as well.  Drivers are supposed to support either the</span>
<span class="cm">	 * former, or the latter, but not both at the same time.</span>
<span class="cm">	 */</span>
	<span class="n">WARN</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">pm</span><span class="p">,</span> <span class="s">&quot;driver %s device %04x:%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* New power management framework */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a PCI device configured to wake up the system from sleep states</span>
<span class="cm">	 * has been suspended at run time and there&#39;s a resume request pending</span>
<span class="cm">	 * for it, this is equivalent to the device signaling wakeup, so the</span>
<span class="cm">	 * system suspend operation should be aborted.</span>
<span class="cm">	 */</span>
	<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_runtime_barrier</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">device_may_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">pm_wakeup_event</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm_wakeup_pending</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PCI devices suspended at run time need to be resumed at this</span>
<span class="cm">	 * point, because in general it is necessary to reconfigure them for</span>
<span class="cm">	 * system suspend.  Namely, if the device is supposed to wake up the</span>
<span class="cm">	 * system from the sleep state, we may need to reconfigure it for this</span>
<span class="cm">	 * purpose.  In turn, if the device is not supposed to wake up the</span>
<span class="cm">	 * system from the sleep state, we&#39;ll have to prevent it from signaling</span>
<span class="cm">	 * wake-up.</span>
<span class="cm">	 */</span>
	<span class="n">pm_runtime_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_pm_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cp">#define pci_pm_prepare	NULL</span>
<span class="cp">#define pci_pm_complete	NULL</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SUSPEND</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_pm_default_suspend</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">Fixup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_power_t</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_D0</span>
		    <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">,</span>
				<span class="s">&quot;PCI PM: State of device not saved by %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pm</span><span class="o">-&gt;</span><span class="n">suspend</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">Fixup:</span>
	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_suspend</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_suspend_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_suspend_late</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_SUSPEND</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">suspend_noirq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_power_t</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">suspend_noirq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">suspend_noirq</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_D0</span>
		    <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">,</span>
				<span class="s">&quot;PCI PM: State of device not saved by %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pm</span><span class="o">-&gt;</span><span class="n">suspend_noirq</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_is_bridge</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
			<span class="n">pci_prepare_to_sleep</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_pm_set_unknown_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_resume_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pci_pm_default_resume_early</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_resume_early</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">resume_noirq</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">resume_noirq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is necessary for the suspend error path in which resume is</span>
<span class="cm">	 * called without restoring the standard config registers of the device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span><span class="p">)</span>
		<span class="n">pci_restore_standard_config</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_pm_default_resume</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_pm_reenable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_SUSPEND */</span><span class="cp"></span>

<span class="cp">#define pci_pm_suspend		NULL</span>
<span class="cp">#define pci_pm_suspend_noirq	NULL</span>
<span class="cp">#define pci_pm_resume		NULL</span>
<span class="cp">#define pci_pm_resume_noirq	NULL</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_SUSPEND */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_HIBERNATE_CALLBACKS</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_FREEZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_pm_default_suspend</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_freeze_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_suspend_late</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_FREEZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">freeze_noirq</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">freeze_noirq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">freeze_noirq</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span><span class="p">)</span>
		<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="n">pci_pm_set_unknown_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_thaw_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_resume_early</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_update_current_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">thaw_noirq</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">thaw_noirq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">thaw</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">thaw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_pm_reenable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_poweroff</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_HIBERNATE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_pm_default_suspend</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">Fixup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">poweroff</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">poweroff</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">poweroff</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">Fixup:</span>
	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_suspend</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_poweroff_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">pci_legacy_suspend_late</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PMSG_HIBERNATE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drv</span> <span class="o">||</span> <span class="o">!</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">poweroff_noirq</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">poweroff_noirq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">poweroff_noirq</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pci_is_bridge</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="n">pci_prepare_to_sleep</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_restore_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pci_pm_default_resume_early</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_resume_early</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">restore_noirq</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">restore_noirq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is necessary for the hibernation error path in which restore is</span>
<span class="cm">	 * called without restoring the standard config registers of the device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span><span class="p">)</span>
		<span class="n">pci_restore_standard_config</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_has_legacy_pm_support</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pci_legacy_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_pm_default_resume</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">restore</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">restore</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_pm_reenable_device</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_HIBERNATE_CALLBACKS */</span><span class="cp"></span>

<span class="cp">#define pci_pm_freeze		NULL</span>
<span class="cp">#define pci_pm_freeze_noirq	NULL</span>
<span class="cp">#define pci_pm_thaw		NULL</span>
<span class="cp">#define pci_pm_thaw_noirq	NULL</span>
<span class="cp">#define pci_pm_poweroff		NULL</span>
<span class="cp">#define pci_pm_poweroff_noirq	NULL</span>
<span class="cp">#define pci_pm_restore		NULL</span>
<span class="cp">#define pci_pm_restore_noirq	NULL</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_HIBERNATE_CALLBACKS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pci_power_t</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm</span> <span class="o">||</span> <span class="o">!</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">runtime_suspend</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">runtime_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">suspend_report_result</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">runtime_suspend</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_suspend</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_D0</span>
	    <span class="o">&amp;&amp;</span> <span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">PCI_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">current_state</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">,</span>
			<span class="s">&quot;PCI PM: State of device not saved by %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pm</span><span class="o">-&gt;</span><span class="n">runtime_suspend</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_dev</span><span class="o">-&gt;</span><span class="n">state_saved</span><span class="p">)</span>
		<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="n">pci_finish_runtime_suspend</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm</span> <span class="o">||</span> <span class="o">!</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">runtime_resume</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="n">pci_pm_default_resume_early</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">);</span>
	<span class="n">__pci_enable_wake</span><span class="p">(</span><span class="n">pci_dev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_resume</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">runtime_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_pm_runtime_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="o">*</span><span class="n">pm</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">runtime_idle</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">runtime_idle</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pm_runtime_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* !CONFIG_PM_RUNTIME */</span><span class="cp"></span>

<span class="cp">#define pci_pm_runtime_suspend	NULL</span>
<span class="cp">#define pci_pm_runtime_resume	NULL</span>
<span class="cp">#define pci_pm_runtime_idle	NULL</span>

<span class="cp">#endif </span><span class="cm">/* !CONFIG_PM_RUNTIME */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">pci_dev_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span> <span class="n">pci_pm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="n">pci_pm_complete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">pci_pm_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">pci_pm_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="n">pci_pm_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">pci_pm_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poweroff</span> <span class="o">=</span> <span class="n">pci_pm_poweroff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">pci_pm_restore</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend_noirq</span> <span class="o">=</span> <span class="n">pci_pm_suspend_noirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume_noirq</span> <span class="o">=</span> <span class="n">pci_pm_resume_noirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze_noirq</span> <span class="o">=</span> <span class="n">pci_pm_freeze_noirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw_noirq</span> <span class="o">=</span> <span class="n">pci_pm_thaw_noirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poweroff_noirq</span> <span class="o">=</span> <span class="n">pci_pm_poweroff_noirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore_noirq</span> <span class="o">=</span> <span class="n">pci_pm_restore_noirq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_suspend</span> <span class="o">=</span> <span class="n">pci_pm_runtime_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_resume</span> <span class="o">=</span> <span class="n">pci_pm_runtime_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">runtime_idle</span> <span class="o">=</span> <span class="n">pci_pm_runtime_idle</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define PCI_PM_OPS_PTR	(&amp;pci_dev_pm_ops)</span>

<span class="cp">#else </span><span class="cm">/* !COMFIG_PM_OPS */</span><span class="cp"></span>

<span class="cp">#define PCI_PM_OPS_PTR	NULL</span>

<span class="cp">#endif </span><span class="cm">/* !COMFIG_PM_OPS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * __pci_register_driver - register a new pci driver</span>
<span class="cm"> * @drv: the driver structure to register</span>
<span class="cm"> * @owner: owner module of drv</span>
<span class="cm"> * @mod_name: module name string</span>
<span class="cm"> * </span>
<span class="cm"> * Adds the driver structure to the list of registered drivers.</span>
<span class="cm"> * Returns a negative value on error, otherwise 0. </span>
<span class="cm"> * If no error occurred, the driver remains registered even if </span>
<span class="cm"> * no device was claimed during registration.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__pci_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mod_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* initialize common driver fields */</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">;</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">mod_name</span> <span class="o">=</span> <span class="n">mod_name</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">dynids</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/* register with core */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_create_newid_files</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_newid</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">out_newid:</span>
	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_unregister_driver - unregister a pci driver</span>
<span class="cm"> * @drv: the driver structure to unregister</span>
<span class="cm"> * </span>
<span class="cm"> * Deletes the driver structure from the list of registered PCI drivers,</span>
<span class="cm"> * gives it a chance to clean up by calling its remove() function for</span>
<span class="cm"> * each device it was responsible for, and marks those devices as</span>
<span class="cm"> * driverless.</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">pci_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_remove_newid_files</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
	<span class="n">pci_free_dynids</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">pci_compat_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;compat&quot;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * pci_dev_driver - get the pci_driver of a device</span>
<span class="cm"> * @dev: the device to query</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the appropriate pci_driver structure or %NULL if there is no </span>
<span class="cm"> * registered driver for the device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span>
<span class="nf">pci_dev_driver</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">PCI_ROM_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_BUSY</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">&amp;</span><span class="n">pci_compat_driver</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_bus_match - Tell if a PCI device structure has a matching PCI device id structure</span>
<span class="cm"> * @dev: the PCI device structure to match against</span>
<span class="cm"> * @drv: the device driver to search for matching PCI device id structures</span>
<span class="cm"> * </span>
<span class="cm"> * Used by a driver to check whether a PCI device present in the</span>
<span class="cm"> * system is in its list of supported devices. Returns the matching</span>
<span class="cm"> * pci_device_id structure or %NULL if there is no match.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_bus_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pci_dev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_driver</span> <span class="o">*</span><span class="n">pci_drv</span> <span class="o">=</span> <span class="n">to_pci_driver</span><span class="p">(</span><span class="n">drv</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">found_id</span><span class="p">;</span>

	<span class="n">found_id</span> <span class="o">=</span> <span class="n">pci_match_device</span><span class="p">(</span><span class="n">pci_drv</span><span class="p">,</span> <span class="n">pci_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_dev_get - increments the reference count of the pci device structure</span>
<span class="cm"> * @dev: the device being referenced</span>
<span class="cm"> *</span>
<span class="cm"> * Each live reference to a device should be refcounted.</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers for PCI devices should normally record such references in</span>
<span class="cm"> * their probe() methods, when they bind to a device, and release</span>
<span class="cm"> * them by calling pci_dev_put(), in their disconnect() methods.</span>
<span class="cm"> *</span>
<span class="cm"> * A pointer to the device with the incremented reference counter is returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="nf">pci_dev_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">get_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_dev_put - release a use of the pci device structure</span>
<span class="cm"> * @dev: device that&#39;s been disconnected</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called when a user of a device is finished with it.  When the last</span>
<span class="cm"> * user of the device calls this function, the memory of the device is freed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_dev_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef CONFIG_HOTPLUG</span>
<span class="kt">int</span> <span class="nf">pci_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">pci_bus_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;pci&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span>		<span class="o">=</span> <span class="n">pci_bus_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">uevent</span>		<span class="o">=</span> <span class="n">pci_uevent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">pci_device_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">pci_device_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">pci_device_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span>	<span class="o">=</span> <span class="n">pci_dev_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus_attrs</span>	<span class="o">=</span> <span class="n">pci_bus_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pm</span>		<span class="o">=</span> <span class="n">PCI_PM_OPS_PTR</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pci_driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_bus_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">pci_driver_init</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_add_dynid</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_match_id</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__pci_register_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_unregister_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_dev_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_type</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_dev_get</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_dev_put</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
