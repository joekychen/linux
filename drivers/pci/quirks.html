<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › pci › quirks.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>quirks.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  This file contains work-arounds for many known PCI hardware</span>
<span class="cm"> *  bugs.  Devices present only on certain architectures (host</span>
<span class="cm"> *  bridges et cetera) should be handled in arch-specific code.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note: any quirks for hotpluggable devices must _NOT_ be declared __init.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 1999 Martin Mares &lt;mj@ucw.cz&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Init/reset quirks for USB host controllers should be in the</span>
<span class="cm"> *  USB quirks file, where their drivers can access reuse it.</span>
<span class="cm"> *</span>
<span class="cm"> *  The bridge optimization stuff has been removed. If you really</span>
<span class="cm"> *  have a silly BIOS which is unable to set your host bridge right,</span>
<span class="cm"> *  use the PowerTweak utility (see http://powertweak.sourceforge.net).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/acpi.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/dmi.h&gt;</span>
<span class="cp">#include &lt;linux/pci-aspm.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/ktime.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;	</span><span class="cm">/* isa_dma_bridge_buggy */</span><span class="cp"></span>
<span class="cp">#include &quot;pci.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Decoding should be disabled for a PCI device during BAR sizing to avoid</span>
<span class="cm"> * conflict. But doing so may cause problems on host bridge and perhaps other</span>
<span class="cm"> * key system devices. For devices that need to have mmio decoding always-on,</span>
<span class="cm"> * we need to set the dev-&gt;mmio_always_on bit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_mmio_always_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mmio_always_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_EARLY</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
				<span class="n">PCI_CLASS_BRIDGE_HOST</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_mmio_always_on</span><span class="p">);</span>

<span class="cm">/* The Mellanox Tavor device gives false positive parity errors</span>
<span class="cm"> * Mark this device with a broken_parity_status, to allow</span>
<span class="cm"> * PCI scanning code to &quot;skip&quot; this now blacklisted device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_mellanox_tavor</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">broken_parity_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* This device gives false positives */</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_MELLANOX</span><span class="p">,</span><span class="n">PCI_DEVICE_ID_MELLANOX_TAVOR</span><span class="p">,</span><span class="n">quirk_mellanox_tavor</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_MELLANOX</span><span class="p">,</span><span class="n">PCI_DEVICE_ID_MELLANOX_TAVOR_BRIDGE</span><span class="p">,</span><span class="n">quirk_mellanox_tavor</span><span class="p">);</span>

<span class="cm">/* Deal with broken BIOS&#39;es that neglect to enable passive release,</span>
<span class="cm">   which can cause problems in combination with the 82441FX/PPro MTRRs */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_passive_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dlc</span><span class="p">;</span>

	<span class="cm">/* We have to make sure a particular bit is set in the PIIX3</span>
<span class="cm">	   ISA bridge, so we have to go out and find it. */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">d</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82371SB_0</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dlc</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX3: Enabling Passive Release</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dlc</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="n">dlc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82441</span><span class="p">,</span>	<span class="n">quirk_passive_release</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82441</span><span class="p">,</span>	<span class="n">quirk_passive_release</span><span class="p">);</span>

<span class="cm">/*  The VIA VP2/VP3/MVP3 seem to have some &#39;features&#39;. There may be a workaround</span>
<span class="cm">    but VIA don&#39;t answer queries. If you happen to have good contacts at VIA</span>
<span class="cm">    ask them for me please -- Alan </span>
<span class="cm">    </span>
<span class="cm">    This appears to be BIOS not version dependent. So presumably there is a </span>
<span class="cm">    chipset level fix */</span>
    
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_isa_dma_hangs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isa_dma_bridge_buggy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">isa_dma_bridge_buggy</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Activating ISA DMA hang workarounds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Its not totally clear which chipsets are the problematic ones</span>
<span class="cm">	 * We know 82C586 and 82C596 variants are affected.</span>
<span class="cm">	 */</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C586_0</span><span class="p">,</span>	<span class="n">quirk_isa_dma_hangs</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C596</span><span class="p">,</span>	<span class="n">quirk_isa_dma_hangs</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82371SB_0</span><span class="p">,</span>  <span class="n">quirk_isa_dma_hangs</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AL_M1533</span><span class="p">,</span> 	<span class="n">quirk_isa_dma_hangs</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NEC</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_NEC_CBUS_1</span><span class="p">,</span>	<span class="n">quirk_isa_dma_hangs</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NEC</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_NEC_CBUS_2</span><span class="p">,</span>	<span class="n">quirk_isa_dma_hangs</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NEC</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_NEC_CBUS_3</span><span class="p">,</span>	<span class="n">quirk_isa_dma_hangs</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Intel NM10 &quot;TigerPoint&quot; LPC PM1a_STS.BM_STS must be clear</span>
<span class="cm"> * for some HT machines to use C4 w/o hanging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_tigerpoint_bm_sts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pmbase</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pm1a</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmbase</span><span class="p">);</span>
	<span class="n">pmbase</span> <span class="o">=</span> <span class="n">pmbase</span> <span class="o">&amp;</span> <span class="mh">0xff80</span><span class="p">;</span>
	<span class="n">pm1a</span> <span class="o">=</span> <span class="n">inw</span><span class="p">(</span><span class="n">pmbase</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm1a</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">FW_BUG</span> <span class="s">&quot;TigerPoint LPC.BM_STS cleared</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">outw</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="n">pmbase</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_TGP_LPC</span><span class="p">,</span> <span class="n">quirk_tigerpoint_bm_sts</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Chipsets where PCI-&gt;PCI transfers vanish or hang</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_nopcipci</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_pci_problems</span> <span class="o">&amp;</span> <span class="n">PCIPCI_FAIL</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Disabling direct PCI/PCI transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_pci_problems</span> <span class="o">|=</span> <span class="n">PCIPCI_FAIL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_5597</span><span class="p">,</span>		<span class="n">quirk_nopcipci</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_496</span><span class="p">,</span>		<span class="n">quirk_nopcipci</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_nopciamd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">rev</span><span class="p">;</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">==</span> <span class="mh">0x13</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Erratum 24 */</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Chipset erratum: Disabling direct PCI/AGP transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_pci_problems</span> <span class="o">|=</span> <span class="n">PCIAGP_FAIL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AMD_8151_0</span><span class="p">,</span>	<span class="n">quirk_nopciamd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Triton requires workarounds to be used by the drivers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_triton</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_pci_problems</span><span class="o">&amp;</span><span class="n">PCIPCI_TRITON</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Limiting direct PCI/PCI transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_pci_problems</span> <span class="o">|=</span> <span class="n">PCIPCI_TRITON</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82437</span><span class="p">,</span> 	<span class="n">quirk_triton</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82437VX</span><span class="p">,</span> 	<span class="n">quirk_triton</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82439</span><span class="p">,</span> 	<span class="n">quirk_triton</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82439TX</span><span class="p">,</span> 	<span class="n">quirk_triton</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	VIA Apollo KT133 needs PCI latency patch</span>
<span class="cm"> *	Made according to a windows driver based patch by George E. Breese</span>
<span class="cm"> *	see PCI Latency Adjust on http://www.viahardware.com/download/viatweak.shtm</span>
<span class="cm"> *	and http://www.georgebreese.com/net/software/#PCI</span>
<span class="cm"> *      Also see http://www.au-ja.org/review-kt133a-1-en.phtml for</span>
<span class="cm"> *      the info on which Mr Breese based his work.</span>
<span class="cm"> *</span>
<span class="cm"> *	Updated based on further information from the site and also on</span>
<span class="cm"> *	information provided by VIA </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_vialatency</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">busarb</span><span class="p">;</span>
	<span class="cm">/* Ok we have a potential problem chipset here. Now see if we have</span>
<span class="cm">	   a buggy southbridge */</span>
	   
	<span class="n">p</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_82C686</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 0x40 - 0x4f == 686B, 0x10 - 0x2f == 686A; thanks Dan Hollis */</span>
		<span class="cm">/* Check for buggy part revisions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mh">0x40</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;</span> <span class="mh">0x42</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8231</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>	<span class="cm">/* No problem parts */</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="cm">/* Check for buggy part revisions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mh">0x10</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;</span> <span class="mh">0x12</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Ok we have the problem. Now set the PCI master grant to </span>
<span class="cm">	 *	occur every master grant. The apparent bug is that under high</span>
<span class="cm">	 *	PCI load (quite common in Linux of course) you can get data</span>
<span class="cm">	 *	loss when the CPU is held off the bus for 3 bus master requests</span>
<span class="cm">	 *	This happens to include the IDE controllers....</span>
<span class="cm">	 *</span>
<span class="cm">	 *	VIA only apply this fix when an SB Live! is present but under</span>
<span class="cm">	 *	both Linux and Windows this isn&#39;t enough, and we have seen</span>
<span class="cm">	 *	corruption without SB Live! but with things like 3 UDMA IDE</span>
<span class="cm">	 *	controllers. So we ignore that bit of the VIA recommendation..</span>
<span class="cm">	 */</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x76</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busarb</span><span class="p">);</span>
	<span class="cm">/* Set bit 4 and bi 5 of byte 76 to 0x01 </span>
<span class="cm">	   &quot;Master priority rotation on every PCI master grant */</span>
	<span class="n">busarb</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">busarb</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x76</span><span class="p">,</span> <span class="n">busarb</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Applying VIA southbridge workaround</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8363_0</span><span class="p">,</span>	<span class="n">quirk_vialatency</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8371_1</span><span class="p">,</span>	<span class="n">quirk_vialatency</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8361</span><span class="p">,</span>		<span class="n">quirk_vialatency</span><span class="p">);</span>
<span class="cm">/* Must restore this on a resume from RAM */</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8363_0</span><span class="p">,</span>	<span class="n">quirk_vialatency</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8371_1</span><span class="p">,</span>	<span class="n">quirk_vialatency</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8361</span><span class="p">,</span>		<span class="n">quirk_vialatency</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	VIA Apollo VP3 needs ETBF on BT848/878</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_viaetbf</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_pci_problems</span><span class="o">&amp;</span><span class="n">PCIPCI_VIAETBF</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Limiting direct PCI/PCI transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_pci_problems</span> <span class="o">|=</span> <span class="n">PCIPCI_VIAETBF</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C597_0</span><span class="p">,</span>	<span class="n">quirk_viaetbf</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_vsfx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_pci_problems</span><span class="o">&amp;</span><span class="n">PCIPCI_VSFX</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Limiting direct PCI/PCI transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_pci_problems</span> <span class="o">|=</span> <span class="n">PCIPCI_VSFX</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C576</span><span class="p">,</span>	<span class="n">quirk_vsfx</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Ali Magik requires workarounds to be used by the drivers</span>
<span class="cm"> *	that DMA to AGP space. Latency must be set to 0xA and triton</span>
<span class="cm"> *	workaround applied too</span>
<span class="cm"> *	[Info kindly provided by ALi]</span>
<span class="cm"> */</span>	
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">quirk_alimagik</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_pci_problems</span><span class="o">&amp;</span><span class="n">PCIPCI_ALIMAGIK</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Limiting direct PCI/PCI transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_pci_problems</span> <span class="o">|=</span> <span class="n">PCIPCI_ALIMAGIK</span><span class="o">|</span><span class="n">PCIPCI_TRITON</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_AL_M1647</span><span class="p">,</span> 	<span class="n">quirk_alimagik</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_AL_M1651</span><span class="p">,</span> 	<span class="n">quirk_alimagik</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Natoma has some interesting boundary conditions with Zoran stuff</span>
<span class="cm"> *	at least</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_natoma</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pci_pci_problems</span><span class="o">&amp;</span><span class="n">PCIPCI_NATOMA</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Limiting direct PCI/PCI transfers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_pci_problems</span> <span class="o">|=</span> <span class="n">PCIPCI_NATOMA</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82441</span><span class="p">,</span> 	<span class="n">quirk_natoma</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82443LX_0</span><span class="p">,</span> 	<span class="n">quirk_natoma</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82443LX_1</span><span class="p">,</span> 	<span class="n">quirk_natoma</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82443BX_0</span><span class="p">,</span> 	<span class="n">quirk_natoma</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82443BX_1</span><span class="p">,</span> 	<span class="n">quirk_natoma</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> 	<span class="n">PCI_DEVICE_ID_INTEL_82443BX_2</span><span class="p">,</span> 	<span class="n">quirk_natoma</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  This chip can cause PCI parity errors if config register 0xA0 is read</span>
<span class="cm"> *  while DMAs are occurring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_citrine</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cfg_size</span> <span class="o">=</span> <span class="mh">0xA0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_IBM</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_IBM_CITRINE</span><span class="p">,</span>	<span class="n">quirk_citrine</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  S3 868 and 968 chips report region size equal to 32M, but they decode 64M.</span>
<span class="cm"> *  If it&#39;s needed, re-allocate the region.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_s3_64M</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;</span> <span class="mh">0x3ffffff</span><span class="p">)</span> <span class="o">||</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">!=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="mh">0x3ffffff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="mh">0x3ffffff</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_S3</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_S3_868</span><span class="p">,</span>		<span class="n">quirk_s3_64M</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_S3</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_S3_968</span><span class="p">,</span>		<span class="n">quirk_s3_64M</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Some CS5536 BIOSes (for example, the Soekris NET5501 board w/ comBIOS</span>
<span class="cm"> * ver. 1.33  20070103) don&#39;t set the correct ISA PCI region header info.</span>
<span class="cm"> * BAR0 should be 8 bytes; instead, it may be set to something like 8k</span>
<span class="cm"> * (which conflicts w/ BAR1&#39;s memory range).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_cs5536_vsa</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CS5536 ISA bridge bug detected &quot;</span>
				<span class="s">&quot;(incorrect header); workaround applied.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_CS5536_ISA</span><span class="p">,</span> <span class="n">quirk_cs5536_vsa</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_io_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">region</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">region</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_bus_region</span> <span class="n">bus_region</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span> <span class="o">+</span> <span class="n">nr</span><span class="p">;</span>

		<span class="n">res</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">region</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IO</span><span class="p">;</span>

		<span class="cm">/* Convert from PCI bus to resource space.  */</span>
		<span class="n">bus_region</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="n">bus_region</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
		<span class="n">pcibios_bus_to_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_region</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_claim_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">nr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;quirk: %pR claimed by %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">res</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>	

<span class="cm">/*</span>
<span class="cm"> *	ATI Northbridge setups MCE the processor if you even</span>
<span class="cm"> *	read somewhere between 0x3b0-&gt;0x3bb or read 0x3d3</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_ati_exploding_mce</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ATI Northbridge, reserving I/O ports 0x3b0 to 0x3bb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Mae rhaid i ni beidio ag edrych ar y lleoliadiau I/O hyn */</span>
	<span class="n">request_region</span><span class="p">(</span><span class="mh">0x3b0</span><span class="p">,</span> <span class="mh">0x0C</span><span class="p">,</span> <span class="s">&quot;RadeonIGP&quot;</span><span class="p">);</span>
	<span class="n">request_region</span><span class="p">(</span><span class="mh">0x3d3</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s">&quot;RadeonIGP&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_ATI_RS100</span><span class="p">,</span>   <span class="n">quirk_ati_exploding_mce</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Let&#39;s make the southbridge information explicit instead</span>
<span class="cm"> * of having to worry about people probing the ACPI areas,</span>
<span class="cm"> * for example.. (Yes, it happens, and if you read the wrong</span>
<span class="cm"> * ACPI register it will put the machine to sleep with no</span>
<span class="cm"> * way of waking it up again. Bummer).</span>
<span class="cm"> *</span>
<span class="cm"> * ALI M7101: Two IO regions pointed to by words at</span>
<span class="cm"> *	0xE0 (64 bytes of ACPI registers)</span>
<span class="cm"> *	0xE2 (32 bytes of SMB registers)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_ali7101_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">region</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xE0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
	<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">,</span> <span class="s">&quot;ali7101 ACPI&quot;</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xE2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
	<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ali7101 SMB&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AL_M7101</span><span class="p">,</span>		<span class="n">quirk_ali7101_acpi</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">piix4_io_quirk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">devres</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devres</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">devres</span> <span class="o">&amp;</span> <span class="n">enable</span><span class="p">)</span> <span class="o">!=</span> <span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">devres</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">devres</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">bit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * For now we only print it out. Eventually we&#39;ll want to</span>
<span class="cm">	 * reserve it (at least if it&#39;s in the 0x1000+ range), but</span>
<span class="cm">	 * let&#39;s get enough confirmation reports first. </span>
<span class="cm">	 */</span>
	<span class="n">base</span> <span class="o">&amp;=</span> <span class="o">-</span><span class="n">size</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s PIO at %04x-%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">piix4_mem_quirk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">devres</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devres</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">devres</span> <span class="o">&amp;</span> <span class="n">enable</span><span class="p">)</span> <span class="o">!=</span> <span class="n">enable</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">devres</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">devres</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">bit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * For now we only print it out. Eventually we&#39;ll want to</span>
<span class="cm">	 * reserve it, but let&#39;s get enough confirmation reports first. </span>
<span class="cm">	 */</span>
	<span class="n">base</span> <span class="o">&amp;=</span> <span class="o">-</span><span class="n">size</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s MMIO at %04x-%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * PIIX4 ACPI: Two IO regions pointed to by longwords at</span>
<span class="cm"> *	0x40 (64 bytes of ACPI registers)</span>
<span class="cm"> *	0x90 (16 bytes of SMB registers)</span>
<span class="cm"> * and a few strange programmable PIIX4 device resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_piix4_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">region</span><span class="p">,</span> <span class="n">res_a</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
	<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">,</span> <span class="s">&quot;PIIX4 ACPI&quot;</span><span class="p">);</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
	<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;PIIX4 SMB&quot;</span><span class="p">);</span>

	<span class="cm">/* Device resource A has enables for some of the other ones */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res_a</span><span class="p">);</span>

	<span class="n">piix4_io_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX4 devres B&quot;</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">,</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">);</span>
	<span class="n">piix4_io_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX4 devres C&quot;</span><span class="p">,</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">);</span>

	<span class="cm">/* Device resource D is just bitfields for static resources */</span>

	<span class="cm">/* Device 12 enabled? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res_a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">piix4_io_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX4 devres E&quot;</span><span class="p">,</span> <span class="mh">0x68</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">piix4_mem_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX4 devres F&quot;</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Device 13 enabled? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res_a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">piix4_io_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX4 devres G&quot;</span><span class="p">,</span> <span class="mh">0x70</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">piix4_mem_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX4 devres H&quot;</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">piix4_io_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX4 devres I&quot;</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">piix4_io_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PIIX4 devres J&quot;</span><span class="p">,</span> <span class="mh">0x7c</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82371AB_3</span><span class="p">,</span>	<span class="n">quirk_piix4_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82443MX_3</span><span class="p">,</span>	<span class="n">quirk_piix4_acpi</span><span class="p">);</span>

<span class="cp">#define ICH_PMBASE	0x40</span>
<span class="cp">#define ICH_ACPI_CNTL	0x44</span>
<span class="cp">#define  ICH4_ACPI_EN	0x10</span>
<span class="cp">#define  ICH6_ACPI_EN	0x80</span>
<span class="cp">#define ICH4_GPIOBASE	0x58</span>
<span class="cp">#define ICH4_GPIO_CNTL	0x5c</span>
<span class="cp">#define  ICH4_GPIO_EN	0x10</span>
<span class="cp">#define ICH6_GPIOBASE	0x48</span>
<span class="cp">#define ICH6_GPIO_CNTL	0x4c</span>
<span class="cp">#define  ICH6_GPIO_EN	0x10</span>

<span class="cm">/*</span>
<span class="cm"> * ICH4, ICH4-M, ICH5, ICH5-M ACPI: Three IO regions pointed to by longwords at</span>
<span class="cm"> *	0x40 (128 bytes of ACPI, GPIO &amp; TCO registers)</span>
<span class="cm"> *	0x58 (64 bytes of GPIO I/O space)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_ich4_lpc_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">region</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">enable</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The check for PCIBIOS_MIN_IO is to ensure we won&#39;t create a conflict</span>
<span class="cm">	 * with low legacy (and fixed) ports. We don&#39;t know the decoding</span>
<span class="cm">	 * priority and can&#39;t tell whether the legacy device or the one created</span>
<span class="cm">	 * here is really at that address.  This happens on boards with broken</span>
<span class="cm">	 * BIOSes.</span>
<span class="cm">	*/</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICH_ACPI_CNTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">ICH4_ACPI_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICH_PMBASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
		<span class="n">region</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">region</span> <span class="o">&gt;=</span> <span class="n">PCIBIOS_MIN_IO</span><span class="p">)</span>
			<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">,</span>
					<span class="s">&quot;ICH4 ACPI/GPIO/TCO&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICH4_GPIO_CNTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">ICH4_GPIO_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICH4_GPIOBASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
		<span class="n">region</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">region</span> <span class="o">&gt;=</span> <span class="n">PCIBIOS_MIN_IO</span><span class="p">)</span>
			<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span>
					<span class="n">PCI_BRIDGE_RESOURCES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ICH4 GPIO&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801AA_0</span><span class="p">,</span>		<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801AB_0</span><span class="p">,</span>		<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801BA_0</span><span class="p">,</span>		<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801BA_10</span><span class="p">,</span>	<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801CA_0</span><span class="p">,</span>		<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801CA_12</span><span class="p">,</span>	<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801DB_0</span><span class="p">,</span>		<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801DB_12</span><span class="p">,</span>	<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_82801EB_0</span><span class="p">,</span>		<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>    <span class="n">PCI_DEVICE_ID_INTEL_ESB_1</span><span class="p">,</span>		<span class="n">quirk_ich4_lpc_acpi</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">ich6_lpc_acpi_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">region</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">enable</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICH_ACPI_CNTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">ICH6_ACPI_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICH_PMBASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
		<span class="n">region</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">region</span> <span class="o">&gt;=</span> <span class="n">PCIBIOS_MIN_IO</span><span class="p">)</span>
			<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">,</span>
					<span class="s">&quot;ICH6 ACPI/GPIO/TCO&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICH6_GPIO_CNTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">&amp;</span> <span class="n">ICH6_GPIO_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ICH6_GPIOBASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
		<span class="n">region</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">region</span> <span class="o">&gt;=</span> <span class="n">PCIBIOS_MIN_IO</span><span class="p">)</span>
			<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span>
					<span class="n">PCI_BRIDGE_RESOURCES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ICH6 GPIO&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">ich6_lpc_generic_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dynsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">,</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Enabled? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xfffc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dynsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is not correct. It is 16, 32 or 64 bytes depending on</span>
<span class="cm">		 * register D31:F0:ADh bits 5:4.</span>
<span class="cm">		 *</span>
<span class="cm">		 * But this gets us at least _part_ of it.</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">base</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Just print it out for now. We should reserve it after more debugging */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s PIO at %04x-%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="o">+</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_ich6_lpc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Shared ACPI/GPIO decode with all ICH6+ */</span>
	<span class="n">ich6_lpc_acpi_gpio</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* ICH6-specific generic IO decode */</span>
	<span class="n">ich6_lpc_generic_decode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="s">&quot;LPC Generic IO decode 1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ich6_lpc_generic_decode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="s">&quot;LPC Generic IO decode 2&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH6_0</span><span class="p">,</span> <span class="n">quirk_ich6_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH6_1</span><span class="p">,</span> <span class="n">quirk_ich6_lpc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">ich7_lpc_generic_decode</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">base</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Enabled? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * IO base in bits 15:2, mask in bits 23:18, both</span>
<span class="cm">	 * are dword-based</span>
<span class="cm">	 */</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xfffc</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfc</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">|=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* Just print it out for now. We should reserve it after more debugging */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s PIO at %04x (mask %04x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ICH7-10 has the same common LPC generic IO decode registers */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_ich7_lpc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We share the common ACPI/GPIO decode with ICH6 */</span>
	<span class="n">ich6_lpc_acpi_gpio</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* And have 4 ICH7+ generic decodes */</span>
	<span class="n">ich7_lpc_generic_decode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="s">&quot;ICH7 LPC Generic IO decode 1&quot;</span><span class="p">);</span>
	<span class="n">ich7_lpc_generic_decode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="s">&quot;ICH7 LPC Generic IO decode 2&quot;</span><span class="p">);</span>
	<span class="n">ich7_lpc_generic_decode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">,</span> <span class="s">&quot;ICH7 LPC Generic IO decode 3&quot;</span><span class="p">);</span>
	<span class="n">ich7_lpc_generic_decode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="s">&quot;ICH7 LPC Generic IO decode 4&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH7_0</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH7_1</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH7_31</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH8_0</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH8_2</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH8_3</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH8_1</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH8_4</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH9_2</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH9_4</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH9_7</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH9_8</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>   <span class="n">PCI_DEVICE_ID_INTEL_ICH10_1</span><span class="p">,</span> <span class="n">quirk_ich7_lpc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * VIA ACPI: One IO region pointed to by longword at</span>
<span class="cm"> *	0x48 or 0x20 (256 bytes of ACPI registers)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_vt82c586_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">region</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">);</span>
		<span class="n">region</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
		<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">,</span> <span class="s">&quot;vt82c586 ACPI&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C586_3</span><span class="p">,</span>	<span class="n">quirk_vt82c586_acpi</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * VIA VT82C686 ACPI: Three IO region pointed to by (long)words at</span>
<span class="cm"> *	0x48 (256 bytes of ACPI registers)</span>
<span class="cm"> *	0x70 (128 bytes of hardware monitoring register)</span>
<span class="cm"> *	0x90 (16 bytes of SMB registers)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_vt82c686_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">hm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">smb</span><span class="p">;</span>

	<span class="n">quirk_vt82c586_acpi</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x70</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hm</span><span class="p">);</span>
	<span class="n">hm</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
	<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;vt82c686 HW-mon&quot;</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smb</span><span class="p">);</span>
	<span class="n">smb</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
	<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smb</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;vt82c686 SMB&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C686_4</span><span class="p">,</span>	<span class="n">quirk_vt82c686_acpi</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * VIA VT8235 ISA Bridge: Two IO regions pointed to by words at</span>
<span class="cm"> *	0x88 (128 bytes of power management registers)</span>
<span class="cm"> *	0xd0 (16 bytes of SMB registers)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_vt8235_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pm</span><span class="p">,</span> <span class="n">smb</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pm</span><span class="p">);</span>
	<span class="n">pm</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
	<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">,</span> <span class="s">&quot;vt8235 PM&quot;</span><span class="p">);</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xd0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smb</span><span class="p">);</span>
	<span class="n">smb</span> <span class="o">&amp;=</span> <span class="n">PCI_BASE_ADDRESS_IO_MASK</span><span class="p">;</span>
	<span class="n">quirk_io_region</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">smb</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">PCI_BRIDGE_RESOURCES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;vt8235 SMB&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8235</span><span class="p">,</span>	<span class="n">quirk_vt8235_acpi</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * TI XIO2000a PCIe-PCI Bridge erroneously reports it supports fast back-to-back:</span>
<span class="cm"> *	Disable fast back-to-back on the secondary bus segment</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_xio2000a</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">command</span><span class="p">;</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TI XIO2000a quirk detected; &quot;</span>
		<span class="s">&quot;secondary bus fast back-to-back transfers disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">bus_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_FAST_BACK</span><span class="p">)</span>
			<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">command</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_COMMAND_FAST_BACK</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_TI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_TI_XIO2000A</span><span class="p">,</span>
			<span class="n">quirk_xio2000a</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_IO_APIC </span>

<span class="cp">#include &lt;asm/io_apic.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * VIA 686A/B: If an IO-APIC is active, we need to route all on-chip</span>
<span class="cm"> * devices to the external APIC.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: When we have device-specific interrupt routers,</span>
<span class="cm"> * this code will go away from quirks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_via_ioapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_ioapics</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="cm">/* nothing routed to external APIC */</span>
	<span class="k">else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span> <span class="cm">/* all known bits (4-0) routed to external APIC */</span>
		
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%sbling VIA external APIC routing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;Disa&quot;</span> <span class="o">:</span> <span class="s">&quot;Ena&quot;</span><span class="p">);</span>

	<span class="cm">/* Offset 0x58: External APIC IRQ output control */</span>
	<span class="n">pci_write_config_byte</span> <span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x58</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C686</span><span class="p">,</span>	<span class="n">quirk_via_ioapic</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C686</span><span class="p">,</span>	<span class="n">quirk_via_ioapic</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * VIA 8237: Some BIOSs don&#39;t set the &#39;Bypass APIC De-Assert Message&#39; Bit.</span>
<span class="cm"> * This leads to doubled level interrupt rates.</span>
<span class="cm"> * Set this bit to get rid of cycle wastage.</span>
<span class="cm"> * Otherwise uncritical.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_via_vt8237_bypass_apic_deassert</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">misc_control2</span><span class="p">;</span>
<span class="cp">#define BYPASS_APIC_DEASSERT 8</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">misc_control2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">misc_control2</span> <span class="o">&amp;</span> <span class="n">BYPASS_APIC_DEASSERT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bypassing VIA 8237 APIC De-Assert Message</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="n">misc_control2</span><span class="o">|</span><span class="n">BYPASS_APIC_DEASSERT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8237</span><span class="p">,</span>		<span class="n">quirk_via_vt8237_bypass_apic_deassert</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8237</span><span class="p">,</span>		<span class="n">quirk_via_vt8237_bypass_apic_deassert</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The AMD io apic can hang the box when an apic irq is masked.</span>
<span class="cm"> * We check all revs &gt;= B0 (yet not in the pre production!) as the bug</span>
<span class="cm"> * is currently marked NoFix</span>
<span class="cm"> *</span>
<span class="cm"> * We have multiple reports of hangs with this chipset that went away with</span>
<span class="cm"> * noapic specified. For the moment we assume it&#39;s the erratum. We may be wrong</span>
<span class="cm"> * of course. However the advice is demonstrably good even if so..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_amd_ioapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mh">0x02</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;I/O APIC: AMD Erratum #22 may be present. In the event of instability try</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;        : booting with the </span><span class="se">\&quot;</span><span class="s">noapic</span><span class="se">\&quot;</span><span class="s"> option</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AMD_VIPER_7410</span><span class="p">,</span>	<span class="n">quirk_amd_ioapic</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">quirk_ioapic_rmw</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sis_apic_bug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_ANY_ID</span><span class="p">,</span>			<span class="n">quirk_ioapic_rmw</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_IO_APIC */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Some settings of MMRBC can lead to data corruption so block changes.</span>
<span class="cm"> * See AMD 8131 HyperTransport PCI-X Tunnel Revision Guide</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">quirk_amd_8131_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;=</span> <span class="mh">0x12</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;AMD8131 rev %x detected; &quot;</span>
			<span class="s">&quot;disabling PCI-X MMRBC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">bus_flags</span> <span class="o">|=</span> <span class="n">PCI_BUS_FLAGS_NO_MMRBC</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_8131_BRIDGE</span><span class="p">,</span> <span class="n">quirk_amd_8131_mmrbc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME: it is questionable that quirk_via_acpi</span>
<span class="cm"> * is needed.  It shows up as an ISA bridge, and does not</span>
<span class="cm"> * support the PCI_INTERRUPT_LINE register at all.  Therefore</span>
<span class="cm"> * it seems like setting the pci_dev&#39;s &#39;irq&#39; to the</span>
<span class="cm"> * value of the ACPI SCI interrupt is only done for convenience.</span>
<span class="cm"> *	-jgarzik</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_via_acpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * VIA ACPI device: SCI IRQ line in PCI config byte 0x42</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">&amp;=</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">irq</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C586_3</span><span class="p">,</span>	<span class="n">quirk_via_acpi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C686_4</span><span class="p">,</span>	<span class="n">quirk_via_acpi</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> *	VIA bridges which have VLink</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">via_vlink_dev_lo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">via_vlink_dev_hi</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_via_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* See what bridge we have and find the device ranges */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIA_82C686</span>:
		<span class="cm">/* The VT82C686 is special, it attaches to PCI and can have</span>
<span class="cm">		   any device number. All its subdevices are functions of</span>
<span class="cm">		   that single device. */</span>
		<span class="n">via_vlink_dev_lo</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="n">via_vlink_dev_hi</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIA_8237</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIA_8237A</span>:
		<span class="n">via_vlink_dev_lo</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIA_8235</span>:
		<span class="n">via_vlink_dev_lo</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIA_8231</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIA_8233_0</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIA_8233A</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_VIA_8233C_0</span>:
		<span class="n">via_vlink_dev_lo</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C686</span><span class="p">,</span>	<span class="n">quirk_via_bridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8231</span><span class="p">,</span>		<span class="n">quirk_via_bridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8233_0</span><span class="p">,</span>	<span class="n">quirk_via_bridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8233A</span><span class="p">,</span>	<span class="n">quirk_via_bridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8233C_0</span><span class="p">,</span>	<span class="n">quirk_via_bridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8235</span><span class="p">,</span>		<span class="n">quirk_via_bridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8237</span><span class="p">,</span>		<span class="n">quirk_via_bridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8237A</span><span class="p">,</span>	<span class="n">quirk_via_bridge</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	quirk_via_vlink		-	VIA VLink IRQ number update</span>
<span class="cm"> *	@dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> *	If the device we are dealing with is on a PIC IRQ we need to</span>
<span class="cm"> *	ensure that the IRQ line register which usually is not relevant</span>
<span class="cm"> *	for PCI cards, is actually written so that interrupts get sent</span>
<span class="cm"> *	to the right place.</span>
<span class="cm"> *	We only do this on systems where a VIA south bridge was detected,</span>
<span class="cm"> *	and only for VIA devices on the motherboard (see quirk_via_bridge</span>
<span class="cm"> *	above).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_via_vlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">irq</span><span class="p">,</span> <span class="n">new_irq</span><span class="p">;</span>

	<span class="cm">/* Check if we have VLink at all */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">via_vlink_dev_lo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">new_irq</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t quirk interrupts outside the legacy IRQ range */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_irq</span> <span class="o">||</span> <span class="n">new_irq</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Internal device ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">via_vlink_dev_hi</span> <span class="o">||</span>
	    <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">via_vlink_dev_lo</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* This is an internal VLink device on a PIC interrupt. The BIOS</span>
<span class="cm">	   ought to have set this but may not have, so we redo it */</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_INTERRUPT_LINE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_irq</span> <span class="o">!=</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VIA VLink IRQ fixup, from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">irq</span><span class="p">,</span> <span class="n">new_irq</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>	<span class="cm">/* unknown if delay really needed */</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_INTERRUPT_LINE</span><span class="p">,</span> <span class="n">new_irq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_ENABLE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">quirk_via_vlink</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * VIA VT82C598 has its device ID settable and many BIOSes</span>
<span class="cm"> * set it to the ID of VT82C597 for backward compatibility.</span>
<span class="cm"> * We need to switch it off to be able to recognize the real</span>
<span class="cm"> * type of the chip.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_vt82c598_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_82C597_0</span><span class="p">,</span>	<span class="n">quirk_vt82c598_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CardBus controllers have a legacy base address that enables them</span>
<span class="cm"> * to respond as i82365 pcmcia controllers.  We don&#39;t want them to</span>
<span class="cm"> * do this even if the Linux CardBus driver is not loaded, because</span>
<span class="cm"> * the Linux i82365 driver does not (and should not) handle CardBus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_cardbus_legacy</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CB_LEGACY_MODE_BASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_FINAL</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
			<span class="n">PCI_CLASS_BRIDGE_CARDBUS</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_cardbus_legacy</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
			<span class="n">PCI_CLASS_BRIDGE_CARDBUS</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_cardbus_legacy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Following the PCI ordering rules is optional on the AMD762. I&#39;m not</span>
<span class="cm"> * sure what the designers were smoking but let&#39;s not inhale...</span>
<span class="cm"> *</span>
<span class="cm"> * To be fair to AMD, it follows the spec by default, its BIOS people</span>
<span class="cm"> * who turn it off!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_amd_ordering</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pcic</span><span class="p">;</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pcic</span><span class="o">&amp;</span><span class="mi">6</span><span class="p">)</span><span class="o">!=</span><span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pcic</span> <span class="o">|=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BIOS failed to enable PCI standards compliance; fixing this error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span> <span class="n">pcic</span><span class="p">);</span>
		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcic</span><span class="p">);</span>
		<span class="n">pcic</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">23</span><span class="p">);</span>	<span class="cm">/* Required in this mode */</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="n">pcic</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AMD_FE_GATE_700C</span><span class="p">,</span> <span class="n">quirk_amd_ordering</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AMD_FE_GATE_700C</span><span class="p">,</span> <span class="n">quirk_amd_ordering</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	DreamWorks provided workaround for Dunord I-3000 problem</span>
<span class="cm"> *</span>
<span class="cm"> *	This card decodes and responds to addresses not apparently</span>
<span class="cm"> *	assigned to it. We force a larger allocation to ensure that</span>
<span class="cm"> *	nothing gets put too close to it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_dunord</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">dev</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="mh">0xffffff</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_DUNORD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_DUNORD_I3000</span><span class="p">,</span>	<span class="n">quirk_dunord</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * i82380FB mobile docking controller: its PCI-to-PCI bridge</span>
<span class="cm"> * is subtractive decoding (transparent), and does indicate this</span>
<span class="cm"> * in the ProgIf. Unfortunately, the ProgIf value is wrong - 0x80</span>
<span class="cm"> * instead of 0x01.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_transparent_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">transparent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82380FB</span><span class="p">,</span>	<span class="n">quirk_transparent_bridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_TOSHIBA</span><span class="p">,</span>	<span class="mh">0x605</span><span class="p">,</span>	<span class="n">quirk_transparent_bridge</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Common misconfiguration of the MediaGX/Geode PCI master that will</span>
<span class="cm"> * reduce PCI bandwidth from 70MB/s to 25MB/s.  See the GXM/GXLV/GX1</span>
<span class="cm"> * datasheets found at http://www.national.com/analog for info on what</span>
<span class="cm"> * these bits do.  &lt;christer@weinigel.se&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_mediagx_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Fixup for MediaGX/Geode Slave Disconnect Boundary (0x41=0x%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
                <span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CYRIX</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_CYRIX_PCI_MASTER</span><span class="p">,</span> <span class="n">quirk_mediagx_master</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_CYRIX</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_CYRIX_PCI_MASTER</span><span class="p">,</span> <span class="n">quirk_mediagx_master</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Ensure C0 rev restreaming is off. This is normally done by</span>
<span class="cm"> *	the BIOS but in the odd case it is not the results are corruption</span>
<span class="cm"> *	hence the presence of a Linux check</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_disable_pxb</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">config</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">!=</span> <span class="mh">0x04</span><span class="p">)</span>		<span class="cm">/* Only C0 requires this */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">config</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">6</span><span class="p">);</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;C0 revision 450NX. Disabling PCI restreaming</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82454NX</span><span class="p">,</span>	<span class="n">quirk_disable_pxb</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82454NX</span><span class="p">,</span>	<span class="n">quirk_disable_pxb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_amd_ide_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* set SBX00/Hudson-2 SATA in IDE mode to AHCI mode */</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CLASS_DEVICE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">tmp</span><span class="o">|</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x9</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0xa</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_STORAGE_SATA_AHCI</span><span class="p">;</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;set SATA to AHCI mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ATI_IXP600_SATA</span><span class="p">,</span> <span class="n">quirk_amd_ide_mode</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ATI_IXP600_SATA</span><span class="p">,</span> <span class="n">quirk_amd_ide_mode</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ATI_IXP700_SATA</span><span class="p">,</span> <span class="n">quirk_amd_ide_mode</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ATI_IXP700_SATA</span><span class="p">,</span> <span class="n">quirk_amd_ide_mode</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_HUDSON2_SATA_IDE</span><span class="p">,</span> <span class="n">quirk_amd_ide_mode</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_HUDSON2_SATA_IDE</span><span class="p">,</span> <span class="n">quirk_amd_ide_mode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Serverworks CSB5 IDE does not fully support native mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_svwks_csb5ide</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">prog</span><span class="p">;</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CLASS_PROG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prog</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prog</span> <span class="o">&amp;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prog</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CLASS_PROG</span><span class="p">,</span> <span class="n">prog</span><span class="p">);</span>
		<span class="cm">/* PCI layer will sort out resources */</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SERVERWORKS</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SERVERWORKS_CSB5IDE</span><span class="p">,</span> <span class="n">quirk_svwks_csb5ide</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Intel 82801CAM ICH3-M datasheet says IDE modes must be the same</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">quirk_ide_samemode</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">prog</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CLASS_PROG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prog</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">prog</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">prog</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">prog</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">prog</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;IDE mode mismatch; forcing legacy mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">prog</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">5</span><span class="p">;</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CLASS_PROG</span><span class="p">,</span> <span class="n">prog</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82801CA_10</span><span class="p">,</span> <span class="n">quirk_ide_samemode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Some ATA devices break if put into D3</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_no_ata_d3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">|=</span> <span class="n">PCI_DEV_FLAGS_NO_D3</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* Quirk the legacy ATA devices only. The AHCI ones are ok */</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SERVERWORKS</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
				<span class="n">PCI_CLASS_STORAGE_IDE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_no_ata_d3</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
				<span class="n">PCI_CLASS_STORAGE_IDE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_no_ata_d3</span><span class="p">);</span>
<span class="cm">/* ALi loses some register settings that we cannot then restore */</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
				<span class="n">PCI_CLASS_STORAGE_IDE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_no_ata_d3</span><span class="p">);</span>
<span class="cm">/* VIA comes back fine but we need to keep it alive or ACPI GTM failures</span>
<span class="cm">   occur when mode detecting */</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
				<span class="n">PCI_CLASS_STORAGE_IDE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_no_ata_d3</span><span class="p">);</span>

<span class="cm">/* This was originally an Alpha specific thing, but it really fits here.</span>
<span class="cm"> * The i82375 PCI/EISA bridge appears as non-classified. Fix that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">quirk_eisa_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_BRIDGE_EISA</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82375</span><span class="p">,</span>	<span class="n">quirk_eisa_bridge</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * On ASUS P4B boards, the SMBus PCI Device within the ICH2/4 southbridge</span>
<span class="cm"> * is not activated. The myth is that Asus said that they do not want the</span>
<span class="cm"> * users to be irritated by just another PCI Device in the Win98 device</span>
<span class="cm"> * manager. (see the file prog/hotplug/README.p4b in the lm_sensors </span>
<span class="cm"> * package 2.7.0 for details)</span>
<span class="cm"> *</span>
<span class="cm"> * The SMBus PCI Device can be activated by setting a bit in the ICH LPC </span>
<span class="cm"> * bridge. Unfortunately, this device has no subvendor/subdevice ID. So it </span>
<span class="cm"> * becomes necessary to do this tweak in two steps -- the chosen trigger</span>
<span class="cm"> * is either the Host bridge (preferred) or on-board VGA controller.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we used to unhide the SMBus that way on Toshiba laptops</span>
<span class="cm"> * (Satellite A40 and Tecra M2) but then found that the thermal management</span>
<span class="cm"> * was done by SMM code, which could cause unsynchronized concurrent</span>
<span class="cm"> * accesses to the SMBus registers, with potentially bad effects. Thus you</span>
<span class="cm"> * should be very careful when adding new entries: if SMM is accessing the</span>
<span class="cm"> * Intel SMBus, this is a very good reason to leave it hidden.</span>
<span class="cm"> *</span>
<span class="cm"> * Likewise, many recent laptops use ACPI for thermal management. If the</span>
<span class="cm"> * ACPI DSDT code accesses the SMBus, then Linux should not access it</span>
<span class="cm"> * natively, and keeping the SMBus hidden is the right thing to do. If you</span>
<span class="cm"> * are about to add an entry in the table below, please first disassemble</span>
<span class="cm"> * the DSDT and double-check that there is no code accessing the SMBus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">asus_hides_smbus</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">asus_hides_smbus_hostbridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_ASUSTEK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82845_HB</span><span class="p">)</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x8025</span>: <span class="cm">/* P4B-LX */</span>
			<span class="k">case</span> <span class="mh">0x8070</span>: <span class="cm">/* P4B */</span>
			<span class="k">case</span> <span class="mh">0x8088</span>: <span class="cm">/* P4B533 */</span>
			<span class="k">case</span> <span class="mh">0x1626</span>: <span class="cm">/* L3C notebook */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82845G_HB</span><span class="p">)</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x80b1</span>: <span class="cm">/* P4GE-V */</span>
			<span class="k">case</span> <span class="mh">0x80b2</span>: <span class="cm">/* P4PE */</span>
			<span class="k">case</span> <span class="mh">0x8093</span>: <span class="cm">/* P4B533-V */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82850_HB</span><span class="p">)</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x8030</span>: <span class="cm">/* P4T533 */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_7205_0</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x8070</span>: <span class="cm">/* P4G8X Deluxe */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_E7501_MCH</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x80c9</span>: <span class="cm">/* PU-DLS */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82855GM_HB</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x1751</span>: <span class="cm">/* M2N notebook */</span>
			<span class="k">case</span> <span class="mh">0x1821</span>: <span class="cm">/* M5N notebook */</span>
			<span class="k">case</span> <span class="mh">0x1897</span>: <span class="cm">/* A6L notebook */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82855PM_HB</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x184b</span>: <span class="cm">/* W1N notebook */</span>
			<span class="k">case</span> <span class="mh">0x186a</span>: <span class="cm">/* M6Ne notebook */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82865_HB</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x80f2</span>: <span class="cm">/* P4P800-X */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82915GM_HB</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x1882</span>: <span class="cm">/* M6V notebook */</span>
			<span class="k">case</span> <span class="mh">0x1977</span>: <span class="cm">/* A6VA notebook */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_HP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>  <span class="n">PCI_DEVICE_ID_INTEL_82855PM_HB</span><span class="p">)</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x088C</span>: <span class="cm">/* HP Compaq nc8000 */</span>
			<span class="k">case</span> <span class="mh">0x0890</span>: <span class="cm">/* HP Compaq nc6000 */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82865_HB</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x12bc</span>: <span class="cm">/* HP D330L */</span>
			<span class="k">case</span> <span class="mh">0x12bd</span>: <span class="cm">/* HP D530 */</span>
			<span class="k">case</span> <span class="mh">0x006a</span>: <span class="cm">/* HP Compaq nx9500 */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82875_HB</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x12bf</span>: <span class="cm">/* HP xw4100 */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
       <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_SAMSUNG</span><span class="p">))</span> <span class="p">{</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span>  <span class="n">PCI_DEVICE_ID_INTEL_82855PM_HB</span><span class="p">)</span>
                       <span class="k">switch</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
                       <span class="k">case</span> <span class="mh">0xC00C</span>: <span class="cm">/* Samsung P35 notebook */</span>
                               <span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                       <span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_COMPAQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82855PM_HB</span><span class="p">)</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x0058</span>: <span class="cm">/* Compaq Evo N620c */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82810_IG3</span><span class="p">)</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0xB16C</span>: <span class="cm">/* Compaq Deskpro EP 401963-001 (PCA# 010174) */</span>
				<span class="cm">/* Motherboard doesn&#39;t have Host bridge</span>
<span class="cm">				 * subvendor/subdevice IDs, therefore checking</span>
<span class="cm">				 * its on-board VGA controller */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82801DB_2</span><span class="p">)</span>
			<span class="k">switch</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x00b8</span>: <span class="cm">/* Compaq Evo D510 CMT */</span>
			<span class="k">case</span> <span class="mh">0x00b9</span>: <span class="cm">/* Compaq Evo D510 SFF */</span>
			<span class="k">case</span> <span class="mh">0x00ba</span>: <span class="cm">/* Compaq Evo D510 USDT */</span>
				<span class="cm">/* Motherboard doesn&#39;t have Host bridge</span>
<span class="cm">				 * subvendor/subdevice IDs and on-board VGA</span>
<span class="cm">				 * controller is disabled if an AGP card is</span>
<span class="cm">				 * inserted, therefore checking USB UHCI</span>
<span class="cm">				 * Controller #1 */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_INTEL_82815_CGC</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mh">0x001A</span>: <span class="cm">/* Compaq Deskpro EN SSF P667 815E */</span>
				<span class="cm">/* Motherboard doesn&#39;t have host bridge</span>
<span class="cm">				 * subvendor/subdevice IDs, therefore checking</span>
<span class="cm">				 * its on-board VGA controller */</span>
				<span class="n">asus_hides_smbus</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82845_HB</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82845G_HB</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82850_HB</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82865_HB</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82875_HB</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_7205_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_E7501_MCH</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82855PM_HB</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82855GM_HB</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82915GM_HB</span><span class="p">,</span> <span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>

<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82810_IG3</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801DB_2</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82815_CGC</span><span class="p">,</span>	<span class="n">asus_hides_smbus_hostbridge</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_hides_smbus_lpc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">asus_hides_smbus</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xF2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xF2</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x8</span><span class="p">));</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xF2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;i801 SMBus device continues to play &#39;hide and seek&#39;! 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabled i801 SMBus device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801AA_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801DB_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801BA_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801CA_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801CA_12</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801DB_12</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801EB_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801AA_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801DB_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801BA_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801CA_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801CA_12</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801DB_12</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_82801EB_0</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc</span><span class="p">);</span>

<span class="cm">/* It appears we just have one such device. If not, we have a warning */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">asus_rcba_base</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_hides_smbus_lpc_ich6_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rcba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">asus_hides_smbus</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">asus_rcba_base</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xF0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcba</span><span class="p">);</span>
	<span class="cm">/* use bits 31:14, 16 kB aligned */</span>
	<span class="n">asus_rcba_base</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">rcba</span> <span class="o">&amp;</span> <span class="mh">0xFFFFC000</span><span class="p">,</span> <span class="mh">0x4000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">asus_rcba_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_hides_smbus_lpc_ich6_resume_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">asus_hides_smbus</span> <span class="o">||</span> <span class="o">!</span><span class="n">asus_rcba_base</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* read the Function Disable register, dword mode only */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">asus_rcba_base</span> <span class="o">+</span> <span class="mh">0x3418</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFF7</span><span class="p">,</span> <span class="n">asus_rcba_base</span> <span class="o">+</span> <span class="mh">0x3418</span><span class="p">);</span> <span class="cm">/* enable the SMBus device */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_hides_smbus_lpc_ich6_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">asus_hides_smbus</span> <span class="o">||</span> <span class="o">!</span><span class="n">asus_rcba_base</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">asus_rcba_base</span><span class="p">);</span>
	<span class="n">asus_rcba_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabled ICH6/i801 SMBus device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_hides_smbus_lpc_ich6</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">asus_hides_smbus_lpc_ich6_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">asus_hides_smbus_lpc_ich6_resume_early</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">asus_hides_smbus_lpc_ich6_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH6_1</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc_ich6</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_SUSPEND</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH6_1</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc_ich6_suspend</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH6_1</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc_ich6_resume</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ICH6_1</span><span class="p">,</span>	<span class="n">asus_hides_smbus_lpc_ich6_resume_early</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * SiS 96x south bridge: BIOS typically hides SMBus device...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_sis_96x_smbus</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x77</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabling SiS 96x SMBus</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x77</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x10</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_961</span><span class="p">,</span>		<span class="n">quirk_sis_96x_smbus</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_962</span><span class="p">,</span>		<span class="n">quirk_sis_96x_smbus</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_963</span><span class="p">,</span>		<span class="n">quirk_sis_96x_smbus</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_LPC</span><span class="p">,</span>		<span class="n">quirk_sis_96x_smbus</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_961</span><span class="p">,</span>		<span class="n">quirk_sis_96x_smbus</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_962</span><span class="p">,</span>		<span class="n">quirk_sis_96x_smbus</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_963</span><span class="p">,</span>		<span class="n">quirk_sis_96x_smbus</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_LPC</span><span class="p">,</span>		<span class="n">quirk_sis_96x_smbus</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * ... This is further complicated by the fact that some SiS96x south</span>
<span class="cm"> * bridges pretend to be 85C503/5513 instead.  In that case see if we</span>
<span class="cm"> * spotted a compatible north bridge to make sure.</span>
<span class="cm"> * (pci_find_device doesn&#39;t work yet)</span>
<span class="cm"> *</span>
<span class="cm"> * We can also enable the sis96x bit in the discovery register..</span>
<span class="cm"> */</span>
<span class="cp">#define SIS_DETECT_REGISTER 0x40</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_sis_503</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">devid</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SIS_DETECT_REGISTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SIS_DETECT_REGISTER</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">));</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">devid</span> <span class="o">&amp;</span> <span class="mh">0xfff0</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x0960</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">devid</span> <span class="o">!=</span> <span class="mh">0x0018</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SIS_DETECT_REGISTER</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, it now shows up as a 96x.. run the 96x quirk by</span>
<span class="cm">	 * hand in case it has already been processed.</span>
<span class="cm">	 * (depends on link order, which is apparently not guaranteed)</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">devid</span><span class="p">;</span>
	<span class="n">quirk_sis_96x_smbus</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_503</span><span class="p">,</span>		<span class="n">quirk_sis_503</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SI</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_SI_503</span><span class="p">,</span>		<span class="n">quirk_sis_503</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * On ASUS A8V and A8V Deluxe boards, the onboard AC97 audio controller</span>
<span class="cm"> * and MC97 modem controller are disabled when a second PCI soundcard is</span>
<span class="cm"> * present. This patch, tweaking the VT8237 ISA bridge, enables them.</span>
<span class="cm"> * -- bjd</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">asus_hides_ac97_lpc</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">asus_hides_ac97</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_ASUSTEK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_VIA_8237</span><span class="p">)</span>
			<span class="n">asus_hides_ac97</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asus_hides_ac97</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0xc0</span><span class="p">));</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Onboard AC97/MC97 devices continue to play &#39;hide and seek&#39;! 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabled onboard AC97/MC97 devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8237</span><span class="p">,</span> <span class="n">asus_hides_ac97_lpc</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_VIA_8237</span><span class="p">,</span> <span class="n">asus_hides_ac97_lpc</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_ATA) || defined(CONFIG_ATA_MODULE)</span>

<span class="cm">/*</span>
<span class="cm"> *	If we are using libata we can drive this chip properly but must</span>
<span class="cm"> *	do this early on to make the additional device appear during</span>
<span class="cm"> *	the PCI scanning.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_jmicron_ata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">conf1</span><span class="p">,</span> <span class="n">conf5</span><span class="p">,</span> <span class="n">class</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hdr</span><span class="p">;</span>

	<span class="cm">/* Only poke fn 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf1</span><span class="p">);</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf5</span><span class="p">);</span>

	<span class="n">conf1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x00CFF302</span><span class="p">;</span> <span class="cm">/* Clear bit 1, 8, 9, 12-19, 22, 23 */</span>
	<span class="n">conf5</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>  <span class="cm">/* Clear bit 24 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB360</span>: <span class="cm">/* SATA single port */</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB362</span>: <span class="cm">/* SATA dual ports */</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB364</span>: <span class="cm">/* SATA dual ports */</span>
		<span class="cm">/* The controller should be in single function ahci mode */</span>
		<span class="n">conf1</span> <span class="o">|=</span> <span class="mh">0x0002A100</span><span class="p">;</span> <span class="cm">/* Set 8, 13, 15, 17 */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB365</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB366</span>:
		<span class="cm">/* Redirect IDE second PATA port to the right spot */</span>
		<span class="n">conf5</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB361</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB363</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB369</span>:
		<span class="cm">/* Enable dual function mode, AHCI on fn 0, IDE fn1 */</span>
		<span class="cm">/* Set the class codes correctly and then direct IDE 0 */</span>
		<span class="n">conf1</span> <span class="o">|=</span> <span class="mh">0x00C2A1B3</span><span class="p">;</span> <span class="cm">/* Set 0, 1, 4, 5, 7, 8, 13, 15, 17, 22, 23 */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB368</span>:
		<span class="cm">/* The controller should be in single function IDE mode */</span>
		<span class="n">conf1</span> <span class="o">|=</span> <span class="mh">0x00C00000</span><span class="p">;</span> <span class="cm">/* Set 22, 23 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">conf1</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="n">conf5</span><span class="p">);</span>

	<span class="cm">/* Update pdev accordingly */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_HEADER_TYPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">);</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">hdr_type</span> <span class="o">=</span> <span class="n">hdr</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">multifunction</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">hdr</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CLASS_REVISION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">class</span><span class="p">);</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB360</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB361</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB362</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB363</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB364</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB365</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB366</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB368</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB369</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB360</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB361</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB362</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB363</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB364</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB365</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB366</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB368</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_JMICRON</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_JMICRON_JMB369</span><span class="p">,</span> <span class="n">quirk_jmicron_ata</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">quirk_alder_ioapic</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xff00</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* the first BAR is the location of the IO APIC...we must</span>
<span class="cm">	 * not touch this (and it&#39;s already covered by the fixmap), so</span>
<span class="cm">	 * forcibly insert it into the resource tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">insert_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iomem_resource</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* The next five BARs all seem to be rubbish, so just clean</span>
<span class="cm">	 * them out */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>

<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_EESSC</span><span class="p">,</span>	<span class="n">quirk_alder_ioapic</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_pcie_mch</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_msi_off</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">no_msi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_E7520_MCH</span><span class="p">,</span>	<span class="n">quirk_pcie_mch</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_E7320_MCH</span><span class="p">,</span>	<span class="n">quirk_pcie_mch</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_E7525_MCH</span><span class="p">,</span>	<span class="n">quirk_pcie_mch</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * It&#39;s possible for the MSI to get corrupted if shpc and acpi</span>
<span class="cm"> * are used together on certain PXH-based systems.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_pcie_pxh</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_msi_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">no_msi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PXH quirk detected; SHPC device MSI disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXHD_0</span><span class="p">,</span>	<span class="n">quirk_pcie_pxh</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXHD_1</span><span class="p">,</span>	<span class="n">quirk_pcie_pxh</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXH_0</span><span class="p">,</span>	<span class="n">quirk_pcie_pxh</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXH_1</span><span class="p">,</span>	<span class="n">quirk_pcie_pxh</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXHV</span><span class="p">,</span>	<span class="n">quirk_pcie_pxh</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Some Intel PCI Express chipsets have trouble with downstream</span>
<span class="cm"> * device power management.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_intel_pcie_pm</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_pm_d3_delay</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">no_d1d2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25e2</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25e3</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25e4</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25e5</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25e6</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25e7</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25f7</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25f8</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25f9</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x25fa</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2601</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2602</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2603</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2604</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2605</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2606</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2607</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2608</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x2609</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x260a</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x260b</span><span class="p">,</span> <span class="n">quirk_intel_pcie_pm</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
<span class="cm">/*</span>
<span class="cm"> * Boot interrupts on some chipsets cannot be turned off. For these chipsets,</span>
<span class="cm"> * remap the original interrupt in the linux kernel to the boot interrupt, so</span>
<span class="cm"> * that a PCI device&#39;s interrupt handler is installed on the boot interrupt</span>
<span class="cm"> * line instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_reroute_to_boot_interrupts_intel</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">noioapicquirk</span> <span class="o">||</span> <span class="n">noioapicreroute</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq_reroute_variant</span> <span class="o">=</span> <span class="n">INTEL_IRQ_REROUTE_VARIANT</span><span class="p">;</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rerouting interrupts for [%04x:%04x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_80333_0</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_80333_1</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ESB2_0</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXH_0</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXH_1</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXHV</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_80332_0</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_80332_1</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_80333_0</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_80333_1</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_ESB2_0</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXH_0</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXH_1</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_PXHV</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_80332_0</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_INTEL_80332_1</span><span class="p">,</span>	<span class="n">quirk_reroute_to_boot_interrupts_intel</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * On some chipsets we can disable the generation of legacy INTx boot</span>
<span class="cm"> * interrupts.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * IO-APIC1 on 6300ESB generates boot interrupts, see intel order no</span>
<span class="cm"> * 300641-004US, section 5.7.3.</span>
<span class="cm"> */</span>
<span class="cp">#define INTEL_6300_IOAPIC_ABAR		0x40</span>
<span class="cp">#define INTEL_6300_DISABLE_BOOT_IRQ	(1&lt;&lt;14)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_disable_intel_boot_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pci_config_word</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">noioapicquirk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">INTEL_6300_IOAPIC_ABAR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_config_word</span><span class="p">);</span>
	<span class="n">pci_config_word</span> <span class="o">|=</span> <span class="n">INTEL_6300_DISABLE_BOOT_IRQ</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">INTEL_6300_IOAPIC_ABAR</span><span class="p">,</span> <span class="n">pci_config_word</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;disabled boot interrupts on device [%04x:%04x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>   <span class="n">PCI_DEVICE_ID_INTEL_ESB_10</span><span class="p">,</span> 	<span class="n">quirk_disable_intel_boot_interrupt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>   <span class="n">PCI_DEVICE_ID_INTEL_ESB_10</span><span class="p">,</span> 	<span class="n">quirk_disable_intel_boot_interrupt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * disable boot interrupts on HT-1000</span>
<span class="cm"> */</span>
<span class="cp">#define BC_HT1000_FEATURE_REG		0x64</span>
<span class="cp">#define BC_HT1000_PIC_REGS_ENABLE	(1&lt;&lt;0)</span>
<span class="cp">#define BC_HT1000_MAP_IDX		0xC00</span>
<span class="cp">#define BC_HT1000_MAP_DATA		0xC01</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_disable_broadcom_boot_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pci_config_dword</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">noioapicquirk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">BC_HT1000_FEATURE_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_config_dword</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">BC_HT1000_FEATURE_REG</span><span class="p">,</span> <span class="n">pci_config_dword</span> <span class="o">|</span>
			<span class="n">BC_HT1000_PIC_REGS_ENABLE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">irq</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span> <span class="n">irq</span> <span class="o">&lt;</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="mi">32</span><span class="p">;</span> <span class="n">irq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">BC_HT1000_MAP_IDX</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">BC_HT1000_MAP_DATA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">BC_HT1000_FEATURE_REG</span><span class="p">,</span> <span class="n">pci_config_dword</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;disabled boot interrupts on device [%04x:%04x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SERVERWORKS</span><span class="p">,</span>   <span class="n">PCI_DEVICE_ID_SERVERWORKS_HT1000SB</span><span class="p">,</span> 	<span class="n">quirk_disable_broadcom_boot_interrupt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SERVERWORKS</span><span class="p">,</span>   <span class="n">PCI_DEVICE_ID_SERVERWORKS_HT1000SB</span><span class="p">,</span> 	<span class="n">quirk_disable_broadcom_boot_interrupt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * disable boot interrupts on AMD and ATI chipsets</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * NOIOAMODE needs to be disabled to disable &quot;boot interrupts&quot;. For AMD 8131</span>
<span class="cm"> * rev. A0 and B0, NOIOAMODE needs to be disabled anyway to fix IO-APIC mode</span>
<span class="cm"> * (due to an erratum).</span>
<span class="cm"> */</span>
<span class="cp">#define AMD_813X_MISC			0x40</span>
<span class="cp">#define AMD_813X_NOIOAMODE		(1&lt;&lt;0)</span>
<span class="cp">#define AMD_813X_REV_B1			0x12</span>
<span class="cp">#define AMD_813X_REV_B2			0x13</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_disable_amd_813x_boot_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pci_config_dword</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">noioapicquirk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="n">AMD_813X_REV_B1</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="n">AMD_813X_REV_B2</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">AMD_813X_MISC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_config_dword</span><span class="p">);</span>
	<span class="n">pci_config_dword</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">AMD_813X_NOIOAMODE</span><span class="p">;</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">AMD_813X_MISC</span><span class="p">,</span> <span class="n">pci_config_dword</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;disabled boot interrupts on device [%04x:%04x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AMD_8131_BRIDGE</span><span class="p">,</span>	<span class="n">quirk_disable_amd_813x_boot_interrupt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AMD_8131_BRIDGE</span><span class="p">,</span>	<span class="n">quirk_disable_amd_813x_boot_interrupt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AMD_8132_BRIDGE</span><span class="p">,</span>	<span class="n">quirk_disable_amd_813x_boot_interrupt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>	<span class="n">PCI_DEVICE_ID_AMD_8132_BRIDGE</span><span class="p">,</span>	<span class="n">quirk_disable_amd_813x_boot_interrupt</span><span class="p">);</span>

<span class="cp">#define AMD_8111_PCI_IRQ_ROUTING	0x56</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_disable_amd_8111_boot_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">pci_config_word</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">noioapicquirk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">AMD_8111_PCI_IRQ_ROUTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_config_word</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_config_word</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot interrupts on device [%04x:%04x] &quot;</span>
			 <span class="s">&quot;already disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">AMD_8111_PCI_IRQ_ROUTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;disabled boot interrupts on device [%04x:%04x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>   <span class="n">PCI_DEVICE_ID_AMD_8111_SMBUS</span><span class="p">,</span> 	<span class="n">quirk_disable_amd_8111_boot_interrupt</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span>   <span class="n">PCI_DEVICE_ID_AMD_8111_SMBUS</span><span class="p">,</span> 	<span class="n">quirk_disable_amd_8111_boot_interrupt</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_X86_IO_APIC */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Toshiba TC86C001 IDE controller reports the standard 8-byte BAR0 size</span>
<span class="cm"> * but the PIO transfers won&#39;t work if BAR0 falls at the odd 8 bytes.</span>
<span class="cm"> * Re-allocate the region if needed...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">quirk_tc86c001_ide</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_TOSHIBA_2</span><span class="p">,</span>
			 <span class="n">PCI_DEVICE_ID_TOSHIBA_TC86C001_IDE</span><span class="p">,</span>
			 <span class="n">quirk_tc86c001_ide</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_netmos</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_parallel</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_serial</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These Netmos parts are multiport serial devices with optional</span>
<span class="cm">	 * parallel ports.  Even when parallel ports are present, they</span>
<span class="cm">	 * are identified as class SERIAL, which means the serial driver</span>
<span class="cm">	 * will claim them.  To prevent this, mark them as class OTHER.</span>
<span class="cm">	 * These combo devices should be claimed by parport_serial.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The subdevice ID is of the form 0x00PS, where &lt;P&gt; is the number</span>
<span class="cm">	 * of parallel ports and &lt;S&gt; is the number of serial ports.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NETMOS_9835</span>:
		<span class="cm">/* Well, this rule doesn&#39;t hold for the following 9835 device */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_IBM</span> <span class="o">&amp;&amp;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">==</span> <span class="mh">0x0299</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NETMOS_9735</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NETMOS_9745</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NETMOS_9845</span>:
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_NETMOS_9855</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">num_parallel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Netmos %04x (%u parallel, &quot;</span>
				<span class="s">&quot;%u serial); changing class SERIAL to OTHER &quot;</span>
				<span class="s">&quot;(use parport_serial)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">num_parallel</span><span class="p">,</span> <span class="n">num_serial</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCI_CLASS_COMMUNICATION_OTHER</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NETMOS</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
			 <span class="n">PCI_CLASS_COMMUNICATION_SERIAL</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_netmos</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_e100_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">command</span><span class="p">,</span> <span class="n">pmcsr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">csr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cmd_hi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pm</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* PCI IDs taken from drivers/net/e100.c */</span>
	<span class="k">case</span> <span class="mh">0x1029</span>:
	<span class="k">case</span> <span class="mh">0x1030</span> <span class="p">...</span> <span class="mh">0x1034</span>:
	<span class="k">case</span> <span class="mh">0x1038</span> <span class="p">...</span> <span class="mh">0x103E</span>:
	<span class="k">case</span> <span class="mh">0x1050</span> <span class="p">...</span> <span class="mh">0x1057</span>:
	<span class="k">case</span> <span class="mh">0x1059</span>:
	<span class="k">case</span> <span class="mh">0x1064</span> <span class="p">...</span> <span class="mh">0x106B</span>:
	<span class="k">case</span> <span class="mh">0x1091</span> <span class="p">...</span> <span class="mh">0x1095</span>:
	<span class="k">case</span> <span class="mh">0x1209</span>:
	<span class="k">case</span> <span class="mh">0x1229</span>:
	<span class="k">case</span> <span class="mh">0x2449</span>:
	<span class="k">case</span> <span class="mh">0x2459</span>:
	<span class="k">case</span> <span class="mh">0x245D</span>:
	<span class="k">case</span> <span class="mh">0x27DC</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some firmware hands off the e100 with interrupts enabled,</span>
<span class="cm">	 * which can cause a flood of interrupts if packets are</span>
<span class="cm">	 * received before the driver attaches to the device.  So</span>
<span class="cm">	 * disable all e100 interrupts here.  The driver will</span>
<span class="cm">	 * re-enable them when it&#39;s ready.</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">command</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_MEMORY</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that the device is in the D0 power state. If it&#39;s not,</span>
<span class="cm">	 * there is no point to look any further.</span>
<span class="cm">	 */</span>
	<span class="n">pm</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_PM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm</span> <span class="o">+</span> <span class="n">PCI_PM_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmcsr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pmcsr</span> <span class="o">&amp;</span> <span class="n">PCI_PM_CTRL_STATE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PCI_D0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Convert from PCI bus to resource space.  */</span>
	<span class="n">csr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">csr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t map e100 registers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd_hi</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">csr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_hi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Firmware left e100 interrupts enabled; &quot;</span>
			<span class="s">&quot;disabling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">csr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">csr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
			<span class="n">PCI_CLASS_NETWORK_ETHERNET</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">quirk_e100_interrupt</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The 82575 and 82598 may experience data corruption issues when transitioning</span>
<span class="cm"> * out of L0S.  To prevent this we need to disable L0S on the pci-e link</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_disable_aspm_l0s</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Disabling L0s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pci_disable_link_state</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCIE_LINK_STATE_L0S</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10a7</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10a9</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10b6</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10c6</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10c7</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10c8</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10d6</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10db</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10dd</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10e1</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10ec</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10f1</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x10f4</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x1508</span><span class="p">,</span> <span class="n">quirk_disable_aspm_l0s</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">fixup_rev1_53c810</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* rev 1 ncr53c810 chips don&#39;t set the class at all which means</span>
<span class="cm">	 * they don&#39;t get their resources remapped. Fix that here.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">PCI_CLASS_NOT_DEFINED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NCR 53c810 rev 1 detected; setting PCI class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_STORAGE_SCSI</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NCR</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C810</span><span class="p">,</span> <span class="n">fixup_rev1_53c810</span><span class="p">);</span>

<span class="cm">/* Enable 1k I/O space granularity on the Intel P64H2 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_p64h2_1k_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">en1k</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">io_base_lo</span><span class="p">,</span> <span class="n">io_limit_lo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="n">limit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span> <span class="o">+</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">en1k</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">en1k</span> <span class="o">&amp;</span> <span class="mh">0x200</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enable I/O Space to 1KB granularity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_IO_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_base_lo</span><span class="p">);</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_IO_LIMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_limit_lo</span><span class="p">);</span>
		<span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">io_base_lo</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_IO_RANGE_MASK</span> <span class="o">|</span> <span class="mh">0x0c</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">io_limit_lo</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCI_IO_RANGE_MASK</span> <span class="o">|</span> <span class="mh">0x0c</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">+</span> <span class="mh">0x3ff</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x1460</span><span class="p">,</span>		<span class="n">quirk_p64h2_1k_io</span><span class="p">);</span>

<span class="cm">/* Fix the IOBL_ADR for 1k I/O space granularity on the Intel P64H2</span>
<span class="cm"> * The IOBL_ADR gets re-written to 4k boundaries in pci_setup_bridge()</span>
<span class="cm"> * in drivers/pci/setup-bus.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_p64h2_1k_io_fix_iobl</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">en1k</span><span class="p">,</span> <span class="n">iobl_adr</span><span class="p">,</span> <span class="n">iobl_adr_1k</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">resource</span> <span class="o">+</span> <span class="n">PCI_BRIDGE_RESOURCES</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">en1k</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">en1k</span> <span class="o">&amp;</span> <span class="mh">0x200</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_IO_BASE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iobl_adr</span><span class="p">);</span>

		<span class="n">iobl_adr_1k</span> <span class="o">=</span> <span class="n">iobl_adr</span> <span class="o">|</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">&amp;</span> <span class="mh">0xfc00</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iobl_adr</span> <span class="o">!=</span> <span class="n">iobl_adr_1k</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Fixing P64H2 IOBL_ADR from 0x%x to 0x%x for 1KB granularity</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">iobl_adr</span><span class="p">,</span><span class="n">iobl_adr_1k</span><span class="p">);</span>
			<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_IO_BASE</span><span class="p">,</span> <span class="n">iobl_adr_1k</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>	<span class="mh">0x1460</span><span class="p">,</span>		<span class="n">quirk_p64h2_1k_io_fix_iobl</span><span class="p">);</span>

<span class="cm">/* Under some circumstances, AER is not linked with extended capabilities.</span>
<span class="cm"> * Force it to be linked by setting the corresponding control bit in the</span>
<span class="cm"> * config space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">quirk_nvidia_ck804_pcie_aer_ext_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xf41</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xf41</span><span class="p">,</span> <span class="n">b</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">);</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			       <span class="s">&quot;Linking AER extended capability</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span>  <span class="n">PCI_DEVICE_ID_NVIDIA_CK804_PCIE</span><span class="p">,</span>
			<span class="n">quirk_nvidia_ck804_pcie_aer_ext_cap</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span>  <span class="n">PCI_DEVICE_ID_NVIDIA_CK804_PCIE</span><span class="p">,</span>
			<span class="n">quirk_nvidia_ck804_pcie_aer_ext_cap</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_via_cx700_pci_parking_caching</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Disable PCI Bus Parking and PCI Master read caching on CX700</span>
<span class="cm">	 * which causes unspecified timing errors with a VT6212L on the PCI</span>
<span class="cm">	 * bus leading to USB2.0 packet loss.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This quirk is only enabled if a second (on the external PCI bus)</span>
<span class="cm">	 * VT6212L is found -- the CX700 core itself also contains a USB</span>
<span class="cm">	 * host controller with the same PCI ID as the VT6212L.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Count VT6212L instances */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span>
		<span class="n">PCI_DEVICE_ID_VIA_8235_USB_2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">b</span><span class="p">;</span>

	<span class="cm">/* p should contain the first (internal) VT6212L -- see if we have</span>
<span class="cm">	   an external one by searching again */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8235_USB_2</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x76</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Turn off PCI Bus Parking */</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x76</span><span class="p">,</span> <span class="n">b</span> <span class="o">^</span> <span class="mh">0x40</span><span class="p">);</span>

			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Disabling VIA CX700 PCI parking</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x72</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Turn off PCI Master read caching */</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x72</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

			<span class="cm">/* Set PCI Master Bus time-out to &quot;1x16 PCLK&quot; */</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x75</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>

			<span class="cm">/* Disable &quot;Read FIFO Timer&quot; */</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x77</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Disabling VIA CX700 PCI caching</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="mh">0x324e</span><span class="p">,</span> <span class="n">quirk_via_cx700_pci_parking_caching</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * For Broadcom 5706, 5708, 5709 rev. A nics, any read beyond the</span>
<span class="cm"> * VPD end tag will hang the device.  This problem was initially</span>
<span class="cm"> * observed when a vpd entry was created in sysfs</span>
<span class="cm"> * (&#39;/sys/bus/pci/devices/&lt;id&gt;/vpd&#39;).   A read to this sysfs entry</span>
<span class="cm"> * will dump 32k of data.  Reading a full 32k will cause an access</span>
<span class="cm"> * beyond the VPD end tag causing the device to hang.  Once the device</span>
<span class="cm"> * is hung, the bnx2 driver will not be able to reset the device.</span>
<span class="cm"> * We believe that it is legal to read beyond the end tag and</span>
<span class="cm"> * therefore the solution is to limit the read/write length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_brcm_570x_limit_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only disable the VPD capability for 5706, 5706S, 5708,</span>
<span class="cm">	 * 5708S and 5709 rev. A</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5706</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5706S</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5708</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5708S</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NX2_5709</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NX2_5706</span><span class="p">,</span>
			<span class="n">quirk_brcm_570x_limit_vpd</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NX2_5706S</span><span class="p">,</span>
			<span class="n">quirk_brcm_570x_limit_vpd</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NX2_5708</span><span class="p">,</span>
			<span class="n">quirk_brcm_570x_limit_vpd</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NX2_5708S</span><span class="p">,</span>
			<span class="n">quirk_brcm_570x_limit_vpd</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NX2_5709</span><span class="p">,</span>
			<span class="n">quirk_brcm_570x_limit_vpd</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NX2_5709S</span><span class="p">,</span>
			<span class="n">quirk_brcm_570x_limit_vpd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_brcm_5719_limit_mrrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rev</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rev</span><span class="p">);</span>

	<span class="cm">/* Only CAP the MRRS if the device is a 5719 A0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">==</span> <span class="mh">0x05719000</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">readrq</span> <span class="o">=</span> <span class="n">pcie_get_readrq</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readrq</span> <span class="o">&gt;</span> <span class="mi">2048</span><span class="p">)</span>
			<span class="n">pcie_set_readrq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2048</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">DECLARE_PCI_FIXUP_ENABLE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			 <span class="n">PCI_DEVICE_ID_TIGON3_5719</span><span class="p">,</span>
			 <span class="n">quirk_brcm_5719_limit_mrrs</span><span class="p">);</span>

<span class="cm">/* Originally in EDAC sources for i82875P:</span>
<span class="cm"> * Intel tells BIOS developers to hide device 6 which</span>
<span class="cm"> * configures the overflow device access containing</span>
<span class="cm"> * the DRBs - this is where we expose device 6.</span>
<span class="cm"> * http://www.x86-secret.com/articles/tweak/pat/patsecrets-2.htm</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_unhide_mch_dev6</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xF4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabling MCH &#39;Overflow&#39; Device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xF4</span><span class="p">,</span> <span class="n">reg</span> <span class="o">|</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82865_HB</span><span class="p">,</span>
			<span class="n">quirk_unhide_mch_dev6</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82875_HB</span><span class="p">,</span>
			<span class="n">quirk_unhide_mch_dev6</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TILE</span>
<span class="cm">/*</span>
<span class="cm"> * The Tilera TILEmpower platform needs to set the link speed</span>
<span class="cm"> * to 2.5GT(Giga-Transfers)/s (Gen 1). The default link speed</span>
<span class="cm"> * setting is 5GT/s (Gen 2). 0x98 is the Link Control2 PCIe</span>
<span class="cm"> * capability register of the PEX8624 PCIe switch. The switch</span>
<span class="cm"> * supports link speed auto negotiation, but falsely sets</span>
<span class="cm"> * the link speed to 5GT/s.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_tile_plx_gen1</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tile_plx_gen1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_PLX</span><span class="p">,</span> <span class="mh">0x8624</span><span class="p">,</span> <span class="n">quirk_tile_plx_gen1</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TILE */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PCI_MSI</span>
<span class="cm">/* Some chipsets do not support MSI. We cannot easily rely on setting</span>
<span class="cm"> * PCI_BUS_FLAGS_NO_MSI in its bus flags because there are actually</span>
<span class="cm"> * some other busses controlled by the chipset even if Linux is not</span>
<span class="cm"> * aware of it.  Instead of setting the flag on all busses in the</span>
<span class="cm"> * machine, simply disable MSI globally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">quirk_disable_all_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_no_msi</span><span class="p">();</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MSI quirk detected; MSI disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SERVERWORKS</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SERVERWORKS_GCNB_LE</span><span class="p">,</span> <span class="n">quirk_disable_all_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ATI_RS400_200</span><span class="p">,</span> <span class="n">quirk_disable_all_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ATI_RS480</span><span class="p">,</span> <span class="n">quirk_disable_all_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_VT3336</span><span class="p">,</span> <span class="n">quirk_disable_all_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_VT3351</span><span class="p">,</span> <span class="n">quirk_disable_all_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_VT3364</span><span class="p">,</span> <span class="n">quirk_disable_all_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VIA_8380_0</span><span class="p">,</span> <span class="n">quirk_disable_all_msi</span><span class="p">);</span>

<span class="cm">/* Disable MSI on chipsets that are known to not support it */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_disable_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MSI quirk detected; &quot;</span>
			<span class="s">&quot;subordinate MSI disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">bus_flags</span> <span class="o">|=</span> <span class="n">PCI_BUS_FLAGS_NO_MSI</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_8131_BRIDGE</span><span class="p">,</span> <span class="n">quirk_disable_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_VIA</span><span class="p">,</span> <span class="mh">0xa238</span><span class="p">,</span> <span class="n">quirk_disable_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x5a3f</span><span class="p">,</span> <span class="n">quirk_disable_msi</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The APC bridge device in AMD 780 family northbridges has some random</span>
<span class="cm"> * OEM subsystem ID in its vendor ID register (erratum 18), so instead</span>
<span class="cm"> * we use the possible vendor/device IDs of the host bridge for the</span>
<span class="cm"> * declared quirk, and search for the APC bridge by slot number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_amd_780_apc_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">host_bridge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">apc_bridge</span><span class="p">;</span>

	<span class="n">apc_bridge</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">host_bridge</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apc_bridge</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">apc_bridge</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="mh">0x9602</span><span class="p">)</span>
			<span class="n">quirk_disable_msi</span><span class="p">(</span><span class="n">apc_bridge</span><span class="p">);</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">apc_bridge</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="mh">0x9600</span><span class="p">,</span> <span class="n">quirk_amd_780_apc_msi</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="mh">0x9601</span><span class="p">,</span> <span class="n">quirk_amd_780_apc_msi</span><span class="p">);</span>

<span class="cm">/* Go through the list of Hypertransport capabilities and</span>
<span class="cm"> * return 1 if a HT MSI capability is found and enabled */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">msi_ht_cap_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ttl</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">HT_CAPTYPE_MSI_MAPPING</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">ttl</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">HT_MSI_FLAGS</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Found %s HT MSI Mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HT_MSI_FLAGS_ENABLE</span> <span class="o">?</span>
				<span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HT_MSI_FLAGS_ENABLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_next_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
						  <span class="n">HT_CAPTYPE_MSI_MAPPING</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check the hypertransport MSI mapping to know whether MSI is enabled or not */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_msi_ht_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msi_ht_cap_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MSI quirk detected; &quot;</span>
			<span class="s">&quot;subordinate MSI disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">bus_flags</span> <span class="o">|=</span> <span class="n">PCI_BUS_FLAGS_NO_MSI</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SERVERWORKS</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SERVERWORKS_HT2000_PCIE</span><span class="p">,</span>
			<span class="n">quirk_msi_ht_cap</span><span class="p">);</span>

<span class="cm">/* The nVidia CK804 chipset may have 2 HT MSI mappings.</span>
<span class="cm"> * MSI are supported if the MSI capability set in any of these mappings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_nvidia_ck804_msi_ht_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* check HT MSI cap on this chipset and the root one.</span>
<span class="cm">	 * a single one having MSI is enough to be sure that MSI are supported.</span>
<span class="cm">	 */</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msi_ht_cap_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msi_ht_cap_enabled</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MSI quirk detected; &quot;</span>
			<span class="s">&quot;subordinate MSI disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">subordinate</span><span class="o">-&gt;</span><span class="n">bus_flags</span> <span class="o">|=</span> <span class="n">PCI_BUS_FLAGS_NO_MSI</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NVIDIA_CK804_PCIE</span><span class="p">,</span>
			<span class="n">quirk_nvidia_ck804_msi_ht_cap</span><span class="p">);</span>

<span class="cm">/* Force enable MSI mapping capability on HT bridges */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">ht_enable_msi_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ttl</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">HT_CAPTYPE_MSI_MAPPING</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">ttl</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">HT_MSI_FLAGS</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabling HT MSI Mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">HT_MSI_FLAGS</span><span class="p">,</span>
					      <span class="n">flags</span> <span class="o">|</span> <span class="n">HT_MSI_FLAGS_ENABLE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_next_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
						  <span class="n">HT_CAPTYPE_MSI_MAPPING</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SERVERWORKS</span><span class="p">,</span>
			 <span class="n">PCI_DEVICE_ID_SERVERWORKS_HT1000_PXB</span><span class="p">,</span>
			 <span class="n">ht_enable_msi_mapping</span><span class="p">);</span>

<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AMD</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMD_8132_BRIDGE</span><span class="p">,</span>
			 <span class="n">ht_enable_msi_mapping</span><span class="p">);</span>

<span class="cm">/* The P5N32-SLI motherboards from Asus have a problem with msi</span>
<span class="cm"> * for the MCP55 NIC. It is not yet determined whether the msi problem</span>
<span class="cm"> * also affects other devices. As for now, turn off msi for this device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">nvenet_msi_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">board_name</span> <span class="o">=</span> <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BOARD_NAME</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">board_name</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">board_name</span><span class="p">,</span> <span class="s">&quot;P5N32-SLI PREMIUM&quot;</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">strstr</span><span class="p">(</span><span class="n">board_name</span><span class="p">,</span> <span class="s">&quot;P5N32-E SLI&quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;Disabling msi for MCP55 NIC on P5N32-SLI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">no_msi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NVIDIA_NVENET_15</span><span class="p">,</span>
			<span class="n">nvenet_msi_disable</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Some versions of the MCP55 bridge from nvidia have a legacy irq routing</span>
<span class="cm"> * config register.  This register controls the routing of legacy interrupts</span>
<span class="cm"> * from devices that route through the MCP55.  If this register is misprogramed</span>
<span class="cm"> * interrupts are only sent to the bsp, unlike conventional systems where the</span>
<span class="cm"> * irq is broadxast to all online cpus.  Not having this register set</span>
<span class="cm"> * properly prevents kdump from booting up properly, so lets make sure that</span>
<span class="cm"> * we have it set correctly.</span>
<span class="cm"> * Note this is an undocumented register.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">nvbridge_check_legacy_irq_routing</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_HT</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Rewriting irq routing register on MCP55</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">));</span>
		<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NVIDIA_MCP55_BRIDGE_V0</span><span class="p">,</span>
			<span class="n">nvbridge_check_legacy_irq_routing</span><span class="p">);</span>

<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_NVIDIA_MCP55_BRIDGE_V4</span><span class="p">,</span>
			<span class="n">nvbridge_check_legacy_irq_routing</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ht_check_msi_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ttl</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check if there is HT MSI cap or enabled on this device */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">HT_CAPTYPE_MSI_MAPPING</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">ttl</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">HT_MSI_FLAGS</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HT_MSI_FLAGS_ENABLE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">found</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_next_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
						  <span class="n">HT_CAPTYPE_MSI_MAPPING</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">host_bridge_with_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">host_bridge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">dev_no</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_no</span> <span class="o">=</span> <span class="n">host_bridge</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">dev_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">host_bridge</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* found next host bridge ?*/</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">HT_CAPTYPE_SLAVE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ht_check_msi_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PCI_HT_CAP_SLAVE_CTRL0     4    </span><span class="cm">/* link control */</span><span class="cp"></span>
<span class="cp">#define PCI_HT_CAP_SLAVE_CTRL1     8    </span><span class="cm">/* link control to */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">is_end_of_ht_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ctrl_off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">HT_CAPTYPE_SLAVE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_CAP_FLAGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">ctrl_off</span> <span class="o">=</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">PCI_HT_CAP_SLAVE_CTRL0</span> <span class="o">:</span> <span class="n">PCI_HT_CAP_SLAVE_CTRL1</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">ctrl_off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">))</span>
		<span class="n">end</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">nv_ht_enable_msi_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">host_bridge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">dev_no</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_no</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">dev_no</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host_bridge</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host_bridge</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="n">host_bridge</span><span class="p">,</span> <span class="n">HT_CAPTYPE_SLAVE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">host_bridge</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* don&#39;t enable end_device/host_bridge with leaf directly here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_bridge</span> <span class="o">==</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">is_end_of_ht_chain</span><span class="p">(</span><span class="n">host_bridge</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">host_bridge_with_leaf</span><span class="p">(</span><span class="n">host_bridge</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* root did that ! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msi_ht_cap_enabled</span><span class="p">(</span><span class="n">host_bridge</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ht_enable_msi_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">host_bridge</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">ht_disable_msi_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ttl</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">HT_CAPTYPE_MSI_MAPPING</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="n">ttl</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">HT_MSI_FLAGS</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Disabling HT MSI Mapping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">HT_MSI_FLAGS</span><span class="p">,</span>
					      <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HT_MSI_FLAGS_ENABLE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_next_ht_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
						  <span class="n">HT_CAPTYPE_MSI_MAPPING</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">__nv_msi_ht_cap_quirk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">all</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">host_bridge</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_msi_enabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* check if there is HT MSI cap or enabled on this device */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">ht_check_msi_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* no HT MSI CAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * HT MSI mapping should be disabled on devices that are below</span>
<span class="cm">	 * a non-Hypertransport host bridge. Locate the host bridge...</span>
<span class="cm">	 */</span>
	<span class="n">host_bridge</span> <span class="o">=</span> <span class="n">pci_get_bus_and_slot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PCI_DEVFN</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_bridge</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;nv_msi_ht_cap_quirk didn&#39;t locate host bridge</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_ht_capability</span><span class="p">(</span><span class="n">host_bridge</span><span class="p">,</span> <span class="n">HT_CAPTYPE_SLAVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Host bridge is to HT */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* it is not enabled, try to enable it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">)</span>
				<span class="n">ht_enable_msi_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">nv_ht_enable_msi_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* HT MSI is not enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Host bridge is not to HT, disable HT MSI mapping on this device */</span>
	<span class="n">ht_disable_msi_mapping</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">nv_msi_ht_cap_quirk_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__nv_msi_ht_cap_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">nv_msi_ht_cap_quirk_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__nv_msi_ht_cap_quirk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">nv_msi_ht_cap_quirk_leaf</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_NVIDIA</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">nv_msi_ht_cap_quirk_leaf</span><span class="p">);</span>

<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">nv_msi_ht_cap_quirk_all</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">nv_msi_ht_cap_quirk_all</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_msi_intx_disable_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">|=</span> <span class="n">PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_msi_intx_disable_ati_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* SB700 MSI issue will be fixed at HW level from revision A21,</span>
<span class="cm">	 * we need check PCI REVISION ID of SMBus controller to get SB700</span>
<span class="cm">	 * revision.</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pci_get_device</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_ATI_SBX00_SMBUS</span><span class="p">,</span>
			   <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mh">0x3B</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mh">0x30</span><span class="p">))</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">|=</span> <span class="n">PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG</span><span class="p">;</span>
	<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_TIGON3_5780</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_TIGON3_5780S</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_TIGON3_5714</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_TIGON3_5714S</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_TIGON3_5715</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_BROADCOM</span><span class="p">,</span>
			<span class="n">PCI_DEVICE_ID_TIGON3_5715S</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>

<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4390</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_ati_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4391</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_ati_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4392</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_ati_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4393</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_ati_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4394</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_ati_bug</span><span class="p">);</span>

<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4373</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4374</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATI</span><span class="p">,</span> <span class="mh">0x4375</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>

<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATTANSIC</span><span class="p">,</span> <span class="mh">0x1062</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATTANSIC</span><span class="p">,</span> <span class="mh">0x1063</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATTANSIC</span><span class="p">,</span> <span class="mh">0x2060</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATTANSIC</span><span class="p">,</span> <span class="mh">0x2062</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATTANSIC</span><span class="p">,</span> <span class="mh">0x1073</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_ATTANSIC</span><span class="p">,</span> <span class="mh">0x1083</span><span class="p">,</span>
			<span class="n">quirk_msi_intx_disable_bug</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI_MSI */</span><span class="cp"></span>

<span class="cm">/* Allow manual resource allocation for PCI hotplug bridges</span>
<span class="cm"> * via pci=hpmemsize=nnM and pci=hpiosize=nnM parameters. For</span>
<span class="cm"> * some PCI-PCI hotplug bridges, like PLX 6254 (former HINT HB6),</span>
<span class="cm"> * kernel fails to allocate resources when hotplug device is </span>
<span class="cm"> * inserted and PCI bus is rescanned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_hotplug_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">is_hotplug_bridge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_HINT</span><span class="p">,</span> <span class="mh">0x0020</span><span class="p">,</span> <span class="n">quirk_hotplug_bridge</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is a quirk for the Ricoh MMC controller found as a part of</span>
<span class="cm"> * some mulifunction chips.</span>

<span class="cm"> * This is very similar and based on the ricoh_mmc driver written by</span>
<span class="cm"> * Philip Langdale. Thank you for these magic sequences.</span>
<span class="cm"> *</span>
<span class="cm"> * These chips implement the four main memory card controllers (SD, MMC, MS, xD)</span>
<span class="cm"> * and one or both of cardbus or firewire.</span>
<span class="cm"> *</span>
<span class="cm"> * It happens that they implement SD and MMC</span>
<span class="cm"> * support as separate controllers (and PCI functions). The linux SDHCI</span>
<span class="cm"> * driver supports MMC cards but the chip detects MMC cards in hardware</span>
<span class="cm"> * and directs them to the MMC controller - so the SDHCI driver never sees</span>
<span class="cm"> * them.</span>
<span class="cm"> *</span>
<span class="cm"> * To get around this, we must disable the useless MMC controller.</span>
<span class="cm"> * At that point, the SDHCI controller will start seeing them</span>
<span class="cm"> * It seems to be the case that the relevant PCI registers to deactivate the</span>
<span class="cm"> * MMC controller live on PCI function 0, which might be the cardbus controller</span>
<span class="cm"> * or the firewire controller, depending on the particular chip in question</span>
<span class="cm"> *</span>
<span class="cm"> * This has to be done early, because as soon as we disable the MMC controller</span>
<span class="cm"> * other pci functions shift up one level, e.g. function #2 becomes function</span>
<span class="cm"> * #1, and this will confuse the pci core.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_MMC_RICOH_MMC</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ricoh_mmc_fixup_rl5c476</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* disable via cardbus interface */</span>
	<span class="n">u8</span> <span class="n">write_enable</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">write_target</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">disable</span><span class="p">;</span>

	<span class="cm">/* disable must be done via function #0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xB7</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disable</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8E</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_enable</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8E</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">);</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8D</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_target</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8D</span><span class="p">,</span> <span class="mh">0xB7</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xB7</span><span class="p">,</span> <span class="n">disable</span> <span class="o">|</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8E</span><span class="p">,</span> <span class="n">write_enable</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8D</span><span class="p">,</span> <span class="n">write_target</span><span class="p">);</span>

	<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;proprietary Ricoh MMC controller disabled (via cardbus function)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MMC cards are now supported by standard SDHCI controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RICOH</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_RICOH_RL5C476</span><span class="p">,</span> <span class="n">ricoh_mmc_fixup_rl5c476</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RICOH</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_RICOH_RL5C476</span><span class="p">,</span> <span class="n">ricoh_mmc_fixup_rl5c476</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ricoh_mmc_fixup_r5c832</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* disable via firewire interface */</span>
	<span class="n">u8</span> <span class="n">write_enable</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">disable</span><span class="p">;</span>

	<span class="cm">/* disable must be done via function #0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * RICOH 0xe823 SD/MMC card reader fails to recognize</span>
<span class="cm">	 * certain types of SD/MMC cards. Lowering the SD base</span>
<span class="cm">	 * clock frequency from 200Mhz to 50Mhz fixes this issue.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 0x150 - SD2.0 mode enable for changing base clock</span>
<span class="cm">	 *	   frequency to 50Mhz</span>
<span class="cm">	 * 0xe1  - Base clock frequency</span>
<span class="cm">	 * 0x32  - 50Mhz new clock frequency</span>
<span class="cm">	 * 0xf9  - Key register for 0x150</span>
<span class="cm">	 * 0xfc  - key register for 0xe1</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_RICOH_R5CE823</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xf9</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x150</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xf9</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xe1</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">);</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

		<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MMC controller base frequency changed to 50Mhz.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xCB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disable</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disable</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xCA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_enable</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xCA</span><span class="p">,</span> <span class="mh">0x57</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xCB</span><span class="p">,</span> <span class="n">disable</span> <span class="o">|</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0xCA</span><span class="p">,</span> <span class="n">write_enable</span><span class="p">);</span>

	<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;proprietary Ricoh MMC controller disabled (via firewire function)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MMC cards are now supported by standard SDHCI controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RICOH</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_RICOH_R5C832</span><span class="p">,</span> <span class="n">ricoh_mmc_fixup_r5c832</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RICOH</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_RICOH_R5C832</span><span class="p">,</span> <span class="n">ricoh_mmc_fixup_r5c832</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RICOH</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_RICOH_R5CE823</span><span class="p">,</span> <span class="n">ricoh_mmc_fixup_r5c832</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_RESUME_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_RICOH</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_RICOH_R5CE823</span><span class="p">,</span> <span class="n">ricoh_mmc_fixup_r5c832</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/*CONFIG_MMC_RICOH_MMC*/</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_DMAR_TABLE</span>
<span class="cp">#define VTUNCERRMSK_REG	0x1ac</span>
<span class="cp">#define VTD_MSK_SPEC_ERRORS	(1 &lt;&lt; 31)</span>
<span class="cm">/*</span>
<span class="cm"> * This is a quirk for masking vt-d spec defined errors to platform error</span>
<span class="cm"> * handling logic. With out this, platforms using Intel 7500, 5500 chipsets</span>
<span class="cm"> * (and the derivative chipsets like X58 etc) seem to generate NMI/SMI (based</span>
<span class="cm"> * on the RAS config settings of the platform) when a vt-d fault happens.</span>
<span class="cm"> * The resulting SMI caused the system to hang.</span>
<span class="cm"> *</span>
<span class="cm"> * VT-d spec related errors are already handled by the VT-d OS code, so no</span>
<span class="cm"> * need to report the same error through other channels.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vtd_mask_spec_errors</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">word</span><span class="p">;</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VTUNCERRMSK_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">);</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">VTUNCERRMSK_REG</span><span class="p">,</span> <span class="n">word</span> <span class="o">|</span> <span class="n">VTD_MSK_SPEC_ERRORS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x342e</span><span class="p">,</span> <span class="n">vtd_mask_spec_errors</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x3c28</span><span class="p">,</span> <span class="n">vtd_mask_spec_errors</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">fixup_ti816x_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span><span class="o">*</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* TI 816x devices do not have class code set when in PCIe boot mode */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Setting PCI class for 816x PCIe device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="n">PCI_CLASS_MULTIMEDIA_VIDEO</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_CLASS_EARLY</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_TI</span><span class="p">,</span> <span class="mh">0xb800</span><span class="p">,</span>
				 <span class="n">PCI_CLASS_NOT_DEFINED</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fixup_ti816x_class</span><span class="p">);</span>

<span class="cm">/* Some PCIe devices do not work reliably with the claimed maximum</span>
<span class="cm"> * payload size supported.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">fixup_mpss_256</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcie_mpss</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 256 bytes */</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SOLARFLARE</span><span class="p">,</span>
			 <span class="n">PCI_DEVICE_ID_SOLARFLARE_SFC4000A_0</span><span class="p">,</span> <span class="n">fixup_mpss_256</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SOLARFLARE</span><span class="p">,</span>
			 <span class="n">PCI_DEVICE_ID_SOLARFLARE_SFC4000A_1</span><span class="p">,</span> <span class="n">fixup_mpss_256</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_SOLARFLARE</span><span class="p">,</span>
			 <span class="n">PCI_DEVICE_ID_SOLARFLARE_SFC4000B</span><span class="p">,</span> <span class="n">fixup_mpss_256</span><span class="p">);</span>

<span class="cm">/* Intel 5000 and 5100 Memory controllers have an errata with read completion</span>
<span class="cm"> * coalescing (which is enabled by default on some BIOSes) and MPS of 256B.</span>
<span class="cm"> * Since there is no way of knowing what the PCIE MPS on each fabric will be</span>
<span class="cm"> * until all of the devices are discovered and buses walked, read completion</span>
<span class="cm"> * coalescing must be disabled.  Unfortunately, it cannot be re-enabled because</span>
<span class="cm"> * it is possible to hotplug a device with MPS of 256B.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">quirk_intel_mc_errata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">rcc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcie_bus_config</span> <span class="o">==</span> <span class="n">PCIE_BUS_TUNE_OFF</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Intel errata specifies bits to change but does not say what they are.</span>
<span class="cm">	 * Keeping them magical until such time as the registers and values can</span>
<span class="cm">	 * be explained.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error attempting to read the read &quot;</span>
			<span class="s">&quot;completion coalescing register.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rcc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="n">rcc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Error attempting to write the read &quot;</span>
			<span class="s">&quot;completion coalescing register.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info_once</span><span class="p">(</span><span class="s">&quot;Read completion coalescing disabled due to hardware &quot;</span>
		     <span class="s">&quot;errata relating to 256B MPS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* Intel 5000 series memory controllers and ports 2-7 */</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25c0</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25d0</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25d4</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25d8</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25e2</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25e3</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25e4</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25e5</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25e6</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25e7</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25f7</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25f8</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25f9</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x25fa</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="cm">/* Intel 5100 series memory controllers and ports 2-7 */</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65c0</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65e2</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65e3</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65e4</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65e5</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65e6</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65e7</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65f7</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65f8</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65f9</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_HEADER</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x65fa</span><span class="p">,</span> <span class="n">quirk_intel_mc_errata</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_one_fixup_debug</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">),</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">calltime</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">rettime</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">duration</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;calling  %pF @ %i for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fn</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">calltime</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="n">fn</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rettime</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="n">delta</span> <span class="o">=</span> <span class="n">ktime_sub</span><span class="p">(</span><span class="n">rettime</span><span class="p">,</span> <span class="n">calltime</span><span class="p">);</span>
	<span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;pci fixup %pF returned after %lld usecs for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fn</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some BIOS implementations leave the Intel GPU interrupts enabled,</span>
<span class="cm"> * even though no one is handling them (f.e. i915 driver is never loaded).</span>
<span class="cm"> * Additionally the interrupt destination is not set up properly</span>
<span class="cm"> * and the interrupt ends up -somewhere-.</span>
<span class="cm"> *</span>
<span class="cm"> * These spurious interrupts are &quot;sticky&quot; and the kernel disables</span>
<span class="cm"> * the (shared) interrupt line after 100.000+ generated interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * Fix it by disabling the still enabled interrupts.</span>
<span class="cm"> * This resolves crashes often seen on monitor unplug.</span>
<span class="cm"> */</span>
<span class="cp">#define I915_DEIER_REG 0x4400c</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">disable_igfx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;igfx quirk: Can&#39;t iomap PCI device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if any interrupt line is still enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">regs</span> <span class="o">+</span> <span class="n">I915_DEIER_REG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BIOS left Intel GPU interrupts enabled; &quot;</span>
			<span class="s">&quot;disabling</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">regs</span> <span class="o">+</span> <span class="n">I915_DEIER_REG</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x0102</span><span class="p">,</span> <span class="n">disable_igfx_irq</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x010a</span><span class="p">,</span> <span class="n">disable_igfx_irq</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The Intel 6 Series/C200 Series chipset&#39;s EHCI controllers on many</span>
<span class="cm"> * ASUS motherboards will cause memory corruption or a system crash</span>
<span class="cm"> * if they are in D3 while the system is put into S3 sleep.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">asus_ehci_no_d3</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sys_info</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">good_Asus_board</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;P8Z68-V&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">&amp;</span> <span class="n">PCI_DEV_FLAGS_NO_D3_DURING_SLEEP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">!=</span> <span class="n">PCI_VENDOR_ID_ASUSTEK</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sys_info</span> <span class="o">=</span> <span class="n">dmi_get_system_info</span><span class="p">(</span><span class="n">DMI_BOARD_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sys_info</span> <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">sys_info</span><span class="p">,</span> <span class="n">good_Asus_board</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">good_Asus_board</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;broken D3 during system sleep on ASUS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_flags</span> <span class="o">|=</span> <span class="n">PCI_DEV_FLAGS_NO_D3_DURING_SLEEP</span><span class="p">;</span>
	<span class="n">device_set_wakeup_capable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x1c26</span><span class="p">,</span> <span class="n">asus_ehci_no_d3</span><span class="p">);</span>
<span class="n">DECLARE_PCI_FIXUP_FINAL</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="mh">0x1c2d</span><span class="p">,</span> <span class="n">asus_ehci_no_d3</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_do_fixups</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">class_shift</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">f</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">PCI_ANY_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">||</span>
		     <span class="n">f</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">PCI_ANY_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">||</span>
		     <span class="n">f</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">PCI_ANY_ID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;calling %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">hook</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">initcall_debug</span><span class="p">)</span>
				<span class="n">do_one_fixup_debug</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">hook</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">f</span><span class="o">-&gt;</span><span class="n">hook</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__start_pci_fixups_early</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__end_pci_fixups_early</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__start_pci_fixups_header</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__end_pci_fixups_header</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__start_pci_fixups_final</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__end_pci_fixups_final</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__start_pci_fixups_enable</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__end_pci_fixups_enable</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__start_pci_fixups_resume</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__end_pci_fixups_resume</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__start_pci_fixups_resume_early</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__end_pci_fixups_resume_early</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__start_pci_fixups_suspend</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_fixup</span> <span class="n">__end_pci_fixups_suspend</span><span class="p">[];</span>


<span class="kt">void</span> <span class="nf">pci_fixup_device</span><span class="p">(</span><span class="k">enum</span> <span class="n">pci_fixup_pass</span> <span class="n">pass</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_fixup</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">pass</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">pci_fixup_early</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">__start_pci_fixups_early</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__end_pci_fixups_early</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">pci_fixup_header</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">__start_pci_fixups_header</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__end_pci_fixups_header</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">pci_fixup_final</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">__start_pci_fixups_final</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__end_pci_fixups_final</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">pci_fixup_enable</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">__start_pci_fixups_enable</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__end_pci_fixups_enable</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">pci_fixup_resume</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">__start_pci_fixups_resume</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__end_pci_fixups_resume</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">pci_fixup_resume_early</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">__start_pci_fixups_resume_early</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__end_pci_fixups_resume_early</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">pci_fixup_suspend</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">__start_pci_fixups_suspend</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">__end_pci_fixups_suspend</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* stupid compiler warning, you would think with an enum... */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_do_fixups</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_fixup_device</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pci_apply_final_quirks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cls</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_cache_line_size</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;PCI: CLS %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pci_cache_line_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">for_each_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_fixup_device</span><span class="p">(</span><span class="n">pci_fixup_final</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If arch hasn&#39;t set it explicitly yet, use the CLS</span>
<span class="cm">		 * value shared by all PCI devices.  If there&#39;s a</span>
<span class="cm">		 * mismatch, fall back to the default value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_cache_line_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span>
				<span class="n">cls</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span> <span class="o">||</span> <span class="n">cls</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;PCI: CLS mismatch (%u != %u), &quot;</span>
			       <span class="s">&quot;using %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cls</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
			       <span class="n">pci_dfl_cache_line_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">pci_cache_line_size</span> <span class="o">=</span> <span class="n">pci_dfl_cache_line_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_cache_line_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;PCI: CLS %u bytes, default %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cls</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pci_dfl_cache_line_size</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">pci_cache_line_size</span> <span class="o">=</span> <span class="n">cls</span> <span class="o">?</span> <span class="n">cls</span> <span class="o">:</span> <span class="n">pci_dfl_cache_line_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fs_initcall_sync</span><span class="p">(</span><span class="n">pci_apply_final_quirks</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Followings are device-specific reset methods which can be used to</span>
<span class="cm"> * reset a single function if other methods (e.g. FLR, PM D0-&gt;D3) are</span>
<span class="cm"> * not available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reset_intel_generic_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="cm">/* only implement PCI_CLASS_SERIAL_USB at present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">PCI_CLASS_SERIAL_USB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_VNDR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reset_intel_82599_sfp_virtfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_EXP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span>
				<span class="n">PCI_EXP_DEVCTL_BCR_FLR</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;../gpu/drm/i915/i915_reg.h&quot;</span>
<span class="cp">#define MSG_CTL			0x45010</span>
<span class="cp">#define NSDE_PWR_STATE		0xd0100</span>
<span class="cp">#define IGD_OPERATION_TIMEOUT	10000     </span><span class="cm">/* set timeout 10 seconds */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">reset_ivb_igd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probe</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mmio_base</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmio_base</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">,</span> <span class="n">mmio_base</span> <span class="o">+</span> <span class="n">MSG_CTL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clobbering SOUTH_CHICKEN2 register is fine only if the next</span>
<span class="cm">	 * driver loaded sets the right bits. However, this&#39;s a reset and</span>
<span class="cm">	 * the bits have been set by i915 previously, so we clobber</span>
<span class="cm">	 * SOUTH_CHICKEN2 register directly here.</span>
<span class="cm">	 */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000005</span><span class="p">,</span> <span class="n">mmio_base</span> <span class="o">+</span> <span class="n">SOUTH_CHICKEN2</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">PCH_PP_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffffffe</span><span class="p">;</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">mmio_base</span> <span class="o">+</span> <span class="n">PCH_PP_CONTROL</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">IGD_OPERATION_TIMEOUT</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ioread32</span><span class="p">(</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">PCH_PP_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xb0000000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reset_complete</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;timeout during reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">reset_complete:</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="mh">0x00000002</span><span class="p">,</span> <span class="n">mmio_base</span> <span class="o">+</span> <span class="n">NSDE_PWR_STATE</span><span class="p">);</span>

	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">mmio_base</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PCI_DEVICE_ID_INTEL_82599_SFP_VF   0x10ed</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_IVB_M_VGA      0x0156</span>
<span class="cp">#define PCI_DEVICE_ID_INTEL_IVB_M2_VGA     0x0166</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev_reset_methods</span> <span class="n">pci_dev_reset_methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_82599_SFP_VF</span><span class="p">,</span>
		 <span class="n">reset_intel_82599_sfp_virtfn</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_IVB_M_VGA</span><span class="p">,</span>
		<span class="n">reset_ivb_igd</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INTEL_IVB_M2_VGA</span><span class="p">,</span>
		<span class="n">reset_ivb_igd</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>
		<span class="n">reset_intel_generic_dev</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * These device-specific reset methods are here rather than in a driver</span>
<span class="cm"> * because when a host assigns a device to a guest VM, the host may need</span>
<span class="cm"> * to reset the device but probably doesn&#39;t have a driver for it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_dev_specific_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">probe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_dev_reset_methods</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">pci_dev_reset_methods</span><span class="p">;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">||</span>
		     <span class="n">i</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">PCI_ANY_ID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">||</span>
		     <span class="n">i</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">PCI_ANY_ID</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
