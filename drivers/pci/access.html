<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › pci › access.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>access.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>

<span class="cp">#include &quot;pci.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * This interrupt-safe spinlock protects all accesses to PCI</span>
<span class="cm"> * configuration space.</span>
<span class="cm"> */</span>

<span class="n">DEFINE_RAW_SPINLOCK</span><span class="p">(</span><span class="n">pci_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Wrappers for all PCI configuration access functions.  They just check</span>
<span class="cm"> *  alignment, do locking and call the low-level functions pointed to</span>
<span class="cm"> *  by pci_dev-&gt;ops.</span>
<span class="cm"> */</span>

<span class="cp">#define PCI_byte_BAD 0</span>
<span class="cp">#define PCI_word_BAD (pos &amp; 1)</span>
<span class="cp">#define PCI_dword_BAD (pos &amp; 3)</span>

<span class="cp">#define PCI_OP_READ(size,type,len) \</span>
<span class="cp">int pci_bus_read_config_##size \</span>
<span class="cp">	(struct pci_bus *bus, unsigned int devfn, int pos, type *value)	\</span>
<span class="cp">{									\</span>
<span class="cp">	int res;							\</span>
<span class="cp">	unsigned long flags;						\</span>
<span class="cp">	u32 data = 0;							\</span>
<span class="cp">	if (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	\</span>
<span class="cp">	raw_spin_lock_irqsave(&amp;pci_lock, flags);			\</span>
<span class="cp">	res = bus-&gt;ops-&gt;read(bus, devfn, pos, len, &amp;data);		\</span>
<span class="cp">	*value = (type)data;						\</span>
<span class="cp">	raw_spin_unlock_irqrestore(&amp;pci_lock, flags);		\</span>
<span class="cp">	return res;							\</span>
<span class="cp">}</span>

<span class="cp">#define PCI_OP_WRITE(size,type,len) \</span>
<span class="cp">int pci_bus_write_config_##size \</span>
<span class="cp">	(struct pci_bus *bus, unsigned int devfn, int pos, type value)	\</span>
<span class="cp">{									\</span>
<span class="cp">	int res;							\</span>
<span class="cp">	unsigned long flags;						\</span>
<span class="cp">	if (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	\</span>
<span class="cp">	raw_spin_lock_irqsave(&amp;pci_lock, flags);			\</span>
<span class="cp">	res = bus-&gt;ops-&gt;write(bus, devfn, pos, len, value);		\</span>
<span class="cp">	raw_spin_unlock_irqrestore(&amp;pci_lock, flags);		\</span>
<span class="cp">	return res;							\</span>
<span class="cp">}</span>

<span class="n">PCI_OP_READ</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">PCI_OP_READ</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">PCI_OP_READ</span><span class="p">(</span><span class="n">dword</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">PCI_OP_WRITE</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">PCI_OP_WRITE</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">PCI_OP_WRITE</span><span class="p">(</span><span class="n">dword</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_read_config_byte</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_read_config_word</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_read_config_dword</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_write_config_byte</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_write_config_word</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_write_config_dword</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_bus_set_ops - Set raw operations of pci bus</span>
<span class="cm"> * @bus:	pci bus struct</span>
<span class="cm"> * @ops:	new raw operations</span>
<span class="cm"> *</span>
<span class="cm"> * Return previous raw operations</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="nf">pci_bus_set_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_bus</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_ops</span> <span class="o">*</span><span class="n">old_ops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">old_ops</span> <span class="o">=</span> <span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">bus</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">old_ops</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_bus_set_ops</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_read_vpd - Read one entry from Vital Product Data</span>
<span class="cm"> * @dev:	pci device struct</span>
<span class="cm"> * @pos:	offset in vpd space</span>
<span class="cm"> * @count:	number of bytes to read</span>
<span class="cm"> * @buf:	pointer to where to store result</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">pci_read_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_read_vpd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_write_vpd - Write entry to Vital Product Data</span>
<span class="cm"> * @dev:	pci device struct</span>
<span class="cm"> * @pos:	offset in vpd space</span>
<span class="cm"> * @count:	number of bytes to write</span>
<span class="cm"> * @buf:	buffer containing write data</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">pci_write_vpd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_write_vpd</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The following routines are to prevent the user from accessing PCI config</span>
<span class="cm"> * space when it&#39;s unsafe to do so.  Some devices require this during BIST and</span>
<span class="cm"> * we&#39;re required to prevent it during D-state transitions.</span>
<span class="cm"> *</span>
<span class="cm"> * We have a bit per device to indicate it&#39;s blocked and a global wait queue</span>
<span class="cm"> * for callers to sleep on until devices are unblocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">pci_cfg_wait</span><span class="p">);</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">pci_wait_cfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

	<span class="n">__add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_cfg_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">block_cfg_access</span><span class="p">);</span>
	<span class="n">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_cfg_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns 0 on success, negative values indicate error. */</span>
<span class="cp">#define PCI_USER_READ_CONFIG(size,type)					\</span>
<span class="cp">int pci_user_read_config_##size						\</span>
<span class="cp">	(struct pci_dev *dev, int pos, type *val)			\</span>
<span class="cp">{									\</span>
<span class="cp">	int ret = 0;							\</span>
<span class="cp">	u32 data = -1;							\</span>
<span class="cp">	if (PCI_##size##_BAD)						\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	raw_spin_lock_irq(&amp;pci_lock);				\</span>
<span class="cp">	if (unlikely(dev-&gt;block_cfg_access))				\</span>
<span class="cp">		pci_wait_cfg(dev);					\</span>
<span class="cp">	ret = dev-&gt;bus-&gt;ops-&gt;read(dev-&gt;bus, dev-&gt;devfn,			\</span>
<span class="cp">					pos, sizeof(type), &amp;data);	\</span>
<span class="cp">	raw_spin_unlock_irq(&amp;pci_lock);				\</span>
<span class="cp">	*val = (type)data;						\</span>
<span class="cp">	if (ret &gt; 0)							\</span>
<span class="cp">		ret = -EINVAL;						\</span>
<span class="cp">	return ret;							\</span>
<span class="cp">}</span>

<span class="cm">/* Returns 0 on success, negative values indicate error. */</span>
<span class="cp">#define PCI_USER_WRITE_CONFIG(size,type)				\</span>
<span class="cp">int pci_user_write_config_##size					\</span>
<span class="cp">	(struct pci_dev *dev, int pos, type val)			\</span>
<span class="cp">{									\</span>
<span class="cp">	int ret = -EIO;							\</span>
<span class="cp">	if (PCI_##size##_BAD)						\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	raw_spin_lock_irq(&amp;pci_lock);				\</span>
<span class="cp">	if (unlikely(dev-&gt;block_cfg_access))				\</span>
<span class="cp">		pci_wait_cfg(dev);					\</span>
<span class="cp">	ret = dev-&gt;bus-&gt;ops-&gt;write(dev-&gt;bus, dev-&gt;devfn,		\</span>
<span class="cp">					pos, sizeof(type), val);	\</span>
<span class="cp">	raw_spin_unlock_irq(&amp;pci_lock);				\</span>
<span class="cp">	if (ret &gt; 0)							\</span>
<span class="cp">		ret = -EINVAL;						\</span>
<span class="cp">	return ret;							\</span>
<span class="cp">}</span>

<span class="n">PCI_USER_READ_CONFIG</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="n">u8</span><span class="p">)</span>
<span class="n">PCI_USER_READ_CONFIG</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">u16</span><span class="p">)</span>
<span class="n">PCI_USER_READ_CONFIG</span><span class="p">(</span><span class="n">dword</span><span class="p">,</span> <span class="n">u32</span><span class="p">)</span>
<span class="n">PCI_USER_WRITE_CONFIG</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="n">u8</span><span class="p">)</span>
<span class="n">PCI_USER_WRITE_CONFIG</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">u16</span><span class="p">)</span>
<span class="n">PCI_USER_WRITE_CONFIG</span><span class="p">(</span><span class="n">dword</span><span class="p">,</span> <span class="n">u32</span><span class="p">)</span>

<span class="cm">/* VPD access through PCI 2.2+ VPD capability */</span>

<span class="cp">#define PCI_VPD_PCI22_SIZE (PCI_VPD_ADDR_MASK + 1)</span>

<span class="k">struct</span> <span class="n">pci_vpd_pci22</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_vpd</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">flag</span><span class="p">;</span>
	<span class="n">bool</span>	<span class="n">busy</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">cap</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for last operation to complete.</span>
<span class="cm"> * This code has to spin since there is no other notification from the PCI</span>
<span class="cm"> * hardware. Since the VPD is often implemented by serial attachment to an</span>
<span class="cm"> * EEPROM, it may take many milliseconds to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative values indicate error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pci_vpd_pci22_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_vpd_pci22</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_vpd_pci22</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">20</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">busy</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_user_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_VPD_ADDR</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PCI_VPD_ADDR_F</span><span class="p">)</span> <span class="o">==</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				   <span class="s">&quot;vpd r/w failed.  This is likely a firmware &quot;</span>
				   <span class="s">&quot;bug on this device.  Contact the card &quot;</span>
				   <span class="s">&quot;vendor for a firmware update.&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cond_resched</span><span class="p">())</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pci_vpd_pci22_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_vpd_pci22</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_vpd_pci22</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">len</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_killable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_vpd_pci22_wait</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">skip</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_user_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_VPD_ADDR</span><span class="p">,</span>
						 <span class="n">pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">PCI_VPD_ADDR_F</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_vpd_pci22_wait</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_user_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_VPD_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">skip</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pos</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">val</span> <span class="o">&gt;&gt;=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pci_vpd_pci22_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_vpd_pci22</span> <span class="o">*</span><span class="n">vpd</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_vpd_pci22</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_killable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_vpd_pci22_wait</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_user_write_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_VPD_DATA</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_user_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vpd</span><span class="o">-&gt;</span><span class="n">cap</span> <span class="o">+</span> <span class="n">PCI_VPD_ADDR</span><span class="p">,</span>
						 <span class="n">pos</span> <span class="o">|</span> <span class="n">PCI_VPD_ADDR_F</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_vpd_pci22_wait</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">pos</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_vpd_pci22_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_vpd_pci22</span><span class="p">,</span> <span class="n">base</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_vpd_ops</span> <span class="n">pci_vpd_pci22_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">pci_vpd_pci22_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">pci_vpd_pci22_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">pci_vpd_pci22_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">pci_vpd_pci22_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_vpd_pci22</span> <span class="o">*</span><span class="n">vpd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cap</span><span class="p">;</span>

	<span class="n">cap</span> <span class="o">=</span> <span class="n">pci_find_capability</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CAP_ID_VPD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">vpd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vpd</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vpd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">PCI_VPD_PCI22_SIZE</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pci_vpd_pci22_ops</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">cap</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">vpd</span><span class="o">-&gt;</span><span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pci_vpd_truncate - Set available Vital Product Data size</span>
<span class="cm"> * @dev:	pci device struct</span>
<span class="cm"> * @size:	available memory in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Adjust size of available VPD area.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pci_vpd_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* limited by the access method */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pci_vpd_truncate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_cfg_access_lock - Lock PCI config reads/writes</span>
<span class="cm"> * @dev:	pci device struct</span>
<span class="cm"> *</span>
<span class="cm"> * When access is locked, any userspace reads or writes to config</span>
<span class="cm"> * space and concurrent lock requests will sleep until access is</span>
<span class="cm"> * allowed via pci_cfg_access_unlocked again.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_cfg_access_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">block_cfg_access</span><span class="p">)</span>
		<span class="n">pci_wait_cfg</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">block_cfg_access</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_cfg_access_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_cfg_access_trylock - try to lock PCI config reads/writes</span>
<span class="cm"> * @dev:	pci device struct</span>
<span class="cm"> *</span>
<span class="cm"> * Same as pci_cfg_access_lock, but will return 0 if access is</span>
<span class="cm"> * already locked, 1 otherwise. This function can be used from</span>
<span class="cm"> * atomic contexts.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">pci_cfg_access_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">locked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">block_cfg_access</span><span class="p">)</span>
		<span class="n">locked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">block_cfg_access</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">locked</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_cfg_access_trylock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * pci_cfg_access_unlock - Unlock PCI config reads/writes</span>
<span class="cm"> * @dev:	pci device struct</span>
<span class="cm"> *</span>
<span class="cm"> * This function allows PCI config accesses to resume.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pci_cfg_access_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* This indicates a problem in the caller, but we don&#39;t need</span>
<span class="cm">	 * to kill them, unlike a double-block above. */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">block_cfg_access</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">block_cfg_access</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_cfg_wait</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pci_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pci_cfg_access_unlock</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
